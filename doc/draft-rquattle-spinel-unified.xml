<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' []>
<rfc ipr="noDerivativesTrust200902" category="info" docName="draft-rquattle-spinel-unified-2cb23088-dirty">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="yes"?>
<?rfc private=""?>
<?rfc topblock="yes"?>
<?rfc comments="yes"?>
<front>
<title abbrev="Spinel Protocol (Unified)">Spinel Host-Controller Protocol</title>

<author initials="R." surname="Quattlebaum" fullname="Robert S. Quattlebaum">
<organization>Nest Labs, Inc.</organization>
<address>
<postal>
<street>3400 Hillview Ave.</street>
<city>Palo Alto</city>
<code>94304</code>
<country>USA</country>
<region>California</region>
</postal>
<phone></phone>
<email>rquattle@nestlabs.com</email>
<uri></uri>
</address>
</author>
<author initials="J.H." surname="Woodyatt" fullname="James Woodyatt" role="editor">
<organization>Nest Labs, Inc.</organization>
<address>
<postal>
<street>3400 Hillview Ave.</street>
<city>Palo Alto</city>
<code>94304</code>
<country>USA</country>
<region>California</region>
</postal>
<phone></phone>
<email>jhw@nestlabs.com</email>
<uri></uri>
</address>
</author>
<date year="2017" month="June" day="22"/>

<area>Internet</area>
<workgroup></workgroup>
<keyword>Spinel</keyword>
<keyword>IPv6</keyword>
<keyword>NCP</keyword>


<abstract>
<t>This document describes the Spinel protocol, which facilitates the control and
management of IPv6 network interfaces on devices where general purpose
application processors offload network functions at their interfaces to network
co-processors (NCP) connected by simple communication links like serial data
channels. While initially developed to support Thread(R), Spinel's layered
design allows it to be easily adapted to other similar network technologies.
</t>
<t>This document also describes various Spinel specializations, including support
for the Thread(R) low-power mesh network technology.
</t>
</abstract>


</front>

<middle>

<section anchor="introduction" title="Introduction">
<t>Spinel is a host-controller protocol designed to enable interoperation over simple serial connections between general purpose device operating systems (OS) and network co-processors (NCP) for the purpose of controlling and managing their IPv6 network interfaces, achieving the following goals:
</t>
<t>
<list style="symbols">
<t>Adopt a layered approach to the protocol design, allowing future
support for other network protocols.</t>
<t>Minimize the number of required commands/methods by providing a
rich, property-based API.</t>
<t>Support NCPs capable of being connected to more than one network
at a time.</t>
<t>Gracefully handle the addition of new features and capabilities
without necessarily breaking backward compatibility.</t>
<t>Be as minimal and light-weight as possible without unnecessarily
sacrificing flexibility.</t>
</list>
</t>
<t>On top of this core framework, we define the properties and commands
to enable various features and network protocols.
</t>

<section anchor="about-this-draft" title="About this Draft">
<t>This document is currently in a draft status and is changing often.
This section discusses some ideas for changes to the protocol that
haven't yet been fully specified, as well as some of the impetus for
the current design.
</t>

<section anchor="scope" title="Scope">
<t>The eventual intent is to have two documents: A Spinel basis document
which discusses the network-technology-agnostic mechanisms and a
Thread(R) specialization document which describes all of the Thread(R)-specific
implementation details. Currently, this document covers both.
</t>
</section>

<section anchor="renumbering" title="Renumbering">
<t>Efforts are currently maintained to try to prevent overtly
backward-incompatible changes to the existing protocol, but if you are
implementing Spinel in your own products you should expect there to be
at least one large renumbering event and major version number change
before the standard is considered &quot;baked&quot;. All changes will be clearly
marked and documented to make such a transition as easy as possible.
</t>
<t>To allow conclusive detection of protocol (in)compatibility between
the host and the NCP, the following commands and properties are
already considered to be &quot;baked&quot; and will not change:
</t>
<t>
<list style="symbols">
<t>Command IDs zero through eight. (Reset, No-op, and Property-Value
Commands)</t>
<t>Property IDs zero through two. (Last status, Protocol Version, and
NCP Version)</t>
</list>
</t>
<t>Renumbering would be undertaken in order to better organize the
allocation of property IDs and capability IDs. One of the initial
goals of this protocol was for it to be possible for a host or NCP to
only implement properties with values less than 127 and for the NCP to
still be usable---relegating all larger property values for extra
features or other capabilities that aren't strictly necessary. This
would allow simple implementations to avoid the need to implement
support for PUIs (<xref target="packed-unsigned-integer"/>).
</t>
<t>As time has gone by and the protocol has become more fleshed out, it
has become clear that some of the initial allocations were inadequate
and should be revisited if we want to try to achieve the original
goal.
</t>
</section>
</section>
</section>

<section anchor="frame-format" title="Frame Format">
<t>A frame is defined simply as the concatenation of
</t>
<t>
<list style="symbols">
<t>A header byte</t>
<t>A command (up to three bytes, see <xref target="packed-unsigned-integer"/> for format)</t>
<t>An optional command payload</t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD</c><c>CMD_PAYLOAD</c>
</texttable>

<section anchor="header-format" title="Header Format">
<t>The header byte is broken down as follows:
</t>

<figure align="center"><artwork align="center">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|  FLG  |  NLI  |      TID      |
+---+---+---+---+---+---+---+---+
</artwork></figure>
<t><cref source="RQ">Eventually, when https://github.com/miekg/mmark/issues/95
is addressed, the above table should be swapped out with this:

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|---|---|---|---|---|---|---|---|
|  FLG ||  NLI ||      TID   ||||</cref></t>

<section anchor="flg-flag" title="FLG: Flag">
<t>The flag field of the header byte (<spanx style="verb">FLG</spanx>) is always set to the value
two (or <spanx style="verb">10</spanx> in binary). Any frame received with these bits set to
any other value else MUST NOT be considered a Spinel frame.
</t>
<t>This convention allows Spinel to be line compatible with BTLE HCI. By
defining the first two bit in this way we can disambiguate between
Spinel frames and HCI frames (which always start with either <spanx style="verb">0x01</spanx>
or <spanx style="verb">0x04</spanx>) without any additional framing overhead.
</t>
</section>

<section anchor="nli-network-link-identifier" title="NLI: Network Link Identifier">
<t>The Network Link Identifier (NLI) is a number between 0 and 3, which is associated by the OS with one of up to four IPv6 zone indices corresponding to conceptual IPv6 interfaces on the NCP. This allows the protocol to support IPv6 nodes connecting simultaneously to more than one IPv6 network link using a single NCP instance. The first Network Link Identifier (0) MUST refer to a distinguished conceptual interface provided by the NCP for its IPv6 link type. The other three Network Link Identifiers (1, 2 and 3) MAY be dissociated from any conceptual interface.
</t>
</section>

<section anchor="tid-transaction-identifier" title="TID: Transaction Identifier">
<t>The least significant bits of the header represent the Transaction
Identifier(TID). The TID is used for correlating responses to the
commands which generated them.
</t>
<t>When a command is sent from the host, any reply to that command sent
by the NCP will use the same value for the TID. When the host receives
a frame that matches the TID of the command it sent, it can easily
recognize that frame as the actual response to that command.
</t>
<t>The TID value of zero (0) is used for commands to which a correlated
response is not expected or needed, such as for unsolicited update
commands sent to the host from the NCP.
</t>
</section>

<section anchor="command-identifier-cmd" title="Command Identifier (CMD)">
<t>The command identifier is a 21-bit unsigned integer encoded in up to
three bytes using the packed unsigned integer format described in
<xref target="packed-unsigned-integer"/>. This encoding allows for up to 2,097,152 individual
commands, with the first 127 commands represented as a single byte.
Command identifiers larger than 2,097,151 are explicitly forbidden.
</t>
<texttable>
<ttcol align="center">CID Range</ttcol>
<ttcol align="center">Description</ttcol>

<c>0 - 63</c><c>Reserved for core commands</c>
<c>64 - 15,359</c><c><spanx style="emph">UNALLOCATED</spanx></c>
<c>15,360 - 16,383</c><c>Vendor-specific</c>
<c>16,384 - 1,999,999</c><c><spanx style="emph">UNALLOCATED</spanx></c>
<c>2,000,000 - 2,097,151</c><c>Experimental use only</c>
</texttable>
</section>

<section anchor="command-payload-optional" title="Command Payload (Optional)">
<t>Depending on the semantics of the command in question, a payload MAY
be included in the frame. The exact composition and length of the
payload is defined by the command identifier.
</t>
</section>
</section>
</section>

<section anchor="data-packing" title="Data Packing">
<t>Data serialization for properties is performed using a light-weight
data packing format which was loosely inspired by D-Bus. The format of
a serialization is defined by a specially formatted string.
</t>
<t>This packing format is used for notational convenience. While this
string-based datatype format has been designed so that the strings may
be directly used by a structured data parser, such a thing is not
required to implement Spinel. Indeed, higly constrained applications
may find such a thing to be too heavyweight.
</t>
<t>Goals:
</t>
<t>
<list style="symbols">
<t>Be lightweight and favor direct representation of values.</t>
<t>Use an easily readable and memorable format string.</t>
<t>Support lists and structures.</t>
<t>Allow properties to be appended to structures while maintaining
backward compatibility.</t>
</list>
</t>
<t>Each primitive datatype has an ASCII character associated with it.
Structures can be represented as strings of these characters. For
example:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">C</spanx>: A single unsigned byte.</t>
<t><spanx style="verb">C6U</spanx>: A single unsigned byte, followed by a 128-bit IPv6
address, followed by a zero-terminated UTF8 string.</t>
<t><spanx style="verb">A(6)</spanx>: An array of concatenated IPv6 addresses</t>
</list>
</t>
<t>In each case, the data is represented exactly as described. For
example, an array of 10 IPv6 address is stored as 160 bytes.
</t>

<section anchor="primitive-types" title="Primitive Types">
<texttable>
<ttcol align="center">Char</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Description</ttcol>

<c><spanx style="verb">.</spanx></c><c>DATATYPE_VOID</c><c>Empty data type. Used internally.</c>
<c><spanx style="verb">b</spanx></c><c>DATATYPE_BOOL</c><c>Boolean value. Encoded in 8-bits as either 0x00 or 0x01. All other values are illegal.</c>
<c><spanx style="verb">C</spanx></c><c>DATATYPE_UINT8</c><c>Unsigned 8-bit integer.</c>
<c><spanx style="verb">c</spanx></c><c>DATATYPE_INT8</c><c>Signed 8-bit integer.</c>
<c><spanx style="verb">S</spanx></c><c>DATATYPE_UINT16</c><c>Unsigned 16-bit integer.</c>
<c><spanx style="verb">s</spanx></c><c>DATATYPE_INT16</c><c>Signed 16-bit integer.</c>
<c><spanx style="verb">L</spanx></c><c>DATATYPE_UINT32</c><c>Unsigned 32-bit integer.</c>
<c><spanx style="verb">l</spanx></c><c>DATATYPE_INT32</c><c>Signed 32-bit integer.</c>
<c><spanx style="verb">i</spanx></c><c>DATATYPE_UINT_PACKED</c><c>Packed Unsigned Integer. See <xref target="packed-unsigned-integer"/>.</c>
<c><spanx style="verb">6</spanx></c><c>DATATYPE_IPv6ADDR</c><c>IPv6 Address. (Big-endian)</c>
<c><spanx style="verb">E</spanx></c><c>DATATYPE_EUI64</c><c>EUI-64 Address. (Big-endian)</c>
<c><spanx style="verb">e</spanx></c><c>DATATYPE_EUI48</c><c>EUI-48 Address. (Big-endian)</c>
<c><spanx style="verb">D</spanx></c><c>DATATYPE_DATA</c><c>Arbitrary data. See <xref target="data-blobs"/>.</c>
<c><spanx style="verb">d</spanx></c><c>DATATYPE_DATA_WLEN</c><c>Arbitrary data with prepended length. See <xref target="data-blobs"/>.</c>
<c><spanx style="verb">U</spanx></c><c>DATATYPE_UTF8</c><c>Zero-terminated UTF8-encoded string.</c>
<c><spanx style="verb">t(...)</spanx></c><c>DATATYPE_STRUCT</c><c>Structured datatype with prepended length. See <xref target="structured-data"/>.</c>
<c><spanx style="verb">A(...)</spanx></c><c>DATATYPE_ARRAY</c><c>Array of datatypes. Compound type. See <xref target="arrays"/>.</c>
</texttable>
<t>All multi-byte values are little-endian unless explicitly stated
otherwise.
</t>
</section>

<section anchor="packed-unsigned-integer" title="Packed Unsigned Integer">
<t>For certain types of integers, such command or property identifiers,
usually have a value on the wire that is less than 127. However, in
order to not preclude the use of values larger than 255, we would need
to add an extra byte. Doing this would add an extra byte to the
majority of instances, which can add up in terms of bandwidth.
</t>
<t>The packed unsigned integer format is based on the <eref target="https://www.w3.org/TR/exi/#encodingUnsignedInteger">unsigned integer
format in EXI</eref>, except that we limit the maximum value to the
largest value that can be encoded into three bytes(2,097,151).
</t>
<t>For all values less than 127, the packed form of the number is simply
a single byte which directly represents the number. For values larger
than 127, the following process is used to encode the value:
</t>
<t>
<list style="numbers">
<t>The unsigned integer is broken up into <spanx style="emph">n</spanx> 7-bit chunks and placed
into <spanx style="emph">n</spanx> octets, leaving the most significant bit of each octet
unused.</t>
<t>Order the octets from least-significant to most-significant.
(Little-endian)</t>
<t>Clear the most significant bit of the most significant octet. Set
the least significant bit on all other octets.</t>
</list>
</t>
<t>Where <spanx style="emph">n</spanx> is the smallest number of 7-bit chunks you can use to
represent the given value.
</t>
<t>Take the value 1337, for example:
</t>

<figure align="center"><artwork align="center">
1337 =&gt; 0x0539
     =&gt; [39 0A]
     =&gt; [B9 0A]
</artwork></figure>
<t>To decode the value, you collect the 7-bit chunks until you find an
octet with the most significant bit clear.
</t>
</section>

<section anchor="data-blobs" title="Data Blobs">
<t>There are two types for data blobs: <spanx style="verb">d</spanx> and <spanx style="verb">D</spanx>.
</t>
<t>
<list style="symbols">
<t><spanx style="verb">d</spanx> has the length of the data (in bytes) prepended to the data
(with the length encoded as type <spanx style="verb">S</spanx>). The size of the length
field is not included in the length.</t>
<t><spanx style="verb">D</spanx> does not have a prepended length: the length of the data is
implied by the bytes remaining to be parsed. It is an error for
<spanx style="verb">D</spanx> to not be the last type in a type in a type signature.</t>
</list>
</t>
<t>This dichotomy allows for more efficient encoding by eliminating
redundency. If the rest of the buffer is a data blob, encoding the
length would be redundant because we already know how many bytes are
in the rest of the buffer.
</t>
<t>In some cases we use <spanx style="verb">d</spanx> even if it is the last field in a type signature.
We do this to allow for us to be able to append additional fields
to the type signature if necessary in the future. This is usually the
case with embedded structs, like in the scan results.
</t>
<t>For example, let's say we have a buffer that is encoded with the
datatype signature of <spanx style="verb">CLLD</spanx>. In this case, it is pretty easy to tell
where the start and end of the data blob is: the start is 9 bytes from
the start of the buffer, and its length is the length of the buffer
minus 9. (9 is the number of bytes taken up by a byte and two longs)
</t>
<t>The datatype signature <spanx style="verb">CLLDU</spanx> is illegal because we can't determine
where the last field (a zero-terminated UTF8 string) starts. But the
datatype <spanx style="verb">CLLdU</spanx> <spanx style="emph">is</spanx> legal, because the parser can determine the
exact length of the data blob-- allowing it to know where the start
of the next field would be.
</t>
</section>

<section anchor="structured-data" title="Structured Data">
<t>The structure data type (<spanx style="verb">t(...)</spanx>) is a way of bundling together
several fields into a single structure. It can be thought of as a
<spanx style="verb">d</spanx> type except that instead of being opaque, the fields in the
content are known. This is useful for things like scan results where
you have substructures which are defined by different layers.
</t>
<t>For example, consider the type signature <spanx style="verb">Lt(ES)t(6C)</spanx>. In this
hypothetical case, the first struct is defined by the MAC layer, and
the second struct is defined by the PHY layer. Because of the use of
structures, we know exactly what part comes from that layer.
Additionally, we can add fields to each structure without introducing
backward compatability problems: Data encoded as <spanx style="verb">Lt(ESU)t(6C)</spanx> (Notice
the extra <spanx style="verb">U</spanx>) will
decode just fine as <spanx style="verb">Lt(ES)t(6C)</spanx>. Additionally, if we don't care
about the MAC layer and only care about the network layer, we could
parse as <spanx style="verb">Lt()t(6C)</spanx>.
</t>
<t>Note that data encoded as <spanx style="verb">Lt(ES)t(6C)</spanx> will also parse as <spanx style="verb">Ldd</spanx>,
with the structures from both layers now being opaque data blobs.
</t>
</section>

<section anchor="arrays" title="Arrays">
<t>An array is simply a concatenated set of <spanx style="emph">n</spanx> data encodings. For example,
the type <spanx style="verb">A(6)</spanx> is simply a list of IPv6 addresses---one after the other.
The type <spanx style="verb">A(6E)</spanx> likewise a concatenation of IPv6-address/EUI-64 pairs.
</t>
<t>If an array contains many fields, the fields will often be surrounded
by a structure (<spanx style="verb">t(...)</spanx>). This effectively prepends each item in the
array with its length. This is useful for improving parsing performance
or to allow additional fields to be added in the future in a backward
compatible way. If there is a high certainty that additional
fields will never be added, the struct may be omitted (saving two bytes
per item).
</t>
<t>This specification does not define a way to embed an array as a field
alongside other fields.
</t>
</section>
</section>

<section anchor="commands" title="Commands">

<section anchor="cmd-noop" title="CMD 0: (Host-&gt;NCP) CMD_NOOP">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_NOOP</c>
</texttable>
<t>No-Operation command. Induces the NCP to send a success status back to
the host. This is primarily used for liveliness checks.
</t>
<t>The command payload for this command SHOULD be empty. The receiver
MUST ignore any non-empty command payload.
</t>
<t>There is no error condition for this command.
</t>
</section>

<section anchor="cmd-reset" title="CMD 1: (Host-&gt;NCP) CMD_RESET">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_RESET</c>
</texttable>
<t>Reset NCP command. Causes the NCP to perform a software reset. Due to
the nature of this command, the TID is ignored. The host should
instead wait for a <spanx style="verb">CMD_PROP_VALUE_IS</spanx> command from the NCP indicating
<spanx style="verb">PROP_LAST_STATUS</spanx> has been set to <spanx style="verb">STATUS_RESET_SOFTWARE</spanx>.
</t>
<t>The command payload for this command SHOULD be empty. The receiver
MUST ignore any non-empty command payload.
</t>
<t>If an error occurs, the value of <spanx style="verb">PROP_LAST_STATUS</spanx> will be emitted
instead with the value set to the generated status code for the error.
</t>
</section>

<section anchor="cmd-prop-value-get" title="CMD 2: (Host-&gt;NCP) CMD_PROP_VALUE_GET">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_GET</c><c>PROP_ID</c>
</texttable>
<t>Get property value command. Causes the NCP to emit a
<spanx style="verb">CMD_PROP_VALUE_IS</spanx> command for the given property identifier.
</t>
<t>The payload for this command is the property identifier encoded in the
packed unsigned integer format described in <xref target="packed-unsigned-integer"/>.
</t>
<t>If an error occurs, the value of <spanx style="verb">PROP_LAST_STATUS</spanx> will be emitted
instead with the value set to the generated status code for the error.
</t>
</section>

<section anchor="cmd-prop-value-set" title="CMD 3: (Host-&gt;NCP) CMD_PROP_VALUE_SET">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_SET</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Set property value command. Instructs the NCP to set the given
property to the specific given value, replacing any previous value.
</t>
<t>The payload for this command is the property identifier encoded in the
packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by
the property value. The exact format of the property value is defined
by the property.
</t>
<t>If an error occurs, the value of <spanx style="verb">PROP_LAST_STATUS</spanx> will be emitted
with the value set to the generated status code for the error.
</t>
</section>

<section anchor="cmd-prop-value-insert" title="CMD 4: (Host-&gt;NCP) CMD_PROP_VALUE_INSERT">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_INSERT</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Insert value into property command. Instructs the NCP to insert the
given value into a list-oriented property, without removing other
items in the list. The resulting order of items in the list is defined
by the individual property being operated on.
</t>
<t>The payload for this command is the property identifier encoded in the
packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by
the value to be inserted. The exact format of the value is defined by
the property.
</t>
<t>If the type signature of the property specified by <spanx style="verb">PROP_ID</spanx> consists
of a single structure enclosed by an array (<spanx style="verb">A(t(...))</spanx>), then the
contents of <spanx style="verb">VALUE</spanx> MUST contain the contents of the structure (<spanx style="verb">...</spanx>)
rather than the serialization of the whole item (<spanx style="verb">t(...)</spanx>).  Specifically,
the length of the structure MUST NOT be prepended to <spanx style="verb">VALUE</spanx>. This
helps to eliminate redundant data.
</t>
<t>If an error occurs, the value of <spanx style="verb">PROP_LAST_STATUS</spanx> will be emitted
with the value set to the generated status code for the error.
</t>
</section>

<section anchor="cmd-prop-value-remove" title="CMD 5: (Host-&gt;NCP) CMD_PROP_VALUE_REMOVE">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_REMOVE</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Remove value from property command. Instructs the NCP to remove the
given value from a list-oriented property, without affecting other
items in the list. The resulting order of items in the list is defined
by the individual property being operated on.
</t>
<t>Note that this command operates <spanx style="emph">by value</spanx>, not by index!
</t>
<t>The payload for this command is the property identifier encoded in the
packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by
the value to be removed. The exact format of the value is defined by
the property.
</t>
<t>If the type signature of the property specified by <spanx style="verb">PROP_ID</spanx> consists
of a single structure enclosed by an array (<spanx style="verb">A(t(...))</spanx>), then the
contents of <spanx style="verb">VALUE</spanx> MUST contain the contents of the structure (<spanx style="verb">...</spanx>)
rather than the serialization of the whole item (<spanx style="verb">t(...)</spanx>).  Specifically,
the length of the structure MUST NOT be prepended to <spanx style="verb">VALUE</spanx>. This
helps to eliminate redundant data.
</t>
<t>If an error occurs, the value of <spanx style="verb">PROP_LAST_STATUS</spanx> will be emitted
with the value set to the generated status code for the error.
</t>
</section>

<section anchor="cmd-prop-value-is" title="CMD 6: (NCP-&gt;Host) CMD_PROP_VALUE_IS">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_IS</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Property value notification command. This command can be sent by the
NCP in response to a previous command from the host, or it can be sent
by the NCP in an unsolicited fashion to notify the host of various
state changes asynchronously.
</t>
<t>The payload for this command is the property identifier encoded in the
packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by
the current value of the given property.
</t>
</section>

<section anchor="cmd-prop-value-inserted" title="CMD 7: (NCP-&gt;Host) CMD_PROP_VALUE_INSERTED">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_INSERTED</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Property value insertion notification command. This command can be
sent by the NCP in response to the <spanx style="verb">CMD_PROP_VALUE_INSERT</spanx> command, or
it can be sent by the NCP in an unsolicited fashion to notify the host
of various state changes asynchronously.
</t>
<t>The payload for this command is the property identifier encoded in the
packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by
the value that was inserted into the given property.
</t>
<t>If the type signature of the property specified by <spanx style="verb">PROP_ID</spanx> consists
of a single structure enclosed by an array (<spanx style="verb">A(t(...))</spanx>), then the
contents of <spanx style="verb">VALUE</spanx> MUST contain the contents of the structure (<spanx style="verb">...</spanx>)
rather than the serialization of the whole item (<spanx style="verb">t(...)</spanx>).  Specifically,
the length of the structure MUST NOT be prepended to <spanx style="verb">VALUE</spanx>. This
helps to eliminate redundant data.
</t>
<t>The resulting order of items in the list is defined by the given
property.
</t>
</section>

<section anchor="cmd-prop-value-removed" title="CMD 8: (NCP-&gt;Host) CMD_PROP_VALUE_REMOVED">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_REMOVED</c><c>PROP_ID</c><c>VALUE</c>
</texttable>
<t>Property value removal notification command. This command can be sent
by the NCP in response to the <spanx style="verb">CMD_PROP_VALUE_REMOVE</spanx> command, or it
can be sent by the NCP in an unsolicited fashion to notify the host of
various state changes asynchronously.
</t>
<t>Note that this command operates <spanx style="emph">by value</spanx>, not by index!
</t>
<t>The payload for this command is the property identifier encoded in the
packed unsigned integer format described in <xref target="packed-unsigned-integer"/>, followed by
the value that was removed from the given property.
</t>
<t>If the type signature of the property specified by <spanx style="verb">PROP_ID</spanx> consists
of a single structure enclosed by an array (<spanx style="verb">A(t(...))</spanx>), then the
contents of <spanx style="verb">VALUE</spanx> MUST contain the contents of the structure (<spanx style="verb">...</spanx>)
rather than the serialization of the whole item (<spanx style="verb">t(...)</spanx>).  Specifically,
the length of the structure MUST NOT be prepended to <spanx style="verb">VALUE</spanx>. This
helps to eliminate redundant data.
</t>
<t>The resulting order of items in the list is defined by the given
property.
</t>
</section>

<section anchor="cmd-peek" title="CMD 18: (Host-&gt;NCP) CMD_PEEK">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">4</ttcol>
<ttcol align="center">2</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PEEK</c><c>ADDRESS</c><c>COUNT</c>
</texttable>
<t>This command allows the NCP to fetch values from the RAM of the NCP
for debugging purposes. Upon success, <spanx style="verb">CMD_PEEK_RET</spanx> is sent from the
NCP to the host. Upon failure, <spanx style="verb">PROP_LAST_STATUS</spanx> is emitted with
the appropriate error indication.
</t>
<t>Due to the low-level nature of this command, certain error conditions
may induce the NCP to reset.
</t>
<t>The NCP MAY prevent certain regions of memory from being accessed.
</t>
<t>The implementation of this command has security implications.
See <xref target="security-considerations"/> for more information.
</t>
<t>This command requires the capability <spanx style="verb">CAP_PEEK_POKE</spanx> to be present.
</t>
</section>

<section anchor="cmd-peek-ret" title="CMD 19: (NCP-&gt;Host) CMD_PEEK_RET">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">4</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PEEK_RET</c><c>ADDRESS</c><c>COUNT</c><c>BYTES</c>
</texttable>
<t>This command contains the contents of memory that was requested by
a previous call to <spanx style="verb">CMD_PEEK</spanx>.
</t>
<t>This command requires the capability <spanx style="verb">CAP_PEEK_POKE</spanx> to be present.
</t>
</section>

<section anchor="cmd-poke" title="CMD 20: (Host-&gt;NCP) CMD_POKE">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">4</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_POKE</c><c>ADDRESS</c><c>COUNT</c><c>BYTES</c>
</texttable>
<t>This command writes the bytes to the specified memory address
for debugging purposes.
</t>
<t>Due to the low-level nature of this command, certain error conditions
may induce the NCP to reset.
</t>
<t>The implementation of this command has security implications.
See <xref target="security-considerations"/> for more information.
</t>
<t>This command requires the capability <spanx style="verb">CAP_PEEK_POKE</spanx> to be present.
</t>
</section>

<section anchor="cmd-prop-value-multi-get" title="CMD 21: (Host-&gt;NCP) CMD_PROP_VALUE_MULTI_GET">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">A(i)</spanx></t>
<t>Required Capability: <spanx style="verb">CAP_CMD_MULTI</spanx></t>
</list>
</t>
<t>Fetch the value of multiple properties in one command. Arguments are
an array of property IDs. If all properties are fetched successfully,
a <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> command is sent back to the host containing
the propertyid and value of each fetched property. The order of the
results in <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> match the order of properties given
in <spanx style="verb">CMD_PROP_VALUE_GET</spanx>.
</t>
<t>Errors fetching individual properties are reflected as indicating a
change to <spanx style="verb">PROP_LAST_STATUS</spanx> for that property's place.
</t>
<t>Not all properties can be fetched using this method. As a general rule
of thumb, any property that blocks when getting will fail for that
individual property with <spanx style="verb">STATUS_INVALID_COMMAND_FOR_PROP</spanx>.
</t>
</section>

<section anchor="cmd-prop-value-multi-set" title="CMD 22: (Host-&gt;NCP) CMD_PROP_VALUE_MULTI_SET">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">A(iD)</spanx></t>
<t>Required Capability: <spanx style="verb">CAP_CMD_MULTI</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUE_MULTI_SET</c><c>Property/Value Pairs</c>
</texttable>
<t>With each property/value pair being:
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>LENGTH</c><c>PROP_ID</c><c>PROP_VALUE</c>
</texttable>
<t>This command sets the value of several properties at once in the given
order. The setting of properties stops at the first error, ignoring
any later properties.
</t>
<t>The result of this command is generally <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> unless
(for example) a parsing error has occured (in which case
<spanx style="verb">CMD_PROP_VALUE_IS</spanx> for <spanx style="verb">PROP_LAST_STATUS</spanx> would be the result). The
order of the results in <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> match the order of
properties given in <spanx style="verb">CMD_PROP_VALUE_MULTI_SET</spanx>.
</t>
<t>Since the processing of properties to set stops at the first error,
the resulting <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> can contain fewer items than the
requested number of properties to set.
</t>
<t>Not all properties can be set using this method. As a general rule
of thumb, any property that blocks when setting will fail for that
individual property with <spanx style="verb">STATUS_INVALID_COMMAND_FOR_PROP</spanx>.
</t>
</section>

<section anchor="cmd-prop-values-are" title="CMD 23: (NCP-&gt;Host) CMD_PROP_VALUES_ARE">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">A(iD)</spanx></t>
<t>Required Capability: <spanx style="verb">CAP_CMD_MULTI</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_PROP_VALUES_ARE</c><c>Property/Value Pairs</c>
</texttable>
<t>With each property/value pair being:
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>LENGTH</c><c>PROP_ID</c><c>PROP_VALUE</c>
</texttable>
<t>This command is emitted by the NCP as the response to both the
<spanx style="verb">CMD_PROP_VALUE_MULTI_GET</spanx> and <spanx style="verb">CMD_PROP_VALUE_MULTI_SET</spanx> commands. It
is roughly analogous to <spanx style="verb">CMD_PROP_VALUE_IS</spanx>, except that it contains
more than one property.
</t>
<t>This command SHOULD NOT be emitted asynchronously, or in response to
any command other than <spanx style="verb">CMD_PROP_VALUE_MULTI_GET</spanx> or
<spanx style="verb">CMD_PROP_VALUE_MULTI_SET</spanx>.
</t>
<t>The arguments are a list of structures containing the emitted property
and the associated value. These are presented in the same order as
given in the associated initiating command. In cases where getting or
setting a specific property resulted in an error, the associated slot
in this command will describe <spanx style="verb">PROP_LAST_STATUS</spanx>.
</t>
</section>
</section>

<section anchor="properties" title="Properties">
<t>Spinel is largely a property-based protocol, similar to representational state transfer (REST), with a property defined for every attribute that an OS needs to create, read, update or delete in the function of an IPv6 interface. The inspiration of this approach was memory-mapped hardware registers for peripherals. The goal is to avoid, as much as possible, the use of large complicated structures and/or method argument lists. The reason for avoiding these is because they have a tendency to change, especially early in development. Adding or removing a property from a structure can render the entire protocol incompatible. By using properties, you simply extend the protocol with an additional property.
</t>
<t>Almost all features and capabilities are implemented using properties. Most new features that are initially proposed as commands can be adapted to be property-based instead. Notable exceptions include &quot;Host Buffer Offload&quot; (<xref target="feature-host-buffer-offload"/>) and &quot;Network Save&quot; (<xref target="feature-network-save"/>).
</t>
<t>In Spinel, properties are keyed by an unsigned integer between 0 and 2,097,151 (See <xref target="packed-unsigned-integer"/>).
</t>

<section anchor="property-methods" title="Property Methods">
<t>Properties may support one or more of the following methods:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">VALUE_GET</spanx> (<xref target="cmd-prop-value-get"/>)</t>
<t><spanx style="verb">VALUE_SET</spanx> (<xref target="cmd-prop-value-set"/>)</t>
<t><spanx style="verb">VALUE_INSERT</spanx>  (<xref target="cmd-prop-value-insert"/>)</t>
<t><spanx style="verb">VALUE_REMOVE</spanx>  (<xref target="cmd-prop-value-remove"/>)</t>
</list>
</t>
<t>Additionally, the NCP can send updates to the host (either synchronously or asynchronously) that inform the host about changes to specific properties:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">VALUE_IS</spanx>  (<xref target="cmd-prop-value-is"/>)</t>
<t><spanx style="verb">VALUE_INSERTED</spanx>  (<xref target="cmd-prop-value-inserted"/>)</t>
<t><spanx style="verb">VALUE_REMOVED</spanx>  (<xref target="cmd-prop-value-removed"/>)</t>
</list>
</t>
</section>

<section anchor="property-types" title="Property Types">
<t>Conceptually, there are three different types of properties:
</t>
<t>
<list style="symbols">
<t>Single-value properties</t>
<t>Multiple-value (Array) properties</t>
<t>Stream properties</t>
</list>
</t>

<section anchor="singlevalue-properties" title="Single-Value Properties">
<t>Single-value properties are properties that have a simple representation of a single value. Examples would be:
</t>
<t>
<list style="symbols">
<t>Current radio channel (Represented as an unsigned 8-bit integer)</t>
<t>Network name (Represented as a UTF-8 encoded string)</t>
<t>802.15.4 PAN ID (Represented as an unsigned 16-bit integer)</t>
</list>
</t>
<t>The valid operations on these sorts of properties are <spanx style="verb">GET</spanx> and <spanx style="verb">SET</spanx>.
</t>
</section>

<section anchor="multiplevalue-properties" title="Multiple-Value Properties">
<t>Multiple-Value Properties have more than one value associated with them. Examples would be:
</t>
<t>
<list style="symbols">
<t>List of channels supported by the radio hardware.</t>
<t>List of IPv6 addresses assigned to the interface.</t>
<t>List of capabilities supported by the NCP.</t>
</list>
</t>
<t>The valid operations on these sorts of properties are <spanx style="verb">VALUE_GET</spanx>, <spanx style="verb">VALUE_SET</spanx>, <spanx style="verb">VALUE_INSERT</spanx>, and <spanx style="verb">VALUE_REMOVE</spanx>.
</t>
<t>When the value is fetched using <spanx style="verb">VALUE_GET</spanx>, the returned value is the concatenation of all of the individual values in the list. If the length of the value for an individual item in the list is not defined by the type then each item returned in the list is prepended with a length (See <xref target="arrays"/>). The order of the returned items, unless explicitly defined for that specific property, is undefined.
</t>
<t><spanx style="verb">VALUE_SET</spanx> provides a way to completely replace all previous values. Calling <spanx style="verb">VALUE_SET</spanx> with an empty value effectively instructs the NCP to clear the value of that property.
</t>
<t><spanx style="verb">VALUE_INSERT</spanx> and <spanx style="verb">VALUE_REMOVE</spanx> provide mechanisms for the insertion or removal of individual items <spanx style="emph">by value</spanx>. The payload for these commands is a plain single value.
</t>
</section>

<section anchor="stream-properties" title="Stream Properties">
<t>Stream properties are special properties representing streams of data. Examples would be:
</t>
<t>
<list style="symbols">
<t>Network packet stream (<xref target="prop-stream-net"/>)</t>
<t>Raw packet stream (<xref target="prop-stream-raw"/>)</t>
<t>Debug message stream (<xref target="prop-stream-debug"/>)</t>
<t>Network Beacon stream (<xref target="prop-mac-scan-beacon"/>)</t>
</list>
</t>
<t>All such properties emit changes asynchronously using the <spanx style="verb">VALUE_IS</spanx> command, sent from the NCP to the host. For example, as IPv6 traffic is received by the NCP, the IPv6 packets are sent to the host by way of asynchronous <spanx style="verb">VALUE_IS</spanx> notifications.
</t>
<t>Some of these properties also support the host send data back to the NCP. For example, this is how the host sends IPv6 traffic to the NCP.
</t>
<t>These types of properties generally do not support <spanx style="verb">VALUE_GET</spanx>, as it is meaningless.
</t>
</section>
</section>

<section anchor="property-numbering" title="Property Numbering">
<t>While the majority of the properties that allow the configuration
of network connectivity are network protocol specific, there are
several properties that are required in all implementations.
</t>
<t>Future property allocations SHALL be made from the
following allocation plan:
</t>
<texttable>
<ttcol align="left">Property ID Range</ttcol>
<ttcol align="left">Description</ttcol>

<c>0 - 127</c><c>Reserved for frequently-used properties</c>
<c>128 - 15,359</c><c>Unallocated</c>
<c>15,360 - 16,383</c><c>Vendor-specific</c>
<c>16,384 - 1,999,999</c><c>Unallocated</c>
<c>2,000,000 - 2,097,151</c><c>Experimental use only</c>
</texttable>
<t>For an explanation of the data format encoding shorthand used
throughout this document, see <xref target="data-packing"/>.
</t>
</section>

<section anchor="property-sections" title="Property Sections">
<t>The currently assigned properties are broken up into several
sections, each with reserved ranges of property identifiers.
These ranges are:
</t>
<texttable>
<ttcol align="center">Name</ttcol>
<ttcol align="center">Range (Inclusive)</ttcol>
<ttcol align="center">Documentation</ttcol>

<c>Core</c><c>0x00 - 0x1F, 0x1000 - 0x11FF</c><c><xref target="prop-core"/></c>
<c>PHY</c><c>0x20 - 0x2F, 0x1200 - 0x12FF</c><c><xref target="prop-phy"/></c>
<c>MAC</c><c>0x30 - 0x3F, 0x1300 - 0x13FF</c><c><xref target="prop-mac"/></c>
<c>NET</c><c>0x40 - 0x4F, 0x1400 - 0x14FF</c><c><xref target="prop-net"/></c>
<c>Tech</c><c>0x50 - 0x5F, 0x1500 - 0x15FF</c><c>Technology-specific</c>
<c>IPv6</c><c>0x60 - 0x6F, 0x1600 - 0x16FF</c><c><xref target="prop-ipv6"/></c>
<c>Stream</c><c>0x70 - 0x7F, 0x1700 - 0x17FF</c><c><xref target="prop-core"/></c>
<c>Debug</c><c>0x4000 - 0x4400</c><c><xref target="prop-debug"/></c>
</texttable>
<t>Note that some of the property sections have two reserved
ranges: a primary range (which is encoded as a single byte)
and an extended range (which is encoded as two bytes).
properties which are used more frequently are generally
allocated from the former range.
</t>
</section>

<section anchor="prop-core" title="Core Properties">

<section anchor="prop-last-status" title="PROP 0: PROP_LAST_STATUS">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Encoding: <spanx style="verb">i</spanx></t>
</list>
</t>
<texttable>
<ttcol align="right">Octets:</ttcol>
<ttcol align="center">1-3</ttcol>

<c>Fields:</c><c>LAST_STATUS</c>
</texttable>
<t>Describes the status of the last operation. Encoded as a packed
unsigned integer.
</t>
<t>This property is emitted often to indicate the result status of
pretty much any Host-to-NCP operation.
</t>
<t>It is emitted automatically at NCP startup with a value indicating
the reset reason.
</t>
<t>See <xref target="status-codes"/> for the complete list of status codes.
</t>
</section>

<section anchor="prop-protocol-version" title="PROP 1: PROP_PROTOCOL_VERSION">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Encoding: <spanx style="verb">ii</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">1-3</ttcol>

<c>Fields:</c><c>MAJOR_VERSION</c><c>MINOR_VERSION</c>
</texttable>
<t>Describes the protocol version information. This property contains
four fields, each encoded as a packed unsigned integer:
</t>
<t>
<list style="symbols">
<t>Major Version Number</t>
<t>Minor Version Number</t>
</list>
</t>
<t>This document describes major version 4, minor version 3 of this protocol.
</t>
<t>The host MUST only use this property from NLI 0. Behavior when used
from other NLIs is undefined.
</t>

<section anchor="major-version-number" title="Major Version Number">
<t>The major version number is used to identify large and incompatible
differences between protocol versions.
</t>
<t>The host MUST enter a FAULT state if it does not explicitly support
the given major version number.
</t>
</section>

<section anchor="minor-version-number" title="Minor Version Number">
<t>The minor version number is used to identify small but otherwise
compatible differences between protocol versions. A mismatch between
the advertised minor version number and the minor version that is
supported by the host SHOULD NOT be fatal to the operation of the
host.
</t>
</section>
</section>

<section anchor="prop-ncp-version" title="PROP 2: PROP_NCP_VERSION">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">U</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>NCP_VESION_STRING</c>
</texttable>
<t>Contains a string which describes the firmware currently running on
the NCP. Encoded as a zero-terminated UTF-8 string.
</t>
<t>The format of the string is not strictly defined, but it is intended
to present similarly to the &quot;User-Agent&quot; string from HTTP. The
RECOMMENDED format of the string is as follows:
</t>

<figure align="center"><artwork align="center">
STACK-NAME/STACK-VERSION[BUILD_INFO][; OTHER_INFO]; BUILD_DATE_AND_TIME
</artwork></figure>
<t>Examples:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">OpenThread/1.0d26-25-gb684c7f; DEBUG; May 9 2016 18:22:04</spanx></t>
<t><spanx style="verb">ConnectIP/2.0b125 s1 ALPHA; Sept 24 2015 20:49:19</spanx></t>
</list>
</t>
<t>The host MUST only use this property from NLI 0. Behavior when used
from other NLIs is undefined.
</t>
</section>

<section anchor="prop-interface-type" title="PROP 3: PROP_INTERFACE_TYPE">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Encoding: <spanx style="verb">i</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1-3</ttcol>

<c>Fields:</c><c>INTERFACE_TYPE</c>
</texttable>
<t>This integer identifies what the network protocol for this NCP.
Currently defined values are:
</t>
<t>
<list style="symbols">
<t>0: Bootloader</t>
<t>2: ZigBee IP(TM)</t>
<t>3: Thread(R)</t>
</list>
</t>
<t>The host MUST enter a FAULT state if it does not recognize the
protocol given by the NCP.
</t>
</section>

<section anchor="prop-interface-vendor-id" title="PROP 4: PROP_INTERFACE_VENDOR_ID">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Encoding: <spanx style="verb">i</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1-3</ttcol>

<c>Fields:</c><c>VENDOR_ID</c>
</texttable>
<t>Vendor identifier.
</t>
</section>

<section anchor="prop-caps" title="PROP 5: PROP_CAPS">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">A(i)</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">1-3</ttcol>
<ttcol align="center">...</ttcol>

<c>Fields:</c><c>CAP_1</c><c>CAP_2</c><c>...</c>
</texttable>
<t>Describes the supported capabilities of this NCP. Encoded as a list of
packed unsigned integers.
</t>
<t>A capability is defined as a 21-bit integer that describes a subset of
functionality which is supported by the NCP.
</t>
<t>Currently defined values are:
</t>
<t>
<list style="symbols">
<t>1: <spanx style="verb">CAP_LOCK</spanx></t>
<t>2: <spanx style="verb">CAP_NET_SAVE</spanx></t>
<t>3: <spanx style="verb">CAP_HBO</spanx>: Host Buffer Offload. See <xref target="feature-host-buffer-offload"/>.</t>
<t>4: <spanx style="verb">CAP_POWER_SAVE</spanx></t>
<t>5: <spanx style="verb">CAP_COUNTERS</spanx></t>
<t>6: <spanx style="verb">CAP_JAM_DETECT</spanx>: Jamming detection. See <xref target="feature-jam-detect"/></t>
<t>7: <spanx style="verb">CAP_PEEK_POKE</spanx>: PEEK/POKE debugging commands.</t>
<t>8: <spanx style="verb">CAP_WRITABLE_RAW_STREAM</spanx>: <spanx style="verb">PROP_STREAM_RAW</spanx> is writable.</t>
<t>9: <spanx style="verb">CAP_GPIO</spanx>: Support for GPIO access. See <xref target="feature-gpio-access"/>.</t>
<t>10: <spanx style="verb">CAP_TRNG</spanx>: Support for true random number generation. See <xref target="feature-trng"/>.</t>
<t>11: <spanx style="verb">CAP_CMD_MULTI</spanx>: Support for <spanx style="verb">CMD_PROP_VALUE_MULTI_GET</spanx> (<xref target="cmd-prop-value-multi-get"/>), <spanx style="verb">CMD_PROP_VALUE_MULTI_SET</spanx> (<xref target="cmd-prop-value-multi-set"/>, and <spanx style="verb">CMD_PROP_VALUES_ARE</spanx> (<xref target="cmd-prop-values-are"/>).</t>
<t>12: <spanx style="verb">CAP_UNSOL_UPDATE_FILTER</spanx>: Support for <spanx style="verb">PROP_UNSOL_UPDATE_FILTER</spanx> (<xref target="prop-unsol-update-filter"/>) and <spanx style="verb">PROP_UNSOL_UPDATE_LIST</spanx> (<xref target="prop-unsol-update-list"/>).</t>
<t>16: <spanx style="verb">CAP_802_15_4_2003</spanx></t>
<t>17: <spanx style="verb">CAP_802_15_4_2006</spanx></t>
<t>18: <spanx style="verb">CAP_802_15_4_2011</spanx></t>
<t>21: <spanx style="verb">CAP_802_15_4_PIB</spanx></t>
<t>24: <spanx style="verb">CAP_802_15_4_2450MHZ_OQPSK</spanx></t>
<t>25: <spanx style="verb">CAP_802_15_4_915MHZ_OQPSK</spanx></t>
<t>26: <spanx style="verb">CAP_802_15_4_868MHZ_OQPSK</spanx></t>
<t>27: <spanx style="verb">CAP_802_15_4_915MHZ_BPSK</spanx></t>
<t>28: <spanx style="verb">CAP_802_15_4_868MHZ_BPSK</spanx></t>
<t>29: <spanx style="verb">CAP_802_15_4_915MHZ_ASK</spanx></t>
<t>30: <spanx style="verb">CAP_802_15_4_868MHZ_ASK</spanx></t>
<t>48: <spanx style="verb">CAP_ROLE_ROUTER</spanx></t>
<t>49: <spanx style="verb">CAP_ROLE_SLEEPY</spanx></t>
<t>52: <spanx style="verb">CAP_NET_THREAD_1_0</spanx></t>
<t>512: <spanx style="verb">CAP_MAC_WHITELIST</spanx></t>
<t>513: <spanx style="verb">CAP_MAC_RAW</spanx></t>
<t>514: <spanx style="verb">CAP_OOB_STEERING_DATA</spanx></t>
<t>1024: <spanx style="verb">CAP_THREAD_COMMISSIONER</spanx></t>
<t>1025: <spanx style="verb">CAP_THREAD_TMF_PROXY</spanx></t>
</list>
</t>
<t>Additionally, future capability allocations SHALL be made from the
following allocation plan:
</t>
<texttable>
<ttcol align="center">Capability Range</ttcol>
<ttcol align="center">Description</ttcol>

<c>0 - 127</c><c>Reserved for core capabilities</c>
<c>128 - 15,359</c><c><spanx style="emph">UNALLOCATED</spanx></c>
<c>15,360 - 16,383</c><c>Vendor-specific</c>
<c>16,384 - 1,999,999</c><c><spanx style="emph">UNALLOCATED</spanx></c>
<c>2,000,000 - 2,097,151</c><c>Experimental use only</c>
</texttable>
</section>

<section anchor="prop-interface-count" title="PROP 6: PROP_INTERFACE_COUNT">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c><spanx style="verb">INTERFACE_COUNT</spanx></c>
</texttable>
<t>Describes the number of concurrent interfaces supported by this NCP.
Since the concurrent interface mechanism is still TBD, this value MUST
always be one.
</t>
<t>This value is encoded as an unsigned 8-bit integer.
</t>
<t>The host MUST only use this property from NLI 0. Behavior when used
from other NLIs is undefined.
</t>
</section>

<section anchor="prop-power-state" title="PROP 7: PROP_POWER_STATE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c>POWER_STATE</c>
</texttable>
<t>Describes the current power state of the NCP. By writing to this
property you can manage the lower state of the NCP. Enumeration is
encoded as a single unsigned byte.
</t>
<t>Defined values are:
</t>
<t>
<list style="symbols">
<t>0: <spanx style="verb">POWER_STATE_OFFLINE</spanx>: NCP is physically powered off.
(Enumerated for completeness sake, not expected on the wire)</t>
<t>1: <spanx style="verb">POWER_STATE_DEEP_SLEEP</spanx>: Almost everything on the NCP is shut
down, but can still be resumed via a command or interrupt.</t>
<t>2: <spanx style="verb">POWER_STATE_STANDBY</spanx>: NCP is in the lowest power state that
can still be awoken by an event from the radio (e.g. waiting for
alarm)</t>
<t>3: <spanx style="verb">POWER_STATE_LOW_POWER</spanx>: NCP is responsive (and possibly
connected), but using less power. (e.g. &quot;Sleepy&quot; child node)</t>
<t>4: <spanx style="verb">POWER_STATE_ONLINE</spanx>: NCP is fully powered. (e.g. &quot;Parent&quot;
node)</t>
</list>
</t>
<t><cref source="RQ">We should consider reversing the numbering here so that 0 is
     `POWER_STATE_ONLINE`. We may also want to include some extra
     values between the defined values for future expansion, so
     that we can preserve the ordered relationship. --</cref></t>
</section>

<section anchor="prop-hwaddr" title="PROP 8: PROP_HWADDR">
<t>
<list style="symbols">
<t>Type: Read-Only*</t>
<t>Packed-Encoding: <spanx style="verb">E</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">8</ttcol>

<c>Fields:</c><c>HWADDR</c>
</texttable>
<t>The static EUI64 address of the device, used as a serial number.
This value is read-only, but may be writable under certain
vendor-defined circumstances.
</t>
</section>

<section anchor="prop-lock" title="PROP 9: PROP_LOCK">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c>LOCK</c>
</texttable>
<t>Property lock. Used for grouping changes to several properties to
take effect at once, or to temporarily prevent the automatic updating
of property values. When this property is set, the execution of the
NCP is effectively frozen until it is cleared.
</t>
<t>This property is only supported if the <spanx style="verb">CAP_LOCK</spanx> capability is present.
</t>
<t>Unlike most other properties, setting this property to true when the
value of the property is already true MUST fail with a last status
of <spanx style="verb">STATUS_ALREADY</spanx>.
</t>
</section>

<section anchor="prop-host-power-state" title="PROP 10: PROP_HOST_POWER_STATE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
<t>Default value: 4</t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c><spanx style="verb">HOST_POWER_STATE</spanx></c>
</texttable>
<t>Describes the current power state of the <spanx style="emph">host</spanx>. This property is used
by the host to inform the NCP when it has changed power states. The
NCP can then use this state to determine which properties need
asynchronous updates. Enumeration is encoded as a single unsigned
byte. These states are defined in similar terms to <spanx style="verb">PROP_POWER_STATE</spanx>
(<xref target="prop-power-state"/>).
</t>
<t>Defined values are:
</t>
<t>
<list style="symbols">
<t>0: <spanx style="verb">HOST_POWER_STATE_OFFLINE</spanx>: Host is physically powered off and
cannot be woken by the NCP. All asynchronous commands are
squelched.</t>
<t>1: <spanx style="verb">HOST_POWER_STATE_DEEP_SLEEP</spanx>: The host is in a low power state
where it can be woken by the NCP but will potentially require more
than two seconds to become fully responsive. The NCP MUST
avoid sending unnecessary property updates, such as child table
updates or non-critical messages on the debug stream. If the NCP
needs to wake the host for traffic, the NCP MUST first take
action to wake the host. Once the NCP signals to the host that it
should wake up, the NCP MUST wait for some activity from the
host (indicating that it is fully awake) before sending frames.</t>
<t>2: <spanx style="strong">RESERVED</spanx>. This value MUST NOT be set by the host. If
received by the NCP, the NCP SHOULD consider this as a synonym
of <spanx style="verb">HOST_POWER_STATE_DEEP_SLEEP</spanx>.</t>
<t>3: <spanx style="verb">HOST_POWER_STATE_LOW_POWER</spanx>: The host is in a low power state
where it can be immediately woken by the NCP. The NCP SHOULD
avoid sending unnecessary property updates, such as child table
updates or non-critical messages on the debug stream.</t>
<t>4: <spanx style="verb">HOST_POWER_STATE_ONLINE</spanx>: The host is awake and responsive. No
special filtering is performed by the NCP on asynchronous updates.</t>
<t>All other values are <spanx style="strong">RESERVED</spanx>. They MUST NOT be set by the
host. If received by the NCP, the NCP SHOULD consider the value as
a synonym of <spanx style="verb">HOST_POWER_STATE_LOW_POWER</spanx>.</t>
</list>
</t>
<t><cref source="RQ">We should consider reversing the numbering here so that 0 is
     `POWER_STATE_ONLINE`. We may also want to include some extra
     values between the defined values for future expansion, so
     that we can preserve the ordered relationship. --</cref></t>
<t>After setting this power state, any further commands from the host to
the NCP will cause <spanx style="verb">HOST_POWER_STATE</spanx> to automatically revert to
<spanx style="verb">HOST_POWER_STATE_ONLINE</spanx>.
</t>
<t>When the host is entering a low-power state, it should wait for the
response from the NCP acknowledging the command (with <spanx style="verb">CMD_VALUE_IS</spanx>).
Once that acknowledgement is received the host may enter the low-power
state.
</t>
<t>If the NCP has the <spanx style="verb">CAP_UNSOL_UPDATE_FILTER</spanx> capability, any unsolicited
property updates masked by <spanx style="verb">PROP_UNSOL_UPDATE_FILTER</spanx> should be honored
while the host indicates it is in a low-power state. After resuming to the
<spanx style="verb">HOST_POWER_STATE_ONLINE</spanx> state, the value of <spanx style="verb">PROP_UNSOL_UPDATE_FILTER</spanx>
MUST be unchanged from the value assigned prior to the host indicating
it was entering a low-power state.
</t>
<t>The host MUST only use this property from NLI 0. Behavior when used
from other NLIs is undefined.
</t>
</section>

<section anchor="prop-unsol-update-filter" title="PROP 4104: PROP_UNSOL_UPDATE_FILTER">
<t>
<list style="symbols">
<t>Required only if <spanx style="verb">CAP_UNSOL_UPDATE_FILTER</spanx> is set.</t>
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">A(I)</spanx></t>
<t>Default value: Empty.</t>
</list>
</t>
<t>Contains a list of properties which are <spanx style="emph">excluded</spanx> from generating
unsolicited value updates. This property MUST be empty after reset.
</t>
<t>In other words, the host may opt-out of unsolicited property updates
for a specific property by adding that property id to this list.
</t>
<t>Hosts SHOULD NOT add properties to this list which are not
present in <spanx style="verb">PROP_UNSOL_UPDATE_LIST</spanx>. If such properties are added,
the NCP MUST ignore the unsupported properties.
</t>
<t><cref source="RQ">The justification for the above behavior is to attempt to avoid possible
     future interop problems by explicitly making sure that unknown
     properties are ignored. Since unknown properties will obviously not be
     generating unsolicited updates, it seems fairly harmless. An
     implementation may print out a warning to the debug stream.

     Note that the error is still detectable: If you VALUE\_SET unsupported
     properties, the resulting VALUE\_IS would contain only the supported
     properties of that set(since the unsupported properties would be
     ignored). If an implementation cares that much about getting this
     right then it needs to make sure that it checks
     PROP\_UNSOL\_UPDATE\_LIST first.
  --</cref></t>
<t>Implementations of this property are only REQUIRED to support
and use the following commands:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CMD_PROP_VALUE_GET</spanx> (<xref target="cmd-prop-value-get"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_SET</spanx> (<xref target="cmd-prop-value-set"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_IS</spanx> (<xref target="cmd-prop-value-is"/>)</t>
</list>
</t>
<t>Implementations of this property MAY optionally support and use
the following commands:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CMD_PROP_VALUE_INSERT</spanx> (<xref target="cmd-prop-value-insert"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_REMOVE</spanx> (<xref target="cmd-prop-value-remove"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_INSERTED</spanx> (<xref target="cmd-prop-value-inserted"/>)</t>
<t><spanx style="verb">CMD_PROP_VALUE_REMOVED</spanx> (<xref target="cmd-prop-value-removed"/>)</t>
</list>
</t>
<t>Host implementations which are aiming to maximize their compatability across
different firmwre implementations SHOULD NOT assume the availability of the
optional commands for this property.
</t>
<t>The value of this property SHALL be independent for each NLI.
</t>
</section>

<section anchor="prop-unsol-update-list" title="PROP 4105: PROP_UNSOL_UPDATE_LIST">
<t>
<list style="symbols">
<t>Required only if <spanx style="verb">CAP_UNSOL_UPDATE_FILTER</spanx> is set.</t>
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">A(I)</spanx></t>
</list>
</t>
<t>Contains a list of properties which are capable of generating
unsolicited value updates. This list can be used when populating
<spanx style="verb">PROP_UNSOL_UPDATE_FILTER</spanx> to disable all unsolicited property
updates.
</t>
<t>This property is intended to effectively behave as a constant
for a given NCP firmware.
</t>
<t>Note that not all properties that support unsolicited updates need to
be listed here. Scan results, for example, are only generated due to
direct action on the part of the host, so those properties MUST NOT
not be included in this list.
</t>
<t>The value of this property MAY be different across available
NLIs.
</t>
</section>
</section>

<section anchor="prop-stream" title="Stream Properties">

<section anchor="prop-stream-debug" title="PROP 112: PROP_STREAM_DEBUG">
<t>
<list style="symbols">
<t>Type: Read-Only-Stream</t>
<t>Packed-Encoding: <spanx style="verb">D</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>UTF8_DATA</c>
</texttable>
<t>This property is a streaming property, meaning that you cannot explicitly
fetch the value of this property. The stream provides human-readable debugging
output which may be displayed in the host logs.
</t>
<t>The location of newline characters is not assumed by the host: it is
the NCP's responsibility to insert newline characters where needed,
just like with any other text stream.
</t>
<t>To receive the debugging stream, you wait for <spanx style="verb">CMD_PROP_VALUE_IS</spanx>
commands for this property from the NCP.
</t>
</section>

<section anchor="prop-stream-raw" title="PROP 113: PROP_STREAM_RAW">
<t>
<list style="symbols">
<t>Type: Read-Write-Stream</t>
<t>Packed-Encoding: <spanx style="verb">dD</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>FRAME_DATA_LEN</c><c>FRAME_DATA</c><c>FRAME_METADATA</c>
</texttable>
<t>This stream provides the capability of sending and receiving raw packets
to and from the radio. The exact format of the frame metadata and data is
dependent on the MAC and PHY being used.
</t>
<t>This property is a streaming property, meaning that you cannot explicitly
fetch the value of this property. To receive traffic, you wait for
<spanx style="verb">CMD_PROP_VALUE_IS</spanx> commands with this property id from the NCP.
</t>
<t>Implementations may OPTIONALLY support the ability to transmit arbitrary
raw packets. Support for this feature is indicated by the presence of the
<spanx style="verb">CAP_WRITABLE_RAW_STREAM</spanx> capability.
</t>
<t>If the capability <spanx style="verb">CAP_WRITABLE_RAW_STREAM</spanx> is set, then packets written
to this stream with <spanx style="verb">CMD_PROP_VALUE_SET</spanx> will be sent out over the radio.
This allows the caller to use the radio directly, with the stack being
implemented on the host instead of the NCP.
</t>

<section anchor="frame-metadata-format" title="Frame Metadata Format">
<t>Any data past the end of <spanx style="verb">FRAME_DATA_LEN</spanx> is considered metadata and is
OPTIONAL. Frame metadata MAY be empty or partially specified. Partially
specified metadata MUST be accepted. Default values are used for all
unspecified fields.
</t>
<t>The same general format is used for <spanx style="verb">PROP_STREAM_RAW</spanx>, <spanx style="verb">PROP_STREAM_NET</spanx>,
and <spanx style="verb">PROP_STREAM_NET_INSECURE</spanx>. It can be used for frames sent from the
NCP to the host as well as frames sent from the host to the NCP.
</t>
<t>The frame metadata field consists of the following fields:
</t>
<texttable>
<ttcol align="left">Field</ttcol>
<ttcol align="left">Description</ttcol>
<ttcol align="left">Type</ttcol>
<ttcol align="center">Len</ttcol>
<ttcol align="center">Default</ttcol>

<c>MD_POWER</c><c>(dBm) RSSI/TX-Power</c><c><spanx style="verb">c</spanx> int8</c><c>1</c><c>-128</c>
<c>MD_NOISE</c><c>(dBm) Noise floor</c><c><spanx style="verb">c</spanx> int8</c><c>1</c><c>-128</c>
<c>MD_FLAG</c><c>Flags (defined below)</c><c><spanx style="verb">S</spanx> uint16</c><c>2</c><c></c>
<c>MD_PHY</c><c>PHY-specific data</c><c><spanx style="verb">d</spanx> data</c><c>&gt;=2</c><c></c>
<c>MD_VEND</c><c>Vendor-specific data</c><c><spanx style="verb">d</spanx> data</c><c>&gt;=2</c><c></c>
</texttable>
<t>The following fields are ignored by the NCP for packets sent to it from
the host:
</t>
<t>
<list style="symbols">
<t>MD_NOISE</t>
<t>MD_FLAG</t>
</list>
</t>
<t>When specifying <spanx style="verb">MD_POWER</spanx> for a packet to be transmitted, the actual
transmit power is never larger than the current value of <spanx style="verb">PROP_PHY_TX_POWER</spanx>
(<xref target="prop-phy-tx-power"/>). When left unspecified (or set to the value -128),
an appropriate transmit power will be chosen by the NCP.
</t>
<t>The bit values in <spanx style="verb">MD_FLAG</spanx> are defined as follows:
</t>
<texttable>
<ttcol align="center">Bit</ttcol>
<ttcol align="center">Mask</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Description if set</ttcol>

<c>15</c><c>0x0001</c><c>MD_FLAG_TX</c><c>Packet was transmitted, not received.</c>
<c>13</c><c>0x0004</c><c>MD_FLAG_BAD_FCS</c><c>Packet was received with bad FCS</c>
<c>12</c><c>0x0008</c><c>MD_FLAG_DUPE</c><c>Packet seems to be a duplicate</c>
<c>0-11, 14</c><c>0xFFF2</c><c>MD_FLAG_RESERVED</c><c>Flags reserved for future use.</c>
</texttable>
<t>The format of <spanx style="verb">MD_PHY</spanx> is specified by the PHY layer currently in use,
and may contain information such as the channel, LQI, antenna, or other
pertainent information.
</t>
</section>
</section>

<section anchor="prop-stream-net" title="PROP 114: PROP_STREAM_NET">
<t>
<list style="symbols">
<t>Type: Read-Write-Stream</t>
<t>Packed-Encoding: <spanx style="verb">dD</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>FRAME_DATA_LEN</c><c>FRAME_DATA</c><c>FRAME_METADATA</c>
</texttable>
<t>This stream provides the capability of sending and receiving data packets
to and from the currently attached network. The exact format of the frame
metadata and data is dependent on the network protocol being used.
</t>
<t>This property is a streaming property, meaning that you cannot explicitly
fetch the value of this property. To receive traffic, you wait for
<spanx style="verb">CMD_PROP_VALUE_IS</spanx> commands with this property id from the NCP.
</t>
<t>To send network packets, you call <spanx style="verb">CMD_PROP_VALUE_SET</spanx> on this property with
the value of the packet.
</t>
<t>Any data past the end of <spanx style="verb">FRAME_DATA_LEN</spanx> is considered metadata, the
format of which is described in <xref target="frame-metadata-format"/>.
</t>
</section>

<section anchor="prop-stream-net-insecure" title="PROP 115: PROP_STREAM_NET_INSECURE">
<t>
<list style="symbols">
<t>Type: Read-Write-Stream</t>
<t>Packed-Encoding: <spanx style="verb">dD</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>FRAME_DATA_LEN</c><c>FRAME_DATA</c><c>FRAME_METADATA</c>
</texttable>
<t>This stream provides the capability of sending and receiving unencrypted
and unauthenticated data packets to and from nearby devices for the
purposes of device commissioning. The exact format of the frame
metadata and data is dependent on the network protocol being used.
</t>
<t>This property is a streaming property, meaning that you cannot explicitly
fetch the value of this property. To receive traffic, you wait for
<spanx style="verb">CMD_PROP_VALUE_IS</spanx> commands with this property id from the NCP.
</t>
<t>To send network packets, you call <spanx style="verb">CMD_PROP_VALUE_SET</spanx> on this property with
the value of the packet.
</t>
<t>Any data past the end of <spanx style="verb">FRAME_DATA_LEN</spanx> is considered metadata, the
format of which is described in <xref target="frame-metadata-format"/>.
</t>
</section>
</section>

<section anchor="prop-phy" title="PHY Properties">

<section anchor="prop-phy-enabled" title="PROP 32: PROP_PHY_ENABLED">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx> (bool8)</t>
</list>
</t>
<t>Set to 1 if the PHY is enabled, set to 0 otherwise.
May be directly enabled to bypass higher-level packet processing
in order to implement things like packet sniffers. This property
can only be written if the <spanx style="verb">SPINEL_CAP_MAC_RAW</spanx> capability is present.
</t>
</section>

<section anchor="prop-phy-chan" title="PROP 33: PROP_PHY_CHAN">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx> (uint8)</t>
</list>
</t>
<t>Value is the current channel. Must be set to one of the
values contained in <spanx style="verb">PROP_PHY_CHAN_SUPPORTED</spanx>.
</t>
</section>

<section anchor="prop-phy-chan-supported" title="PROP 34: PROP_PHY_CHAN_SUPPORTED">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">A(C)</spanx> (array of uint8)</t>
<t>Unit: List of channels</t>
</list>
</t>
<t>Value is a list of channel values that are supported by the
hardware.
</t>
</section>

<section anchor="prop-phy-freq" title="PROP 35: PROP_PHY_FREQ">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">L</spanx> (uint32)</t>
<t>Unit: Kilohertz</t>
</list>
</t>
<t>Value is the radio frequency (in kilohertz) of the
current channel.
</t>
</section>

<section anchor="prop-phy-cca-threshold" title="PROP 36: PROP_PHY_CCA_THRESHOLD">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">c</spanx> (int8)</t>
<t>Unit: dBm</t>
</list>
</t>
<t>Value is the CCA (clear-channel assessment) threshold. Set to
-128 to disable.
</t>
<t>When setting, the value will be rounded down to a value
that is supported by the underlying radio hardware.
</t>
</section>

<section anchor="prop-phy-tx-power" title="PROP 37: PROP_PHY_TX_POWER">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">c</spanx> (int8)</t>
<t>Unit: dBm</t>
</list>
</t>
<t>Value is the transmit power of the radio.
</t>
<t>When setting, the value will be rounded down to a value
that is supported by the underlying radio hardware.
</t>
</section>

<section anchor="prop-phy-rssi" title="PROP 38: PROP_PHY_RSSI">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">c</spanx> (int8)</t>
<t>Unit: dBm</t>
</list>
</t>
<t>Value is the current RSSI (Received signal strength indication)
from the radio. This value can be used in energy scans and for
determining the ambient noise floor for the operating environment.
</t>
</section>

<section anchor="prop-phy-rx-sensitivity" title="PROP 39: PROP_PHY_RX_SENSITIVITY">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">c</spanx> (int8)</t>
<t>Unit: dBm</t>
</list>
</t>
<t>Value is the radio receive sensitivity. This value can be used as
lower bound noise floor for link metrics computation.
</t>
</section>
</section>

<section anchor="prop-mac" title="MAC Properties">

<section anchor="prop-mac-scan-state" title="PROP 48: PROP_MAC_SCAN_STATE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
<t>Unit: Enumeration</t>
</list>
</t>
<t>Possible Values:
</t>
<t>
<list style="symbols">
<t>0: <spanx style="verb">SCAN_STATE_IDLE</spanx></t>
<t>1: <spanx style="verb">SCAN_STATE_BEACON</spanx></t>
<t>2: <spanx style="verb">SCAN_STATE_ENERGY</spanx></t>
<t>3: <spanx style="verb">SCAN_STATE_DISCOVER</spanx></t>
</list>
</t>
<t>Set to <spanx style="verb">SCAN_STATE_BEACON</spanx> to start an active scan.
Beacons will be emitted from <spanx style="verb">PROP_MAC_SCAN_BEACON</spanx>.
</t>
<t>Set to <spanx style="verb">SCAN_STATE_ENERGY</spanx> to start an energy scan.
Channel energy result will be reported by emissions
of <spanx style="verb">PROP_MAC_ENERGY_SCAN_RESULT</spanx> (per channel).
</t>
<t>Set to <spanx style="verb">SCAN_STATE_DISOVER</spanx> to start a Thread MLE discovery
scan operation. Discovery scan result will be emitted from
<spanx style="verb">PROP_MAC_SCAN_BEACON</spanx>.
</t>
<t>Value switches to <spanx style="verb">SCAN_STATE_IDLE</spanx> when scan is complete.
</t>
</section>

<section anchor="prop-mac-scan-mask" title="PROP 49: PROP_MAC_SCAN_MASK">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">A(C)</spanx></t>
<t>Unit: List of channels to scan</t>
</list>
</t>
</section>

<section anchor="prop-mac-scan-period" title="PROP 50: PROP_MAC_SCAN_PERIOD">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">S</spanx> (uint16)</t>
<t>Unit: milliseconds per channel</t>
</list>
</t>
</section>

<section anchor="prop-mac-scan-beacon" title="PROP 51: PROP_MAC_SCAN_BEACON">
<t>
<list style="symbols">
<t>Type: Read-Only-Stream</t>
<t>Packed-Encoding: <spanx style="verb">Ccdd</spanx> (or <spanx style="verb">Cct(ESSc)t(iCUdd)</spanx>)</t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>

<c>Fields:</c><c>CH</c><c>RSSI</c><c>MAC_LEN</c><c>MAC_DATA</c><c>NET_LEN</c><c>NET_DATA</c>
</texttable>
<t>Scan beacons have two embedded structures which contain
information about the MAC layer and the NET layer. Their
format depends on the MAC and NET layer currently in use.
The format below is for an 802.15.4 MAC with Thread:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">C</spanx>: Channel</t>
<t><spanx style="verb">c</spanx>: RSSI of the beacon</t>
<t><spanx style="verb">t</spanx>: MAC layer properties (802.15.4 layer shown below for convenience)
<list style="symbols">
<t><spanx style="verb">E</spanx>: Long address</t>
<t><spanx style="verb">S</spanx>: Short address</t>
<t><spanx style="verb">S</spanx>: PAN-ID</t>
<t><spanx style="verb">c</spanx>: LQI</t>
</list></t>
<t>NET layer properties (Standard net layer shown below for convenience)
<list style="symbols">
<t><spanx style="verb">i</spanx>: Protocol Number</t>
<t><spanx style="verb">C</spanx>: Flags</t>
<t><spanx style="verb">U</spanx>: Network Name</t>
<t><spanx style="verb">d</spanx>: XPANID</t>
<t><spanx style="verb">d</spanx>: Steering data</t>
</list></t>
</list>
</t>
<t>Extra parameters may be added to each of the structures
in the future, so care should be taken to read the length
that prepends each structure.
</t>
</section>

<section anchor="prop-mac-15-4-laddr" title="PROP 52: PROP_MAC_15_4_LADDR">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">E</spanx></t>
</list>
</t>
<t>The 802.15.4 long address of this node.
</t>
<t>This property is only present on NCPs which implement 802.15.4
</t>
</section>

<section anchor="prop-mac-15-4-saddr" title="PROP 53: PROP_MAC_15_4_SADDR">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">S</spanx></t>
</list>
</t>
<t>The 802.15.4 short address of this node.
</t>
<t>This property is only present on NCPs which implement 802.15.4
</t>
</section>

<section anchor="prop-mac-15-4-panid" title="PROP 54: PROP_MAC_15_4_PANID">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">S</spanx></t>
</list>
</t>
<t>The 802.15.4 PANID this node is associated with.
</t>
<t>This property is only present on NCPs which implement 802.15.4
</t>
</section>

<section anchor="prop-mac-raw-stream-enabled" title="PROP 55: PROP_MAC_RAW_STREAM_ENABLED">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Set to true to enable raw MAC frames to be emitted from <spanx style="verb">PROP_STREAM_RAW</spanx>.
See <xref target="prop-stream-raw"/>.
</t>
</section>

<section anchor="prop-mac-promiscuous-mode" title="PROP 56: PROP_MAC_PROMISCUOUS_MODE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>Possible Values:
</t>
<texttable>
<ttcol align="center">Id</ttcol>
<ttcol align="center">Name</ttcol>
<ttcol align="center">Description</ttcol>

<c>0</c><c><spanx style="verb">MAC_PROMISCUOUS_MODE_OFF</spanx></c><c>Normal MAC filtering is in place.</c>
<c>1</c><c><spanx style="verb">MAC_PROMISCUOUS_MODE_NETWORK</spanx></c><c>All MAC packets matching network are passed up the stack.</c>
<c>2</c><c><spanx style="verb">MAC_PROMISCUOUS_MODE_FULL</spanx></c><c>All decoded MAC packets are passed up the stack.</c>
</texttable>
<t>See <xref target="prop-stream-raw"/>.
</t>
</section>

<section anchor="prop-mac-escan-result" title="PROP 57: PROP_MAC_ENERGY_SCAN_RESULT">
<t>
<list style="symbols">
<t>Type: Read-Only-Stream</t>
<t>Packed-Encoding: <spanx style="verb">Cc</spanx></t>
</list>
</t>
<t>This property is emitted during energy scan operation
per scanned channel with following format:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">C</spanx>: Channel</t>
<t><spanx style="verb">c</spanx>: RSSI (in dBm)</t>
</list>
</t>
</section>

<section anchor="prop-mac-whitelist" title="PROP 4864: PROP_MAC_WHITELIST">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">A(T(Ec))</spanx></t>
<t>Required capability: <spanx style="verb">CAP_MAC_WHITELIST</spanx></t>
</list>
</t>
<t>Structure Parameters:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">E</spanx>: EUI64 address of node</t>
<t><spanx style="verb">c</spanx>: Optional RSSI-override value. The value 127 indicates
   that the RSSI-override feature is not enabled for this
   address. If this value is omitted when setting or
   inserting, it is assumed to be 127. This parameter is
   ignored when removing.</t>
</list>
</t>
</section>

<section anchor="prop-mac-whitelist-enabled" title="PROP 4865: PROP_MAC_WHITELIST_ENABLED">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
<t>Required capability: <spanx style="verb">CAP_MAC_WHITELIST</spanx></t>
</list>
</t>
</section>

<section anchor="prop-mac-src-match-enabled" title="PROP 4867: SPINEL_PROP_MAC_SRC_MATCH_ENABLED">
<t>
<list style="symbols">
<t>Type: Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Set to true to enable radio source matching or false to disable it. This property
is only available if the <spanx style="verb">SPINEL_CAP_MAC_RAW</spanx> capability is present. The source match
functionality is used by radios when generating ACKs. The short and extended address
lists are used for settings the Frame Pending bit in the ACKs.
</t>
</section>

<section anchor="prop-mac-src-match-short-addresses" title="PROP 4868: SPINEL_PROP_MAC_SRC_MATCH_SHORT_ADDRESSES">
<t>
<list style="symbols">
<t>Type: Write</t>
<t>Packed-Encoding: <spanx style="verb">A(S)</spanx></t>
</list>
</t>
<t>Configures the list of short addresses used for source matching. This property
is only available if the <spanx style="verb">SPINEL_CAP_MAC_RAW</spanx> capability is present.
</t>
<t>Structure Parameters:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">S</spanx>: Short address for hardware generated ACKs</t>
</list>
</t>
</section>

<section anchor="prop-mac-src-match-extended-addresses" title="PROP 4869: SPINEL_PROP_MAC_SRC_MATCH_EXTENDED_ADDRESSES">
<t>
<list style="symbols">
<t>Type: Write</t>
<t>Packed-Encoding: <spanx style="verb">A(E)</spanx></t>
</list>
</t>
<t>Configures the list of extended addresses used for source matching. This property
is only available if the <spanx style="verb">SPINEL_CAP_MAC_RAW</spanx> capability is present.
</t>
<t>Structure Parameters:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">E</spanx>: EUI64 address for hardware generated ACKs</t>
</list>
</t>
</section>

<section anchor="prop-mac-blacklist" title="PROP 4870: PROP_MAC_BLACKLIST">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">A(T(E))</spanx></t>
<t>Required capability: <spanx style="verb">CAP_MAC_WHITELIST</spanx></t>
</list>
</t>
<t>Structure Parameters:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">E</spanx>: EUI64 address of node</t>
</list>
</t>
</section>

<section anchor="prop-mac-blacklist-enabled" title="PROP 4871: PROP_MAC_BLACKLIST_ENABLED">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
<t>Required capability: <spanx style="verb">CAP_MAC_WHITELIST</spanx></t>
</list>
</t>
</section>
</section>

<section anchor="prop-net" title="NET Properties">

<section anchor="prop-net-saved" title="PROP 64: PROP_NET_SAVED">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Returns true if there is a network state stored/saved.
</t>
</section>

<section anchor="prop-net-if-up" title="PROP 65: PROP_NET_IF_UP">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Network interface up/down status. Non-zero (set to 1) indicates up,
zero indicates down.
</t>
</section>

<section anchor="prop-net-stack-up" title="PROP 66: PROP_NET_STACK_UP">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
<t>Unit: Enumeration</t>
</list>
</t>
<t>Thread stack operational status. Non-zero (set to 1) indicates up,
zero indicates down.
</t>
</section>

<section anchor="prop-net-role" title="PROP 67: PROP_NET_ROLE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
<t>Unit: Enumeration</t>
</list>
</t>
<t>Values:
</t>
<t>
<list style="symbols">
<t>0: <spanx style="verb">NET_ROLE_DETACHED</spanx></t>
<t>1: <spanx style="verb">NET_ROLE_CHILD</spanx></t>
<t>2: <spanx style="verb">NET_ROLE_ROUTER</spanx></t>
<t>3: <spanx style="verb">NET_ROLE_LEADER</spanx></t>
</list>
</t>
</section>

<section anchor="prop-net-network-name" title="PROP 68: PROP_NET_NETWORK_NAME">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">U</spanx></t>
</list>
</t>
</section>

<section anchor="prop-net-xpanid" title="PROP 69: PROP_NET_XPANID">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">D</spanx></t>
</list>
</t>
</section>

<section anchor="prop-net-master-key" title="PROP 70: PROP_NET_MASTER_KEY">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">D</spanx></t>
</list>
</t>
</section>

<section anchor="prop-net-key-sequence-counter" title="PROP 71: PROP_NET_KEY_SEQUENCE_COUNTER">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">L</spanx></t>
</list>
</t>
</section>

<section anchor="prop-net-partition-id" title="PROP 72: PROP_NET_PARTITION_ID">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">L</spanx></t>
</list>
</t>
<t>The partition ID of the partition that this node is a member of.
</t>
</section>

<section anchor="prop-net-require-join-existing" title="PROP 73: PROP_NET_REQUIRE_JOIN_EXISTING">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
</section>

<section anchor="prop-net-key-swtich-guardtime" title="PROP 74: PROP_NET_KEY_SWITCH_GUARDTIME">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">L</spanx></t>
</list>
</t>
</section>

<section anchor="prop-net-pskc" title="PROP 75: PROP_NET_PSKC">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">D</spanx></t>
</list>
</t>
</section>
</section>

<section anchor="prop-ipv6" title="IPv6 Properties">

<section anchor="prop-ipv6-ll-addr" title="PROP 96: PROP_IPV6_LL_ADDR">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">6</spanx></t>
</list>
</t>
<t>IPv6 Address
</t>
</section>

<section anchor="prop-ipv6-ml-addr" title="PROP 97: PROP_IPV6_ML_ADDR">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">6</spanx></t>
</list>
</t>
<t>IPv6 Address + Prefix Length
</t>
</section>

<section anchor="prop-ipv6-ml-prefix" title="PROP 98: PROP_IPV6_ML_PREFIX">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">6C</spanx></t>
</list>
</t>
<t>IPv6 Prefix + Prefix Length
</t>
</section>

<section anchor="prop-ipv6-address-table" title="PROP 99: PROP_IPV6_ADDRESS_TABLE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">A(t(6CLLC))</spanx></t>
</list>
</t>
<t>Array of structures containing:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">6</spanx>: IPv6 Address</t>
<t><spanx style="verb">C</spanx>: Network Prefix Length</t>
<t><spanx style="verb">L</spanx>: Valid Lifetime</t>
<t><spanx style="verb">L</spanx>: Preferred Lifetime</t>
<t><spanx style="verb">C</spanx>: Flags</t>
</list>
</t>
</section>

<section anchor="prop-101-propipv6icmppingoffload" title="PROP 101: PROP_IPv6_ICMP_PING_OFFLOAD">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Allow the NCP to directly respond to ICMP ping requests. If this is
turned on, ping request ICMP packets will not be passed to the host.
</t>
<t>Default value is <spanx style="verb">false</spanx>.
</t>
</section>
</section>

<section anchor="prop-debug" title="Debug Properties">

<section anchor="prop-debug-test-assert" title="PROP 16384: PROP_DEBUG_TEST_ASSERT">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Reading this property will cause an assert on the NCP. This
is intended for testing the assert functionality of
underlying platform/NCP. Assert should ideally cause the
NCP to reset, but if <spanx style="verb">assert</spanx> is not supported or disabled
boolean value of <spanx style="verb">false</spanx> is returned in response.
</t>
</section>

<section anchor="prop-debug-ncp-log-level" title="PROP 16385: PROP_DEBUG_NCP_LOG_LEVEL">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>Provides access to the NCP log level. Currently defined values are (which follows
the RFC 5424):
</t>
<t>
<list style="symbols">
<t>0: Emergency (emerg).</t>
<t>1: Alert (alert).</t>
<t>2: Critical (crit).</t>
<t>3: Error (err).</t>
<t>4: Warning (warn).</t>
<t>5: Notice (notice).</t>
<t>6: Information (info).</t>
<t>7: Debug (debug).</t>
</list>
</t>
<t>If the NCP supports dynamic log level control, setting this property
changes the log level accordingly. Getting the value returns the current
log level.  If the dynamic log level control is not supported, setting this
property returns a <spanx style="verb">PROP_LAST_STATUS</spanx> with <spanx style="verb">STATUS_INVALID_COMMAND_FOR_PROP</spanx>.
</t>
</section>
</section>
</section>

<section anchor="status-codes" title="Status Codes">
<t>Status codes are sent from the NCP to the host via
<spanx style="verb">PROP_LAST_STATUS</spanx> using the <spanx style="verb">CMD_VALUE_IS</spanx> command to indicate
the return status of a previous command. As with any response,
the TID field of the FLAG byte is used to correlate the response
with the request.
</t>
<t>Note that most successfully executed commands do not indicate
a last status of <spanx style="verb">STATUS_OK</spanx>. The usual way the NCP indicates a
successful command is to mirror the property change back to the
host. For example, if you do a <spanx style="verb">CMD_VALUE_SET</spanx> on <spanx style="verb">PROP_PHY_ENABLED</spanx>,
the NCP would indicate success by responding with a <spanx style="verb">CMD_VALUE_IS</spanx>
for <spanx style="verb">PROP_PHY_ENABLED</spanx>. If the command failed, <spanx style="verb">PROP_LAST_STATUS</spanx>
would be emitted instead.
</t>
<t>See <xref target="prop-last-status"/> for more information on <spanx style="verb">PROP_LAST_STATUS</spanx>.
</t>
<t>
<list style="symbols">
<t>0: <spanx style="verb">STATUS_OK</spanx>: Operation has completed successfully.</t>
<t>1: <spanx style="verb">STATUS_FAILURE</spanx>: Operation has failed for some undefined
reason.</t>
<t>2: <spanx style="verb">STATUS_UNIMPLEMENTED</spanx>: The given operation has not been implemented.</t>
<t>3: <spanx style="verb">STATUS_INVALID_ARGUMENT</spanx>: An argument to the given operation is invalid.</t>
<t>4: <spanx style="verb">STATUS_INVALID_STATE</spanx> : The given operation is invalid for the current
state of the device.</t>
<t>5: <spanx style="verb">STATUS_INVALID_COMMAND</spanx>: The given command is not recognized.</t>
<t>6: <spanx style="verb">STATUS_INVALID_INTERFACE</spanx>: The given Spinel interface is not supported.</t>
<t>7: <spanx style="verb">STATUS_INTERNAL_ERROR</spanx>: An internal runtime error has occurred.</t>
<t>8: <spanx style="verb">STATUS_SECURITY_ERROR</spanx>: A security or authentication error has occurred.</t>
<t>9: <spanx style="verb">STATUS_PARSE_ERROR</spanx>: An error has occurred while parsing the command.</t>
<t>10: <spanx style="verb">STATUS_IN_PROGRESS</spanx>: The operation is in progress and will be
completed asynchronously.</t>
<t>11: <spanx style="verb">STATUS_NOMEM</spanx>: The operation has been prevented due to memory
pressure.</t>
<t>12: <spanx style="verb">STATUS_BUSY</spanx>: The device is currently performing a mutually exclusive
operation.</t>
<t>13: <spanx style="verb">STATUS_PROP_NOT_FOUND</spanx>: The given property is not recognized.</t>
<t>14: <spanx style="verb">STATUS_PACKET_DROPPED</spanx>: The packet was dropped.</t>
<t>15: <spanx style="verb">STATUS_EMPTY</spanx>: The result of the operation is empty.</t>
<t>16: <spanx style="verb">STATUS_CMD_TOO_BIG</spanx>: The command was too large to fit in the internal
buffer.</t>
<t>17: <spanx style="verb">STATUS_NO_ACK</spanx>: The packet was not acknowledged.</t>
<t>18: <spanx style="verb">STATUS_CCA_FAILURE</spanx>: The packet was not sent due to a CCA failure.</t>
<t>19: <spanx style="verb">STATUS_ALREADY</spanx>: The operation is already in progress or
the property was already set to the given value.</t>
<t>20: <spanx style="verb">STATUS_ITEM_NOT_FOUND</spanx>: The given item could not be found in the property.</t>
<t>21: <spanx style="verb">STATUS_INVALID_COMMAND_FOR_PROP</spanx>: The given command cannot be performed
on this property.</t>
<t>22-111: RESERVED</t>
<t>112-127: Reset Causes
<list style="symbols">
<t>112: <spanx style="verb">STATUS_RESET_POWER_ON</spanx></t>
<t>113: <spanx style="verb">STATUS_RESET_EXTERNAL</spanx></t>
<t>114: <spanx style="verb">STATUS_RESET_SOFTWARE</spanx></t>
<t>115: <spanx style="verb">STATUS_RESET_FAULT</spanx></t>
<t>116: <spanx style="verb">STATUS_RESET_CRASH</spanx></t>
<t>117: <spanx style="verb">STATUS_RESET_ASSERT</spanx></t>
<t>118: <spanx style="verb">STATUS_RESET_OTHER</spanx></t>
<t>119: <spanx style="verb">STATUS_RESET_UNKNOWN</spanx></t>
<t>120: <spanx style="verb">STATUS_RESET_WATCHDOG</spanx></t>
<t>121-127: RESERVED-RESET-CODES</t>
</list></t>
<t>128 - 15,359: UNALLOCATED</t>
<t>15,360 - 16,383: Vendor-specific</t>
<t>16,384 - 1,999,999: UNALLOCATED</t>
<t>2,000,000 - 2,097,151: Experimental Use Only (MUST NEVER be used
in production!)</t>
</list>
</t>
</section>

<section anchor="tech-thread" title="Technology: Thread(R)">
<t>This section describes all of the properties and semantics required
for managing a Thread(R) NCP.
</t>
<t>Thread(R) NCPs have the following requirements:
</t>
<t>
<list style="symbols">
<t>The property <spanx style="verb">PROP_INTERFACE_TYPE</spanx> must be 3.</t>
<t>The non-optional properties in the following sections MUST be
implemented: CORE, PHY, MAC, NET, and IPV6.</t>
</list>
</t>
<t>All serious implementations of an NCP SHOULD also support the network
save feature (See <xref target="feature-network-save"/>).
</t>

<section anchor="thread-caps" title="Capabilities">
<t>The Thread(R) technology defines the following capabilities:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CAP_NET_THREAD_1_0</spanx> - Indicates that the NCP implements v1.0 of the Thread(R) standard.</t>
<t><spanx style="verb">CAP_NET_THREAD_1_1</spanx> - Indicates that the NCP implements v1.1 of the Thread(R) standard.</t>
</list>
</t>
</section>

<section anchor="thread-properties" title="Properties">
<t>Properties for Thread(R) are allocated out of the <spanx style="verb">Tech</spanx> property
section (see <xref target="property-sections"/>).
</t>

<section anchor="prop-80-propthreadleaderaddr" title="PROP 80: PROP_THREAD_LEADER_ADDR">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">6</spanx></t>
</list>
</t>
<t>The IPv6 address of the leader. (Note: May change to long and short address of leader)
</t>
</section>

<section anchor="prop-81-propthreadparent" title="PROP 81: PROP_THREAD_PARENT">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">ES</spanx></t>
<t>LADDR, SADDR</t>
</list>
</t>
<t>The long address and short address of the parent of this node.
</t>
</section>

<section anchor="prop-82-propthreadchildtable" title="PROP 82: PROP_THREAD_CHILD_TABLE">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">A(t(ES))</spanx></t>
</list>
</t>
<t>Table containing the long and short addresses of all
the children of this node.
</t>
</section>

<section anchor="prop-83-propthreadleaderrid" title="PROP 83: PROP_THREAD_LEADER_RID">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>The router-id of the current leader.
</t>
</section>

<section anchor="prop-84-propthreadleaderweight" title="PROP 84: PROP_THREAD_LEADER_WEIGHT">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>The leader weight of the current leader.
</t>
</section>

<section anchor="prop-85-propthreadlocalleaderweight" title="PROP 85: PROP_THREAD_LOCAL_LEADER_WEIGHT">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>The leader weight for this node.
</t>
</section>

<section anchor="prop-86-propthreadnetworkdata" title="PROP 86: PROP_THREAD_NETWORK_DATA">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">D</spanx></t>
</list>
</t>
<t>The local network data.
</t>
</section>

<section anchor="prop-87-propthreadnetworkdataversion" title="PROP 87: PROP_THREAD_NETWORK_DATA_VERSION">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">S</spanx></t>
</list>
</t>
</section>

<section anchor="prop-88-propthreadstablenetworkdata" title="PROP 88: PROP_THREAD_STABLE_NETWORK_DATA">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">D</spanx></t>
</list>
</t>
<t>The local stable network data.
</t>
</section>

<section anchor="prop-89-propthreadstablenetworkdataversion" title="PROP 89: PROP_THREAD_STABLE_NETWORK_DATA_VERSION">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">S</spanx></t>
</list>
</t>
</section>

<section anchor="prop-90-propthreadonmeshnets" title="PROP 90: PROP_THREAD_ON_MESH_NETS">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">A(t(6CbCb))</spanx></t>
</list>
</t>
<t>Data per item is:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">6</spanx>: IPv6 Prefix</t>
<t><spanx style="verb">C</spanx>: Prefix length in bits</t>
<t><spanx style="verb">b</spanx>: Stable flag</t>
<t><spanx style="verb">C</spanx>: TLV flags</t>
<t><spanx style="verb">b</spanx>: &quot;Is defined locally&quot; flag. Set if this network was locally
defined. Assumed to be true for set, insert and replace. Clear if
the on mesh network was defined by another node.</t>
</list>
</t>
</section>

<section anchor="prop-91-propthreadoffmeshroutes" title="PROP 91: PROP_THREAD_OFF_MESH_ROUTES">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">A(t(6CbCbb))</spanx></t>
</list>
</t>
<t>Data per item is:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">6</spanx>: Route Prefix</t>
<t><spanx style="verb">C</spanx>: Prefix length in bits</t>
<t><spanx style="verb">b</spanx>: Stable flag</t>
<t><spanx style="verb">C</spanx>: Route preference flags</t>
<t><spanx style="verb">b</spanx>: &quot;Is defined locally&quot; flag. Set if this route info was locally
defined as part of local network data. Assumed to be true for set,
insert and replace. Clear if the route is part of partition's network
data.</t>
<t><spanx style="verb">b</spanx>: &quot;Next hop is this device&quot; flag. Set if the next hop for the
route is this device itself (i.e., route was added by this device)
This value is ignored when adding an external route. For any added
route the next hop is this device.</t>
</list>
</t>
</section>

<section anchor="prop-92-propthreadassistingports" title="PROP 92: PROP_THREAD_ASSISTING_PORTS">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">A(S)</spanx></t>
</list>
</t>
</section>

<section anchor="prop-93-propthreadallowlocalnetdatachange" title="PROP 93: PROP_THREAD_ALLOW_LOCAL_NET_DATA_CHANGE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Set to true before changing local net data. Set to false when finished.
This allows changes to be aggregated into single events.
</t>
</section>

<section anchor="prop-94-propthreadmode" title="PROP 94: PROP_THREAD_MODE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>This property contains the value of the mode
TLV for this node. The meaning of the bits in this
bitfield are defined by section 4.5.2 of the Thread(R)
specification.
</t>
</section>

<section anchor="prop-5376-propthreadchildtimeout" title="PROP 5376: PROP_THREAD_CHILD_TIMEOUT">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">L</spanx></t>
</list>
</t>
<t>Used when operating in the Child role.
</t>
</section>

<section anchor="prop-5377-propthreadrloc16" title="PROP 5377: PROP_THREAD_RLOC16">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">S</spanx></t>
</list>
</t>
</section>

<section anchor="prop-5378-propthreadrouterupgradethreshold" title="PROP 5378: PROP_THREAD_ROUTER_UPGRADE_THRESHOLD">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
</section>

<section anchor="prop-5379-propthreadcontextreusedelay" title="PROP 5379: PROP_THREAD_CONTEXT_REUSE_DELAY">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">L</spanx></t>
</list>
</t>
</section>

<section anchor="prop-5380-propthreadnetworkidtimeout" title="PROP 5380: PROP_THREAD_NETWORK_ID_TIMEOUT">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>Allows you to get or set the Thread(R) <spanx style="verb">NETWORK_ID_TIMEOUT</spanx> constant, as
defined by the Thread(R) specification.
</t>
</section>

<section anchor="prop-5381-propthreadactiverouterids" title="PROP 5381: PROP_THREAD_ACTIVE_ROUTER_IDS">
<t>
<list style="symbols">
<t>Type: Read-Write/Write-Only</t>
<t>Packed-Encoding: <spanx style="verb">A(C)</spanx> (List of active thread router ids)</t>
</list>
</t>
<t>Note that some implementations may not support <spanx style="verb">CMD_GET_VALUE</spanx>
router ids, but may support <spanx style="verb">CMD_REMOVE_VALUE</spanx> when the node is
a leader.
</t>
</section>

<section anchor="prop-5382-propthreadrloc16debugpassthru" title="PROP 5382: PROP_THREAD_RLOC16_DEBUG_PASSTHRU">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Allow the HOST to directly observe all IPv6 packets received by the NCP,
including ones sent to the RLOC16 address.
</t>
<t>Default value is <spanx style="verb">false</spanx>.
</t>
</section>

<section anchor="prop-5383-propthreadrouterroleenabled" title="PROP 5383: PROP_THREAD_ROUTER_ROLE_ENABLED">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>Allow the HOST to indicate whether or not the router role is enabled.
If current role is a router, setting this property to <spanx style="verb">false</spanx> starts
a re-attach process as an end-device.
</t>
</section>

<section anchor="prop-5384-propthreadrouterdowngradethreshold" title="PROP 5384: PROP_THREAD_ROUTER_DOWNGRADE_THRESHOLD">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
</section>

<section anchor="prop-5385-propthreadrouterselectionjitter" title="PROP 5385: PROP_THREAD_ROUTER_SELECTION_JITTER">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>Specifies the self imposed random delay in seconds a REED waits before
registering to become an Active Router.
</t>
</section>

<section anchor="prop-5386-propthreadpreferredrouterid" title="PROP 5386: PROP_THREAD_PREFERRED_ROUTER_ID">
<t>
<list style="symbols">
<t>Type: Write-Only</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>Specifies the preferred Router Id. Upon becoming a router/leader the node
attempts to use this Router Id. If the preferred Router Id is not set or
if it can not be used, a randomly generated router id is picked. This
property can be set only when the device role is either detached or
disabled.
</t>
</section>

<section anchor="prop-5387-propthreadneighbortable" title="PROP 5387: PROP_THREAD_NEIGHBOR_TABLE">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">A(t(ESLCcCbLL))</spanx></t>
</list>
</t>
<t>Data per item is:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">E</spanx>: Extended/long address</t>
<t><spanx style="verb">S</spanx>: RLOC16</t>
<t><spanx style="verb">L</spanx>: Age</t>
<t><spanx style="verb">C</spanx>: Link Quality In</t>
<t><spanx style="verb">c</spanx>: Average RSS</t>
<t><spanx style="verb">C</spanx>: Mode (bit-flags)</t>
<t><spanx style="verb">b</spanx>: <spanx style="verb">true</spanx> if neighbor is a child, <spanx style="verb">false</spanx> otherwise.</t>
<t><spanx style="verb">L</spanx>: Link Frame Counter</t>
<t><spanx style="verb">L</spanx>: MLE Frame Counter</t>
</list>
</t>
</section>

<section anchor="prop-5388-propthreadchildcountmax" title="PROP 5388: PROP_THREAD_CHILD_COUNT_MAX">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">C</spanx></t>
</list>
</t>
<t>Specifies the maximum number of children currently allowed.
This parameter can only be set when Thread(R) protocol operation
has been stopped.
</t>
</section>

<section anchor="prop-5389-propthreadleadernetworkdata" title="PROP 5389: PROP_THREAD_LEADER_NETWORK_DATA">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">D</spanx></t>
</list>
</t>
<t>The leader network data.
</t>
</section>

<section anchor="prop-5390-propthreadstableleadernetworkdata" title="PROP 5390: PROP_THREAD_STABLE_LEADER_NETWORK_DATA">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">D</spanx></t>
</list>
</t>
<t>The stable leader network data.
</t>
</section>

<section anchor="prop-thread-joiners" title="PROP 5391: PROP_THREAD_JOINERS">
<t>
<list style="symbols">
<t>Type: Insert/Remove Only (optionally Read-Write)</t>
<t>Packed-Encoding: <spanx style="verb">A(t(ULE))</spanx></t>
<t>Required capability: <spanx style="verb">CAP_THREAD_COMMISSIONER</spanx></t>
</list>
</t>
<t>Data per item is:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">U</spanx>: PSKd</t>
<t><spanx style="verb">L</spanx>: Timeout in seconds</t>
<t><spanx style="verb">E</spanx>: Extended/long address (optional)</t>
</list>
</t>
<t>Passess Pre-Shared Key for the Device to the NCP in the commissioning process.
When the Extended address is ommited all Devices which provided a valid PSKd
are allowed to join the Thread(R) Network.
</t>
</section>

<section anchor="prop-thread-commissioner-enabled" title="PROP 5392: PROP_THREAD_COMMISSIONER_ENABLED">
<t>
<list style="symbols">
<t>Type: Write only (optionally Read-Write)</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
<t>Required capability: <spanx style="verb">CAP_THREAD_COMMISSIONER</spanx></t>
</list>
</t>
<t>Set to true to enable the native commissioner. It is mandatory before adding the joiner to the network.
</t>
</section>

<section anchor="prop-thread-tmf-proxy-enabled" title="PROP 5393: PROP_THREAD_TMF_PROXY_ENABLED">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
<t>Required capability: <spanx style="verb">CAP_THREAD_TMF_PROXY</spanx></t>
</list>
</t>
<t>Set to true to enable the TMF proxy.
</t>
</section>

<section anchor="prop-thread-tmf-proxy-stream" title="PROP 5394: PROP_THREAD_TMF_PROXY_STREAM">
<t>
<list style="symbols">
<t>Type: Read-Write-Stream</t>
<t>Packed-Encoding: <spanx style="verb">dSS</spanx></t>
<t>Required capability: <spanx style="verb">CAP_THREAD_TMF_PROXY</spanx></t>
</list>
</t>
<t>Data per item is:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">d</spanx>: CoAP frame</t>
<t><spanx style="verb">S</spanx>: source/destination RLOC/ALOC</t>
<t><spanx style="verb">S</spanx>: source/destination port</t>
</list>
</t>
<texttable>
<ttcol align="center">Octects:</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">n</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">2</ttcol>

<c>Fields:</c><c>Length</c><c>CoAP</c><c>locator</c><c>port</c>
</texttable>
<t>This property allows the host to send and receive TMF messages from
the NCP's RLOC address and support Thread-specific border router functions.
</t>
</section>

<section anchor="prop-thread-discovery-scan-joiner-flag" title="PROP 5395: PROP_THREAD_DISOVERY_SCAN_JOINER_FLAG">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding:: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>This property specifies the value used in Thread(R) MLE Discovery Request
TLV during discovery scan operation. Default value is <spanx style="verb">false</spanx>.
</t>
</section>

<section anchor="prop-thread-discovery-scan-enable-filtering" title="PROP 5396: PROP_THREAD_DISCOVERY_SCAN_ENABLE_FILTERING">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding:: <spanx style="verb">b</spanx></t>
</list>
</t>
<t>This property is used to enable/disable EUI64 filtering during discovery
scan operation. Default value is <spanx style="verb">false</spanx>.
</t>
</section>

<section anchor="prop-thread-discovery-scan-panid" title="PROP 5397: PROP_THREAD_DISCOVERY_SCAN_PANID">
<t>
<list style="symbols">
<t>Type: Read-write</t>
<t>Packed-Encoding:: <spanx style="verb">S</spanx></t>
</list>
</t>
<t>This property specifies the PANID used for filtering during discovery
scan operation. Default value is <spanx style="verb">0xffff</spanx> (broadcast PANID) which disables
PANID filtering.
</t>
</section>

<section anchor="prop-thread-steering-data" title="PROP 5398: PROP_THREAD_STEERING_DATA">
<t>
<list style="symbols">
<t>Type: Write-Only</t>
<t>Packed-Encoding: <spanx style="verb">E</spanx></t>
<t>Required capability: <spanx style="verb">CAP_OOB_STEERING_DATA</spanx></t>
</list>
</t>
<t>This property can be used to set the steering data for MLE Discovery
Response messages.
</t>
<t>
<list style="symbols">
<t>All zeros to clear the steering data (indicating no steering data).</t>
<t>All 0xFFs to set the steering data (bloom filter) to accept/allow all.</t>
<t>A specific EUI64 which is then added to steering data/bloom filter.</t>
</list>
</t>
</section>
</section>
</section>

<section anchor="feature-network-save" title="Feature: Network Save">
<t>The network save/recall feature is an optional NCP capability that, when
present, allows the host to save and recall network credentials and
state to and from nonvolatile storage.
</t>
<t>The presence of the save/recall feature can be detected by checking for
the presence of the <spanx style="verb">CAP_NET_SAVE</spanx> capability in <spanx style="verb">PROP_CAPS</spanx>.
</t>
<t>Network clear feature allows host to erase all network credentials and
state from non-volatile memory.
</t>

<section anchor="commands-1" title="Commands">

<section anchor="cmd-9-hostncp-cmdnetsave" title="CMD 9: (Host-&gt;NCP) CMD_NET_SAVE">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_NET_SAVE</c>
</texttable>
<t>Save network state command. Saves any current network credentials and
state necessary to reconnect to the current network to non-volatile
memory.
</t>
<t>This operation affects non-volatile memory only. The current network
information stored in volatile memory is unaffected.
</t>
<t>The response to this command is always a <spanx style="verb">CMD_PROP_VALUE_IS</spanx> for
<spanx style="verb">PROP_LAST_STATUS</spanx>, indicating the result of the operation.
</t>
<t>This command is only available if the <spanx style="verb">CAP_NET_SAVE</spanx> capability is
set.
</t>
</section>

<section anchor="cmd-10-hostncp-cmdnetclear" title="CMD 10: (Host-&gt;NCP) CMD_NET_CLEAR">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_NET_CLEAR</c>
</texttable>
<t>Clear saved network settings command. Erases all network credentials
and state from non-volatile memory. The erased settings include any data
saved automatically by the network stack firmware and/or data saved by
<spanx style="verb">CMD_NET_SAVE</spanx> operation.
</t>
<t>This operation affects non-volatile memory only. The current network
information stored in volatile memory is unaffected.
</t>
<t>The response to this command is always a <spanx style="verb">CMD_PROP_VALUE_IS</spanx> for
<spanx style="verb">PROP_LAST_STATUS</spanx>, indicating the result of the operation.
</t>
<t>This command is always available independent of the value of
<spanx style="verb">CAP_NET_SAVE</spanx> capability.
</t>
</section>

<section anchor="cmd-11-hostncp-cmdnetrecall" title="CMD 11: (Host-&gt;NCP) CMD_NET_RECALL">
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c>HEADER</c><c>CMD_NET_RECALL</c>
</texttable>
<t>Recall saved network state command. Recalls any previously saved
network credentials and state previously stored by <spanx style="verb">CMD_NET_SAVE</spanx> from
non-volatile memory.
</t>
<t>This command will typically generated several unsolicited property
updates as the network state is loaded. At the conclusion of loading,
the authoritative response to this command is always a
<spanx style="verb">CMD_PROP_VALUE_IS</spanx> for <spanx style="verb">PROP_LAST_STATUS</spanx>, indicating the result of
the operation.
</t>
<t>This command is only available if the <spanx style="verb">CAP_NET_SAVE</spanx> capability is
set.
</t>
</section>
</section>
</section>

<section anchor="feature-host-buffer-offload" title="Feature: Host Buffer Offload">
<t>The memory on an NCP may be much more limited than the memory on
the host processor. In such situations, it is sometimes useful
for the NCP to offload buffers to the host processor temporarily
so that it can perform other operations.
</t>
<t>Host buffer offload is an optional NCP capability that, when
present, allows the NCP to store data buffers on the host processor
that can be recalled at a later time.
</t>
<t>The presence of this feature can be detected by the host by
checking for the presence of the <spanx style="verb">CAP_HBO</spanx>
capability in <spanx style="verb">PROP_CAPS</spanx>.
</t>

<section anchor="commands-2" title="Commands">

<section anchor="cmd-12-ncphost-cmdhbooffload" title="CMD 12: (NCP-&gt;Host) CMD_HBO_OFFLOAD">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">LscD</spanx>
<list style="symbols">
<t><spanx style="verb">OffloadId</spanx>: 32-bit unique block identifier</t>
<t><spanx style="verb">Expiration</spanx>: In seconds-from-now</t>
<t><spanx style="verb">Priority</spanx>: Critical, High, Medium, Low</t>
<t><spanx style="verb">Data</spanx>: Data to offload</t>
</list></t>
</list>
</t>
</section>

<section anchor="cmd-13-ncphost-cmdhboreclaim" title="CMD 13: (NCP-&gt;Host) CMD_HBO_RECLAIM">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">Lb</spanx>
<list style="symbols">
<t><spanx style="verb">OffloadId</spanx>: 32-bit unique block identifier</t>
<t><spanx style="verb">KeepAfterReclaim</spanx>: If not set to true, the block will be
dropped by the host after it is sent to the NCP.</t>
</list></t>
</list>
</t>
</section>

<section anchor="cmd-14-ncphost-cmdhbodrop" title="CMD 14: (NCP-&gt;Host) CMD_HBO_DROP">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">L</spanx>
<list style="symbols">
<t><spanx style="verb">OffloadId</spanx>: 32-bit unique block identifier</t>
</list></t>
</list>
</t>
</section>

<section anchor="cmd-15-hostncp-cmdhbooffloaded" title="CMD 15: (Host-&gt;NCP) CMD_HBO_OFFLOADED">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">Li</spanx>
<list style="symbols">
<t><spanx style="verb">OffloadId</spanx>: 32-bit unique block identifier</t>
<t><spanx style="verb">Status</spanx>: Status code for the result of the operation.</t>
</list></t>
</list>
</t>
</section>

<section anchor="cmd-16-hostncp-cmdhboreclaimed" title="CMD 16: (Host-&gt;NCP) CMD_HBO_RECLAIMED">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">LiD</spanx>
<list style="symbols">
<t><spanx style="verb">OffloadId</spanx>: 32-bit unique block identifier</t>
<t><spanx style="verb">Status</spanx>: Status code for the result of the operation.</t>
<t><spanx style="verb">Data</spanx>: Data that was previously offloaded (if any)</t>
</list></t>
</list>
</t>
</section>

<section anchor="cmd-17-hostncp-cmdhbodropped" title="CMD 17: (Host-&gt;NCP) CMD_HBO_DROPPED">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">Li</spanx>
<list style="symbols">
<t><spanx style="verb">OffloadId</spanx>: 32-bit unique block identifier</t>
<t><spanx style="verb">Status</spanx>: Status code for the result of the operation.</t>
</list></t>
</list>
</t>
</section>
</section>

<section anchor="properties-1" title="Properties">

<section anchor="prop-hbo-mem-max" title="PROP 10: PROP_HBO_MEM_MAX">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">L</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">4</ttcol>

<c>Fields:</c><c><spanx style="verb">PROP_HBO_MEM_MAX</spanx></c>
</texttable>
<t>Describes the number of bytes that may be offloaded from the NCP to
the host. Default value is zero, so this property must be set by the
host to a non-zero value before the NCP will begin offloading blocks.
</t>
<t>This value is encoded as an unsigned 32-bit integer.
</t>
<t>This property is only available if the <spanx style="verb">CAP_HBO</spanx>
capability is present in <spanx style="verb">PROP_CAPS</spanx>.
</t>
</section>

<section anchor="prop-hbo-block-max" title="PROP 11: PROP_HBO_BLOCK_MAX">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">S</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">2</ttcol>

<c>Fields:</c><c><spanx style="verb">PROP_HBO_BLOCK_MAX</spanx></c>
</texttable>
<t>Describes the number of blocks that may be offloaded from the NCP to
the host. Default value is 32. Setting this value to zero will cause
host block offload to be effectively disabled.
</t>
<t>This value is encoded as an unsigned 16-bit integer.
</t>
<t>This property is only available if the <spanx style="verb">CAP_HBO</spanx>
capability is present in <spanx style="verb">PROP_CAPS</spanx>.
</t>
</section>
</section>
</section>

<section anchor="feature-jam-detect" title="Feature: Jam Detection">
<t>Jamming detection is a feature that allows the NCP to report when it
detects high levels of interference that are characteristic of intentional
signal jamming.
</t>
<t>The presence of this feature can be detected by checking for the
presence of the <spanx style="verb">CAP_JAM_DETECT</spanx> (value 6) capability in <spanx style="verb">PROP_CAPS</spanx>.
</t>

<section anchor="properties-2" title="Properties">

<section anchor="prop-jam-detect-enable" title="PROP 4608: PROP_JAM_DETECT_ENABLE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
<t>Default Value: false</t>
<t>REQUIRED for <spanx style="verb">CAP_JAM_DETECT</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c><spanx style="verb">PROP_JAM_DETECT_ENABLE</spanx></c>
</texttable>
<t>Indicates if jamming detection is enabled or disabled. Set to true
to enable jamming detection.
</t>
<t>This property is only available if the <spanx style="verb">CAP_JAM_DETECT</spanx>
capability is present in <spanx style="verb">PROP_CAPS</spanx>.
</t>
</section>

<section anchor="prop-jam-detected" title="PROP 4609: PROP_JAM_DETECTED">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">b</spanx></t>
<t>REQUIRED for <spanx style="verb">CAP_JAM_DETECT</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>

<c>Fields:</c><c><spanx style="verb">PROP_JAM_DETECTED</spanx></c>
</texttable>
<t>Set to true if radio jamming is detected. Set to false otherwise.
</t>
<t>When jamming detection is enabled, changes to the value of this
property are emitted asynchronously via <spanx style="verb">CMD_PROP_VALUE_IS</spanx>.
</t>
<t>This property is only available if the <spanx style="verb">CAP_JAM_DETECT</spanx>
capability is present in <spanx style="verb">PROP_CAPS</spanx>.
</t>
</section>

<section anchor="prop-4610-propjamdetectrssithreshold" title="PROP 4610: PROP_JAM_DETECT_RSSI_THRESHOLD">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">c</spanx></t>
<t>Units: dBm</t>
<t>Default Value: Implementation-specific</t>
<t>RECOMMENDED for <spanx style="verb">CAP_JAM_DETECT</spanx></t>
</list>
</t>
<t>This parameter describes the threshold RSSI level (measured in
dBm) above which the jamming detection will consider the
channel blocked.
</t>
</section>

<section anchor="prop-4611-propjamdetectwindow" title="PROP 4611: PROP_JAM_DETECT_WINDOW">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">c</spanx></t>
<t>Units: Seconds (1-64)</t>
<t>Default Value: Implementation-specific</t>
<t>RECOMMENDED for <spanx style="verb">CAP_JAM_DETECT</spanx></t>
</list>
</t>
<t>This parameter describes the window period for signal jamming
detection.
</t>
</section>

<section anchor="prop-4612-propjamdetectbusy" title="PROP 4612: PROP_JAM_DETECT_BUSY">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
<t>Packed-Encoding: <spanx style="verb">i</spanx></t>
<t>Units: Seconds (1-64)</t>
<t>Default Value: Implementation-specific</t>
<t>RECOMMENDED for <spanx style="verb">CAP_JAM_DETECT</spanx></t>
</list>
</t>
<t>This parameter describes the number of aggregate seconds within
the detection window where the RSSI must be above
<spanx style="verb">PROP_JAM_DETECT_RSSI_THRESHOLD</spanx> to trigger detection.
</t>
<t>The behavior of the jamming detection feature when <spanx style="verb">PROP_JAM_DETECT_BUSY</spanx>
is larger than <spanx style="verb">PROP_JAM_DETECT_WINDOW</spanx> is undefined.
</t>
</section>

<section anchor="prop-4613-propjamdetecthistorybitmap" title="PROP 4613: PROP_JAM_DETECT_HISTORY_BITMAP">
<t>
<list style="symbols">
<t>Type: Read-Only</t>
<t>Packed-Encoding: <spanx style="verb">LL</spanx></t>
<t>Default Value: Implementation-specific</t>
<t>RECOMMENDED for <spanx style="verb">CAP_JAM_DETECT</spanx></t>
</list>
</t>
<t>This value provides information about current state of jamming detection
module for monitoring/debugging purpose. It returns a 64-bit value where
each bit corresponds to one second interval starting with bit 0 for the
most recent interval and bit 63 for the oldest intervals (63 sec earlier).
The bit is set to 1 if the jamming detection module observed/detected
high signal level during the corresponding one second interval.
The value is read-only and is encoded as two <spanx style="verb">L</spanx> (uint32) values in
little-endian format (first <spanx style="verb">L</spanx> (uint32) value gives the lower bits
corresponding to more recent history).
</t>
</section>
</section>
</section>

<section anchor="feature-gpio-access" title="Feature: GPIO Access">
<t>This feature allows the host to have control over some or all of the
GPIO pins on the NCP. The host can determine which GPIOs are available
by examining <spanx style="verb">PROP_GPIO_CONFIG</spanx>, described below. This API supports a
maximum of 256 individual GPIO pins.
</t>
<t>Support for this feature can be determined by the presence of <spanx style="verb">CAP_GPIO</spanx>.
</t>

<section anchor="properties-3" title="Properties">

<section anchor="prop-4096-propgpioconfig" title="PROP 4096: PROP_GPIO_CONFIG">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">A(t(CCU))</spanx></t>
<t>Type: Read-write (Writable only using <spanx style="verb">CMD_PROP_VALUE_INSERT</spanx>,
<xref target="cmd-prop-value-insert"/>)</t>
</list>
</t>
<t>An array of structures which contain the following fields:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">C</spanx>: GPIO Number</t>
<t><spanx style="verb">C</spanx>: GPIO Configuration Flags</t>
<t><spanx style="verb">U</spanx>: Human-readable GPIO name</t>
</list>
</t>
<t>GPIOs which do not have a corresponding entry are not supported.
</t>
<t>The configuration parameter contains the configuration flags for the
GPIO:
</t>

<figure align="center"><artwork align="center">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|DIR|PUP|PDN|TRIGGER|  RESERVED |
+---+---+---+---+---+---+---+---+
        |O/D|
        +---+
</artwork></figure>
<t>
<list style="symbols">
<t><spanx style="verb">DIR</spanx>: Pin direction. Clear (0) for input, set (1) for output.</t>
<t><spanx style="verb">PUP</spanx>: Pull-up enabled flag.</t>
<t><spanx style="verb">PDN</spanx>/<spanx style="verb">O/D</spanx>: Flag meaning depends on pin direction:
<list style="symbols">
<t>Input: Pull-down enabled.</t>
<t>Output: Output is an open-drain.</t>
</list></t>
<t><spanx style="verb">TRIGGER</spanx>: Enumeration describing how pin changes generate
asynchronous notification commands (TBD) from the NCP to the host.
<list style="symbols">
<t>0: Feature disabled for this pin</t>
<t>1: Trigger on falling edge</t>
<t>2: Trigger on rising edge</t>
<t>3: Trigger on level change</t>
</list></t>
<t><spanx style="verb">RESERVED</spanx>: Bits reserved for future use. Always cleared to zero
and ignored when read.</t>
</list>
</t>
<t>As an optional feature, the configuration of individual pins may be
modified using the <spanx style="verb">CMD_PROP_VALUE_INSERT</spanx> command. Only the GPIO
number and flags fields MUST be present, the GPIO name (if present)
would be ignored. This command can only be used to modify the
configuration of GPIOs which are already exposed---it cannot be used
by the host to add addional GPIOs.
</t>
</section>

<section anchor="prop-4098-propgpiostate" title="PROP 4098: PROP_GPIO_STATE">
<t>
<list style="symbols">
<t>Type: Read-Write</t>
</list>
</t>
<t>Contains a bit field identifying the state of the GPIOs. The length of
the data associated with these properties depends on the number of
GPIOs. If you have 10 GPIOs, you'd have two bytes. GPIOs are numbered
from most significant bit to least significant bit, so 0x80 is GPIO 0,
0x40 is GPIO 1, etc.
</t>
<t>For GPIOs configured as inputs:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CMD_PROP_VAUE_GET</spanx>: The value of the associated bit describes the
logic level read from the pin.</t>
<t><spanx style="verb">CMD_PROP_VALUE_SET</spanx>: The value of the associated bit is ignored
for these pins.</t>
</list>
</t>
<t>For GPIOs configured as outputs:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CMD_PROP_VAUE_GET</spanx>: The value of the associated bit is
implementation specific.</t>
<t><spanx style="verb">CMD_PROP_VALUE_SET</spanx>: The value of the associated bit determines
the new logic level of the output. If this pin is configured as an
open-drain, setting the associated bit to 1 will cause the pin to
enter a Hi-Z state.</t>
</list>
</t>
<t>For GPIOs which are not specified in <spanx style="verb">PROP_GPIO_CONFIG</spanx>:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CMD_PROP_VAUE_GET</spanx>: The value of the associated bit is
implementation specific.</t>
<t><spanx style="verb">CMD_PROP_VALUE_SET</spanx>: The value of the associated bit MUST be
ignored by the NCP.</t>
</list>
</t>
<t>When writing, unspecified bits are assumed to be zero.
</t>
</section>

<section anchor="prop-4099-propgpiostateset" title="PROP 4099: PROP_GPIO_STATE_SET">
<t>
<list style="symbols">
<t>Type: Write-only</t>
</list>
</t>
<t>Allows for the state of various output GPIOs to be set without
affecting other GPIO states. Contains a bit field identifying the
output GPIOs that should have their state set to 1.
</t>
<t>When writing, unspecified bits are assumed to be zero. The value of
any bits for GPIOs which are not specified in <spanx style="verb">PROP_GPIO_CONFIG</spanx> MUST
be ignored.
</t>
</section>

<section anchor="prop-4100-propgpiostateclear" title="PROP 4100: PROP_GPIO_STATE_CLEAR">
<t>
<list style="symbols">
<t>Type: Write-only</t>
</list>
</t>
<t>Allows for the state of various output GPIOs to be cleared without
affecting other GPIO states. Contains a bit field identifying the
output GPIOs that should have their state cleared to 0.
</t>
<t>When writing, unspecified bits are assumed to be zero. The value of
any bits for GPIOs which are not specified in <spanx style="verb">PROP_GPIO_CONFIG</spanx> MUST
be ignored.
</t>
</section>
</section>
</section>

<section anchor="feature-trng" title="Feature: True Random Number Generation">
<t>This feature allows the host to have access to any strong hardware
random number generator that might be present on the NCP, for things
like key generation or seeding PRNGs.
</t>
<t>Support for this feature can be determined by the presence of <spanx style="verb">CAP_TRNG</spanx>.
</t>
<t>Note well that implementing a cryptographically-strong software-based true
random number generator (that is impervious to things like temperature
changes, manufacturing differences across devices, or unexpected output
correlations) is non-trivial without a well-designed, dedicated hardware
random number generator. Implementors who have little or no experience in
this area are encouraged to not advertise this capability.
</t>

<section anchor="properties-4" title="Properties">

<section anchor="prop-4101-proptrng32" title="PROP 4101: PROP_TRNG_32">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">L</spanx></t>
<t>Type: Read-Only</t>
</list>
</t>
<t>Fetching this property returns a strong random 32-bit integer that is suitable
for use as a PRNG seed or for cryptographic use.
</t>
<t>While the exact mechanism behind the calculation of this value is
implementation-specific, the implementation must satisfy the following
requirements:
</t>
<t>
<list style="symbols">
<t>Data representing at least 32 bits of fresh entropy (extracted from the
primary entropy source) MUST be consumed by the calculation of each query.</t>
<t>Each of the 32 bits returned MUST be free of bias and have no statistical
correlation to any part of the raw data used for the calculation of any
query.</t>
</list>
</t>
<t>Support for this property is REQUIRED if <spanx style="verb">CAP_TRNG</spanx> is included in the
device capabilities.
</t>
</section>

<section anchor="prop-4102-proptrng128" title="PROP 4102: PROP_TRNG_128">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">D</spanx></t>
<t>Type: Read-Only</t>
</list>
</t>
<t>Fetching this property returns 16 bytes of strong random data suitable for
direct cryptographic use without further processing(For example, as an
AES key).
</t>
<t>While the exact mechanism behind the calculation of this value is
implementation-specific, the implementation must satisfy the following
requirements:
</t>
<t>
<list style="symbols">
<t>Data representing at least 128 bits of fresh entropy (extracted from the
primary entropy source) MUST be consumed by the calculation of each query.</t>
<t>Each of the 128 bits returned MUST be free of bias and have no statistical
correlation to any part of the raw data used for the calculation of any
query.</t>
</list>
</t>
<t>Support for this property is REQUIRED if <spanx style="verb">CAP_TRNG</spanx> is included in the
device capabilities.
</t>
</section>

<section anchor="prop-4103-proptrngraw32" title="PROP 4103: PROP_TRNG_RAW_32">
<t>
<list style="symbols">
<t>Argument-Encoding: <spanx style="verb">D</spanx></t>
<t>Type: Read-Only</t>
</list>
</t>
<t>This property is primarily used to diagnose and debug the behavior
of the entropy source used for strong random number generation.
</t>
<t>When queried, returns the raw output from the entropy source used to
generate <spanx style="verb">PROP_TRNG_32</spanx>, prior to any reduction/whitening and/or mixing
with prior state.
</t>
<t>The length of the returned buffer is implementation specific and should be
expected to be non-deterministic.
</t>
<t>Support for this property is RECOMMENDED if <spanx style="verb">CAP_TRNG</spanx> is included in the
device capabilities.
</t>
</section>
</section>
</section>

<section anchor="security-considerations" title="Security Considerations">

<section anchor="raw-application-access" title="Raw Application Access">
<t>Spinel MAY be used as an API boundary for allowing processes to configure
the NCP. However, such a system MUST NOT give unprivileged processess the
ability to send or receive arbitrary command frames to the NCP. Only the
specific commands and properties that are required should be allowed to be
passed, and then only after being checked for proper format.
</t>
</section>
</section>

</middle>
<back>

<section anchor="framing-protocol" title="Framing Protocol">
<t>Since this NCP protocol is defined independently of the physical
transport or framing, any number of transports and framing protocols
could be used successfully. However, in the interests of compatibility,
this document provides some recommendations.
</t>

<section anchor="uart-recommendations" title="UART Recommendations">
<t>The recommended default UART settings are:
</t>
<t>
<list style="symbols">
<t>Bit rate:     115200</t>
<t>Start bits:   1</t>
<t>Data bits:    8</t>
<t>Stop bits:    1</t>
<t>Parity:       None</t>
<t>Flow Control: Hardware</t>
</list>
</t>
<t>These values may be adjusted depending on the individual needs of
the application or product, but some sort of flow control MUST be used.
Hardware flow control is preferred over software flow control. In the
absence of hardware flow control, software flow control (XON/XOFF) MUST
be used instead.
</t>
<t>We also <spanx style="strong">RECOMMEND</spanx> an Arduino-style hardware reset, where the DTR
signal is coupled to the <spanx style="verb">RES</spanx> pin through a 0.01F capacitor. This
causes the NCP to automatically reset whenever the serial port is
opened. At the very least we <spanx style="strong">RECOMMEND</spanx> dedicating one of your host
pins to controlling the <spanx style="verb">RES</spanx> pin on the NCP, so that you can
easily perform a hardware reset if necessary.
</t>

<section anchor="uart-bit-rate-detection" title="UART Bit Rate Detection">
<t>When using a UART, the issue of an appropriate bit rate must be
considered. A bitrate of 115200 bits per second has become a defacto
standard baud rate for many serial peripherals. This rate, however,
is slower than the theoretical maximum bitrate of the 802.15.4 2.4GHz
PHY (250kbit). In most circumstances this mismatch is not significant
because the overall bitrate will be much lower than either of these
rates, but there are circumstances where a faster UART bitrate is
desirable. Thus, this document proposes a simple bitrate detection
scheme that can be employed by the host to detect when the attached
NCP is initially running at a higher bitrate.
</t>
<t>The algorithm is to send successive NOOP commands to the NCP at increasing
bitrates. When a valid <spanx style="verb">CMD_LAST_STATUS</spanx> response has been received, we
have identified the correct bitrate.
</t>
<t>In order to limit the time spent hunting for the appropriate bitrate,
we RECOMMEND that only the following bitrates be checked:
</t>
<t>
<list style="symbols">
<t>115200</t>
<t>230400</t>
<t>1000000 (1Mbit)</t>
</list>
</t>
<t>The bitrate MAY also be changed programmatically by adjusting
<spanx style="verb">PROP_UART_BITRATE</spanx>, if implemented.
</t>
</section>

<section anchor="hdlc-lite" title="HDLC-Lite">
<t><spanx style="emph">HDLC-Lite</spanx> is the recommended framing protocol for transmitting
Spinel frames over a UART. HDLC-Lite consists of only the framing,
escaping, and CRC parts of the larger HDLC protocol---all other parts
of HDLC are omitted. This protocol was chosen because it works well
with software flow control and is widely implemented.
</t>
<t>To transmit a frame with HDLC-lite, the 16-bit CRC must first be
appended to the frame. The CRC function is defined to be CRC-16/CCITT,
otherwise known as the <eref target="http://reveng.sourceforge.net/crc-catalogue/16.htm#crc.cat.kermit">KERMIT CRC</eref>.
</t>
<t>Individual frames are terminated with a frame delimiter octet called
the 'flag' octet (<spanx style="verb">0x7E</spanx>).
</t>
<t>The following octets values are considered <spanx style="emph">special</spanx> and should be
escaped when present in data frames:
</t>
<texttable>
<ttcol align="center">Octet Value</ttcol>
<ttcol align="center">Description</ttcol>

<c>0x7E</c><c>Frame Delimiter (Flag)</c>
<c>0x7D</c><c>Escape Byte</c>
<c>0x11</c><c>XON</c>
<c>0x13</c><c>XOFF</c>
<c>0xF8</c><c>Vendor-Specific</c>
</texttable>
<t>When present in a data frame, these octet values are escaped by
prepending the escape octet (<spanx style="verb">0x7D</spanx>) and XORing the value with <spanx style="verb">0x20</spanx>.
</t>
<t>When receiving a frame, the CRC must be verified after the frame is
unescaped. If the CRC value does not match what is calculated for the
frame data, the frame MUST be discarded. The implementation MAY
indicate the failure to higher levels to handle as they see fit, but
MUST NOT attempt to process the deceived frame.
</t>
<t>Consecutive flag octets are entirely legal and MUST NOT be treated as
a framing error. Consecutive flag octets MAY be used as a way to wake
up a sleeping NCP.
</t>
<t>When first establishing a connection to the NCP, it is customary to
send one or more flag octets to ensure that any previously received
data is discarded.
</t>
</section>
</section>

<section anchor="spi-recommendations" title="SPI Recommendations">
<t>We RECOMMEND the use of the following standard SPI signals:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CS</spanx>:   (Host-to-NCP) Chip Select</t>
<t><spanx style="verb">CLK</spanx>:  (Host-to-NCP) Clock</t>
<t><spanx style="verb">MOSI</spanx>: Master-Output/Slave-Input</t>
<t><spanx style="verb">MISO</spanx>: Master-Input/Slave-Output</t>
<t><spanx style="verb">INT</spanx>:  (NCP-to-Host) Host Interrupt</t>
<t><spanx style="verb">RES</spanx>:  (Host-to-NCP) NCP Hardware Reset</t>
</list>
</t>
<t>The <spanx style="verb">INT</spanx> signal is used by the NCP to indicate to the host that
the NCP has frames pending to send to it. When asserted, the host
SHOULD initiate a SPI transaction in a timely manner.
</t>
<t>We RECOMMEND the following SPI properties:
</t>
<t>
<list style="symbols">
<t><spanx style="verb">CS</spanx> is active low.</t>
<t><spanx style="verb">CLK</spanx> is active high.</t>
<t><spanx style="verb">CLK</spanx> speed is larger than 500 kHz.</t>
<t>Data is valid on leading edge of <spanx style="verb">CLK</spanx>.</t>
<t>Data is sent in multiples of 8-bits (octets).</t>
<t>Octets are sent most-significant bit first.</t>
</list>
</t>
<t>This recommended configuration may be adjusted depending on the
individual needs of the application or product.
</t>

<section anchor="spi-framing-protocol" title="SPI Framing Protocol">
<t>Each SPI frame starts with a 5-byte frame header:
</t>
<texttable>
<ttcol align="center">Octets:</ttcol>
<ttcol align="center">1</ttcol>
<ttcol align="center">2</ttcol>
<ttcol align="center">2</ttcol>

<c>Fields:</c><c>HDR</c><c>RECV_LEN</c><c>DATA_LEN</c>
</texttable>
<t>
<list style="symbols">
<t><spanx style="verb">HDR</spanx>: The first byte is the header byte (defined below)</t>
<t><spanx style="verb">RECV_LEN</spanx>: The second and third bytes indicate the largest frame
size that that device is ready to receive. If zero, then the other
device must not send any data. (Little endian)</t>
<t><spanx style="verb">DATA_LEN</spanx>: The fourth and fifth bytes indicate the size of the
pending data frame to be sent to the other device. If this value
is equal-to or less-than the number of bytes that the other device
is willing to receive, then the data of the frame is immediately
after the header. (Little Endian)</t>
</list>
</t>
<t>The <spanx style="verb">HDR</spanx> byte is defined as:
</t>

<figure align="center"><artwork align="center">
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|RST|CRC|CCF|  RESERVED |PATTERN|
+---+---+---+---+---+---+---+---+
</artwork></figure>
<t>
<list style="symbols">
<t><spanx style="verb">RST</spanx>: This bit is set when that device has been reset since the
last time <spanx style="verb">CS</spanx> was asserted.</t>
<t><spanx style="verb">CRC</spanx>: This bit is set when that device supports writing a 16-bit
CRC at the end of the data. The CRC length is NOT included in DATA_LEN.</t>
<t><spanx style="verb">CCF</spanx>: &quot;CRC Check Failure&quot;. Set if the CRC check on the last received
frame failed, cleared to zero otherwise. This bit is only used if both
sides support CRC.</t>
<t><spanx style="verb">RESERVED</spanx>: These bits are all reserved for future used. They
MUST be cleared to zero and MUST be ignored if set.</t>
<t><spanx style="verb">PATTERN</spanx>: These bits are set to a fixed value to help distinguish
valid SPI frames from garbage (by explicitly making <spanx style="verb">0xFF</spanx> and <spanx style="verb">0x00</spanx>
invalid values). Bit 6 MUST be set to be one and bit 7 MUST be
cleared (0). A frame received that has any other values for these bits
MUST be dropped.</t>
</list>
</t>
<t>Prior to a sending or receiving a frame, the master MAY send a
5-octet frame with zeros for both the max receive frame size and the
the contained frame length. This will induce the slave device to
indicate the length of the frame it wants to send (if any) and
indicate the largest frame it is capable of receiving at the moment.
This allows the master to calculate the size of the next transaction.
Alternatively, if the master has a frame to send it can just go ahead
and send a frame of that length and determine if the frame was accepted
by checking that the <spanx style="verb">RECV_LEN</spanx> from the slave frame is larger than
the frame the master just tried to send. If the <spanx style="verb">RECV_LEN</spanx> is smaller
then the frame wasn't accepted and will need to be transmitted again.
</t>
<t>This protocol can be used either unidirectionally or bidirectionally,
determined by the behavior of the master and the slave.
</t>
<t>If the the master notices <spanx style="verb">PATTERN</spanx> is not set correctly, the master
should consider the transaction to have failed and try again after 10
milliseconds, retrying up to 200 times. After unsuccessfully trying
200 times in a row, the master MAY take appropriate remedial action
(like a NCP hardware reset, or indicating a communication failure to a
user interface).
</t>
<t>At the end of the data of a frame is an optional 16-bit CRC, support for
which is indicated by the <spanx style="verb">CRC</spanx> bit of the <spanx style="verb">HDR</spanx> byte being set. If these
bits are set for both the master and slave frames, then CRC checking is
enabled on both sides, effectively requiring that frame sizes be two bytes
longer than would be otherwise required. The CRC is calculated using the
same mechanism used for the CRC calculation in HDLC-Lite (See <xref target="hdlc-lite"/>).
When both of the <spanx style="verb">CRC</spanx> bits are set, both sides must verify that the <spanx style="verb">CRC</spanx>
is valid before accepting the frame. If not enough bytes were clocked out
for the CRC to be read, then the frame must be ignored. If enough bytes
were clocked out to perform a CRC check, but the CRC check fails, then
the frame must be rejected and the <spanx style="verb">CRC_FAIL</spanx> bit on the next frame (and
ONLY the next frame) MUST be set.
</t>
</section>
</section>

<section anchor="i2c-recommendations" title="IC Recommendations">
<t>TBD
</t>
<t><cref source="RQ">It may make sense to have a look at what Bluetooth HCI is doing
     for native IC framing and go with that.</cref></t>
</section>

<section anchor="native-usb-recommendations" title="Native USB Recommendations">
<t>TBD
</t>
<t><cref source="RQ">It may make sense to have a look at what Bluetooth HCI is doing
     for native USB framing and go with that.</cref></t>
</section>
</section>

<section anchor="test-vectors" title="Test Vectors">

<section anchor="test-vector-packed-unsigned-integer" title="Test Vector: Packed Unsigned Integer">
<texttable>
<ttcol align="right">Decimal Value</ttcol>
<ttcol align="left">Packet Octet Encoding</ttcol>

<c>0</c><c><spanx style="verb">00</spanx></c>
<c>1</c><c><spanx style="verb">01</spanx></c>
<c>127</c><c><spanx style="verb">7F</spanx></c>
<c>128</c><c><spanx style="verb">80 01</spanx></c>
<c>129</c><c><spanx style="verb">81 01</spanx></c>
<c>1,337</c><c><spanx style="verb">B9 0A</spanx></c>
<c>16,383</c><c><spanx style="verb">FF 7F</spanx></c>
<c>16,384</c><c><spanx style="verb">80 80 01</spanx></c>
<c>16,385</c><c><spanx style="verb">81 80 01</spanx></c>
<c>2,097,151</c><c><spanx style="verb">FF FF 7F</spanx></c>
</texttable>
<t><cref source="RQ">The PUI test-vector encodings need to be verified.</cref></t>
</section>

<section anchor="test-vector-reset-command" title="Test Vector: Reset Command">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 0</t>
<t>CMD: 1 (<spanx style="verb">CMD_RESET</spanx>)</t>
</list>
</t>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
80 01
</artwork></figure>
</section>

<section anchor="test-vector-reset-notification" title="Test Vector: Reset Notification">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 0</t>
<t>CMD: 6 (<spanx style="verb">CMD_VALUE_IS</spanx>)</t>
<t>PROP: 0 (<spanx style="verb">PROP_LAST_STATUS</spanx>)</t>
<t>VALUE: 114 (<spanx style="verb">STATUS_RESET_SOFTWARE</spanx>)</t>
</list>
</t>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
80 06 00 72
</artwork></figure>
</section>

<section anchor="test-vector-scan-beacon" title="Test Vector: Scan Beacon">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 0</t>
<t>CMD: 7 (<spanx style="verb">CMD_VALUE_INSERTED</spanx>)</t>
<t>PROP: 51 (<spanx style="verb">PROP_MAC_SCAN_BEACON</spanx>)</t>
<t>VALUE: Structure, encoded as <spanx style="verb">Cct(ESSc)t(iCUd)</spanx>
<list style="symbols">
<t>CHAN: 15</t>
<t>RSSI: -60dBm</t>
<t>MAC_DATA: (0D 00 B6 40 D4 8C E9 38 F9 52 FF FF D2 04 00)
<list style="symbols">
<t>Long address: B6:40:D4:8C:E9:38:F9:52</t>
<t>Short address: 0xFFFF</t>
<t>PAN-ID: 0x04D2</t>
<t>LQI: 0</t>
</list></t>
<t>NET_DATA: (13 00 03 20 73 70 69 6E 65 6C 00 08 00 DE AD 00 BE EF 00 CA FE)
<list style="symbols">
<t>Protocol Number: 3</t>
<t>Flags: 0x20</t>
<t>Network Name: <spanx style="verb">spinel</spanx></t>
<t>XPANID: <spanx style="verb">DE AD 00 BE EF 00 CA FE</spanx></t>
</list></t>
</list></t>
</list>
</t>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
80 07 33 0F C4 0D 00 B6 40 D4 8C E9 38 F9 52 FF FF D2 04 00
13 00 03 20 73 70 69 6E 65 6C 00 08 00 DE AD 00 BE EF 00 CA
FE
</artwork></figure>
</section>

<section anchor="test-vector-inbound-ipv6-packet" title="Test Vector: Inbound IPv6 Packet">
<t>CMD_VALUE_IS(PROP_STREAM_NET)
</t>
<t><cref source="RQ">FIXME: This test vector is incomplete.</cref></t>
</section>

<section anchor="test-vector-outbound-ipv6-packet" title="Test Vector: Outbound IPv6 Packet">
<t>CMD_VALUE_SET(PROP_STREAM_NET)
</t>
<t><cref source="RQ">FIXME: This test vector is incomplete.</cref></t>
</section>

<section anchor="test-vector-fetch-list-of-onmesh-networks" title="Test Vector: Fetch list of on-mesh networks">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 4</t>
<t>CMD: 2 (<spanx style="verb">CMD_VALUE_GET</spanx>)</t>
<t>PROP: 90 (<spanx style="verb">PROP_THREAD_ON_MESH_NETS</spanx>)</t>
</list>
</t>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
84 02 5A
</artwork></figure>
</section>

<section anchor="test-vector-returned-list-of-onmesh-networks" title="Test Vector: Returned list of on-mesh networks">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 4</t>
<t>CMD: 6 (<spanx style="verb">CMD_VALUE_IS</spanx>)</t>
<t>PROP: 90 (<spanx style="verb">PROP_THREAD_ON_MESH_NETS</spanx>)</t>
<t>VALUE: Array of structures, encoded as <spanx style="verb">A(t(6CbC))</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">IPv6 Prefix</ttcol>
<ttcol align="center">Prefix Length</ttcol>
<ttcol align="center">Stable Flag</ttcol>
<ttcol align="center">Other Flags</ttcol>

<c>2001:DB8:1::</c><c>64</c><c>True</c><c>??</c>
<c>2001:DB8:2::</c><c>64</c><c>False</c><c>??</c>
</texttable>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
84 06 5A 13 00 20 01 0D B8 00 01 00 00 00 00 00 00 00 00 00
00 40 01 ?? 13 00 20 01 0D B8 00 02 00 00 00 00 00 00 00 00
00 00 40 00 ??
</artwork></figure>
</section>

<section anchor="test-vector-adding-an-onmesh-network" title="Test Vector: Adding an on-mesh network">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 5</t>
<t>CMD: 4 (<spanx style="verb">CMD_VALUE_INSERT</spanx>)</t>
<t>PROP: 90 (<spanx style="verb">PROP_THREAD_ON_MESH_NETS</spanx>)</t>
<t>VALUE: Structure, encoded as <spanx style="verb">6CbCb</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">IPv6 Prefix</ttcol>
<ttcol align="center">Prefix Length</ttcol>
<ttcol align="center">Stable Flag</ttcol>
<ttcol align="center">Other Flags</ttcol>

<c>2001:DB8:3::</c><c>64</c><c>True</c><c>??</c>
</texttable>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
85 03 5A 20 01 0D B8 00 03 00 00 00 00 00 00 00 00 00 00 40
01 ?? 01
</artwork></figure>
<t><cref source="RQ">FIXME: This test vector is incomplete.</cref></t>
</section>

<section anchor="test-vector-insertion-notification-of-an-onmesh-network" title="Test Vector: Insertion notification of an on-mesh network">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 5</t>
<t>CMD: 7 (<spanx style="verb">CMD_VALUE_INSERTED</spanx>)</t>
<t>PROP: 90 (<spanx style="verb">PROP_THREAD_ON_MESH_NETS</spanx>)</t>
<t>VALUE: Structure, encoded as <spanx style="verb">6CbCb</spanx></t>
</list>
</t>
<texttable>
<ttcol align="center">IPv6 Prefix</ttcol>
<ttcol align="center">Prefix Length</ttcol>
<ttcol align="center">Stable Flag</ttcol>
<ttcol align="center">Other Flags</ttcol>

<c>2001:DB8:3::</c><c>64</c><c>True</c><c>??</c>
</texttable>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
85 07 5A 20 01 0D B8 00 03 00 00 00 00 00 00 00 00 00 00 40
01 ?? 01
</artwork></figure>
<t><cref source="RQ">FIXME: This test vector is incomplete.</cref></t>
</section>

<section anchor="test-vector-removing-a-local-onmesh-network" title="Test Vector: Removing a local on-mesh network">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 6</t>
<t>CMD: 5 (<spanx style="verb">CMD_VALUE_REMOVE</spanx>)</t>
<t>PROP: 90 (<spanx style="verb">PROP_THREAD_ON_MESH_NETS</spanx>)</t>
<t>VALUE: IPv6 Prefix <spanx style="verb">2001:DB8:3::</spanx></t>
</list>
</t>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
86 05 5A 20 01 0D B8 00 03 00 00 00 00 00 00 00 00 00 00
</artwork></figure>
</section>

<section anchor="test-vector-removal-notification-of-an-onmesh-network" title="Test Vector: Removal notification of an on-mesh network">
<t>
<list style="symbols">
<t>NLI: 0</t>
<t>TID: 6</t>
<t>CMD: 8 (<spanx style="verb">CMD_VALUE_REMOVED</spanx>)</t>
<t>PROP: 90 (<spanx style="verb">PROP_THREAD_ON_MESH_NETS</spanx>)</t>
<t>VALUE: IPv6 Prefix <spanx style="verb">2001:DB8:3::</spanx></t>
</list>
</t>
<t>Frame:
</t>

<figure align="center"><artwork align="center">
86 08 5A 20 01 0D B8 00 03 00 00 00 00 00 00 00 00 00 00
</artwork></figure>
</section>
</section>

<section anchor="example-sessions" title="Example Sessions">

<section anchor="ncp-initialization" title="NCP Initialization">
<t><cref source="RQ">FIXME: This example session is incomplete.</cref></t>
<t>Check the protocol version to see if it is supported:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_GET:PROP_PROTOCOL_VERSION</t>
<t>CMD_VALUE_IS:PROP_PROTOCOL_VERSION</t>
</list>
</t>
<t>Check the NCP version to see if a firmware update may be necessary:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_GET:PROP_NCP_VERSION</t>
<t>CMD_VALUE_IS:PROP_NCP_VERSION</t>
</list>
</t>
<t>Check interface type to make sure that it is what we expect:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_GET:PROP_INTERFACE_TYPE</t>
<t>CMD_VALUE_IS:PROP_INTERFACE_TYPE</t>
</list>
</t>
<t>If the host supports using vendor-specific commands, the vendor should
be verified before using them:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_GET:PROP_VENDOR_ID</t>
<t>CMD_VALUE_IS:PROP_VENDOR_ID</t>
</list>
</t>
<t>Fetch the capability list so that we know what features this NCP
supports:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_GET:PROP_CAPS</t>
<t>CMD_VALUE_IS:PROP_CAPS</t>
</list>
</t>
<t>If the NCP supports CAP_NET_SAVE, then we go ahead and recall the network:
</t>
<t>
<list style="symbols">
<t>CMD_NET_RECALL</t>
</list>
</t>
</section>

<section anchor="attaching-to-a-network" title="Attaching to a network">
<t><cref source="RQ">FIXME: This example session is incomplete.</cref></t>
<t>We make the assumption that the NCP is not currently associated
with a network.
</t>
<t>Set the network properties, if they were not already set:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_PHY_CHAN</t>
<t>CMD_VALUE_IS:PROP_PHY_CHAN</t>
<t>CMD_VALUE_SET:PROP_NET_XPANID</t>
<t>CMD_VALUE_IS:PROP_NET_XPANID</t>
<t>CMD_VALUE_SET:PROP_MAC_15_4_PANID</t>
<t>CMD_VALUE_IS:PROP_MAC_15_4_PANID</t>
<t>CMD_VALUE_SET:PROP_NET_NETWORK_NAME</t>
<t>CMD_VALUE_IS:PROP_NET_NETWORK_NAME</t>
<t>CMD_VALUE_SET:PROP_NET_MASTER_KEY</t>
<t>CMD_VALUE_IS:PROP_NET_MASTER_KEY</t>
<t>CMD_VALUE_SET:PROP_NET_KEY_SEQUENCE_COUNTER</t>
<t>CMD_VALUE_IS:PROP_NET_KEY_SEQUENCE_COUNTER</t>
<t>CMD_VALUE_SET:PROP_NET_KEY_SWITCH_GUARDTIME</t>
<t>CMD_VALUE_IS:PROP_NET_KEY_SWITCH_GUARDTIME</t>
</list>
</t>
<t>Bring the network interface up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_IF_UP:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_IF_UP:TRUE</t>
</list>
</t>
<t>Bring the routing stack up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_STACK_UP:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_STACK_UP:TRUE</t>
</list>
</t>
<t>Some asynchronous events from the NCP:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_IS:PROP_NET_ROLE</t>
<t>CMD_VALUE_IS:PROP_NET_PARTITION_ID</t>
<t>CMD_VALUE_IS:PROP_THREAD_ON_MESH_NETS</t>
</list>
</t>
</section>

<section anchor="successfully-joining-a-preexisting-network" title="Successfully joining a pre-existing network">
<t><cref source="RQ">FIXME: This example session is incomplete.</cref></t>
<t>This example session is identical to the above session up to the point
where we set PROP_NET_IF_UP to true. From there, the behavior changes.
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_REQUIRE_JOIN_EXISTING:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_REQUIRE_JOIN_EXISTING:TRUE</t>
</list>
</t>
<t>Bring the routing stack up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_STACK_UP:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_STACK_UP:TRUE</t>
</list>
</t>
<t>Some asynchronous events from the NCP:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_IS:PROP_NET_ROLE</t>
<t>CMD_VALUE_IS:PROP_NET_PARTITION_ID</t>
<t>CMD_VALUE_IS:PROP_THREAD_ON_MESH_NETS</t>
</list>
</t>
<t>Now let's save the network settings to NVRAM:
</t>
<t>
<list style="symbols">
<t>CMD_NET_SAVE</t>
</list>
</t>
</section>

<section anchor="unsuccessfully-joining-a-preexisting-network" title="Unsuccessfully joining a pre-existing network">
<t>This example session is identical to the above session up to the point
where we set PROP_NET_IF_UP to true. From there, the behavior changes.
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_REQUIRE_JOIN_EXISTING:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_REQUIRE_JOIN_EXISTING:TRUE</t>
</list>
</t>
<t>Bring the routing stack up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_STACK_UP:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_STACK_UP:TRUE</t>
</list>
</t>
<t>Some asynchronous events from the NCP:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_IS:PROP_LAST_STATUS:STATUS_JOIN_NO_PEERS</t>
<t>CMD_VALUE_IS:PROP_NET_STACK_UP:FALSE</t>
</list>
</t>
</section>

<section anchor="detaching-from-a-network" title="Detaching from a network">
<t>TBD
</t>
</section>

<section anchor="attaching-to-a-saved-network" title="Attaching to a saved network">
<t><cref source="RQ">FIXME: This example session is incomplete.</cref></t>
<t>Recall the saved network if you haven't already done so:
</t>
<t>
<list style="symbols">
<t>CMD_NET_RECALL</t>
</list>
</t>
<t>Bring the network interface up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_IF_UP:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_IF_UP:TRUE</t>
</list>
</t>
<t>Bring the routing stack up:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_NET_STACK_UP:TRUE</t>
<t>CMD_VALUE_IS:PROP_NET_STACK_UP:TRUE</t>
</list>
</t>
<t>Some asynchronous events from the NCP:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_IS:PROP_NET_ROLE</t>
<t>CMD_VALUE_IS:PROP_NET_PARTITION_ID</t>
<t>CMD_VALUE_IS:PROP_THREAD_ON_MESH_NETS</t>
</list>
</t>
</section>

<section anchor="ncp-software-reset" title="NCP Software Reset">
<t><cref source="RQ">FIXME: This example session is incomplete.</cref></t>
<t>
<list style="symbols">
<t>CMD_RESET</t>
<t>CMD_VALUE_IS:PROP_LAST_STATUS:STATUS_RESET_SOFTWARE</t>
</list>
</t>
<t>Then jump to <xref target="ncp-initialization"/>.
</t>
</section>

<section anchor="adding-an-onmesh-prefix" title="Adding an on-mesh prefix">
<t>TBD
</t>
</section>

<section anchor="entering-lowpower-modes" title="Entering low-power modes">
<t>TBD
</t>
</section>

<section anchor="sniffing-raw-packets" title="Sniffing raw packets">
<t><cref source="RQ">FIXME: This example session is incomplete.</cref></t>
<t>This assumes that the NCP has been initialized.
</t>
<t>Optionally set the channel:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_PHY_CHAN:x</t>
<t>CMD_VALUE_IS:PROP_PHY_CHAN</t>
</list>
</t>
<t>Set the filter mode:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_MAC_PROMISCUOUS_MODE:MAC_PROMISCUOUS_MODE_MONITOR</t>
<t>CMD_VALUE_IS:PROP_MAC_PROMISCUOUS_MODE:MAC_PROMISCUOUS_MODE_MONITOR</t>
</list>
</t>
<t>Enable the raw stream:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_MAC_RAW_STREAM_ENABLED:TRUE</t>
<t>CMD_VALUE_IS:PROP_MAC_RAW_STREAM_ENABLED:TRUE</t>
</list>
</t>
<t>Enable the PHY directly:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_SET:PROP_PHY_ENABLED:TRUE</t>
<t>CMD_VALUE_IS:PROP_PHY_ENABLED:TRUE</t>
</list>
</t>
<t>Now we will get raw 802.15.4 packets asynchronously on
PROP_STREAM_RAW:
</t>
<t>
<list style="symbols">
<t>CMD_VALUE_IS:PROP_STREAM_RAW:...</t>
<t>CMD_VALUE_IS:PROP_STREAM_RAW:...</t>
<t>CMD_VALUE_IS:PROP_STREAM_RAW:...</t>
</list>
</t>
<t>This mode may be entered even when associated with a network.
In that case, you should set <spanx style="verb">PROP_MAC_PROMISCUOUS_MODE</spanx> to
<spanx style="verb">MAC_PROMISCUOUS_MODE_PROMISCUOUS</spanx> or <spanx style="verb">MAC_PROMISCUOUS_MODE_NORMAL</spanx>, so that
you can avoid receiving packets from other networks or that are destined
for other nodes.
</t>
</section>
</section>

<section anchor="glossary" title="Glossary">
<t><cref source="RQ">Alphabetize before finalization.</cref></t>
<t>
<list style="hanging">
<t hangText="FCS">
<vspace />
Final Checksum. Octets added to the end of a packet to help determine if the packet was received without corruption.</t>
<t hangText="NCP">
<vspace />
Network Control Processor.</t>
<t hangText="NLI">
<vspace />
Network Link Identifier. May be a value between zero and three. See <xref target="nli-network-link-identifier"/> for more information.</t>
<t hangText="OS">
<vspace />
Operating System, i.e. the IPv6 node using Spinel to control and manage one or more of its IPv6 network interfaces.</t>
<t hangText="PHY">
<vspace />
Physical layer. Refers to characteristics and parameters related to the physical implementation and operation of a networking medium.</t>
<t hangText="PUI">
<vspace />
Packed Unsigned Integer. A way to serialize an unsigned integer using one, two, or three octets. Used throughout the Spinel protocol. See <xref target="packed-unsigned-integer"/> for more information.</t>
<t hangText="TID">
<vspace />
Transaction Identifier. May be a value between zero and fifteen. See <xref target="tid-transaction-identifier"/> for more information.</t>
</list>
</t>
</section>

<section anchor="acknowledgments" title="Acknowledgments">
<t>Thread is a registered trademark of The Thread Group, Inc.
</t>
<t>Special thanks to Nick Banks, Jonathan Hui, Abtin Keshavarzian, Yakun Xu,
Piotr Szkotak, Arjuna Sivasithambaresan and Martin Turon for their
substantial contributions and feedback related to this document.
</t>
<t>This document was prepared using <eref target="https://github.com/miekg/mmark">mmark</eref>
by (Miek Gieben) and <eref target="http://xml2rfc.ietf.org/">xml2rfc (version 2)</eref>.
</t>
</section>

</back>
</rfc>
