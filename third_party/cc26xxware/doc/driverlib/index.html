<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.ico" >
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CC26xx Driver Library: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ti_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CC26xx Driver Library
   </div>
  </td>
  <td id="projectlogo"><a href="http://www.ti.com"><img align="right" alt="Logo" src="ti_logo_header.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>APIs</span></a></li>
      <li><a href="usergroup0.html"><span>Register&#160;Descriptions</span></a></li>
      <li><a href="usergroup1.html"><span>Online&#160;Resources</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro_intro">Introduction</a></li>
<li class="level1"><a href="#intro_source_code">Source Code Overview</a></li>
<li class="level1"><a href="#intro_precompile">Pre-compiled Driver Library</a></li>
<li class="level1"><a href="#prog_model_intro">Programming Model</a><ul><li class="level2"><a href="#prog_model_direct">Direct Register Access Model</a><ul><li class="level3"><a href="#prog_model_bitband">Bit-Band Operations</a></li>
</ul>
</li>
<li class="level2"><a href="#prog_model_software">Software Driver Model</a></li>
<li class="level2"><a href="#prog_model_combine">Combining the Models</a></li>
</ul>
</li>
<li class="level1"><a href="#rom_intro">ROM Functions</a><ul><li class="level2"><a href="#rom_default">Default DriverLib Call</a></li>
<li class="level2"><a href="#rom_rom_call">Direct ROM Call</a></li>
<li class="level2"><a href="#rom_flash_call">Direct Flash Call</a></li>
<li class="level2"><a href="#rom_precompiled">Using Pre-compiled Driver Library</a></li>
</ul>
</li>
<li class="level1"><a href="#hapi">HAPI Functions</a></li>
<li class="level1"><a href="#error">Error Checking</a></li>
<li class="level1"><a href="#setup">Device Setup</a></li>
<li class="level1"><a href="#ccfg">Customer Configuration (CCFG)</a></li>
<li class="level1"><a href="#rtos">TI RTOS</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro_intro"></a>
Introduction</h1>
<p>The CC26xx Driver Library from Texas Instruments&reg;&#160; (also referred to as "DriverLib") is a set of drivers for accessing the peripherals found on the CC26xx family of ARM&reg;&#160;Cortex&trade;-M3 based devices. The DriverLib functions are grouped in APIs based on either specific on-chip peripheral module (e.g. SPI, UART, etc ) or more general functionality (e.g. system control, oscillator settings, etc). Each API uses a unique pre-fix for all the DriverLib functions in that API to indicate which module or type of functionality being accessed (with a few exceptions).</p>
<p>The capabilities and organization of the drivers are governed by the following design goals:</p>
<ul>
<li>They are written entirely in C language except where absolutely not possible.</li>
<li>They demonstrate how to use the peripheral in its common mode of operation.</li>
<li>They are reasonably efficient in terms of memory and processor usage.</li>
<li>They are as self-contained as possible.</li>
<li>Where possible, computations that can be performed at compile time are done there instead of at run time.</li>
<li>They can be built with more than one tool chain.</li>
</ul>
<p>Some consequences of these design goals are:</p>
<ul>
<li>The drivers are not necessarily as efficient as they could be (from a code size and/or execution speed point of view). While the most efficient piece of code for operating a peripheral would be written in assembly language and custom tailored to the specific requirements of the application, further size optimizations of the drivers would make them more difficult to understand.</li>
<li>The drivers do not support the full capabilities of the hardware. Some of the peripherals provide complex capabilities which cannot be used by the drivers in this library, though the existing code can be used as a reference upon which to add support for the additional features.</li>
<li>The APIs have a means of removing all error-checking code. Because the error checking is usually useful only during initial program development, it can be removed to significantly improve code size and speed.</li>
</ul>
<p>For many applications the drivers can be used as is. But in some cases the drivers must be enhanced or rewritten to meet the functionality, memory, or processing requirements of the application. If so, the existing driver can be used as a reference on how to operate the peripheral.</p>
<h1><a class="anchor" id="intro_source_code"></a>
Source Code Overview</h1>
<p>A brief overview of the organization of the driver library source code follows:</p>
<p>driverlib/</p><ul>
<li>This directory contains the source code for the drivers. The API of each module consists of a .c file and a .h file.</li>
</ul>
<p>inc/</p><ul>
<li>This directory contains the header files used for the direct register access programming model. The hw_*.h header files, one per peripheral, describe all the registers and the bit fields within those registers for each peripheral. These header files are used by the drivers to directly access a peripheral, and can be used by application code to bypass the driver library API if necessary.</li>
</ul>
<p>Currently, DriverLib source code supports the following tools:</p><ul>
<li>CCS</li>
<li>IAR</li>
<li>GCC</li>
<li>Keil</li>
</ul>
<h1><a class="anchor" id="intro_precompile"></a>
Pre-compiled Driver Library</h1>
<p>Besides the source code for the driver library Texas Instruments also provides pre-compiled libraries of the driver library. These libraries are found in driverlib/bin/.</p>
<p>Currently, pre-compiled libraries are provided for the following tools:</p><ul>
<li>CCS</li>
<li>IAR</li>
<li>GCC</li>
<li>Keil</li>
</ul>
<h1><a class="anchor" id="prog_model_intro"></a>
Programming Model</h1>
<p>DriverLib provides support for two programming models:</p><ul>
<li>Direct register access model: Access registers and bit fields directly.</li>
<li>Software driver model: Use the provided APIs to indirectly access registers and bit fields.</li>
</ul>
<p>Each model can be used independently or combined, based on the needs of the application or the programming environment desired by the developer.</p>
<p>Each programming model has advantages and disadvantages. Use of the direct register access model generally results in smaller and more efficient code than using the software driver model. However, the direct register access model requires detailed knowledge of the operation of each register and bit field, as well as their interactions and any sequencing required for proper operation of the peripheral; the software driver model insulates the developer from these details, thus generally requiring less time to develop applications.</p>
<h2><a class="anchor" id="prog_model_direct"></a>
Direct Register Access Model</h2>
<p>In the direct register access model, the peripherals are programmed by the application by writing values directly into the registers in the peripheral. A set of defines, that simplify this process, is provided.</p>
<p>These defines are located in the <code>inc/</code> directory and there is a single <code>hw_&lt;module&gt;.h</code> header file for each peripheral type. For example, the defines for SSI are located in the <code>hw_ssi.h</code> header file.</p>
<p>The defines used by the direct register access model follow a naming convention that makes it easier to know how to use a particular macro. The rules are as follows:</p>
<ul>
<li>All register name macros start with the module name (for example, <code>SSI</code> for the SSI module) and are followed by the name of the register as it appears in the data sheet.</li>
<li>The register defines are offset values relative to the base address of a peripheral instance. If an offset is used, this will be identified in the register name using <code>_O_</code> (for example, <code>CR0</code> register in the data sheet results in <code>SSI_O_CR0</code>). The base address of each peripheral is defined in the memory map header file located in the <code>inc/</code> directory, with the name <code>hw_memmap.h</code>.</li>
<li>All register defines for a given peripheral are listed in the first section of the corresponding header file (for example, in the first section of the <code>hw_ssi.h</code> file for the SSI registers).</li>
<li>All register bit fields start with the module name, followed by the register name, and then followed by the bit field name as it appears in the data sheet. For example, the <code>SCR</code> bit field in the <code>CR0</code> register in the <code>SSI</code> module is identified by <code>SSI_CR0_SCR...</code>.</li>
<li>Defines that end in <code>_M</code> represent the mask for a bit field in a register.</li>
<li>Defines that end in <code>_S</code> represent the number of bits to shift a value in order to align it with a bit field. These values match the macro with the same base name but ending with <code>_M</code>.</li>
<li>Defines that end in <code>_BITN</code> have the same value as <code>_S</code> but are only defined for single-bit bit fields thus representing the bit number. These defines should be used for bit band operations to ensure that only single-bit bit fields are accessed.</li>
<li>Defines that end in <code>_W</code> represent the width of the bit field.</li>
<li>If a bit field has enumerated values the enumeration names are appended to the name of the bit field define. For example, the <code>SSI_CR0_DSS</code> bit field has a set of enumerations that specify the allowed values of this bit field pre-shifted to the correct bit positions. E.g. the enumeration "7_BIT" can be set using the define <code>SSI_CR0_DSS_7_BIT</code>. This improves readability and also helps the programmer select valid values for specific bit fields.</li>
</ul>
<p>A set of macros is provided in <code>hw_types.h</code> to use together with the register defines to read and write the corresponding addresses:</p>
<ul>
<li>HWREG(x) : Access (read or write) a full word (32 bits) at address x in the memory map.</li>
<li>HWREGH(x) : Access a halfword (16 bits) at address x in the memory map.</li>
<li>HWREGB(x) : Access a byte (8 bits) at address x in the memory map.</li>
<li>HWREGBITW(x, b) : Access bit-band region for bit-band operation using full word access.</li>
<li>HWREGBITH(x, b) : Access bit-band region for bit-band operation using halfword access.</li>
<li>HWREGBITB(x, b) : Access bit-band region for bit-band operation using byte access.</li>
</ul>
<p>Given these defines and macros, the <code>CR0</code> register, in the first instance of the SSI peripheral (SSI0), can be programmed as follows:</p>
<pre class="fragment">    HWREG(SSI0_BASE + SSI_O_CR0) = ((5 &lt;&lt; SSI_CR0_SCR_S) | SSI_CR0_SPH | SSI_CR0_SPO);
</pre><p>Alternatively, the following has the same effect (although it is not as easy to understand):</p>
<pre class="fragment">    HWREG(SSI0_BASE + SSI_O_CR0) = 0x000005c0;
</pre><p>The value of the <code>SCR</code> field from the <code>CR0</code> register can be extracted as follows:</p>
<pre class="fragment">    ulValue = (HWREG(SSI0_BASE + SSI_O_CR0) &amp; SSI_CR0_SCR_M) &gt;&gt; SSI_CR0_SCR_S;
</pre><dl class="section note"><dt>Note</dt><dd>These examples all use constants (defines) as argument for the macro which means that the macro can be resolved at <b>compile-time</b> for very efficient memory accesses. If using variables (e.g. a count value for accessing continuous addresses) the macro can only be resolved at <b>run-time</b> thus resulting in more code and less efficient execution.</dd></dl>
<h3><a class="anchor" id="prog_model_bitband"></a>
Bit-Band Operations</h3>
<p>The device supports ARM's so-called "bit-band operations" which is a mechanism that makes a read-modify-write operation an atomic operation seen from the CPU's perspective. I.e. the CPU can write a single bit in a register/memory without executing the usual read-modify-write operation but instead the CPU only needs to perform a single write operation, and then the bus performs the actual read-modify-write towards the memory or peripheral module. Same goes for reading single bits as the bus takes care of masking and shifting such that the CPU receives a word only containing the bit of interest located at the LSB.</p>
<p>Bit-band operations are only possible in the <b>bit-band regions</b> where the LSB of each word represents a single bit in a <b>bit-band alias</b> region. The term "bit-band alias" describes the registers or memory locations to which the bus performs the actual read-modify-write operation. In other words, if a programmer wants to perform a bit operation on a register, the register must be in the bit-band alias region, and then he can perform a bit-band operation to the bit-band region and then the bus remaps it to the bit-band alias address.</p>
<p>The provided macros, <code>HWREGBITW</code> etc, "hide" the bit-band regions to the programmer such that the programmer only needs to program which bit of a register (in the bit-band alias region) he wants to write or read. Thus the macro maps the register and bit number to an address in the bit-band region and then the bus performs the bit-band operation by remapping back to the bit-band alias address.</p>
<p>The device has two bit-band alias regions, each spanning 1MB, which are:</p>
<ul>
<li>SRAM : <code>0x2000_0000 - 0x200F_FFFF</code></li>
<li>Peripheral : <code>0x4000_0000 - 0x400F_FFFF</code></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Not all addresses in the two ranges are accessible thus accessing an address in the bit-band region which does not have a valid bit-band alias will result in a bus error. See the memory map of the device to make sure which addresses are accessible!</dd></dl>
<p>The corresponding bit-band regions, each spanning 32MB, (accessed through the macros) are:</p>
<ul>
<li>SRAM : <code>0x2200_0000 - 0x23FF_FFFF</code></li>
<li>Peripheral : <code>0x4200_0000 - 0x43FF_FFFF</code></li>
</ul>
<p>Thus, instead of using the usual read-modify-write to clear a bit:</p>
<pre class="fragment">    HWREG(SSI0_BASE + SSI_O_CR0) &amp;= ~(SSI_CR0_SPO_M);
</pre><p>it is possible to use bit-banding:</p>
<pre class="fragment">    HWREGBITW(SSI0_BASE + SSI_O_CR0, SSI_CR0_SPO_BITN) = 0;
</pre><dl class="section note"><dt>Note</dt><dd>The macros for bit-banding are a little more complex thus using variables instead of constants (defines) as arguments for the macros will result in more code in order to calculate the address in the bit-band region at run time. If it is necessary to use variables with bit-banding then consider accessing the bit-band region directly instead of using the provided macros if code size or execution time are critical.</dd></dl>
<h2><a class="anchor" id="prog_model_software"></a>
Software Driver Model</h2>
<p>In the software driver model, the APIs provided in DriverLib are used by applications to control the peripherals. Because these drivers provide complete control of the peripherals in their normal mode of operation, it is possible to write an entire application without direct access to the hardware. This method provides for rapid development of the application without requiring knowledge of how to program the peripheral registers.</p>
<p>Corresponding to the direct register access model example, the following call also programs the <code>CR0</code> register in the SSI module (though the register name is hidden by the API):</p>
<pre class="fragment">    SSIConfigSetExpClk(SSI0_BASE, 50000000, SSI_FRF_MOTO_MODE_3,
                       SSI_MODE_MASTER, 1000000, 8);
</pre><p>The resulting value in the <code>CR0</code> register might not be exactly the same because <a class="el" href="group__ssi__api.html#ga920b241b9d99f0b19f1c0a6f3779bc10" title="Configures the synchronous serial port. ">SSIConfigSetExpClk()</a> may compute a different value for the <code>SCR</code> bit field than what was used in the direct register access model example.</p>
<h2><a class="anchor" id="prog_model_combine"></a>
Combining the Models</h2>
<p>The direct register access model and software driver model can be used together in a single application, thus applying the most appropriate model as needed to any particular situation within the application. For example, the software driver model can be used to configure the peripherals (because this is not performance critical) and the direct register access model can be used to operate the peripheral (which may be more performance critical). Or, the software driver model can be used for peripherals that are not performance critical (such as a UART used for data logging) and the direct register access model can be used for performance critical peripherals.</p>
<h1><a class="anchor" id="rom_intro"></a>
ROM Functions</h1>
<p>In order to free up code space in the flash memory for user applications a part of the driver library has been stored in the on-chip ROM which allows the user to chose between calling certain drivers from either ROM or flash. Calling the ROM version of a driver function prevents the compiler from putting the function in flash and thus leaving more flash memory for applications.</p>
<p>Besides saving space in flash other benefits of using the ROM version of a driver library function are faster execution and reduced power consumption as flash is both slower and more power consuming than the ROM. A minor disadvantage of calling a ROM function is a small overhead in the function call as it does a table look-up to find the address of the ROM function. However, only driver library functions of a certain size have been selected to be stored in ROM which means that the ROM version of a function is always faster and less power consuming than its flash equivalent.</p>
<h2><a class="anchor" id="rom_default"></a>
Default DriverLib Call</h2>
<p>Because of the benefits of using the ROM version of a given driver a mechanism to select the ROM version as default has been implemented. This mechanism uses defines to effectively rename functions and function calls to distinguish between ROM and flash versions.</p>
<p>The mechanism works like this:</p>
<ul>
<li>The file <code><a class="el" href="rom_8h.html">rom.h</a></code> contains the list of ROM functions available in the device and each ROM function has a define that tells the compiler where to find the function in ROM (via a look-up table). All ROM functions have the prefix <code>ROM_</code>.</li>
<li>In the beginning of the .h file for every module all functions that are <b>not</b> <code>static inline</code> are defined (renamed) from <code>FunctionName()</code> to <code>NOROM_FunctionName()</code> thus all flash functions now have the prefix <code>NOROM_</code> - except <code>static inline</code> functions which will keep the original name.</li>
<li>At the end of the .h file all the defines (function names) are re-defined to the ROM version with the prefix <code>ROM_</code> thus when a user includes the .h file in his .c file then all DriverLib calls are redefined to call the ROM function. The default redefinition to ROM functions can be avoided by defining <code>DRIVERLIB_NOROM</code> in the project. This will prevent the redefinition to <code>ROM_</code> functions and keep the definition to <code>NOROM_</code> functions and thus always use the flash version.</li>
<li>In the beginning of the .c file for a module all non <code>static inline</code> functions are redefined to <code>NOROM_FunctionName</code> in order to make sure that the functions in the DriverLib .c file are always redefined to have the prefix <code>NOROM_</code> i.e. calling a <code>NOROM_</code> function will always call the flash version.</li>
</ul>
<p>In summary: By default, the compiler will use DriverLib in ROM whenever possible and if the user wishes to avoid the ROM versions entirely (e.g. test and debugging) he can make a project-wide define called <code>DRIVERLIB_NOROM</code> which forces DriverLib to ignore the ROM functions. However, some functions from the flash API will always execute from ROM as they are not allowed to execute from flash (e.g. program and erase).</p>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="index.html#rom_precompiled">Using Pre-compiled Driver Library</a> when you are not compiling DriverLib yourself but using pre-compiled library instead.</dd></dl>
<h2><a class="anchor" id="rom_rom_call"></a>
Direct ROM Call</h2>
<p>If a user wishes to avoid ROM versions of DriverLib by default but only use specific DriverLib functions from ROM this is possible:</p>
<ul>
<li>Define <code>DRIVERLIB_NOROM</code> in the project to use flash versions as default.</li>
<li>Include <code><a class="el" href="rom_8h.html">rom.h</a></code> in the user .c file.</li>
<li>Use prefix <code>ROM_</code> whenever a ROM function is wanted.</li>
</ul>
<h2><a class="anchor" id="rom_flash_call"></a>
Direct Flash Call</h2>
<p>If ROM functions are used as default then it is possible to use the flash version of a specific function:</p>
<ul>
<li>Use prefix <code>NOROM_</code> whenever a flash function is wanted.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If you use <code>NOROM_</code> explicitly to call the flash version of a DriverLib function (FunctionA) and <b>that</b> function makes a function call to another DriverLib function (FunctionB) then the internal function call (to FunctionB) will use the global selection; in this case the ROM version.</dd></dl>
<h2><a class="anchor" id="rom_precompiled"></a>
Using Pre-compiled Driver Library</h2>
<p>When using the pre-compiled version of DriverLib then setting the define <code>DRIVERLIB_NOROM</code> in the project has no effect on the library itself. Thus all internal calls in the pre-compiled library to other DriverLib functions will <b>always</b> be to ROM version - if it exists.</p>
<h1><a class="anchor" id="hapi"></a>
HAPI Functions</h1>
<p>Besides the functions available in the DriverLib a number of functions are also available in a ROM-only version. These functions are called HAPI functions (Hard API) and are generally used by various tools. Source code is not available for the HAPI functions but the functions are available for users to call. The list of HAPI functions available can be found in <code><a class="el" href="rom_8h.html">rom.h</a></code>.</p>
<h1><a class="anchor" id="error"></a>
Error Checking</h1>
<p>Invalid arguments and error conditions are handled in a non-traditional manner in DriverLib. Typically, a function would check its arguments to make sure that they are valid (if required; some may be unconditionally valid such as a 32-bit value used as the load value for a 32-bit timer). If an invalid argument is provided, an error code would be returned. The caller then has to check the return code from each invocation of the function to make sure that it succeeded.</p>
<p>This method results in a significant amount of argument-checking code in each function and return-code-checking code at each call site. For a self-contained application, this extra code becomes an unneeded overhead once the application is debugged. Having a means of removing it allows the final code to be smaller and therefore run faster and consume less power.</p>
<p>In this driver library, most functions do not return error status. Argument checking is done via a call to the <code>ASSERT</code> macro (provided in <code><a class="el" href="debug_8h.html">debug.h</a></code>). This macro has the usual definition of an assert macro; it takes an expression that <b>must</b> be true. By making this macro empty, the argument checking is completely removed from the code thus avoiding the error checking overhead.</p>
<p>There are two definitions of the <code>ASSERT</code> macro provided in <code><a class="el" href="debug_8h.html">debug.h</a></code>; one that is empty (used for normal/release builds) and one that evaluates the expression (used when the library is built for debugging). The debug version calls the <code>__error__</code> function whenever the expression is not true, passing the file name and line number of the <code>ASSERT</code> macro invocation. The <code>__error__</code> function is prototyped in <code><a class="el" href="debug_8h.html">debug.h</a></code> and must be provided by the application because it is the application's responsibility to deal with error conditions.</p>
<p>To enable the <code>ASSERT</code> macro define the symbol <code>DRIVERLIB_DEBUG</code> within your project and/or compiler setup.</p>
<dl class="section note"><dt>Note</dt><dd>Defining <code>DRIVERLIB_DEBUG</code> for the entire project might result in a significant increase in code size depending on the number of modules used in the project. Defining <code>DRIVERLIB_DEBUG</code> for specific files is possible if a project-wide define results in an unacceptable code size increase.</dd></dl>
<p>By setting a breakpoint on the <code>__error__</code> function, the debugger immediately stops whenever an error occurs anywhere in the application (something that would be very difficult to do with other error checking methods). When the debugger stops, the arguments to the <code>__error__</code> function and the backtrace of the stack pinpoint the function that found an error, what it found to be a problem, and where it was called from. As an example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="group__uart__api.html#ga93348c8712402d4f1410b0ba3e0122ad">UARTParityModeSet</a>(uint32_t ui32Base, uint32_t ui32Parity)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// Check the arguments.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <a class="code" href="group__debug__api.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>(UARTBaseValid(ui32Base));</div>
<div class="line">    <a class="code" href="group__debug__api.html#ga28301f76c53b643912da7c538f74e2c6">ASSERT</a>((ui32Parity == <a class="code" href="group__uart__api.html#ga195d4b28a36df1b8588ca5380a442174">UART_CONFIG_PAR_NONE</a>) ||</div>
<div class="line">           (ui32Parity == <a class="code" href="group__uart__api.html#gab0b5949051df64b22671181391963e95">UART_CONFIG_PAR_EVEN</a>) ||</div>
<div class="line">           (ui32Parity == <a class="code" href="group__uart__api.html#ga539811fccbd8e4bf55e4041a7fdfb3d8">UART_CONFIG_PAR_ODD</a>) ||</div>
<div class="line">           (ui32Parity == <a class="code" href="group__uart__api.html#ga8f41997eb87d51c953d48fcfce366be7">UART_CONFIG_PAR_ONE</a>) ||</div>
<div class="line">           (ui32Parity == <a class="code" href="group__uart__api.html#ga47e9212c4de4dc69d2febced118e12ca">UART_CONFIG_PAR_ZERO</a>));</div>
</div><!-- fragment --><p>Each argument is individually checked, so the line number of the failing <code>ASSERT</code> indicates the argument that is invalid. The debugger is able to display the values of the arguments (from the stack backtrace) as well as the caller of the function that had the argument error. This method allows the problem to be quickly identified at the cost of a small amount of code.</p>
<h1><a class="anchor" id="setup"></a>
Device Setup</h1>
<p>DriverLib includes a special function called trimDevice() which must always be called right after the ROM boot sequence in order to apply trim settings and certain customer configurations (from CCFG) to the device.</p>
<dl class="section note"><dt>Note</dt><dd>trimDevice() is called by the startup file provided as part of CC13/26xxWare.</dd></dl>
<h1><a class="anchor" id="ccfg"></a>
Customer Configuration (CCFG)</h1>
<p>CC13/26xxWare also includes a customer configuration file (ccfg.c) which contains settings that are being applied mainly by ROM boot sequence, trimDevice() during startup, and radio SW. The configuration settings are stored in a specially allocated address range in flash referred to as "CCFG area". The user must edit the CCFG to fit the needs of the specific design and application.</p>
<p>Typically, a user application does not need to read the settings in CCFG; however, a few settings might be interesting for a user to read thus DriverLib provides an API that allows simple access to a subset of the CCFG settings (see the <a class="el" href="group__ccfgread__api.html">CCFGRead API</a>). The remaining settings not covered by the DriverLib API can of course be read using the "Direct Register Access Model" described earlier. Although located in flash the CCFG settings are documented in the register descriptions as part of the CPU Domain Memory Map.</p>
<h1><a class="anchor" id="rtos"></a>
TI RTOS</h1>
<p>Texas Instruments provides a Real-Time Operating System (RTOS) for CC26xx called TI-RTOS which uses the DriverLib as the main interface to access the hardware registers thus minimizing the need for direct register accesses from TI-RTOS itself. The TI-RTOS package provides its own set of RTOS drivers that call DriverLib functions but RTOS drivers can be used only together with TI-RTOS and not stand-alone in a non-RTOS application.</p>
<p>When using TI-RTOS and the included RTOS drivers it is important that a user application does not "bypass" TI-RTOS drivers by calling DriverLib functions directly to configure any hardware that is controlled by TI-RTOS. Doing so can cause a conflict that may result in unexpected behavior by the RTOS. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">&copy Copyright 2016 Texas Instruments Incorporated. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
