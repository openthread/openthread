/*
* Copyright (c) 2014 - 2015, Freescale Semiconductor, Inc.
* Copyright 2016-2019 NXP
* All rights reserved.
*
* SPDX-License-Identifier: BSD-3-Clause
*/

/** @addtogroup nxp.com
  * @{
  */

/** @addtogroup jn518x
  * @{
  */

#ifndef _JN518XHW_H_
#define _JN518XHW_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _JN5189_H_
/* -------------------------  Interrupt Number Definition  ------------------------ */

typedef enum {
/* -------------------  Cortex-M4 Processor Exceptions Numbers  ------------------- */
  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
  MemoryManagement_IRQn         = -12,              /*!<   4  Memory Management, MPU mismatch, including Access Violation
                                                         and No Match                                                          */
  BusFault_IRQn                 = -11,              /*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                         related Fault                                                         */
  UsageFault_IRQn               = -10,              /*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition    */
  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
/* ----------------------  jn518x Specific Interrupt Numbers  --------------------- */
System_IRQn                   =  0,               /*!< System (BOD, Watchdog Timer, Flash controller) interrupt */
DMA_IRQn                      =  1,               /*!< DMA interrupt */
GINT_IRQn                     =  2,               /*!< GPIO global interrupt */
IRBlaster_IRQn                =  3,               /*!< Infra Red Blaster */
PINT0_IRQn                    =  4,               /*!< Pin Interrupt (and Pattern matching) 0 */
PINT1_IRQn                    =  5,               /*!< Pin Interrupt (and Pattern matching) 1 */
PINT2_IRQn                    =  6,               /*!< Pin Interrupt (and Pattern matching) 2 */
PINT3_IRQn                    =  7,               /*!< Pin Interrupt (and Pattern matching) 3 */
SPIFI_IRQn                    =  8,               /*!< Quad-SPI flash interface interrupt */
Timer0_IRQn                   =  9,               /*!< Counter/Timer 0 interrupt */
Timer1_IRQn                   = 10,               /*!< Counter/Timer 1 interrupt */
USART0_IRQn                   = 11,
USART1_IRQn                   = 12,
I2C0_IRQn                     = 13,
I2C1_IRQn                     = 14,
SPI0_IRQn                     = 15,
SPI1_IRQn                     = 16,
PWM0_IRQn                     = 17,               /*!< PWM channel 0  interrupt */
PWM1_IRQn                     = 18,               /*!< PWM channel 1  interrupt */
PWM2_IRQn                     = 19,               /*!< PWM channel 2  interrupt */
PWM3_IRQn                     = 20,               /*!< PWM channel 3  interrupt */
PWM4_IRQn                     = 21,               /*!< PWM channel 4  interrupt */
PWM5_IRQn                     = 22,               /*!< PWM channel 5  interrupt */
PWM6_IRQn                     = 23,               /*!< PWM channel 6  interrupt */
PWM7_IRQn                     = 24,               /*!< PWM channel 7  interrupt */
PWM8_IRQn                     = 25,               /*!< PWM channel 8  interrupt */
PWM9_IRQn                     = 26,               /*!< PWM channel 9  interrupt */
PWM10_IRQn                    = 27,               /*!< PWM channel 10 interrupt */
I2C2_IRQn                     = 28,
RTC_IRQn                      = 29,
NFCTag_IRQn                   = 30,
MAILBOX_IRQn                  = 31,
ADC_SEQA_IRQn                 = 32,
ADC_SEQB_IRQn                 = 33,
ADC_THCMP_OVR_IRQn            = 34,
DMIC_IRQn                     = 35,
HWVAD_IRQn                    = 36,
BLE_DP_IRQn                   = 37,
BLE_DP0_IRQn                  = 38,
BLE_DP1_IRQn                  = 39,
BLE_DP2_IRQn                  = 40,
BLE_LL_ALL_IRQn               = 41,
ZIGBEE_MAC_IRQn               = 42,
ZIGBEE_MODEM_IRQn             = 43,
RFP_TMU_IRQn                  = 44,
RFP_AGC_IRQn                  = 45,
ISO7816_IRQn                  = 46,
ANA_COMP_IRQn                 = 47,
WAKE_UP_TIMER0_IRQn           = 48,
WAKE_UP_TIMER1_IRQn           = 49,
PVT_AMBER0_IRQn               = 50,
PVT_RED0_IRQn                 = 51,
PVT_AMBER1_IRQn               = 52,
PVT_RED1_IRQn                 = 53,
BLE_WAKE_TIMER_IRQn           = 54,
HASH_IRQn                     = 55,
} IRQn_Type;

#else

#undef AES
#undef CODEPATCH
#undef DMA
#undef DMIC
#undef FLASH
#undef GINT
#undef GPIO
#undef I2C0
#undef I2C1
#undef I2C2
#undef IOCON
#undef IR
#undef ISO7816
#undef MAILBOX
#undef OTPC
#undef PINT
#undef PMC
#undef PVT
#undef PWM
#undef RNG
#undef RTC
#undef SPI0
#undef SPI1
#undef SPIFI
#undef SYSCON
#undef USART0
#undef USART1
#undef WWDT
#undef HASH

#endif

/** @addtogroup Configuration_of_CMSIS
  * @{
  */


/* ================================================================================ */
/* ================      Processor and Core Peripheral Section     ================ */
/* ================================================================================ */

#ifndef _JN5189_H_

/* ----------------Configuration of the Cortex-M4 Processor and Core Peripherals---------------- */
#if defined(CPU_JN518X_REV)&&(CPU_JN518X_REV == 1)
    /* ES1 if explicitly configured */
#define __CM4_REV                 0x0000            /*!< Cortex-M4 Core Revision                                               */
#else
    /* ES2 default */
#define __CM4_REV                 0x0001            /*!< Cortex-M4 Core Revision                                               */
#endif
#define __MPU_PRESENT                  0            /*!< MPU present or not                                                    */
#define __NVIC_PRIO_BITS               3            /*!< Number of Bits used for Priority Levels                               */
#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
#define __FPU_PRESENT                  0            /*!< FPU present or not                                                    */
/** @} */ /* End of group Configuration_of_CMSIS */
#endif

#include "core_cm4.h"                               /*!< Cortex-M4 processor and core peripherals                              */
#include "system_jn518x.h"                          /*!< jn518x System                                                         */


/* ================================================================================ */
/* ================       Device Specific Peripheral Section       ================ */
/* ================================================================================ */


/** @addtogroup Device_Peripheral_Registers
  * @{
  */


/* -------------------  Start of section using anonymous unions  ------------------ */
#if defined(__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined(__ICCARM__)
  #pragma language=extended
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__TMS470__)
/* anonymous unions are enabled by default */
#elif defined(__TASKING__)
  #pragma warning 586
#else
  #warning Not supported compiler type
#endif


typedef struct {
  union {
    __IO uint32_t  CFG;                             /*!< Configuration register for DMA channel x                              */
    
    struct {
      __IO uint32_t  PERIPHREQEN:  1;               /*!< Peripheral request Enable. If a DMA channel is used to perform
                                                         a memory-to-memory move, any peripheral DMA request associated
                                                          with that channel can be disabled to prevent any interaction
                                                          between the peripheral and the DMA controller. 0 Disabled. Peripheral
                                                          DMA requests are disabled. 1 Enabled. Peripheral DMA requests
                                                          are enabled.                                                         */
      __IO uint32_t  HWTRIGEN   :  1;               /*!< Hardware Triggering Enable for this channel. 0 Disabled. Hardware
                                                         triggering is not used. 1 Enabled. Use hardware triggering.           */
           uint32_t             :  2;
      __IO uint32_t  TRIGPOL    :  1;               /*!< Trigger Polarity. Selects the polarity of a hardware trigger
                                                         for this channel. 0 Active low - falling edge. Hardware trigger
                                                          is active low or falling edge triggered, based on TRIGTYPE.
                                                          1 Active high - rising edge. Hardware trigger is active high
                                                          or rising edge triggered, based on TRIGTYPE.                         */
      __IO uint32_t  TRIGTYPE   :  1;               /*!< Trigger Type. Selects hardware trigger as edge triggered or
                                                         level triggered. 0 Edge. Hardware trigger is edge triggered.
                                                          Transfers will be initiated and completed, as specified for
                                                          a single trigger. 1 Level. Hardware trigger is level triggered.
                                                          Note that when level triggering without burst (BURSTPOWER =
                                                          0) is selected, only hardware triggers should be used on that
                                                          channel. Transfers continue as long as the trigger level is
                                                          asserted. Once the trigger is de-asserted, the transfer will
                                                          be paused until the tri                                              */
      __IO uint32_t  TRIGBURST  :  1;               /*!< Trigger Burst. Selects whether hardware triggers cause a single
                                                         or burst transfer. 0 Single transfer. Hardware trigger causes
                                                          a single transfer. 1 Burst transfer. When the trigger for this
                                                          channel is set to edge triggered, a hardware trigger causes
                                                          a burst transfer, as defined by BURSTPOWER. When the trigger
                                                          for this channel is set to level triggered, a hardware trigger
                                                          causes transfers to continue as long as the trigger is asserted,
                                                          unless the transfer is complete.                                     */
           uint32_t             :  1;
      __IO uint32_t  BURSTPOWER :  4;               /*!< Burst Power is used in two ways. It always selects the address
                                                         wrap size when SRCBURSTWRAP and/or DSTBURSTWRAP modes are selected
                                                          (see descriptions elsewhere in this register). When the TRIGBURST
                                                          field elsewhere in this register = 1, Burst Power selects how
                                                          many transfers are performed for each DMA trigger. This can
                                                          be used, for example, with peripherals that contain a FIFO that
                                                          can initiate a DMA operation when the FIFO reaches a certain
                                                          level. 0000: Burst size = 1 (2^0). 0001: Burst size = 2 (2^1).
                                                          0010:                                                                */
           uint32_t             :  2;
      __IO uint32_t  SRCBURSTWRAP:  1;              /*!< Source Burst Wrap. When enabled, the source data address for
                                                         the DMA is wrapped , meaning that the source address range for
                                                          each burst will be the same. As an example, this could be used
                                                          to read several sequential registers from a peripheral for each
                                                          DMA burst, reading the same registers again for each burst.
                                                          0 Disabled. Source burst wrapping is not enabled for this DMA
                                                          channel. 1 Enabled. Source burst wrapping is enabled for this
                                                          DMA channel.                                                         */
      __IO uint32_t  DSTBURSTWRAP:  1;              /*!< Destination Burst Wrap. When enabled, the destination data address
                                                         for the DMA is wrapped , meaning that the destination address
                                                          range for each burst will be the same. As an example, this could
                                                          be used to write several sequential registers to a peripheral
                                                          for each DMA burst, writing the same registers again for each
                                                          burst. 0 Disabled. Destination burst wrapping is not enabled
                                                          for this DMA channel. 1 Enabled. Destination burst wrapping
                                                          is enabled for this DMA channel.                                     */
      __IO uint32_t  CHPRIORITY :  3;               /*!< Priority of this channel when multiple DMA requests are pending.
                                                         Eight priority levels are supported: 0x0 = highest priority.
                                                          0x7 = lowest priority.                                               */
    } CFG_b;                                        /*!< BitSize                                                               */
  };
  
  union {
    __I  uint32_t  CTLSTAT;                         /*!< Control and status register for DMA channel x                         */
    
    struct {
      __I  uint32_t  VALIDPENDING:  1;              /*!< Valid pending flag for this channel. This bit is set when a
                                                         1 is written to the corresponding bit in the related SETVALID
                                                          register when CFGVALID = 1 for the same channel. 0 No effect.
                                                          No effect on DMA operation. 1 Valid pending.                         */
           uint32_t             :  1;
      __I  uint32_t  TRIG       :  1;               /*!< Trigger flag. Indicates that the trigger for this channel is
                                                         currently set. This bit is cleared at the end of an entire transfer
                                                          or upon reload when CLRTRIG = 1. 0 Not triggered. The trigger
                                                          for this DMA channel is not set. DMA operations will not be
                                                          carried out. 1 Triggered. The trigger for this DMA channel is
                                                          set. DMA operations will be carried out.                             */
    } CTLSTAT_b;                                    /*!< BitSize                                                               */
  };
  
  union {
    __IO uint32_t  XFERCFG;                         /*!< Transfer configuration register for DMA channel x                     */
    
    struct {
      __IO uint32_t  CFGVALID   :  1;               /*!< Configuration Valid flag. This bit indicates whether the current
                                                         channel descriptor is valid and can potentially be acted upon,
                                                          if all other activation criteria are fulfilled. 0 Not valid.
                                                          The channel descriptor is not considered valid until validated
                                                          by an associated SETVALID0 setting. 1 Valid. The current channel
                                                          descriptor is considered valid.                                      */
      __IO uint32_t  RELOAD     :  1;               /*!< Indicates whether the channel s control structure will be reloaded
                                                         when the current descriptor is exhausted. Reloading allows ping-pong
                                                          and linked transfers. 0 Disabled. Do not reload the channels
                                                          control structure when the current descriptor is exhausted.
                                                          1 Enabled. Reload the channels control structure when the current
                                                          descriptor is exhausted.                                             */
      __IO uint32_t  SWTRIG     :  1;               /*!< Software Trigger. 0 Not set. When written by software, the trigger
                                                         for this channel is not set. A new trigger, as defined by the
                                                          HWTRIGEN, TRIGPOL, and TRIGTYPE will be needed to start the
                                                          channel. 1 Set. When written by software, the trigger for this
                                                          channel is set immediately. This feature should not be used
                                                          with level triggering when TRIGBURST = 0.                            */
      __IO uint32_t  CLRTRIG    :  1;               /*!< Clear Trigger. 0 Not cleared. The trigger is not cleared when
                                                         this descriptor is exhausted. If there is a reload, the next
                                                          descriptor will be started. 1 Cleared. The trigger is cleared
                                                          when this descriptor is exhausted.                                   */
      __IO uint32_t  SETINTA    :  1;               /*!< Set Interrupt flag A for this channel. There is no hardware
                                                         distinction between interrupt A and B. They can be used by software
                                                          to assist with more complex descriptor usage. By convention,
                                                          interrupt A may be used when only one interrupt flag is needed.
                                                          0 No effect. 1 Set. The INTA flag for this channel will be set
                                                          when the current descriptor is exhausted.                            */
      __IO uint32_t  SETINTB    :  1;               /*!< Set Interrupt flag B for this channel. There is no hardware
                                                         distinction between interrupt A and B. They can be used by software
                                                          to assist with more complex descriptor usage. By convention,
                                                          interrupt A may be used when only one interrupt flag is needed.
                                                          0 No effect. 1 Set. The INTB flag for this channel will be set
                                                          when the current descriptor is exhausted.                            */
           uint32_t             :  2;
      __IO uint32_t  WIDTH      :  2;               /*!< Transfer width used for this DMA channel. 0x0 8-bit. 8-bit transfers
                                                         are performed (8-bit source reads and destination writes). 0x1
                                                          16-bit. 6-bit transfers are performed (16-bit source reads and
                                                          destination writes). 0x2 32-bit. 32-bit transfers are performed
                                                          (32-bit source reads and destination writes). 0x3 Reserved.
                                                          Reserved setting, do not use.                                        */
           uint32_t             :  2;
      __IO uint32_t  SRCINC     :  2;               /*!< Determines whether the source address is incremented for each
                                                         DMA transfer. 0x0 No increment. The source address is not incremented
                                                          for each transfer. This is the usual case when the source is
                                                          a peripheral device. 0x1 1 x width. The source address is incremented
                                                          by the amount specified by Width for each transfer. This is
                                                          the usual case when the source is memory. 0x2 2 x width. The
                                                          source address is incremented by 2 times the amount specified
                                                          by Width for each transfer. 0x3 4 x width. The source address
                                                          is                                                                   */
      __IO uint32_t  DSTINC     :  2;               /*!< Determines whether the destination address is incremented for
                                                         each DMA transfer. 0x0 No increment. The destination address
                                                          is not incremented for each transfer. This is the usual case
                                                          when the destination is a peripheral device. 0x1 1 x width.
                                                          The destination address is incremented by the amount specified
                                                          by Width for each transfer. This is the usual case when the
                                                          destination is memory. 0x2 2 x width. The destination address
                                                          is incremented by 2 times the amount specified by Width for
                                                          each transfer. 0x3 4 x                                               */
      __IO uint32_t  XFERCOUNT  : 10;               /*!< Total number of transfers to be performed, minus 1 encoded.
                                                         The number of bytes transferred is: (XFERCOUNT + 1) x data width
                                                          (as defined by the WIDTH field). Remark: The DMA controller
                                                          uses this bit field during transfer to count down. Hence, it
                                                          cannot be used by software to read back the size of the transfer,
                                                          for instance, in an interrupt handler. 0x0 = a total of 1 transfer
                                                          will be performed. 0x1 = a total of 2 transfers will be performed.
                                                          ... 0x3FF = a total of 1,024 transfers will be performed.            */
    } XFERCFG_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RESERVED0;                       /*!< Reserved                                                              */

    struct {
      __IO uint32_t  DUMMYWORD  : 32;               /*!< Reserved. The value read from a reserved bit is not defined.          */
    } RESERVED0_b;                                  /*!< BitSize                                                               */
  };
} u_dma_Channel_Type;


/* ================================================================================ */
/* ================                    u_syscon                    ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component syscon. It is the System Control APB bus interface. More details will follow. (u_syscon)
  */

typedef struct {                                    /*!< u_syscon Structure                                                    */

  union {
    __IO uint32_t  MEMORYREMAP;                     /*!< Memory Remap control register                                         */

    struct {
      __IO uint32_t  MAP        :  2;               /*!< Select the location of the vector table : 0:Vector Table in
                                                         ROM 1:Vector Table in RAM 2:Vector Table in Flash 3:Vector Table
                                                          in Flash                                                             */
      __IO uint32_t  FLASH_REMAP_APP_0:  1;         /*!< Controls remapping of Application 0 flash space 0 : No remapping
                                                         of Application 0 Flash space 1 : Remapping of Application 0
                                                          Flash space                                                          */
      __IO uint32_t  FLASH_REMAP_APP_1:  1;         /*!< Controls remapping of Application 1 flash space 0 : No remapping
                                                         of Application 0 Flash space 1 : Remapping of Application 0
                                                          Flash space                                                          */
      __IO uint32_t  FLASH_APP_0_SIZE:  7;          /*!< Application 0 flash size, in number of 8-KB units. Max allowed
                                                         value is 80 (640 KB of Flash).                                        */
           uint32_t             :  1;
      __IO uint32_t  FLASH_APP_1_SIZE:  7;          /*!< Application 1 flash size, in number of 8-KB units. Max allowed
                                                         value is 80 (640 KB of Flash).                                        */
           uint32_t             :  1;
      __IO uint32_t  QSPI_REMAP_APP_0:  2;          /*!< Address bits to use when QSPI Flash address [19:18] = 0 (256-KB
                                                         unit page).                                                           */
      __IO uint32_t  QSPI_REMAP_APP_1:  2;          /*!< Address bits to use when QSPI Flash address [19:18] = 1 (256-KB
                                                         unit page).                                                           */
      __IO uint32_t  QSPI_REMAP_APP_2:  2;          /*!< Address bits to use when QSPI Flash address [19:18] = 2 (256-KB
                                                         unit page).                                                           */
      __IO uint32_t  QSPI_REMAP_APP_3:  2;          /*!< Address bits to use when QSPI Flash address [19:18] = 3 (256-KB
                                                         unit page).                                                           */
    } MEMORYREMAP_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[3];

  union {
    __IO uint32_t  AHBMATPRIO;                      /*!< AHB Matrix priority control register                                  */

    struct {
      __IO uint32_t  PRI_CM40_ICODE:  2;            /*!< Cortex-M4 0 I-Code bus priority. Should typically be lower than
                                                         PRI_DCODE for best operation.                                         */
      __IO uint32_t  PRI_CM40_DCODE:  2;            /*!< Cortex-M4 0 D-Code bus priority.                                      */
      __IO uint32_t  PRI_CM40_SYS:  2;              /*!< Cortex-M4 0 System bus priority.                                      */
      __IO uint32_t  PRI_DMA    :  2;               /*!< DMA controller priority.                                              */
      __IO uint32_t  PRI_MODEM  :  2;               /*!< MODEM Master priority.                                                */
      __IO uint32_t  PRI_CM41_ICODE:  2;            /*!< Cortex-M4 1 I-Code bus priority. Should typically be lower than
                                                         PRI_DCODE for best operation.                                         */
      __IO uint32_t  PRI_CM41_DCODE:  2;            /*!< Cortex-M4 1 D-Code bus priority.                                      */
      __IO uint32_t  PRI_CM41_SYS:  2;              /*!< Cortex-M4 1 System bus priority.                                      */
      __IO uint32_t  PRI_TPR    :  2;               /*!< Test Point Master bus priority.                                       */
    } AHBMATPRIO_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[3];

  union {
    __IO uint32_t  BUFFERINGAHB2VPB0;               /*!< Buffering of write accesses on Synchronous System configuration
                                                         APB interface                                                         */

    struct {
      __IO uint32_t  SYSCON     :  1;               /*!< Enable buffering of write accesses on Synchronous System configuration
                                                         APB interface. 0 = disable; 1 = Enable.                               */
      __IO uint32_t  FIREWALL   :  1;               /*!< Enable buffering of write accesses on Firewall APB interface.
                                                         0 = disable; 1 = Enable.                                              */
      __IO uint32_t  OTPC       :  1;               /*!< Enable buffering of write accesses on eFUSE controller APB interface.
                                                         0 = disable; 1 = Enable.                                              */
      __IO uint32_t  I2C0       :  1;               /*!< Enable buffering of write accesses on I2C0 APB interface. 0
                                                         = disable; 1 = Enable.                                                */
      __IO uint32_t  I2C1       :  1;               /*!< Enable buffering of write accesses on I2C1 APB interface. 0
                                                         = disable; 1 = Enable.                                                */
      __IO uint32_t  I2C2       :  1;               /*!< Enable buffering of write accesses on I2C2 APB interface. 0
                                                         = disable; 1 = Enable.                                                */
      __IO uint32_t  ISO7816    :  1;               /*!< Enable buffering of write accesses on ISO7816 APB interface.
                                                         0 = disable; 1 = Enable.                                              */
      __IO uint32_t  IR         :  1;               /*!< Enable buffering of write accesses on Infra red APB interface.
                                                         0 = disable; 1 = Enable.                                              */
      __IO uint32_t  CODEPATCH  :  1;               /*!< Enable buffering of write accesses on Code Patch Unit APB interface.
                                                         0 = disable; 1 = Enable.                                              */
      __IO uint32_t  FLASHCTRL  :  1;               /*!< Enable buffering of write accesses on Flash Controller APB interface.
                                                         0 = disable; 1 = Enable.                                              */
      __IO uint32_t  WDT        :  1;               /*!< Enable buffering of write accesses on Watchdog Timer APB interface.
                                                         0 = disable; 1 = Enable.                                              */
      __IO uint32_t  RTC        :  1;               /*!< Enable buffering of write accesses on RTC APB interface. 0 =
                                                         disable; 1 = Enable.                                                  */
      __IO uint32_t  PWM        :  1;               /*!< Enable buffering of write accesses on PWM APB interface. 0 =
                                                         disable; 1 = Enable.                                                  */
      __IO uint32_t  RNG        :  1;               /*!< Enable buffering of write accesses on Random Number Generator
                                                         APB interface. 0 = disable; 1 = Enable.                               */
      __IO uint32_t  PMUX       :  1;               /*!< Enable buffering of write accesses on Peripheral Input Mux APB
                                                         interface. 0 = disable; 1 = Enable.                                   */
      __IO uint32_t  IOCON      :  1;               /*!< Enable buffering of write accesses on IO Configuration APB interface.
                                                         0 = disable; 1 = Enable.                                              */
      __IO uint32_t  GPIOINT    :  1;               /*!< Enable buffering of write accesses on GPIO Int APB interface.
                                                         0 = disable; 1 = Enable.                                              */
      __IO uint32_t  GPIOGLOBALINT:  1;             /*!< Enable buffering of write accesses on GPIO Global Interrupt
                                                         APB interface. 0 = disable; 1 = Enable.                               */
      __IO uint32_t  PMC        :  1;               /*!< Enable buffering of write accesses on Power Management Controller
                                                         APB interface. 0 = disable; 1 = Enable.                               */
      __IO uint32_t  RFP        :  1;               /*!< Enable buffering of write accesses on RFP APB interface. 0 =
                                                         disable; 1 = Enable.                                                  */
      __IO uint32_t  BLE        :  1;               /*!< Enable buffering of write accesses on BLE Modem APB interface.
                                                         0 = disable; 1 = Enable.                                              */
    } BUFFERINGAHB2VPB0_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  BUFFERINGAHB2VPB1;               /*!< Buffering of write accesses on Asynchronous System configuration
                                                         APB interface                                                         */

    struct {
      __IO uint32_t  ASYNCSYSCON:  1;               /*!< Enable buffering of write accesses on Asynchronous System Configuration
                                                         APB interface. 0 = disable; 1 = Enable.                               */
      __IO uint32_t  CT32B0     :  1;               /*!< Enable buffering of write accesses on Counter/Timer0 APB interface.
                                                         0 = disable; 1 = Enable.                                              */
      __IO uint32_t  CT32B1     :  1;               /*!< Enable buffering of write accesses on Counter/Timer1 APB interface.
                                                         0 = disable; 1 = Enable.                                              */
    } BUFFERINGAHB2VPB1_b;                          /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[6];

  union {
    __IO uint32_t  SYSTCKCAL;                       /*!< System tick counter calibration                                       */

    struct {
      __IO uint32_t  CAL        : 24;               /*!< Cortex System tick timer calibration value, readable from Cortex
                                                         SYST_CALIB.TENMS register field. Set this value to be the number
                                                          of clock periods to give 10ms period. SYSTICK freq is a function
                                                          of the mainclk and SYSTICKCLKDIV register. If the tick timer
                                                          is configured to use the System clock directly then this value
                                                          must reflect the 10ms tick count for that clock.                     */
      __IO uint32_t  SKEW       :  1;               /*!< Cortex System tick timer SYST_CALIB.SKEW setting. When 0, the
                                                         value of SYST_CALIB.TENMS field is considered to be precise.
                                                          When 1, the value of TENMS is not considered to be precise.          */
      __IO uint32_t  NOREF      :  1;               /*!< Cortex System tick timer SYST_CALIB.NOREF setting. When 0, a
                                                         separate reference clock is available. When 1, a separate reference
                                                          clock is not available.                                              */
    } SYSTCKCAL_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3;

  union {
    __IO uint32_t  NMISRC;                          /*!< NMI Source Select                                                     */

    struct {
      __IO uint32_t  IRQM40     :  6;               /*!< The number of the interrupt source within the interrupt array
                                                         that acts as the Non-Maskable Interrupt (NMI) for the Cortex-M4
                                                          0, if enabled by NMIENM40. This can also cause the device to
                                                          wakeup from sleep.                                                   */
           uint32_t             :  2;
      __IO uint32_t  IRQM41     :  6;               /*!< The number of the interrupt source within the interrupt array
                                                         that acts as the Non-Maskable Interrupt (NMI) for the Cortex-M4
                                                          1, if enabled by NMIENM41. This can not cause the device to
                                                          wakeup from sleep.                                                   */
           uint32_t             : 16;
      __IO uint32_t  NMIENM41   :  1;               /*!< Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI)
                                                         source selected by IRQM41                                             */
      __IO uint32_t  NMIENM40   :  1;               /*!< Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI)
                                                         source selected by IRQM40                                             */
    } NMISRC_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ASYNCAPBCTRL;                    /*!< Asynchronous APB Control                                              */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< Enables the asynchronous APB bridge and subsystem                     */
    } ASYNCAPBCTRL_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[44];

  union {
    __IO uint32_t  PRESETCTRL0;                     /*!< Peripheral reset control 0                                            */

    struct {
           uint32_t             :  8;
      __IO uint32_t  FLASH_RST  :  1;               /*!< Flash controller reset control.                                       */
           uint32_t             :  1;
      __IO uint32_t  SPIFI_RST  :  1;               /*!< Quad SPI Flash controller reset control.                              */
      __IO uint32_t  MUX_RST    :  1;               /*!< Input Mux reset control.                                              */
      __IO uint32_t  BLE_TIMING_GEN_RST:  1;        /*!< BLE Low Power Control module reset                                    */
      __IO uint32_t  IOCON_RST  :  1;               /*!< I/O controller reset control.                                         */
      __IO uint32_t  GPIO_RST   :  1;               /*!< GPIO reset control.                                                   */
           uint32_t             :  3;
      __IO uint32_t  PINT_RST   :  1;               /*!< Pin interrupt (PINT) reset control.                                   */
      __IO uint32_t  GINT_RST   :  1;               /*!< Group interrupt (PINT) reset control.                                 */
      __IO uint32_t  DMA_RST    :  1;               /*!< DMA reset control.                                                    */
      __IO uint32_t  ISO7816_RST:  1;               /*!< ISO7816 reset control.                                                */
      __IO uint32_t  WWDT_RST   :  1;               /*!< Watchdog Timer reset control.                                         */
      __IO uint32_t  RTC_RST    :  1;               /*!< Real Time Clock (RTC) reset control.                                  */
      __IO uint32_t  ANA_INT_CTRL_RST:  1;          /*!< Analog Modules Interrupt Controller reset control.                    */
      __IO uint32_t  WAKE_UP_TIMERS_RST:  1;        /*!< Wake up Timers reset control. This will clear interrupt status
                                                         flag. However, configuration for wake timers that is in SYSCON
                                                          will not be reset, these should be managed through the SYSCON
                                                          regsiters.                                                           */
      __IO uint32_t  MAILBOX_RST:  1;               /*!< Inter CPU communication Mailbox reset control.                        */
      __IO uint32_t  ADC_RST    :  1;               /*!< ADC reset control.                                                    */
      __IO uint32_t  EFUSE_RST  :  1;               /*!< eFUSE Controller APB bus interface reset                              */
      __IO uint32_t  PVT_RST    :  1;               /*!< PVT Sensors reset control                                             */
    } PRESETCTRL0_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PRESETCTRL1;                     /*!< Peripheral reset control 1                                            */

    struct {
           uint32_t             : 11;
      __IO uint32_t  USART0_RST :  1;               /*!< UART0 reset control.                                                  */
      __IO uint32_t  USART1_RST :  1;               /*!< UART1 reset control.                                                  */
      __IO uint32_t  I2C0_RST   :  1;               /*!< I2C0 reset control.                                                   */
      __IO uint32_t  I2C1_RST   :  1;               /*!< I2C1 reset control.                                                   */
      __IO uint32_t  SPI0_RST   :  1;               /*!< SPI0 reset control.                                                   */
      __IO uint32_t  SPI1_RST   :  1;               /*!< SPI1 reset control.                                                   */
      __IO uint32_t  IR_RST     :  1;               /*!< Infra Red reset control.                                              */
      __IO uint32_t  PWM_RST    :  1;               /*!< PWM reset control.                                                    */
      __IO uint32_t  RNG_RST    :  1;               /*!< Random Number Generator reset control.                                */
      __IO uint32_t  I2C2_RST   :  1;               /*!< I2C2 reset control.                                                   */
      __IO uint32_t  ZIGBEE_RST :  1;               /*!< Zigbee reset control.                                                 */
      __IO uint32_t  BLE_RST    :  1;               /*!< BLE reset control.                                                    */
      __IO uint32_t  MODEM_MASTER_RST:  1;          /*!< MODEM AHB Master Interface reset control                              */
      __IO uint32_t  AES_RST    :  1;               /*!< AES256 reset control.                                                 */
      __IO uint32_t  RFP_RST    :  1;               /*!< RFP (Radio Front End controller) reset control                        */
      __IO uint32_t  DMIC_RST   :  1;               /*!< DMIC Reset control                                                    */
      __IO uint32_t  HASH_RST   :  1;               /*!< HASH reset control                                                    */
      __IO uint32_t  TPR_RST    :  1;               /*!< Test Point Register Interface reset control                           */
    } PRESETCTRL1_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[6];

  union {
    __O  uint32_t  PRESETCTRLSET0;                  /*!< Set bits in PRESETCTRL0                                               */

    struct {
           uint32_t             :  8;
      __O  uint32_t  FLASH_RST_SET:  1;             /*!< Writing one to this register sets the FLASH_RST bit in the PRESETCTRL0
                                                         register                                                              */
           uint32_t             :  1;
      __O  uint32_t  SPIFI_RST_SET:  1;             /*!< Writing one to this register sets the SPIFI_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  MUX_RST_SET:  1;               /*!< Writing one to this register sets the MUX_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  BLE_TIMING_GEN_RST_SET:  1;    /*!< Writing one to this register sets the BLE_TIMING_GEN_RST bit
                                                         in the PRESETCTRL0 register                                           */
      __O  uint32_t  IOCON_RST_SET:  1;             /*!< Writing one to this register sets the IOCON_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  GPIO_RST_SET:  1;              /*!< Writing one to this register sets the GPIO_RST bit in the PRESETCTRL0
                                                         register                                                              */
           uint32_t             :  3;
      __O  uint32_t  PINT_RST_SET:  1;              /*!< Writing one to this register sets the PINT_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  GINT_RST_SET:  1;              /*!< Writing one to this register sets the GINT_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  DMA_RST_SET:  1;               /*!< Writing one to this register sets the DMA_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  ISO7816_RST_SET:  1;           /*!< Writing one to this register sets the ISO7816_RST bit in the
                                                         PRESETCTRL0 register                                                  */
      __O  uint32_t  WWDT_RST_SET:  1;              /*!< Writing one to this register sets the WWDT_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  RTC_RST_SET:  1;               /*!< Writing one to this register sets the RTC_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  ANA_INT_CTRL_RST_SET:  1;      /*!< Writing one to this register sets the ANA_INT_CTRL_RST bit in
                                                         the PRESETCTRL0 register                                              */
      __O  uint32_t  WAKE_UP_TIMERS_RST_SET:  1;    /*!< Writing one to this register sets the WAKE_UP_TIMERS bit in
                                                         the PRESETCTRL0 register                                              */
      __O  uint32_t  MAILBOX_RST_SET:  1;           /*!< Writing one to this register sets the MAILBOX_RST bit in the
                                                         PRESETCTRL0 register                                                  */
      __O  uint32_t  ADC_RST_SET:  1;               /*!< Writing one to this register sets the ADC_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  EFUSE_RST_SET:  1;             /*!< Writing one to this register sets the EFUSE_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  PVT_RST_SET:  1;               /*!< Writing one to this register sets the PVT_RST bit in the PRESETCTRL0
                                                         register                                                              */
    } PRESETCTRLSET0_b;                             /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  PRESETCTRLSET1;                  /*!< Set bits in PRESETCTRL1                                               */

    struct {
           uint32_t             : 11;
      __O  uint32_t  USART0_RST_SET:  1;            /*!< Writing one to this register sets the UART0_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  USART1_RST_SET:  1;            /*!< Writing one to this register sets the UART1_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  I2C0_RST_SET:  1;              /*!< Writing one to this register sets the I2C0_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  I2C1_RST_SET:  1;              /*!< Writing one to this register sets the I2C1_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  SPI0_RST_SET:  1;              /*!< Writing one to this register sets the SPI0_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  SPI1_RST_SET:  1;              /*!< Writing one to this register sets the SPI1_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  IR_RST_SET :  1;               /*!< Writing one to this register sets the IR_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  PWM_RST_SET:  1;               /*!< Writing one to this register sets the PWM_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  RNG_RST_SET:  1;               /*!< Writing one to this register sets the RNG_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  I2C2_RST_SET:  1;              /*!< Writing one to this register sets the I2C2_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  ZIGBEE_RST_SET:  1;            /*!< Writing one to this register sets the ZIGBEE_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  BLE_RST_SET:  1;               /*!< Writing one to this register sets the BLE_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  MODEM_MASTER_RST_SET:  1;      /*!< Writing one to this register sets the MODEM_MASTER_RST bit in
                                                         the PRESETCTRL1 register                                              */
      __O  uint32_t  AES_RST_SET:  1;               /*!< Writing one to this register sets the AES_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  RFP_RST_SET:  1;               /*!< Writing one to this register sets the RFP_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  DMIC_RST_SET:  1;              /*!< Writing one to this register sets the DMIC_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  HASH_RST_SET:  1;              /*!< Writing one to this register sets the HASH_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  TPR_RST_SET:  1;               /*!< Writing one to this register sets the TPR_RST bit in the PRESETCTRL1
                                                         register                                                              */
    } PRESETCTRLSET1_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[6];

  union {
    __O  uint32_t  PRESETCTRLCLR0;                  /*!< Clear bits in PRESETCTRL0                                             */

    struct {
           uint32_t             :  8;
      __O  uint32_t  FLASH_RST_CLR:  1;             /*!< Writing one to this register clears the FLASH_RST bit in the
                                                         PRESETCTRL0 register                                                  */
           uint32_t             :  1;
      __O  uint32_t  SPIFI_RST_CLR:  1;             /*!< Writing one to this register clears the SPIFI_RST bit in the
                                                         PRESETCTRL0 register                                                  */
      __O  uint32_t  MUX_RST_CLR:  1;               /*!< Writing one to this register clears the MUX_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  BLE_TIMING_GEN_RST_CLR:  1;    /*!< Writing one to this register clears the BLE_TIMING_GEN_RST bit
                                                         in the PRESETCTRL0 register                                           */
      __O  uint32_t  IOCON_RST_CLR:  1;             /*!< Writing one to this register clears the IOCON_RST bit in the
                                                         PRESETCTRL0 register                                                  */
      __O  uint32_t  GPIO_RST_CLR:  1;              /*!< Writing one to this register clears the GPIO_RST bit in the
                                                         PRESETCTRL0 register                                                  */
           uint32_t             :  3;
      __O  uint32_t  PINT_RST_CLR:  1;              /*!< Writing one to this register clears the PINT_RST bit in the
                                                         PRESETCTRL0 register                                                  */
      __O  uint32_t  GINT_RST_CLR:  1;              /*!< Writing one to this register clears the GINT_RST bit in the
                                                         PRESETCTRL0 register                                                  */
      __O  uint32_t  DMA_RST_CLR:  1;               /*!< Writing one to this register clears the DMA_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  ISO7816_RST_CLR:  1;           /*!< Writing one to this register clears the ISO7816_RST bit in the
                                                         PRESETCTRL0 register                                                  */
      __O  uint32_t  WWDT_RST_CLR:  1;              /*!< Writing one to this register clears the WWDT_RST bit in the
                                                         PRESETCTRL0 register                                                  */
      __O  uint32_t  RTC_RST_CLR:  1;               /*!< Writing one to this register clears the RTC_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  ANA_INT_CTRL_RST_CLR:  1;      /*!< Writing one to this register clears the ANA_INT_CTRL_RST bit
                                                         in the PRESETCTRL0 register                                           */
      __O  uint32_t  WAKE_UP_TIMERS_RST_CLR:  1;    /*!< Writing one to this register clears the WAKE_UP_TIMERS_RST bit
                                                         in the PRESETCTRL0 register                                           */
      __O  uint32_t  MAILBOX_RST_CLR:  1;           /*!< Writing one to this register clears the MAILBOX_RST bit in the
                                                         PRESETCTRL0 register                                                  */
      __O  uint32_t  ADC_RST_CLR:  1;               /*!< Writing one to this register clears the ADC_RST bit in the PRESETCTRL0
                                                         register                                                              */
      __O  uint32_t  EFUSE_RST_CLR:  1;             /*!< Writing one to this register clears the EFUSE_RST bit in the
                                                         PRESETCTRL0 register                                                  */
      __O  uint32_t  PVT_RST_CLR:  1;               /*!< Writing one to this register clears the PVT_RST bit in the PRESETCTRL0
                                                         register                                                              */
    } PRESETCTRLCLR0_b;                             /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  PRESETCTRLCLR1;                  /*!< Clear bits in PRESETCTRL1                                             */

    struct {
           uint32_t             : 11;
      __O  uint32_t  USART0_RST_CLR:  1;            /*!< Writing one to this register clears the UART0_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  USART1_RST_CLR:  1;            /*!< Writing one to this register clears the UART1_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  I2C0_RST_CLR:  1;              /*!< Writing one to this register clears the I2C0_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  I2C1_RST_CLR:  1;              /*!< Writing one to this register clears the I2C1_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  SPI0_RST_CLR:  1;              /*!< Writing one to this register clears the SPI0_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  SPI1_RST_CLR:  1;              /*!< Writing one to this register clears the SPI1_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  IR_RST_CLR :  1;               /*!< Writing one to this register clears the IR_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  PWM_RST_CLR:  1;               /*!< Writing one to this register clears the PWM_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  RNG_RST_CLR:  1;               /*!< Writing one to this register clears the RNG_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  I2C2_RST_CLR:  1;              /*!< Writing one to this register clears the I2C2_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  ZIGBEE_RST_CLR:  1;            /*!< Writing one to this register clears the ZIGBEE_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  BLE_RST_CLR:  1;               /*!< Writing one to this register clears the BLE_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  MODEM_MASTER_RST_CLR:  1;      /*!< Writing one to this register clears the MODEM_MASTER_RST bit
                                                         in the PRESETCTRL1 register                                           */
      __O  uint32_t  AES_RST_CLR:  1;               /*!< Writing one to this register clears the AES_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  RFP_RST_CLR:  1;               /*!< Writing one to this register clears the RFP_RST bit in the PRESETCTRL1
                                                         register                                                              */
      __O  uint32_t  DMIC_RST_CLR:  1;              /*!< Writing one to this register clears the DMIC_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  HASH_RST_CLR:  1;              /*!< Writing one to this register clears the HASH_RST bit in the
                                                         PRESETCTRL1 register                                                  */
      __O  uint32_t  TPR_RST_CLR:  1;               /*!< Writing one to this register clears the TPR_RST bit in the PRESETCTRL1
                                                         register                                                              */
    } PRESETCTRLCLR1_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7[46];

  union {
    __IO uint32_t  AHBCLKCTRL0;                     /*!< AHB Clock control 0                                                   */

    struct {
           uint32_t             :  1;
      __IO uint32_t  ROM        :  1;               /*!< Enables the clock for the ROM                                         */
           uint32_t             :  1;
      __IO uint32_t  SRAM_CTRL0 :  1;               /*!< Enables the clock for the SRAM Controller 0 (SRAM 0 to SRAM
                                                         5)                                                                    */
      __IO uint32_t  SRAM_CTRL1 :  1;               /*!< Enables the clock for the SRAM Controller 1 (SRAM 6 to SRAM
                                                         7)                                                                    */
           uint32_t             :  3;
      __IO uint32_t  FLASH      :  1;               /*!< Enables the clock for the Flash controller                            */
           uint32_t             :  1;
      __IO uint32_t  SPIFI      :  1;               /*!< Enables the clock for the Quad SPI Flash controller [Note: SPIFI
                                                         IOs need configuring for high drive]                                  */
      __IO uint32_t  MUX        :  1;               /*!< Enables the clock for the Input Mux                                   */
           uint32_t             :  1;
      __IO uint32_t  IOCON      :  1;               /*!< Enables the clock for the I/O controller                              */
      __IO uint32_t  GPIO       :  1;               /*!< Enables the clock for the GPIO                                        */
           uint32_t             :  3;
      __IO uint32_t  PINT       :  1;               /*!< Enables the clock for the Pin interrupt (PINT)                        */
      __IO uint32_t  GINT       :  1;               /*!< Enables the clock for the Group interrupt (GINT)                      */
      __IO uint32_t  DMA        :  1;               /*!< Enables the clock for the DMA                                         */
      __IO uint32_t  ISO7816    :  1;               /*!< Enables the clock for the ISO7816                                     */
      __IO uint32_t  WWDT       :  1;               /*!< Enables the clock for the Watchdog Timer                              */
      __IO uint32_t  RTC        :  1;               /*!< Enables the clock for the RTC                                         */
      __IO uint32_t  ANA_INT_CTRL:  1;              /*!< Enables the clock for the Analog Interrupt Control module (for
                                                         BOD and comparator status and interrupt control)                      */
      __IO uint32_t  WAKE_UP_TIMERS:  1;            /*!< Enables the clock for the Wake up Timers                              */
      __IO uint32_t  MAILBOX    :  1;               /*!< Enables the clock for the Mailbox                                     */
      __IO uint32_t  ADC        :  1;               /*!< Enables the clock for the ADC Controller                              */
      __IO uint32_t  EFUSE      :  1;               /*!< Enables the (APB interface) clock for the EFUSE Controller            */
      __IO uint32_t  PVT        :  1;               /*!< Enables the clock for the PVT Controller                              */
    } AHBCLKCTRL0_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AHBCLKCTRL1;                     /*!< AHB Clock control 1                                                   */

    struct {
           uint32_t             : 11;
      __IO uint32_t  USART0     :  1;               /*!< Enable the clock for the UART0 .                                      */
      __IO uint32_t  USART1     :  1;               /*!< Enable the clock for the UART1 .                                      */
      __IO uint32_t  I2C0       :  1;               /*!< Enable the clock for the I2C0 .                                       */
      __IO uint32_t  I2C1       :  1;               /*!< Enable the clock for the I2C1 .                                       */
      __IO uint32_t  SPI0       :  1;               /*!< Enable the clock for the SPI0 .                                       */
      __IO uint32_t  SPI1       :  1;               /*!< Enable the clock for the SPI1 .                                       */
      __IO uint32_t  IR         :  1;               /*!< Enable the clock for the Infra Red .                                  */
      __IO uint32_t  PWM        :  1;               /*!< Enable the clock for the PWM .                                        */
      __IO uint32_t  RNG        :  1;               /*!< Enable the clock for the Random Number Generator .                    */
      __IO uint32_t  I2C2       :  1;               /*!< Enable the clock for the I2C2 .                                       */
      __IO uint32_t  ZIGBEE     :  1;               /*!< Enable the clock for the Zigbee Modem .                               */
      __IO uint32_t  BLE        :  1;               /*!< Enable the clock for the BLE Modem .                                  */
      __IO uint32_t  MODEM_MASTER:  1;              /*!< Enable the clock for the Modem AHB Master Interface .                 */
      __IO uint32_t  AES        :  1;               /*!< Enable the clock for the AES .                                        */
      __IO uint32_t  RFP        :  1;               /*!< Enable the clock for the RFP (Radio Front End controller)             */
      __IO uint32_t  DMIC       :  1;               /*!< Enable the clock for the DMIC                                         */
      __IO uint32_t  HASH       :  1;               /*!< Enable the clock for the Hash .                                       */
      __IO uint32_t  TPR        :  1;               /*!< Enable the clock for the TPR (Test Point Register)                    */
    } AHBCLKCTRL1_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED8[6];

  union {
    __O  uint32_t  AHBCLKCTRLSET0;                  /*!< Set bits in AHBCLKCTRL0                                               */

    struct {
           uint32_t             :  1;
      __O  uint32_t  ROM_CLK_SET:  1;               /*!< Writing one to this register sets the ROM bit in the AHBCLKCTRL0
                                                         register.                                                             */
           uint32_t             :  1;
      __O  uint32_t  SRAM_CTRL0_CLK_SET:  1;        /*!< Writing one to this register sets the SRAM_CTRL0 bit in the
                                                         AHBCLKCTRL0 register.                                                 */
      __O  uint32_t  SRAM_CTRL1_CLK_SET:  1;        /*!< Writing one to this register sets the SRAM_CTRL1 bit in the
                                                         AHBCLKCTRL0 register.                                                 */
           uint32_t             :  3;
      __O  uint32_t  FLASH_CLK_SET:  1;             /*!< Writing one to this register sets the FLASH bit in the AHBCLKCTRL0
                                                         register.                                                             */
           uint32_t             :  1;
      __O  uint32_t  SPIFI_CLK_SET:  1;             /*!< Writing one to this register sets the SPIFI bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  MUX_CLK_SET:  1;               /*!< Writing one to this register sets the MUX bit in the AHBCLKCTRL0
                                                         register.                                                             */
           uint32_t             :  1;
      __O  uint32_t  IOCON_CLK_SET:  1;             /*!< Writing one to this register sets the IOCON bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  GPIO_CLK_SET:  1;              /*!< Writing one to this register sets the GPIO bit in the AHBCLKCTRL0
                                                         register.                                                             */
           uint32_t             :  3;
      __O  uint32_t  PINT_CLK_SET:  1;              /*!< Writing one to this register sets the PINT bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  GINT_CLK_SET:  1;              /*!< Writing one to this register sets the GINT bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  DMA_CLK_SET:  1;               /*!< Writing one to this register sets the DMA bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  ISO7816_CLK_SET:  1;           /*!< Writing one to this register sets the ISO7816 bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  WWDT_CLK_SET:  1;              /*!< Writing one to this register sets the WWDT bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  RTC_CLK_SET:  1;               /*!< Writing one to this register sets the RTC bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  ANA_INT_CTRL_CLK_SET:  1;      /*!< Writing one to this register sets the ANA_INT_CTRL bit in the
                                                         AHBCLKCTRL0 register.                                                 */
      __O  uint32_t  WAKE_UP_TIMERS_CLK_SET:  1;    /*!< Writing one to this register sets the WAKE_UP_TIMERS bit in
                                                         the AHBCLKCTRL0 register.                                             */
      __O  uint32_t  MAILBOX_CLK_SET:  1;           /*!< Writing one to this register sets the MAILBOX bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  ADC_CLK_SET:  1;               /*!< Writing one to this register sets the ADC bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  EFUSE_CLK_SET:  1;             /*!< Writing one to this register sets the EFUSE bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  PVT_CLK_SET:  1;               /*!< Writing one to this register sets the PVT bit in the AHBCLKCTRL0
                                                         register.                                                             */
    } AHBCLKCTRLSET0_b;                             /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  AHBCLKCTRLSET1;                  /*!< Set bits in AHBCLKCTRL1                                               */

    struct {
           uint32_t             : 11;
      __O  uint32_t  USART0_CLK_SET:  1;            /*!< Writing one to this register sets the UART0 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  USART1_CLK_SET:  1;            /*!< Writing one to this register sets the UART1 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  I2C0_CLK_SET:  1;              /*!< Writing one to this register sets the I2C0 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  I2C1_CLK_SET:  1;              /*!< Writing one to this register sets the I2C1 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  SPI0_CLK_SET:  1;              /*!< Writing one to this register sets the SPI0 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  SPI1_CLK_SET:  1;              /*!< Writing one to this register sets the SPI1 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  IR_CLK_SET :  1;               /*!< Writing one to this register sets the IR bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  PWM_CLK_SET:  1;               /*!< Writing one to this register sets the PWM bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  RNG_CLK_SET:  1;               /*!< Writing one to this register sets the RNG bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  I2C2_CLK_SET:  1;              /*!< Writing one to this register sets the I2C2 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  ZIGBEE_CLK_SET:  1;            /*!< Writing one to this register sets the ZIGBEE bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  BLE_CLK_SET:  1;               /*!< Writing one to this register sets the BLE bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  MODEM_MASTER_CLK_SET:  1;      /*!< Writing one to this register sets the MODEM_MASTER bit in the
                                                         AHBCLKCTRL1 register.                                                 */
      __O  uint32_t  AES_CLK_SET:  1;               /*!< Writing one to this register sets the AES bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  RFP_CLK_SET:  1;               /*!< Writing one to this register sets the RFP bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  DMIC_CLK_SET:  1;              /*!< Writing one to this register sets the DMIC bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  HASH_CLK_SET:  1;              /*!< Writing one to this register sets the HASH bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  TPR_CLK_SET:  1;               /*!< Writing one to this register sets the TPR bit in the AHBCLKCTRL1
                                                         register.                                                             */
    } AHBCLKCTRLSET1_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED9[6];

  union {
    __O  uint32_t  AHBCLKCTRLCLR0;                  /*!< Clear bits in AHBCLKCTRL0                                             */

    struct {
           uint32_t             :  1;
      __O  uint32_t  ROM_CLK_CLR:  1;               /*!< Writing one to this register clears the ROM bit in the AHBCLKCTRL0
                                                         register.                                                             */
           uint32_t             :  1;
      __O  uint32_t  SRAM_CTRL0_CLK_CLR:  1;        /*!< Writing one to this register clears the SRAM_CTRL0 bit in the
                                                         AHBCLKCTRL0 register.                                                 */
      __O  uint32_t  SRAM_CTRL1_CLK_CLR:  1;        /*!< Writing one to this register clears the SRAM_CTRL1 bit in the
                                                         AHBCLKCTRL0 register.                                                 */
           uint32_t             :  3;
      __O  uint32_t  FLASH_CLK_CLR:  1;             /*!< Writing one to this register clears the FLASH bit in the AHBCLKCTRL0
                                                         register.                                                             */
           uint32_t             :  1;
      __O  uint32_t  SPIFI_CLK_CLR:  1;             /*!< Writing one to this register clears the SPIFI bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  MUX_CLK_CLR:  1;               /*!< Writing one to this register clears the MUX bit in the AHBCLKCTRL0
                                                         register.                                                             */
           uint32_t             :  1;
      __O  uint32_t  IOCON_CLK_CLR:  1;             /*!< Writing one to this register clears the IOCON bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  GPIO_CLK_CLR:  1;              /*!< Writing one to this register clears the GPIO bit in the AHBCLKCTRL0
                                                         register.                                                             */
           uint32_t             :  3;
      __O  uint32_t  PINT_CLK_CLR:  1;              /*!< Writing one to this register clears the PINT bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  GINT_CLK_CLR:  1;              /*!< Writing one to this register clears the GINT bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  DMA_CLK_CLR:  1;               /*!< Writing one to this register clears the DMA bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  ISO7816_CLK_CLR:  1;           /*!< Writing one to this register clears the ISO7816 bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  WWDT_CLK_CLR:  1;              /*!< Writing one to this register clears the WWDT bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  RTC_CLK_CLR:  1;               /*!< Writing one to this register clears the RTC bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  ANA_INT_CTRL_CLK_SET:  1;      /*!< Writing one to this register clears the ANA_INT_CTRL bit in
                                                         the AHBCLKCTRL0 register.                                             */
      __O  uint32_t  WAKE_UP_TIMERS_CLK_SET:  1;    /*!< Writing one to this register clears the WAKE_UP_TIMERS bit in
                                                         the AHBCLKCTRL0 register.                                             */
      __O  uint32_t  MAILBOX_CLK_CLR:  1;           /*!< Writing one to this register clears the MAILBOX bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  ADC_CLK_CLR:  1;               /*!< Writing one to this register clears the ADC bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  EFUSE_CLK_CLR:  1;             /*!< Writing one to this register clears the EFUSE bit in the AHBCLKCTRL0
                                                         register.                                                             */
      __O  uint32_t  PVT_CLK_CLR:  1;               /*!< Writing one to this register clears the PVT bit in the AHBCLKCTRL0
                                                         register.                                                             */
    } AHBCLKCTRLCLR0_b;                             /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  AHBCLKCTRLCLR1;                  /*!< Clear bits in AHBCLKCTRL1                                             */

    struct {
           uint32_t             : 11;
      __O  uint32_t  USART0_CLK_CLR:  1;            /*!< Writing one to this register clears the UART0 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  USART1_CLK_CLR:  1;            /*!< Writing one to this register clears the UART1 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  I2C0_CLK_CLR:  1;              /*!< Writing one to this register clears the I2C0 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  I2C1_CLK_CLR:  1;              /*!< Writing one to this register clears the I2C1 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  SPI0_CLK_CLR:  1;              /*!< Writing one to this register clears the SPI0 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  SPI1_CLK_CLR:  1;              /*!< Writing one to this register clears the SPI1 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  IR_CLK_CLR :  1;               /*!< Writing one to this register clears the IR bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  PWM_CLK_CLR:  1;               /*!< Writing one to this register clears the PWM bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  RNG_CLK_CLR:  1;               /*!< Writing one to this register clears the RNG bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  I2C2_CLK_CLR:  1;              /*!< Writing one to this register clears the I2C2 bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  ZIGBEE_CLK_CLR:  1;            /*!< Writing one to this register clears the ZIGBEE bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  BLE_CLK_CLR:  1;               /*!< Writing one to this register clears the BLE bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  MODEM_MASTER_CLK_CLR:  1;      /*!< Writing one to this register clears the MODEM_MASTER bit in
                                                         the AHBCLKCTRL1 register.                                             */
      __O  uint32_t  AES_CLK_CLR:  1;               /*!< Writing one to this register clears the AES bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  RFP_CLK_CLR:  1;               /*!< Writing one to this register clears the RFP bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  DMIC_CLK_CLR:  1;              /*!< Writing one to this register clears the DMIC bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  HASH_CLK_CLR:  1;              /*!< Writing one to this register clears the HASH bit in the AHBCLKCTRL1
                                                         register.                                                             */
      __O  uint32_t  TPR_CLK_CLR:  1;               /*!< Writing one to this register clears the TPR bit in the AHBCLKCTRL1
                                                         register.                                                             */
    } AHBCLKCTRLCLR1_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED10[14];

  union {
    __IO uint32_t  MAINCLKSEL;                      /*!< Main clock source select                                              */

    struct {
      __IO uint32_t  SEL        :  3;               /*!< Main clock clock source selection 000 : FRO_12MHz 001 : OSC32KCLK
                                                         010 : 32MHz XTAL 011 : FRO_32MHz 100 : FRO_48MHz 101 : External_CLK
                                                          (CLKIN) 11X : FRO_1MHz                                               */
    } MAINCLKSEL_b;                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  OSC32CLKSEL;                     /*!< OSC32KCLK and OSC32MCLK clock sources select. Note: this register
                                                         is not locked by CLOCKGENUPDATELOCKOUT                                */

    struct {
      __IO uint32_t  SEL32MHZ   :  1;               /*!< OSC32MCLK clock source selection                                      */
      __IO uint32_t  SEL32KHZ   :  1;               /*!< OSC32KCLK clock source selection                                      */
    } OSC32CLKSEL_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CLKOUTSEL;                       /*!< CLKOUT clock source select                                            */

    struct {
      __IO uint32_t  SEL        :  3;               /*!< CLKOUT clock source selection                                         */
    } CLKOUTSEL_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED11[5];

  union {
    __IO uint32_t  SPIFICLKSEL;                     /*!< SPIFI clock source select                                             */

    struct {
      __IO uint32_t  SEL        :  3;               /*!< SPIFICLK clock source selection                                       */
    } SPIFICLKSEL_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ADCCLKSEL;                       /*!< ADC clock source select                                               */

    struct {
      __IO uint32_t  SEL        :  2;               /*!< ADCCLK clock source selection                                         */
    } ADCCLKSEL_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED12[2];

  union {
    __IO uint32_t  USARTCLKSEL;                     /*!< USART0 & 1 clock source select                                        */

    struct {
      __IO uint32_t  SEL        :  2;               /*!< USARTCLK (USART0 & 1) clock source selection                          */
    } USARTCLKSEL_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  I2CCLKSEL;                       /*!< I2C0 & 1 clock source select                                          */

    struct {
      __IO uint32_t  SEL        :  2;               /*!< I2CCLK (I2C0 & 1) clock source selection                              */
    } I2CCLKSEL_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SPICLKSEL;                       /*!< SPI0 & 1 clock source select                                          */

    struct {
      __IO uint32_t  SEL        :  2;               /*!< SPICLK (SPI0 & 1) clock source selection                              */
    } SPICLKSEL_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  IRCLKSEL;                        /*!< Infra Red clock source select                                         */

    struct {
      __IO uint32_t  SEL        :  2;               /*!< IRCLK (IR Blaster) clock source selection                             */
    } IRCLKSEL_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PWMCLKSEL;                       /*!< PWM clock source select                                               */

    struct {
      __IO uint32_t  SEL        :  2;               /*!< PWMCLK (PWM) clock source selection                                   */
    } PWMCLKSEL_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  WDTCLKSEL;                       /*!< Watchdog Timer clock source select                                    */

    struct {
      __IO uint32_t  SEL        :  2;               /*!< WDTCLK (Watchdog Timer) clock source selection                        */
    } WDTCLKSEL_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED13;

  union {
    __IO uint32_t  MODEMCLKSEL;                     /*!< Zigbee and BLE Modems clock source select                             */

    struct {
      __IO uint32_t  SEL_ZIGBEE :  1;               /*!< Zigbee Modem clock source selection                                   */
      __IO uint32_t  SEL_BLE    :  1;               /*!< BLE 32 MHz clock source selection                                     */
    } MODEMCLKSEL_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED14[6];

  union {
    __IO uint32_t  FRGCLKSEL;                       /*!< Fractional Rate Generator clock source select                         */

    struct {
      __IO uint32_t  SEL        :  2;               /*!< Fractional Rate Generator clock source selection                      */
    } FRGCLKSEL_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DMICCLKSEL;                      /*!< Digital microphone (D-Mic) subsystem clock select                     */

    struct {
      __IO uint32_t  SEL        :  3;               /*!< DMIC clock source selection                                           */
    } DMICCLKSEL_b;                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  WKTCLKSEL;                       /*!< Wake-up Timer clock select                                            */

    struct {
      __IO uint32_t  SEL        :  2;               /*!< Wake-up Timers clock source selection                                 */
    } WKTCLKSEL_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ISO7816CLKSEL;                   /*!< ISO7816 clock source select                                           */

    struct {
      __IO uint32_t  ISO7816CLKSEL: 32;             /*!< ISO7816 clock source select                                           */
    } ISO7816CLKSEL_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED15[2];

  union {
    __IO uint32_t  SYSTICKCLKDIV;                   /*!< SYSTICK clock divider                                                 */

    struct {
      __IO uint32_t  DIV        :  8;               /*!< Clock divider value. 0: Divide by 1. 255: Divide by 256.              */
           uint32_t             : 21;
      __IO uint32_t  RESET      :  1;               /*!< Resets the divider counter. Can be used to make sure a new divider
                                                         value is used right away rather than completing the previous
                                                          count.                                                               */
      __IO uint32_t  HALT       :  1;               /*!< Halts the divider counter. The intent is to allow the divider
                                                         s clock source to be changed without the risk of a glitch at
                                                          the output.                                                          */
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } SYSTICKCLKDIV_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TRACECLKDIV;                     /*!< TRACE clock divider                                                   */

    struct {
      __IO uint32_t  DIV        :  8;               /*!< Clock divider value. 0: Divide by 1. 255: Divide by 256.              */
           uint32_t             : 21;
      __IO uint32_t  RESET      :  1;               /*!< Resets the divider counter. Can be used to make sure a new divider
                                                         value is used right away rather than completing the previous
                                                          count.                                                               */
      __IO uint32_t  HALT       :  1;               /*!< Halts the divider counter. The intent is to allow the divider
                                                         s clock source to be changed without the risk of a glitch at
                                                          the output.                                                          */
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } TRACECLKDIV_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED16[25];

  union {
    __IO uint32_t  WDTCLKDIV;                       /*!< Watchdog Timer clock divider                                          */

    struct {
      __IO uint32_t  DIV        :  8;               /*!< Clock divider value. 0: Divide by 1. 255: Divide by 256.              */
           uint32_t             : 21;
      __IO uint32_t  RESET      :  1;               /*!< Resets the divider counter. Can be used to make sure a new divider
                                                         value is used right away rather than completing the previous
                                                          count.                                                               */
      __IO uint32_t  HALT       :  1;               /*!< Halts the divider counter. The intent is to allow the divider
                                                         s clock source to be changed without the risk of a glitch at
                                                          the output.                                                          */
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } WDTCLKDIV_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED17[2];

  union {
    __IO uint32_t  IRCLKDIV;                        /*!< Infra Red clock divider                                               */

    struct {
      __IO uint32_t  DIV        :  4;               /*!< Clock divider value. 0: Divide by 1. 15: Divide by 16.                */
           uint32_t             : 25;
      __IO uint32_t  RESET      :  1;               /*!< Resets the divider counter. Can be used to make sure a new divider
                                                         value is used right away rather than completing the previous
                                                          count.                                                               */
      __IO uint32_t  HALT       :  1;               /*!< Halts the divider counter. The intent is to allow the divider
                                                         s clock source to be changed without the risk of a glitch at
                                                          the output.                                                          */
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } IRCLKDIV_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED18;

  union {
    __IO uint32_t  AHBCLKDIV;                       /*!< System clock divider                                                  */

    struct {
      __IO uint32_t  DIV        :  8;               /*!< Clock divider value. 0: Divide by 1. 255: Divide by 256.              */
           uint32_t             : 23;
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } AHBCLKDIV_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CLKOUTDIV;                       /*!< CLKOUT clock divider                                                  */

    struct {
      __IO uint32_t  DIV        :  4;               /*!< Clock divider value. 0: Divide by 1. 15: Divide by 16.                */
           uint32_t             : 25;
      __IO uint32_t  RESET      :  1;               /*!< Resets the divider counter. Can be used to make sure a new divider
                                                         value is used right away rather than completing the previous
                                                          count.                                                               */
      __IO uint32_t  HALT       :  1;               /*!< Halts the divider counter. The intent is to allow the divider
                                                         s clock source to be changed without the risk of a glitch at
                                                          the output.                                                          */
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } CLKOUTDIV_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED19[2];

  union {
    __IO uint32_t  SPIFICLKDIV;                     /*!< SPIFI clock divider                                                   */

    struct {
      __IO uint32_t  DIV        :  2;               /*!< Clock divider value. 0: Divide by 1. 3: Divide by 4.                  */
           uint32_t             : 27;
      __IO uint32_t  RESET      :  1;               /*!< Resets the divider counter. Can be used to make sure a new divider
                                                         value is used right away rather than completing the previous
                                                          count.                                                               */
      __IO uint32_t  HALT       :  1;               /*!< Halts the divider counter. The intent is to allow the divider
                                                         s clock source to be changed without the risk of a glitch at
                                                          the output.                                                          */
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } SPIFICLKDIV_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ADCCLKDIV;                       /*!< ADC clock divider                                                     */

    struct {
      __IO uint32_t  DIV        :  3;               /*!< Clock divider value. 0: Divide by 1. 7: Divide by 8.                  */
           uint32_t             : 26;
      __IO uint32_t  RESET      :  1;               /*!< Resets the divider counter. Can be used to make sure a new divider
                                                         value is used right away rather than completing the previous
                                                          count.                                                               */
      __IO uint32_t  HALT       :  1;               /*!< Halts the divider counter. The intent is to allow the divider
                                                         s clock source to be changed without the risk of a glitch at
                                                          the output.                                                          */
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } ADCCLKDIV_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RTCCLKDIV;                       /*!< Real Time Clock divider (1 KHz clock generation)                      */

    struct {
      __IO uint32_t  DIV        :  5;               /*!< Clock divider value. 0: Divide by 1. 31: Divide by 32.                */
           uint32_t             : 24;
      __IO uint32_t  RESET      :  1;               /*!< Resets the divider counter. Can be used to make sure a new divider
                                                         value is used right away rather than completing the previous
                                                          count.                                                               */
      __IO uint32_t  HALT       :  1;               /*!< Halts the divider counter. The intent is to allow the divider
                                                         s clock source to be changed without the risk of a glitch at
                                                          the output.                                                          */
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } RTCCLKDIV_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED20;

  union {
    __IO uint32_t  FRGCTRL;                         /*!< Fractional rate divider                                               */

    struct {
      __IO uint32_t  DIV        :  8;               /*!< Denominator of the fractional divider. DIV is equal to the programmed
                                                         value +1. Always set to 0xFF to use with the fractional baud
                                                          rate generator : fout = fin / (1 + mult/(div+1))                     */
      __IO uint32_t  MULT       :  8;               /*!< Numerator of the fractional divider. MULT is equal to the programmed
                                                         value                                                                 */
    } FRGCTRL_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED21;

  union {
    __IO uint32_t  DMICCLKDIV;                      /*!< DMIC clock divider                                                    */

    struct {
      __IO uint32_t  DIV        :  8;               /*!< Clock divider value. 0: Divide by 1. 255: Divide by 256.              */
           uint32_t             : 21;
      __IO uint32_t  RESET      :  1;               /*!< Resets the divider counter. Can be used to make sure a new divider
                                                         value is used right away rather than completing the previous
                                                          count.                                                               */
      __IO uint32_t  HALT       :  1;               /*!< Halts the divider counter. The intent is to allow the divider
                                                         s clock source to be changed without the risk of a glitch at
                                                          the output.                                                          */
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } DMICCLKDIV_b;                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RTC1HZCLKDIV;                    /*!< Real Time Clock divider (1 Hz clock generation. The divider
                                                         is fixed to 32768)                                                    */

    struct {
           uint32_t             : 29;
      __IO uint32_t  RESET      :  1;               /*!< Resets the divider counter. Can be used to make sure a new divider
                                                         value is used right away rather than completing the previous
                                                          count.                                                               */
      __IO uint32_t  HALT       :  1;               /*!< Halts the divider counter. The intent is to allow the divider
                                                         s clock source to be changed without the risk of a glitch at
                                                          the output.                                                          */
      __I  uint32_t  REQFLAG    :  1;               /*!< Divider status flag. Set when a change is made to the divider
                                                         value, cleared when the change is complete.                           */
    } RTC1HZCLKDIV_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED22[19];

  union {
    __IO uint32_t  CLOCKGENUPDATELOCKOUT;           /*!< Control clock configuration registers access (like xxxDIV, xxxSEL)    */

    struct {
      __IO uint32_t  LOCK       :  1;               /*!< Disable clock control registers access (like xxxDIV, xxxSEL).
                                                         Affects all clock control registers except OSC32CLKSEL.               */
    } CLOCKGENUPDATELOCKOUT_b;                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED23[101];

  union {
    __IO uint32_t  EFUSECLKCTRL;                    /*!< eFUSE controller clock control                                        */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< Enable the eFUSE controller IP clock (FRO 12 MHz)                     */
    } EFUSECLKCTRL_b;                               /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RNGCTRL;                         /*!< Random Number Generator triggering                                    */

    struct {
      __IO uint32_t  START      :  1;               /*!< Trigger the generation of a random number (Low to high transition)    */
    } RNGCTRL_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RNGCLKCTRL;                      /*!< Random Number Generator Clocks control                                */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< Enable the clocks used by the Random Number Generator (RNG)           */
    } RNGCLKCTRL_b;                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SRAMCTRL;                        /*!< All SRAMs common control signals                                      */

    struct {
      __IO uint32_t  SMB        :  2;               /*!< Light Sleep Bias                                                      */
      __IO uint32_t  RM         :  3;               /*!< Read Margin control settings                                          */
      __IO uint32_t  WM         :  3;               /*!< Write Margin control settings                                         */
      __IO uint32_t  WRME       :  1;               /*!< Write read margin enable                                              */
      __IO uint32_t  RAM        :  4;               /*!< Read assist bias settings                                             */
      __IO uint32_t  WAM        :  2;               /*!< Write assist bias settings                                            */
      __IO uint32_t  RAEN       :  1;               /*!< Read assist enable                                                    */
      __IO uint32_t  WAEN       :  1;               /*!< Write assist enable                                                   */
      __IO uint32_t  STBP       :  1;               /*!< Self time bypass                                                      */
      __IO uint32_t  VSBTEST    :  1;               /*!< Source biasing testability                                            */
    } SRAMCTRL_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SRAMCTRL0;                       /*!< SRAM0 to SRAM7 controls                                               */

    struct {
      __IO uint32_t  SRAM0_LS   :  1;               /*!< SRAM0 Light Sleep mode                                                */
      __IO uint32_t  SRAM0_DSB  :  1;               /*!< SRAM0 Deep sleep mode                                                 */
      __IO uint32_t  SRAM0_DSBDEL:  1;              /*!< SRAM0 Deep sleep delayed                                              */
      __IO uint32_t  SRAM0_LSDEL:  1;               /*!< SRAM0 Sleep mode disable                                              */
      __IO uint32_t  SRAM1_LS   :  1;               /*!< SRAM1 Light Sleep mode                                                */
      __IO uint32_t  SRAM1_DSB  :  1;               /*!< SRAM1 Deep sleep mode                                                 */
      __IO uint32_t  SRAM1_DSBDEL:  1;              /*!< SRAM1 Deep sleep delayed                                              */
      __IO uint32_t  SRAM1_LSDEL:  1;               /*!< SRAM1 Sleep mode disable                                              */
      __IO uint32_t  SRAM2_LS   :  1;               /*!< SRAM2 Light Sleep mode                                                */
      __IO uint32_t  SRAM2_DSB  :  1;               /*!< SRAM2 Deep sleep mode                                                 */
      __IO uint32_t  SRAM2_DSBDEL:  1;              /*!< SRAM2 Deep sleep delayed                                              */
      __IO uint32_t  SRAM2_LSDEL:  1;               /*!< SRAM2 Sleep mode disable                                              */
      __IO uint32_t  SRAM3_LS   :  1;               /*!< SRAM3 Light Sleep mode                                                */
      __IO uint32_t  SRAM3_DSB  :  1;               /*!< SRAM3 Deep sleep mode                                                 */
      __IO uint32_t  SRAM3_DSBDEL:  1;              /*!< SRAM3 Deep sleep delayed                                              */
      __IO uint32_t  SRAM3_LSDEL:  1;               /*!< SRAM3 Sleep mode disable                                              */
      __IO uint32_t  SRAM4_LS   :  1;               /*!< SRAM4 Light Sleep mode                                                */
      __IO uint32_t  SRAM4_DSB  :  1;               /*!< SRAM4 Deep sleep mode                                                 */
      __IO uint32_t  SRAM4_DSBDEL:  1;              /*!< SRAM4 Deep sleep delayed                                              */
      __IO uint32_t  SRAM4_LSDEL:  1;               /*!< SRAM4 Sleep mode disable                                              */
      __IO uint32_t  SRAM5_LS   :  1;               /*!< SRAM5 Light Sleep mode                                                */
      __IO uint32_t  SRAM5_DSB  :  1;               /*!< SRAM5 Deep sleep mode                                                 */
      __IO uint32_t  SRAM5_DSBDEL:  1;              /*!< SRAM5 Deep sleep delayed                                              */
      __IO uint32_t  SRAM5_LSDEL:  1;               /*!< SRAM5 Sleep mode disable                                              */
      __IO uint32_t  SRAM6_LS   :  1;               /*!< SRAM6 Light Sleep mode                                                */
      __IO uint32_t  SRAM6_DSB  :  1;               /*!< SRAM6 Deep sleep mode                                                 */
      __IO uint32_t  SRAM6_DSBDEL:  1;              /*!< SRAM6 Deep sleep delayed                                              */
      __IO uint32_t  SRAM6_LSDEL:  1;               /*!< SRAM6 Sleep mode disable                                              */
      __IO uint32_t  SRAM7_LS   :  1;               /*!< SRAM7 Light Sleep mode                                                */
      __IO uint32_t  SRAM7_DSB  :  1;               /*!< SRAM7 Deep sleep mode                                                 */
      __IO uint32_t  SRAM7_DSBDEL:  1;              /*!< SRAM7 Deep sleep delayed                                              */
      __IO uint32_t  SRAM7_LSDEL:  1;               /*!< SRAM7 Sleep mode disable                                              */
    } SRAMCTRL0_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SRAMCTRL1;                       /*!< SRAM8 to SRAM11 controls                                              */

    struct {
      __IO uint32_t  SRAM8_LS   :  1;               /*!< SRAM8 Light Sleep mode                                                */
      __IO uint32_t  SRAM8_DSB  :  1;               /*!< SRAM8 Deep sleep mode                                                 */
      __IO uint32_t  SRAM8_DSBDEL:  1;              /*!< SRAM8 Deep sleep delayed                                              */
      __IO uint32_t  SRAM8_LSDEL:  1;               /*!< SRAM8 Sleep mode disable                                              */
      __IO uint32_t  SRAM9_LS   :  1;               /*!< SRAM9 Light Sleep mode                                                */
      __IO uint32_t  SRAM9_DSB  :  1;               /*!< SRAM9 Deep sleep mode                                                 */
      __IO uint32_t  SRAM9_DSBDEL:  1;              /*!< SRAM9 Deep sleep delayed                                              */
      __IO uint32_t  SRAM9_LSDEL:  1;               /*!< SRAM9 Sleep mode disable                                              */
      __IO uint32_t  SRAM10_LS  :  1;               /*!< SRAM10 Light Sleep mode                                               */
      __IO uint32_t  SRAM10_DSB :  1;               /*!< SRAM10 Deep sleep mode                                                */
      __IO uint32_t  SRAM10_DSBDEL:  1;             /*!< SRAM10 Deep sleep delayed                                             */
      __IO uint32_t  SRAM10_LSDEL:  1;              /*!< SRAM10 Sleep mode disable                                             */
      __IO uint32_t  SRAM11_LS  :  1;               /*!< SRAM11 Light Sleep mode                                               */
      __IO uint32_t  SRAM11_DSB :  1;               /*!< SRAM11 Deep sleep mode                                                */
      __IO uint32_t  SRAM11_DSBDEL:  1;             /*!< SRAM11 Deep sleep delayed                                             */
      __IO uint32_t  SRAM11_LSDEL:  1;              /*!< SRAM11 Sleep mode disable                                             */
    } SRAMCTRL1_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED24[7];

  union {
    __IO uint32_t  ROMCTRL;                         /*!< ROM control                                                           */

    struct {
      __IO uint32_t  SDB        :  1;               /*!< Shutdown pin (active low)                                             */
      __IO uint32_t  SDBDEL     :  1;               /*!< Shutdown delayed pin (active low)                                     */
      __IO uint32_t  RME        :  1;               /*!< Read Margin Enable                                                    */
      __IO uint32_t  RM         :  4;               /*!< read margin control setting                                           */
      __IO uint32_t  PM         :  2;               /*!< precharge margin control setting                                      */
      __IO uint32_t  VDDMIN     :  1;               /*!< VDDMIN enable setting                                                 */
    } ROMCTRL_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MODEMCTRL;                       /*!< MoDem (Zigbee and Bluetooth) control                                  */

    struct {
      __IO uint32_t  BLE_LP_SLEEP_TRIG:  1;         /*!< (null)                                                                */
      __IO uint32_t  BLE_FREQ_SEL:  1;              /*!< 1 = 16 MHz ; 0 = 8 MHz                                                */
      __IO uint32_t  BLE_DP_DIV_EN:  1;             /*!< 1 = enable Frequency Divider ; 0 = Disable                            */
      __IO uint32_t  BLE_CLK32M_SEL:  1;            /*!< 1 = 16 MHz ; 0 = 32 MHz                                               */
      __IO uint32_t  BLE_AHB_DIV0:  1;              /*!< AHB _CLK = SYS_CLK / (AHB_DIV + 1)                                    */
      __IO uint32_t  BLE_AHB_DIV1:  1;              /*!< (null)                                                                */
      __IO uint32_t  BLE_HCLK_BLE_EN:  1;           /*!< 1 = enable the hclk                                                   */
      __IO uint32_t  BLE_PHASE_MATCH_1:  1;         /*!< (null)                                                                */
      __IO uint32_t  BLE_ISO_ENABLE:  1;            /*!< Control isolation of BLE Low Power Control module (RW_BLE_TIMING_GEN_LP),
                                                         namely :deep_sleep_stat, wakeup_req_trig Must not be set before
                                                          MODEMSTATUS.BLE_LL_CLK_STATUS is high ('1') 0 : isolation is
                                                          disable 1 : isolation is enable                                      */
      __IO uint32_t  BLE_LP_OSC32K_EN:  1;          /*!< 1 = enable the Ble Low power wake up counter clock enable             */
    } MODEMCTRL_b;                                  /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  MODEMSTATUS;                     /*!< MoDem (Zigbee and Bluetooth) status                                   */

    struct {
      __I  uint32_t  BLE_LL_CLK_STATUS:  1;         /*!< 1 = BLE IP in deep sleep ; 0 BLE IP active                            */
      __I  uint32_t  BLE_LP_OSC_EN:  1;             /*!< Enable Oscillator / Xtal that drives the RF, active high              */
      __I  uint32_t  BLE_LP_RADIO_EN:  1;           /*!< Enable Radio, active high                                             */
    } MODEMSTATUS_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  XTAL32KCAP;                      /*!< XTAL 32 KHz oscillator Capacitor test                                 */

    struct {
      __IO uint32_t  XO_OSC_CAP_IN:  7;             /*!< Tune cap in Xi                                                        */
      __IO uint32_t  XO_OSC_CAP_OUT:  7;            /*!< Tune cap in Xo                                                        */
    } XTAL32KCAP_b;                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  XTAL32MCTRL;                     /*!< XTAL 32 MHz oscillator control register                               */

    struct {
      __IO uint32_t  DEACTIVATE_PMC_CTRL:  1;       /*!< eFuse bit XTAL32MSTART_ENA will enable XTAL whenever the device
                                                         is active; this control bit can deactivate this. 0: Enable XTAL
                                                          32 MHz controls coming from PMC. 1: Disable XTAL 32 MHz controls
                                                          coming from PMC.                                                     */
      __IO uint32_t  DEACTIVATE_BLE_CTRL:  1;       /*!< In order to have XTAL ready for BLE after a low power cycle
                                                         the XTAL must be started early by the BLE low power module;
                                                          this can be deactivated. 0: Enable XTAL 32 MHz controls coming
                                                          from BLE Low Power Control module. 1: Disable XTAL 32 MHz controls
                                                          coming from BLE Low Power Control module.                            */
    } XTAL32MCTRL_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED25[41];

  union {
    __IO uint32_t  STARTER0;                        /*!< Start logic 0 wake-up enable register. Enable an interrupt for
                                                         wake-up from deep-sleep mode. Some bits can also control wake-up
                                                          from powerdown mode                                                  */

    struct {
      __IO uint32_t  WDT_BOD    :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep and Powerdown.                                  */
      __IO uint32_t  DMA        :  1;               /*!< DMA Operation in Deep-Sleep and Powerdown not supported. Leave
                                                         set to 0.                                                             */
      __IO uint32_t  GINT       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  IRBLASTER  :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PINT0      :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PINT1      :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PINT2      :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PINT3      :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  SPIFI      :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  TIMER0     :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  TIMER1     :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  USART0     :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep and Powerdown.                                  */
      __IO uint32_t  USART1     :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  I2C0       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep and Powerdown.                                  */
      __IO uint32_t  I2C1       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  SPI0       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep and Powerdown.                                  */
      __IO uint32_t  SPI1       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM0       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM1       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM2       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM3       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM4       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM5       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM6       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM7       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM8       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM9       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  PWM10      :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  I2C2       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  RTC        :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep and Powerdown.                                  */
      __IO uint32_t  NFCTAG     :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  MAILBOX    :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
    } STARTER0_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STARTER1;                        /*!< Start logic 1 wake-up enable register. Enable an interrupt for
                                                         wake-up from deep-sleep mode. Some bits can also control wake-up
                                                          from powerdown mode                                                  */

    struct {
      __IO uint32_t  ADC_SEQA   :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  ADC_SEQB   :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  ADC_THCMP_OVR:  1;             /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  DMIC       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  HWVAD      :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  BLE_DP     :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  BLE_DP0    :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  BLE_DP1    :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  BLE_DP2    :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  BLE_LL_ALL :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  ZIGBEE_MAC :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  ZIGBEE_MODEM:  1;              /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  RFP_TMU    :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  RFP_AGC    :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  ISO7816    :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep.                                                */
      __IO uint32_t  ANA_COMP   :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep and Powerdown.                                  */
      __IO uint32_t  WAKE_UP_TIMER0:  1;            /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep and Powerdown.                                  */
      __IO uint32_t  WAKE_UP_TIMER1:  1;            /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep and Powerdown.                                  */
           uint32_t             :  4;
      __IO uint32_t  BLE_WAKE_UP_TIMER:  1;         /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep and Powerdown.                                  */
      __IO uint32_t  BLE_OSC_EN :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Valid from Deep-Sleep and Powerdown. Used as early wake-up trigger
                                                          to allow 32M XTAL to be started and ready for BLE timeslot           */
           uint32_t             :  7;
      __IO uint32_t  GPIO       :  1;               /*!< interrupt wake-up. 0 = Wake-up disabled. 1 = Wake-up enabled.
                                                         Set this bit to allow GPIO or NTAG_INT to cause a wake-up in
                                                          Deep-Sleep and Power-down mode.                                      */
    } STARTER1_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED26[6];

  union {
    __O  uint32_t  STARTERSET0;                     /*!< Set bits in STARTER0                                                  */

    struct {
      __O  uint32_t  WDT_BOD_SET:  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  DMA_SET    :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  GINT_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  IRBLASTER_SET:  1;             /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PINT0_SET  :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PINT1_SET  :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PINT2_SET  :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PINT3_SET  :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  SPIFI_SET  :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  TIMER0_SET :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  TIMER1_SET :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  USART0_SET :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  USART1_SET :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  I2C0_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  I2C1_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  SPI0_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  SPI1_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM0_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM1_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM2_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM3_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM4_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM5_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM6_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM7_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM8_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM9_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM10_SET  :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  I2C2_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  RTC_SET    :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  NFCTAG_SET :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  MAILBOX_SET:  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER0 register                                                 */
    } STARTERSET0_b;                                /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  STARTERSET1;                     /*!< Set bits in STARTER1                                                  */

    struct {
      __O  uint32_t  ADC_SEQA_SET:  1;              /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ADC_SEQB_SET:  1;              /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ADC_THCMP_OVR_SET:  1;         /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  DMIC_SET   :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  HWVAD_SET  :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  BLE_DP_SET :  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  BLE_DP0_SET:  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  BLE_DP1_SET:  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  BLE_DP2_SET:  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  BLE_LL_ALL_SET:  1;            /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ZIGBEE_MAC_SET:  1;            /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ZIGBEE_MODEM_SET:  1;          /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  RFP_TMU_SET:  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  RFP_AGC_SET:  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ISO7816_SET:  1;               /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ANA_COMP_SET:  1;              /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  WAKE_UP_TIMER0_SET:  1;        /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  WAKE_UP_TIMER1_SET:  1;        /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
           uint32_t             :  4;
      __O  uint32_t  BLE_WAKE_UP_TIMER_SET:  1;     /*!< Writing ones to this register sets the corresponding bit in
                                                         the STARTER1 register                                                 */
    } STARTERSET1_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED27[6];

  union {
    __O  uint32_t  STARTERCLR0;                     /*!< Clear bits in STARTER0                                                */

    struct {
      __O  uint32_t  WDT_BOD_CLR:  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  DMA_CLR    :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  GINT_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  IRBLASTER_CLR:  1;             /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PINT0_CLR  :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PINT1_CLR  :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PINT2_CLR  :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PINT3_CLR  :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  SPIFI_CLR  :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  TIMER0_CLR :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  TIMER1_CLR :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  USART0_CLR :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  USART1_CLR :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  I2C0_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  I2C1_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  SPI0_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  SPI1_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM0_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM1_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM2_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM3_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM4_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM5_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM6_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM7_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM8_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM9_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  PWM10_CLR  :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  I2C2_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  RTC_CLR    :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  NFCTAG_CLR :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
      __O  uint32_t  MAILBOX_CLR:  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER0 register                                                 */
    } STARTERCLR0_b;                                /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  STARTERCLR1;                     /*!< Clear bits in STARTER1                                                */

    struct {
      __O  uint32_t  ADC_SEQA_CLR:  1;              /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ADC_SEQB_CLR:  1;              /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ADC_THCMP_OVR_CLR:  1;         /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  DMIC_CLR   :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  HWVAD_CLR  :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  BLE_DP_CLR :  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  BLE_DP0_CLR:  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  BLE_DP1_CLR:  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  BLE_DP2_CLR:  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  BLE_LL_ALL_CLR:  1;            /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ZIGBEE_MAC_CLR:  1;            /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ZIGBEE_MODEM_CLR:  1;          /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  RFP_TMU_CLR:  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  RFP_AGC_CLR:  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ISO7816_CLR:  1;               /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  ANA_COMP_CLR:  1;              /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  WAKE_UP_TIMER0_CLR:  1;        /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
      __O  uint32_t  WAKE_UP_TIMER1_CLR:  1;        /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
           uint32_t             :  4;
      __O  uint32_t  BLE_WAKE_UP_TIMER_CLR:  1;     /*!< Writing ones to this register clears the corresponding bit in
                                                         the STARTER1 register                                                 */
    } STARTERCLR1_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED28[16];

  union {
    __IO uint32_t  RETENTIONCTRL;                   /*!< I/O retention control register                                        */

    struct {
      __IO uint32_t  IOCLAMP    :  1;               /*!< Global control of activation of I/O clamps (note that each I/O
                                                         clamp must be enable/disable individually in IOCON module).
                                                          Useful in power down mode. 0: I/O clamp is disable 1: I/O clamp
                                                          is enable                                                            */
    } RETENTIONCTRL_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  POWERDOWNSAFETY;                 /*!< Override some powerdown control signals (for debug purposes)          */

    struct {
      __IO uint32_t  OVERRIDEFRO:  1;               /*!< Overrides the fro_is_dead' signal in Sleepcon module, in case
                                                         this doesn't work on silicon.                                         */
    } POWERDOWNSAFETY_b;                            /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MAINCLKSAFETY;                   /*!< Delay from main_clk enable from sleep controller to start of
                                                         AHB and ASYNC_VPB clocks                                              */

    struct {
      __IO uint32_t  MAIN_CLK_SAFETY_DEL: 16;       /*!< When sleep control enables enables main clock to system AHB
                                                         and system_async_vpb clocks the hardware can delay this enable
                                                          using this value, for up up 0xFFFF main clock cycles                 */
    } MAINCLKSAFETY_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED29[27];

  union {
    __IO uint32_t  HARDWARESLEEP;                   /*!< NOT SUPPORTED - Do Not Use. Hardware Sleep control (used to
                                                         postpone power down modes in case an interrupt is pending when
                                                          the processor request deepsleep)                                     */

    struct {
      __IO uint32_t  FORCED     :  1;               /*!< Forces postponing of power down modes (should be used for test
                                                         purposes only): 0: Disable 1: Enable                                  */
      __IO uint32_t  PERIPHERALS:  1;               /*!< Controls postponing of power down modes in case the following
                                                         interrupts are pending: USART0, USART1, SPI0, SPI1, I2C0, I2C1
                                                          0 : Disable 1 : Enable                                               */
      __IO uint32_t  DMIC       :  1;               /*!< Controls postponing of power down modes in case the following
                                                         interrupts are pending: DMIC FIFO 0 Wake up, DMIC FIFO 1 Wake
                                                          up 0 : Disable 1 : Enable                                            */
      __IO uint32_t  SDMA       :  1;               /*!< Controls postponing of power down modes in case the following
                                                         interrupts are pending: System DMA 0 : Disable 1 : Enable             */
      __IO uint32_t  NFCTAG     :  1;               /*!< Controls postponing of power down modes in case the following
                                                         interrupts are pending: I2C2, NFC Tag interrupt 0 : Disable
                                                          1 : Enable                                                           */
      __IO uint32_t  BLEOSC     :  1;               /*!< Controls postponing of power down modes in case the following
                                                         interrupts are pending: BLE Oscillator Enable interrupt 0 :
                                                          Disable 1 : Enable                                                   */
    } HARDWARESLEEP_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED30[31];

  union {
    __IO uint32_t  CPUCTRL;                         /*!< CPU Control for multiple processors                                   */

    struct {
      __IO uint32_t  MASTERCPU  :  1;               /*!< Indicates which CPU is considered the master. This is set as
                                                         Cortex-M4 0 as the master after any IC reset. The master CPU
                                                          cannot have its clock turned off via the related CM4nCLKEN bit
                                                          or be reset via the related CM4xRSTEN in this register. The
                                                          slave CPU stays reset until activated by the master CPU. 0 :
                                                          CM4 0. Cortex-M4 0 is the master CPU. 1 : CM4 1. Cortex-M4 1
                                                          is the master CPU.                                                   */
           uint32_t             :  1;
      __IO uint32_t  CM40CLKEN  :  1;               /*!< Cortex-M4 0 clock enable. 0 : Disabled. The Cortex-M4 0 clock
                                                         is not enabled. 1 : Enabled. The Cortex-M4 0 clock is enabled.        */
      __IO uint32_t  CM41CLKEN  :  1;               /*!< Cortex-M4 1 clock enable. 0 : Disabled. The Cortex-M4 1 clock
                                                         is not enabled. 1 : Enabled. The Cortex-M4 1 clock is enabled.        */
      __IO uint32_t  CM40RSTEN  :  1;               /*!< Cortex-M4 0 reset. 0 : Disabled. The Cortex-M4 0 is not being
                                                         reset. 1 : Enabled. The Cortex-M4 0 is being reset.                   */
      __IO uint32_t  CM41RSTEN  :  1;               /*!< Cortex-M4 1 reset. 0 : Disabled. The Cortex-M4 1 is not being
                                                         reset. 1 : Enabled. The Cortex-M4 1 is being reset.                   */
      __IO uint32_t  POWERCPU   :  1;               /*!< Identifies the owner of reduced power mode control: which CPU
                                                         can cause the device to enter deep-sleep and Deep Power-down
                                                          modes. 0 : CM4 0. Cortex-M4 0 is the owner of reduced power
                                                          mode control. 1 : CM4 1. Cortex-M4 1 is the owner of reduced
                                                          power mode control.                                                  */
      __IO uint32_t  WAKEUPEVENT:  1;               /*!< Identifies the owner of reduced power mode control: which CPU
                                                         can cause the device to enter deep-sleep and Deep Power-down
                                                          modes. 0 : Both processors receive the 'wake-up event' from
                                                          the Sleep Controller. 1 : Only the owner of reduced power mode
                                                          receives the 'wake-up event' from the Sleep Controller.              */
      __IO uint32_t  CM40SYSRESETEN:  1;            /*!< Controls ARM System Reset requests from Cortex-M4 0. 0 : ARM
                                                         System Reset request from Cortex-M4 0 is disable. 1 : ARM System
                                                          Reset request from Cortex-M4 0 is enable.                            */
      __IO uint32_t  CM41SYSRESETEN:  1;            /*!< Controls ARM System Reset requests from Cortex-M4 1. 0 : ARM
                                                         System Reset request from Cortex-M4 1 is disable. 1 : ARM System
                                                          Reset request from Cortex-M4 1 is enable.                            */
           uint32_t             :  5;
      __IO uint32_t  RESERVED1  :  1;               /*!< Reserved. Must be written as a 1                                      */
      __IO uint32_t  RESERVEDC0C4: 16;              /*!< Must be written as 0xC0C4 for the write to have an effect.            */
    } CPUCTRL_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CPBOOT;                          /*!< Coprocessor Boot Address                                              */

    struct {
      __IO uint32_t  CPBOOT     : 32;               /*!< Coprocessor Boot Address                                              */
    } CPBOOT_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CPSTACK;                         /*!< Coprocessor Stack Address                                             */

    struct {
      __IO uint32_t  CPSTACK    : 32;               /*!< Coprocessor Stack Address                                             */
    } CPSTACK_b;                                    /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  CPSTAT;                          /*!< CPU Status                                                            */

    struct {
      __I  uint32_t  CM40SLEEPING:  1;              /*!< When 1, the Cortex-M4 0 CPU is sleeping                               */
      __I  uint32_t  CM41SLEEPING:  1;              /*!< When 1, the Cortex-M4 1 CPU is sleeping                               */
      __I  uint32_t  CM40LOCKUP :  1;               /*!< When 1, the Cortex-M4 0 CPU is in lockup.                             */
      __I  uint32_t  CM41LOCKUP :  1;               /*!< When 1, the Cortex-M4 1 CPU is in lockup.                             */
    } CPSTAT_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED31[60];

  union {
    __I  uint32_t  GPIOSECIN;                       /*!< GPIO Secure IN : Reading these registers returns the current
                                                         state of the pins read, regardless of direction.                      */

    struct {
      __I  uint32_t  GPIOSECIN  : 32;               /*!< GPIO Secure IN : Reading these registers returns the current
                                                         state of the pins read, regardless of direction.                      */
    } GPIOSECIN_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  GPIOSECOUT;                      /*!< GPIO Secure OUT : Pin output state, when the pin is configured
                                                         as output.                                                            */

    struct {
      __IO uint32_t  GPIOSECOUT : 32;               /*!< GPIO Secure OUT : Pin output state, when the pin is configured
                                                         as output.                                                            */
    } GPIOSECOUT_b;                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  GPIOSECDIR;                      /*!< GPIO Secure Direction : Direction register for configuring the
                                                         pins as inputs or outputs.                                            */

    struct {
      __IO uint32_t  GPIOSECDIR : 32;               /*!< GPIO Secure Direction : Direction register for configuring the
                                                         pins as inputs or outputs.                                            */
    } GPIOSECDIR_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED32[61];

  union {
    __IO uint32_t  ANACTRL_CTRL;                    /*!< Analog Interrupt control register. Requires AHBCLKCTRL0.ANA_INT_CTRL
                                                         to be set.                                                            */

    struct {
      __IO uint32_t  COMPINTRLVL:  1;               /*!< Analog Comparator interrupt type: 0 : Analog Comparator interrupt
                                                         is edge sensitive 1 : Analog Comparator interrupt is level sensitive  */
      __IO uint32_t  COMPINTRPOL:  2;               /*!< Analog Comparator interrupt Polarity: When COMPINTRLVL = 0 (edge
                                                         sensitive) 00 : rising edge 01 : falling edge 10 : both edges
                                                          (rising and falling) 11 : both edges (rising and falling) When
                                                          COMPINTRLVL = 1 (level sensitive) 00 : Low level ('0') 01 :
                                                          Low level ('0') 10 : High level ('1') 11 : High level ('1')          */
    } ANACTRL_CTRL_b;                               /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  ANACTRL_VAL;                     /*!< Analog modules (BOD and Analog Comparator) outputs current values
                                                         (BOD 'Power OK' and Analog comparator out). Requires AHBCLKCTRL0.ANA_INT_C
                                                         TRL to be set.                                                        */

    struct {
      __I  uint32_t  BODVBAT    :  1;               /*!< BOD VBAT Status : 0 = Power not OK ; 1 = Power OK                     */
      __I  uint32_t  BODMEM     :  1;               /*!< BOD Memories Status : 0 = Power not OK ; 1 = Power OK                 */
      __I  uint32_t  BODCORE    :  1;               /*!< BOD Core Digital Status : 0 = Power not OK ; 1 = Power OK             */
      __I  uint32_t  ANACOMP    :  1;               /*!< Analog comparator Status : 0 = Comparator in 0 < in 1 ; 1 =
                                                         Comparator in 0 > in 1.                                               */
      __I  uint32_t  BODVBATHIGH:  1;               /*!< Not(BODV BAT). Added here just to keep coherency with other
                                                         registers                                                             */
    } ANACTRL_VAL_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANACTRL_STAT;                    /*!< Analog modules (BOD and Analog Comparator) interrupt status.
                                                         Requires AHBCLKCTRL0.ANA_INT_CTRL to be set.                          */

    struct {
      __IO uint32_t  BODVBAT    :  1;               /*!< BOD VBAT Interrupt status. 0 = No interrupt pending. 1 = Interrupt
                                                         pending. Write 1 to clear.                                            */
      __IO uint32_t  BODMEM     :  1;               /*!< BOD Memories Interrupt status. 0 = No interrupt pending. 1 =
                                                         Interrupt pending. Write 1 to clear.                                  */
      __IO uint32_t  BODCORE    :  1;               /*!< BOD Core Digital Interrupt status. 0 = No interrupt pending.
                                                         1 = Interrupt pending. Write 1 to clear.                              */
      __IO uint32_t  ANACOMP    :  1;               /*!< Analog comparator Interrupt status. 0 = No interrupt pending.
                                                         1 = Interrupt pending. Write 1 to clear.                              */
      __IO uint32_t  BODVBATHIGH:  1;               /*!< NOT(BOD VBAT) interrupt status. Will be set when BOD VBAT goes
                                                         high                                                                  */
    } ANACTRL_STAT_b;                               /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANACTRL_INTENSET;                /*!< Analog modules (BOD and Analog Comparator) Interrupt Enable
                                                         Read and Set register. Requires AHBCLKCTRL0.ANA_INT_CTRL to
                                                          be set.                                                              */

    struct {
      __IO uint32_t  BODVBAT    :  1;               /*!< BOD VBAT Interrupt Enable Read and Set register                       */
      __IO uint32_t  BODMEM     :  1;               /*!< BOD Memories Interrupt Enable Read and Set register                   */
      __IO uint32_t  BODCORE    :  1;               /*!< BOD Core Digital Interrupt Enable Read and Set register               */
      __IO uint32_t  ANACOMP    :  1;               /*!< Analog comparator Interrupt Enable Read and Set register              */
      __IO uint32_t  BODVBATHIGH:  1;               /*!< NOT(BOD VBAT) Interrupt Enable Read and Set register                  */
    } ANACTRL_INTENSET_b;                           /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  ANACTRL_INTENCLR;                /*!< Analog modules (BOD and Analog Comparator) Interrupt Enable
                                                         Clear register. Requires AHBCLKCTRL0.ANA_INT_CTRL to be set.          */

    struct {
      __O  uint32_t  BODVBAT    :  1;               /*!< BOD VBAT Interrupt Enable Clear register                              */
      __O  uint32_t  BODMEM     :  1;               /*!< BOD Memories Interrupt Enable Clear register                          */
      __O  uint32_t  BODCORE    :  1;               /*!< BOD Core Digital Interrupt Enable Clear register                      */
      __O  uint32_t  ANACOMP    :  1;               /*!< Analog comparator Interrupt Enable Clear register                     */
      __O  uint32_t  BODVBATHIGH:  1;               /*!< NOT(BOD VBAT) Interrupt Enable Clear register                         */
    } ANACTRL_INTENCLR_b;                           /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  ANACTRL_INTSTAT;                 /*!< Analog modules (BOD and Analog Comparator) Interrupt Status
                                                         register (masked with interrupt enable). Requires AHBCLKCTRL0.ANA_INT_CTRL
                                                          to be set.                                                           */

    struct {
      __I  uint32_t  BODVBAT    :  1;               /*!< BOD VBAT Interrupt (after interrupt mask). 0 = No interrupt
                                                         pending. 1 = Interrupt pending. Only set when BODVBAT is enable
                                                          in INTENSET                                                          */
      __I  uint32_t  BODMEM     :  1;               /*!< BOD Memories Interrupt (after interrupt mask). 0 = No interrupt
                                                         pending. 1 = Interrupt pending. Only set when BODMEM is enable
                                                          in INTENSET                                                          */
      __I  uint32_t  BODCORE    :  1;               /*!< BOD Core Digital Interrupt (after interrupt mask). 0 = No interrupt
                                                         pending. 1 = Interrupt pending. Only set when BODCORE is enable
                                                          in INTENSET                                                          */
      __I  uint32_t  ANACOMP    :  1;               /*!< Analog comparator Interrupt (after interrupt mask). 0 = No interrupt
                                                         pending. 1 = Interrupt pending. Only set when ANACOMP is enable
                                                          in INTENSET                                                          */
      __I  uint32_t  BODVBATHIGH:  1;               /*!< NOT(BOD VBAT) Interrupt (after interrupt mask). 0 = No interrupt
                                                         pending. 1 = Interrupt pending. Only set when BODVBATHIGH is
                                                          enable in INTENSET                                                   */
    } ANACTRL_INTSTAT_b;                            /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CLOCK_CTRL;                      /*!< Various system clock controls : Flash clock (48 MHz) control,
                                                         clocks to Frequency Measures                                          */

    struct {
      __IO uint32_t  FLASH48MHZ_ENA:  1;            /*!< Enable Flash 48 MHz clock 0 = Disabled 1 = Enabled                    */
      __IO uint32_t  XTAL32MHZ_FREQM_ENA:  1;       /*!< Enable XTAL32MHz clock for Frequency Measure module. 0 = Disabled
                                                         1 = Enabled                                                           */
      __IO uint32_t  FRO1MHZ_FREQM_ENA:  1;         /*!< Enable FRO 1MHz clock for Frequency Measure module. 0 = Disabled
                                                         1 = Enabled                                                           */
    } CLOCK_CTRL_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED33;

  union {
    __IO uint32_t  WKT_CTRL;                        /*!< wake-up timers control                                                */

    struct {
      __IO uint32_t  WKT0_ENA   :  1;               /*!< Enable wake-up timer 0 0 = Disabled 1 = Enabled (counter is
                                                         running)                                                              */
      __IO uint32_t  WKT1_ENA   :  1;               /*!< Enable wake-up timer 1 0 = Disabled 1 = Enabled (counter is
                                                         running)                                                              */
      __IO uint32_t  WKT0_CLK_ENA:  1;              /*!< Enable wake-up timer 0 clock 0 = Disabled 1 = Enabled                 */
      __IO uint32_t  WKT1_CLK_ENA:  1;              /*!< Enable wake-up timer 1 clock 0 = Disabled 1 = Enabled                 */
    } WKT_CTRL_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  WKT_LOAD_WKT0_LSB;               /*!< wake-up timer 0 reload value least significant bits ([31:0]).         */

    struct {
      __IO uint32_t  WKT0_LOAD_LSB: 32;             /*!< Wake-up timer 0 reload value, least significant bits ([31:0]).
                                                         Write when timer is not enabled                                       */
    } WKT_LOAD_WKT0_LSB_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  WKT_LOAD_WKT0_MSB;               /*!< wake-up timer 0 reload value most significant bits ([8:0]).           */

    struct {
      __IO uint32_t  WKT0_LOAD_MSB:  9;             /*!< Wake-up timer 0 reload value, most significant bits ([8:0]).
                                                         Write when timer is not enabled                                       */
    } WKT_LOAD_WKT0_MSB_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  WKT_LOAD_WKT1;                   /*!< wake-up timer 1 reload value.                                         */

    struct {
      __IO uint32_t  WKT1_LOAD  : 28;               /*!< Wake-up timer 1 reload value. Write when timer is not enabled         */
    } WKT_LOAD_WKT1_b;                              /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  WKT_VAL_WKT0_LSB;                /*!< wake-up timer 0 current value least significant bits ([31:0]).
                                                         WARNING : reading not reliable: read this register several times
                                                          until you get a stable value.                                        */

    struct {
      __I  uint32_t  WKT0_VAL_LSB: 32;              /*!< Wake-up timer 0 value, least significant bits ([31:0]). Reread
                                                         until stable value seen.                                              */
    } WKT_VAL_WKT0_LSB_b;                           /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  WKT_VAL_WKT0_MSB;                /*!< wake-up timer 0 current value most significant bits ([8:0]).
                                                         WARNING : reading not reliable: read this register several times
                                                          until you get a stable value.                                        */

    struct {
      __I  uint32_t  WKT0_VAL_MSB:  9;              /*!< Wake-up timer 0 value, most significant bits ([8:0]). Reread
                                                         until stable value seen.                                              */
    } WKT_VAL_WKT0_MSB_b;                           /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  WKT_VAL_WKT1;                    /*!< wake-up timer 1 current value. WARNING : reading not reliable:
                                                         read this register several times until you get a stable value.        */

    struct {
      __I  uint32_t  WKT1_VAL   : 28;               /*!< Wake-up timer 1 value. Reread until stable value seen.                */
    } WKT_VAL_WKT1_b;                               /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  WKT_STAT;                        /*!< wake-up timers status                                                 */

    struct {
      __IO uint32_t  WKT0_TIMEOUT:  1;              /*!< Status timer 0 : 0 = timeout not reached ; 1 = timeout reached.
                                                         Write 1 to clear.                                                     */
      __IO uint32_t  WKT1_TIMEOUT:  1;              /*!< Status timer 1 : 0 = timeout not reached ; 1 = timeout reached.
                                                         Write 1 to clear.                                                     */
      __I  uint32_t  WKT0_RUNNING:  1;              /*!< Status timer 0 : 0 = not running ; 1 = running                        */
      __I  uint32_t  WKT1_RUNNING:  1;              /*!< Status timer 1 : 0 = not running ; 1 = running                        */
    } WKT_STAT_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  WKT_INTENSET;                    /*!< Interrupt Enable Read and Set register                                */

    struct {
      __IO uint32_t  WKT0_TIMEOUT:  1;              /*!< Timer 0 Interrupt Enable Read and Set register                        */
      __IO uint32_t  WKT1_TIMEOUT:  1;              /*!< Timer 1 Interrupt Enable Read and Set register                        */
    } WKT_INTENSET_b;                               /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  WKT_INTENCLR;                    /*!< Interrupt Enable Clear register                                       */

    struct {
      __O  uint32_t  WKT0_TIMEOUT:  1;              /*!< Interrupt Enable Clear register                                       */
      __O  uint32_t  WKT1_TIMEOUT:  1;              /*!< Interrupt Enable Clear register                                       */
    } WKT_INTENCLR_b;                               /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  WKT_INTSTAT;                     /*!< Interrupt Status register                                             */

    struct {
      __I  uint32_t  WKT0_TIMEOUT:  1;              /*!< Timer 0 Interrupt. 0 = No interrupt pending. 1 = Interrupt pending.
                                                         Only set when WKT0_TIMEOUT is enable in INTENSET                      */
      __I  uint32_t  WKT1_TIMEOUT:  1;              /*!< Timer 1 Interrupt. 0 = No interrupt pending. 1 = Interrupt pending.
                                                         Only set when WKT1_TIMEOUT is enable in INTENSET                      */
    } WKT_INTSTAT_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED34[238];

  union {
    __IO uint32_t  AUTOCLKGATEOVERRIDE;             /*!< Control automatic clock gating                                        */

    struct {
      __IO uint32_t  ROM        :  1;               /*!< Override automatic clock gating of ROM controller. 0 = disable.
                                                         1 = enable/always clock                                               */
      __IO uint32_t  SRAM_CTRL0 :  1;               /*!< Override automatic clock gating of SRAM controller 0. 0 = disable.
                                                         1 = enable/always clock                                               */
      __IO uint32_t  SRAM_CTRL1 :  1;               /*!< Override automatic clock gating of SRAM controller 1. 0 = disable.
                                                         1 = enable/always clock                                               */
           uint32_t             :  2;
      __IO uint32_t  SYNC_APB   :  1;               /*!< Override automatic clock gating of synchronous bridge controller.
                                                         0 = disable. 1 = enable/always clock                                  */
      __IO uint32_t  ASYNC_APB  :  1;               /*!< Override automatic clock gating of asynchronous bridge controller.
                                                         0 = disable. 1 = enable/always clock                                  */
           uint32_t             :  6;
      __IO uint32_t  SDMA       :  1;               /*!< Override automatic clock gating of DMA controller. 0 = disable.
                                                         1 = enable/always clock                                               */
           uint32_t             :  1;
      __IO uint32_t  SYSCON     :  1;               /*!< Override automatic clock gating of synchronous system controller
                                                         registers bank. 0 = disable. 1 = enable/always clock                  */
      __O  uint32_t  ENABLEUPDATE: 16;              /*!< The value 0xC0DE must be written for AUTOCLKGATEOVERRIDE registers
                                                         fields updates to have effect.                                        */
    } AUTOCLKGATEOVERRIDE_b;                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  GPIOPSYNC;                       /*!< Enable bypass of the first stage of synchonization inside GPIO_INT
                                                         module.                                                               */

    struct {
      __IO uint32_t  PSYNC      :  1;               /*!< Enable bypass of the first stage of synchonization inside GPIO_INT
                                                         module.                                                               */
    } GPIOPSYNC_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED35[5];

  union {
    __IO uint32_t  INVERTMAINCLK;                   /*!< Invert Main clock                                                     */

    struct {
      __IO uint32_t  INVERT     :  1;               /*!< Invert main_clock (AHB system clock). This inversion should
                                                         only be done for functional ATE patterns when each clock divider
                                                          or clock gate is disabled.                                           */
    } INVERTMAINCLK_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED36[99];

  union {
    __I  uint32_t  DIEID;                           /*!< Chip revision ID & Number                                             */

    struct {
      __I  uint32_t  REV_ID     :  4;               /*!< Chip Revision ID                                                      */
      __I  uint32_t  MCO_NUM_IN_DIE_ID: 20;         /*!< Chip Number (The JN518x SLDI name will be sRE211-A. 's' for
                                                         Global foundry.)                                                      */
    } DIEID_b;                                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED37[8];

  union {
    __IO uint32_t  CPUCFG;                          /*!< CPUs configuration register. Can only be updated if CONFIGLOCKOUT.LOCK=0.
                                                         Do not disable both processors.                                       */

    struct {
      __IO uint32_t  DEFAULT    :  1;               /*!< Default CPU Master. During a write this bit is only valid only
                                                         when both processors are enabled, otherwise this will be set
                                                          to the enabled processor to prevent having a disabled processor
                                                          as the master. 0 : CM4 0 is is default CPU master 1 : CM4 1
                                                          is the default CPU master It is recommended to leave CPU 0 as
                                                          the master processor.                                                */
      __IO uint32_t  CM40ENABLE :  1;               /*!< Enable CM4 0 0 : CM4 0 is disable (Processor in reset) 1 : CM4
                                                         0 is enable                                                           */
      __IO uint32_t  CM41ENABLE :  1;               /*!< Enable CM4 1 0 : CM4 1 is disable (Processor in reset) 1 : CM4
                                                         1 is enable                                                           */
    } CPUCFG_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED38[3];

  union {
    __IO uint32_t  CONFIGLOCKOUT;                   /*!< Disable write access to CPUDFG                                        */

    struct {
      __IO uint32_t  LOCK       :  1;               /*!< Disable write access to CPUCFG. Once set can not be cleared           */
    } CONFIGLOCKOUT_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED39[2];

  union {
    __O  uint32_t  CODESECURITYPROT;                /*!< Security code to allow test access via SWD/JTAG. Reset with
                                                         POR, SW reset or BOD                                                  */

    struct {
      __O  uint32_t  SEC_CODE   : 32;               /*!< Security code to allow test access via SWD/JTAG. Write once
                                                         register, value 0x87654321 enables the access. Any other value
                                                          disables access and locks the mode.                                  */
    } CODESECURITYPROT_b;                           /*!< BitSize                                                               */
  };
} u_syscon_Type;


/* ================================================================================ */
/* ================                     u_otpc                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component otpc It is an eFUSE OTP (One Time Programmable memory) controller with APB bus interface. More details will follow. (u_otpc)
  */

typedef struct {                                    /*!< u_otpc Structure                                                      */

  union {
    __IO uint32_t  ADDR;                            /*!< Address register for reading/writing the E-Fuse OTP                   */

    struct {
      __IO uint32_t  ADDR       : 12;               /*!< Address of OTP value to be read                                       */
    } ADDR_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;

  union {
    __O  uint32_t  READ;                            /*!< Register for reading the E-Fuse OTP.                                  */

    struct {
      __O  uint32_t  READ       :  1;               /*!< When 1 is written, the OTP is read.                                   */
           uint32_t             : 15;
      __O  uint32_t  SEQ        : 16;               /*!< Read unlock sequence: only when 0x7F12 is written is the APB
                                                         commnad accepted. Write unlock sequence [Not supported]: only
                                                          when 0x3A8D is written, the APB command is accepted.                 */
    } READ_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RWIDTH;                          /*!< Register for configuring the read width of the E-Fuse OTP.            */

    struct {
      __IO uint32_t  OPCFG      :  2;               /*!< Not supported - all reads 16bits (Output width configuration).        */
    } RWIDTH_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  HV_REQ;                          /*!< Register for requesting the high voltage (FSOURCE) for the E-Fuse
                                                         OTP.                                                                  */

    struct {
      __IO uint32_t  PMC_REQ    :  1;               /*!< High voltage request. Setting is directly applied to the op_pmc_hv_request
                                                         output line.                                                          */
      __IO uint32_t  PAD_REQ    :  1;               /*!< High voltage request. Setting is directly applied to the op_pad_hv_request
                                                         output line.                                                          */
           uint32_t             : 14;
      __O  uint32_t  SEQ        : 16;               /*!< High voltage unlock sequence: only when 0xB9A5 is written, the
                                                         APB command is accepted.                                              */
    } HV_REQ_b;                                     /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  RDATA;                           /*!< Register for the OTP read back data.                                  */

    struct {
      __I  uint32_t  DATA       : 16;               /*!< Read back data from the E-Fuse OTP. Access to the AES key will
                                                         be blocked if E-Fuse OTP data bit AESR is set.                        */
           uint32_t             : 15;
      __I  uint32_t  VALID      :  1;               /*!< Valid bit. This bit should be cleared when a Read command has
                                                         been given and should be set when the sequencer has successfully
                                                          captured the E-Fuse OTP data.                                        */
    } RDATA_b;                                      /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  AES;                             /*!< Register for reading the AES key.                                     */

    struct {
      __O  uint32_t  KEY        :  1;               /*!< Set to 0. [Two keys are not supported hence can not use this
                                                         to select key to use]                                                 */
           uint32_t             : 15;
      __O  uint32_t  SEQ        : 16;               /*!< AES read unlock sequence: only when 0x9F21 is written, the APB
                                                         command is accepted. Key will be transferred from E-Fuse OTP
                                                          and output to AES block. This occurs even if AES key read access
                                                          is blocked.                                                          */
    } AES_b;                                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1;

  union {
    __I  uint32_t  SECURITY;                        /*!< Register for reading the security status.                             */

    struct {
      __I  uint32_t  VALID      :  1;               /*!< When 1, an AES key has successfully been loaded to the PMC.
                                                         When 0, no AES key has been successfully loaded or the operation
                                                          is still on-going.                                                   */
      __I  uint32_t  MODE       :  1;               /*!< Reads as 0 [Two keys are not supported hence does not indicate
                                                         key in use]                                                           */
    } SECURITY_b;                                   /*!< BitSize                                                               */
  };
} u_otpc_Type;


/* ================================================================================ */
/* ================                     u0_i2c                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component i2c It is an Inter IC with APB bus interface. More details will follow. (u0_i2c)
  */

typedef struct {                                    /*!< u0_i2c Structure                                                      */

  union {
    __IO uint32_t  CFG;                             /*!< Configuration for shared functions.                                   */

    struct {
      __IO uint32_t  MSTEN      :  1;               /*!< Master Enable. When disabled, configurations settings for the
                                                         Master function are not changed, but the Master function is
                                                          internally reset.                                                    */
      __IO uint32_t  SLVEN      :  1;               /*!< Slave Enable. When disabled, configurations settings for the
                                                         Slave function are not changed, but the Slave function is internally
                                                          reset.                                                               */
      __IO uint32_t  MONEN      :  1;               /*!< Monitor Enable. When disabled, configurations settings for the
                                                         Monitor function are not changed, but the Monitor function is
                                                          internally reset.                                                    */
      __IO uint32_t  TIMEOUT    :  1;               /*!< I2C bus Time-out Enable. When disabled, the time-out function
                                                         is internally reset.                                                  */
      __IO uint32_t  MONCLKSTR  :  1;               /*!< Monitor function Clock Stretching.                                    */
      __IO uint32_t  HSCAPABLE  :  1;               /*!< High-speed mode Capable enable. Since High Speed mode alters
                                                         the way I2C pins drive and filter, as well as the timing for
                                                          certain I2C signalling, enabling High-speed mode applies to
                                                          all functions: master, slave, and monitor.                           */
    } CFG_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STAT;                            /*!< Status register for Master, Slave, and Monitor functions.             */

    struct {
      __I  uint32_t  MSTPENDING :  1;               /*!< Master Pending. Indicates that the Master is waiting to continue
                                                         communication on the I2C-bus (pending) or is idle. When the
                                                          master is pending, the MSTSTATE bits indicate what type of software
                                                          service if any the master expects. This flag will cause an interrupt
                                                          when set if, enabled via the INTENSET register. The MSTPENDING
                                                          flag is not set when the DMA is handling an event (if the MSTDMA
                                                          bit in the MSTCTL register is set). If the master is in the
                                                          idle state, and no communication is needed, mask this interru        */
      __I  uint32_t  MSTSTATE   :  3;               /*!< Master State code. The master state code reflects the master
                                                         state when the MSTPENDING bit is set, that is the master is
                                                          pending or in the idle state. Each value of this field indicates
                                                          a specific required service for the Master function. All other
                                                          values are reserved.                                                 */
      __IO uint32_t  MSTARBLOSS :  1;               /*!< Master Arbitration Loss flag. This flag can be cleared by software
                                                         writing a 1 to this bit. It is also cleared automatically a
                                                          1 is written to MSTCONTINUE.                                         */
           uint32_t             :  1;
      __IO uint32_t  MSTSTSTPERR:  1;               /*!< Master Start/Stop Error flag. This flag can be cleared by software
                                                         writing a 1 to this bit. It is also cleared automatically a
                                                          1 is written to MSTCONTINUE.                                         */
           uint32_t             :  1;
      __I  uint32_t  SLVPENDING :  1;               /*!< Slave Pending. Indicates that the Slave function is waiting
                                                         to continue communication on the I2C-bus and needs software
                                                          service. This flag will cause an interrupt when set if enabled
                                                          via INTENSET. The SLVPENDING flag is not set when the DMA is
                                                          handling an event (if the SLVDMA bit in the SLVCTL register
                                                          is set). The SLVPENDING flag is read-only and is automatically
                                                          cleared when a 1 is written to the SLVCONTINUE bit in the SLVCTL
                                                          register. The point in time when SlvPending is set depends on
                                                          whether the I2C i                                                    */
      __I  uint32_t  SLVSTATE   :  2;               /*!< Slave State code. Each value of this field indicates a specific
                                                         required service for the Slave function. All other values are
                                                          reserved. See Table 393 for state values and actions. Remark:
                                                          note that the occurrence of some states and how they are handled
                                                          are affected by DMA mode and Automatic Operation modes.              */
      __I  uint32_t  SLVNOTSTR  :  1;               /*!< Slave Not Stretching. Indicates when the slave function is stretching
                                                         the I2C clock. This is needed in order to gracefully invoke
                                                          Deep Sleep or Power-down modes during slave operation. This
                                                          read-only flag reflects the slave function status in real time.      */
      __I  uint32_t  SLVIDX     :  2;               /*!< Slave address match Index. This field is valid when the I2C
                                                         slave function has been selected by receiving an address that
                                                          matches one of the slave addresses defined by any enabled slave
                                                          address registers, and provides an identification of the address
                                                          that was matched. It is possible that more than one address
                                                          could be matched, but only one match can be reported here.           */
      __IO uint32_t  SLVSEL     :  1;               /*!< Slave selected flag. SLVSEL is set after an address match when
                                                         software tells the Slave function to acknowledge the address,
                                                          or when the address has been automatically acknowledged. It
                                                          is cleared when another address cycle presents an address that
                                                          does not match an enabled address on the Slave function, when
                                                          slave software decides to NACK a matched address, when there
                                                          is a Stop detected on the bus, when the master NACKs slave data,
                                                          and in some combinations of Automatic Operation. SLVSEL is not
                                                          cleared if s                                                         */
      __IO uint32_t  SLVDESEL   :  1;               /*!< Slave Deselected flag. This flag will cause an interrupt when
                                                         set if enabled via INTENSET. This flag can be cleared by writing
                                                          a 1 to this bit.                                                     */
      __I  uint32_t  MONRDY     :  1;               /*!< Monitor Ready. This flag is cleared when the MONRXDAT register
                                                         is read.                                                              */
      __IO uint32_t  MONOV      :  1;               /*!< Monitor Overflow flag.                                                */
      __I  uint32_t  MONACTIVE  :  1;               /*!< Monitor Active flag. Indicates when the Monitor function considers
                                                         the I2C bus to be active. Active is defined here as when some
                                                          Master is on the bus: a bus Start has occurred more recently
                                                          than a bus Stop.                                                     */
      __IO uint32_t  MONIDLE    :  1;               /*!< Monitor Idle flag. This flag is set when the Monitor function
                                                         sees the I2C bus change from active to inactive. This can be
                                                          used by software to decide when to process data accumulated
                                                          by the Monitor function. This flag will cause an interrupt when
                                                          set if enabled via the INTENSET register. The flag can be cleared
                                                          by writing a 1 to this bit.                                          */
           uint32_t             :  4;
      __IO uint32_t  EVENTTIMEOUT:  1;              /*!< Event Time-out Interrupt flag. Indicates when the time between
                                                         events has been longer than the time specified by the TIMEOUT
                                                          register. Events include Start, Stop, and clock edges. The flag
                                                          is cleared by writing a 1 to this bit. No time-out is created
                                                          when the I2C-bus is idle.                                            */
      __IO uint32_t  SCLTIMEOUT :  1;               /*!< SCL Time-out Interrupt flag. Indicates when SCL has remained
                                                         low longer than the time specific by the TIMEOUT register. The
                                                          flag is cleared by writing a 1 to this bit.                          */
    } STAT_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENSET;                        /*!< Interrupt Enable Set and read register.                               */

    struct {
      __IO uint32_t  MSTPENDINGEN:  1;              /*!< Master Pending interrupt Enable.                                      */
           uint32_t             :  3;
      __IO uint32_t  MSTARBLOSSEN:  1;              /*!< Master Arbitration Loss interrupt Enable.                             */
           uint32_t             :  1;
      __IO uint32_t  MSTSTSTPERREN:  1;             /*!< Master Start/Stop Error interrupt Enable.                             */
           uint32_t             :  1;
      __IO uint32_t  SLVPENDINGEN:  1;              /*!< Slave Pending interrupt Enable.                                       */
           uint32_t             :  2;
      __IO uint32_t  SLVNOTSTREN:  1;               /*!< Slave Not Stretching interrupt Enable.                                */
           uint32_t             :  3;
      __IO uint32_t  SLVDESELEN :  1;               /*!< Slave Deselect interrupt Enable.                                      */
      __IO uint32_t  MONRDYEN   :  1;               /*!< Monitor data Ready interrupt Enable.                                  */
      __IO uint32_t  MONOVEN    :  1;               /*!< Monitor Overrun interrupt Enable.                                     */
           uint32_t             :  1;
      __IO uint32_t  MONIDLEEN  :  1;               /*!< Monitor Idle interrupt Enable.                                        */
           uint32_t             :  4;
      __IO uint32_t  EVENTTIMEOUTEN:  1;            /*!< Event time-out interrupt Enable.                                      */
      __IO uint32_t  SCLTIMEOUTEN:  1;              /*!< SCL time-out interrupt Enable.                                        */
    } INTENSET_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENCLR;                        /*!< Interrupt Enable Clear register.                                      */

    struct {
      __IO uint32_t  MSTPCLRDINGCLR:  1;            /*!< Master Pending interrupt clear.                                       */
           uint32_t             :  3;
      __IO uint32_t  MSTARBLOSSCLR:  1;             /*!< Master Arbitration Loss interrupt clear.                              */
           uint32_t             :  1;
      __IO uint32_t  MSTSTSTPERRCLR:  1;            /*!< Master Start/Stop Error interrupt clear.                              */
           uint32_t             :  1;
      __IO uint32_t  SLVPENDINGCLR:  1;             /*!< Slave Pending interrupt clear.                                        */
           uint32_t             :  2;
      __IO uint32_t  SLVNOTSTRCLR:  1;              /*!< Slave Not Stretching interrupt clear.                                 */
           uint32_t             :  3;
      __IO uint32_t  SLVDESELCLR:  1;               /*!< Slave Deselect interrupt clear.                                       */
      __IO uint32_t  MONRDYCLR  :  1;               /*!< Monitor data Ready interrupt clear.                                   */
      __IO uint32_t  MONOVCLR   :  1;               /*!< Monitor Overrun interrupt clear.                                      */
           uint32_t             :  1;
      __IO uint32_t  MONIDLECLR :  1;               /*!< Monitor Idle interrupt clear.                                         */
           uint32_t             :  4;
      __IO uint32_t  EVCLRTTIMEOUTCLR:  1;          /*!< Event time-out interrupt clear.                                       */
      __IO uint32_t  SCLTIMEOUTCLR:  1;             /*!< SCL time-out interrupt clear.                                         */
    } INTENCLR_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TIMEOUT;                         /*!< Time-out value register.                                              */

    struct {
      __IO uint32_t  TOMIN      :  4;               /*!< Time-out time value, bottom four bits. These are hard-wired
                                                         to 0xF. This gives a minimum time-out of 16 I2C function clocks
                                                          and also a time-out resolution of 16 I2C function clocks.            */
      __IO uint32_t  TO         : 12;               /*!< Time-out time value. Specifies the time-out interval value in
                                                         increments of 16 I2C function clocks, as defined by the CLKDIV
                                                          register. To change this value while I2C is in operation, disable
                                                          all time-outs, write a new value to TIMEOUT, then re-enable
                                                          time-outs. 0x000 = A time-out will occur after 16 counts of
                                                          the I2C function clock. 0x001 = A time-out will occur after
                                                          32 counts of the I2C function clock. ... 0xFFF = A time-out
                                                          will occur after 65,536 counts of the I2C function clock.            */
    } TIMEOUT_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CLKDIV;                          /*!< Clock pre-divider for the entire I2C interface. This determines
                                                         what time increments are used for the MSTTIME register, and
                                                          controls some timing of the Slave function.                          */

    struct {
      __IO uint32_t  DIVVAL     : 16;               /*!< This field controls how the I2C clock (FCLK) is used by the
                                                         I2C functions that need an internal clock in order to operate.
                                                          I2C block should be configured for 8MHz clock, this will limit
                                                          SCL master clock range from 444kHz to 2MHz. 0x0000 = FCLK is
                                                          used directly by the I2C. 0x0001 = FCLK is divided by 2 before
                                                          use. 0x0002 = FCLK is divided by 3 before use. ... 0xFFFF =
                                                          FCLK is divided by 65,536 before use.                                */
    } CLKDIV_b;                                     /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  INTSTAT;                         /*!< Interrupt Status register for Master, Slave, and Monitor functions.   */

    struct {
      __I  uint32_t  MSTPDING   :  1;               /*!< Master Pending interrupt.                                             */
           uint32_t             :  3;
      __I  uint32_t  MSTARBLOSS :  1;               /*!< Master Arbitration Loss interrupt.                                    */
           uint32_t             :  1;
      __I  uint32_t  MSTSTSTPERR:  1;               /*!< Master Start/Stop Error interrupt.                                    */
           uint32_t             :  1;
      __I  uint32_t  SLVPENDING :  1;               /*!< Slave Pending interrupt.                                              */
           uint32_t             :  2;
      __I  uint32_t  SLVNOTSTR  :  1;               /*!< Slave Not Stretching interrupt.                                       */
           uint32_t             :  3;
      __I  uint32_t  SLVDESEL   :  1;               /*!< Slave Deselect interrupt.                                             */
      __I  uint32_t  MONRDY     :  1;               /*!< Monitor data Ready interrupt.                                         */
      __I  uint32_t  MONOV      :  1;               /*!< Monitor Overrun interrupt.                                            */
           uint32_t             :  1;
      __I  uint32_t  MONIDLE    :  1;               /*!< Monitor Idle interrupt.                                               */
           uint32_t             :  4;
      __I  uint32_t  EVTTIMEOUT :  1;               /*!< Event time-out interrupt.                                             */
      __I  uint32_t  SCLTIMEOUT :  1;               /*!< SCL time-out interrupt.                                               */
    } INTSTAT_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;

  union {
    __IO uint32_t  MSTCTL;                          /*!< Master control register.                                              */

    struct {
      __IO uint32_t  MSTCONTINUE:  1;               /*!< Master Continue. This bit is write-only.                              */
      __IO uint32_t  MSTSTART   :  1;               /*!< Master Stop control. This bit is write-only.                          */
      __IO uint32_t  MSTSTOP    :  1;               /*!< Master Stop control. This bit is write-only.                          */
      __IO uint32_t  MSTDMA     :  1;               /*!< Master DMA enable. Data operations of the I2C can be performed
                                                         with DMA. Protocol type operations such as Start, address, Stop,
                                                          and address match must always be done with software, typically
                                                          via an interrupt. Address acknowledgement must also be done
                                                          by software except when the I2C is configured to be HSCAPABLE
                                                          (and address acknowledgement is handled entirely by hardware)
                                                          or when Automatic Operation is enabled. When a DMA data transfer
                                                          is complete, MSTDMA must be cleared prior to beginning the next
                                                          operati                                                              */
    } MSTCTL_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MSTTIME;                         /*!< Master timing configuration.                                          */

    struct {
      __IO uint32_t  MSTSCLLOW  :  3;               /*!< Master SCL Low time. Specifies the minimum low time that will
                                                         be asserted by this master on SCL. Other devices on the bus
                                                          (masters or slaves) could lengthen this time. This corresponds
                                                          to the parameter tLOW in the I2C bus specification. I2C bus
                                                          specification parameters tBUF and tSU;STA have the same values
                                                          and are also controlled by MSTSCLLOW.                                */
           uint32_t             :  1;
      __IO uint32_t  MSTSCLHIGH :  3;               /*!< Master SCL High time. Specifies the minimum high time that will
                                                         be asserted by this master on SCL. Other masters in a multi-master
                                                          system could shorten this time. This corresponds to the parameter
                                                          tHIGH in the I2C bus specification. I2C bus specification parameters
                                                          tSU;STO and tHD;STA have the same values and are also controlled
                                                          by MSTSCLHIGH.                                                       */
    } MSTTIME_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MSTDAT;                          /*!< Combined Master receiver and transmitter data register.               */

    struct {
      __IO uint32_t  DATA       :  8;               /*!< Master function data register. Read: read the most recently
                                                         received data for the Master function. Write: transmit data
                                                          using the Master function.                                           */
    } MSTDAT_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[5];

  union {
    __IO uint32_t  SLVCTL;                          /*!< Slave control register.                                               */

    struct {
      __IO uint32_t  SLVCONTINUE:  1;               /*!< Slave Continue.                                                       */
      __IO uint32_t  SLVNACK    :  1;               /*!< Slave NACK.                                                           */
           uint32_t             :  1;
      __IO uint32_t  SLVDMA     :  1;               /*!< Slave DMA enable.                                                     */
           uint32_t             :  4;
      __IO uint32_t  AUTOACK    :  1;               /*!< Automatic Acknowledge.When this bit is set, it will cause an
                                                         I2C header which matches SLVADR0 and the direction set by AUTOMATCHREAD
                                                          to be ACKed immediately; this is used with DMA to allow processing
                                                          of the data without intervention. If this bit is clear and a
                                                          header matches SLVADR0, the behavior is controlled by AUTONACK
                                                          in the SLVADR0 register: allowing NACK or interrupt.                 */
      __IO uint32_t  AUTOMATCHREAD:  1;             /*!< When AUTOACK is set, this bit controls whether it matches a
                                                         read or write request on the next header with an address matching
                                                          SLVADR0. Since DMA needs to be configured to match the transfer
                                                          direction, the direction needs to be specified. This bit allows
                                                          a direction to be chosen for the next operation.                     */
    } SLVCTL_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVDAT;                          /*!< Combined Slave receiver and transmitter data register.                */

    struct {
      __IO uint32_t  DATA       :  8;               /*!< Slave function data register. Read: read the most recently received
                                                         data for the Slave function. Write: transmit data using the
                                                          Slave function.                                                      */
    } SLVDAT_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR0;                         /*!< Slave address 0.                                                      */

    struct {
      __IO uint32_t  SADISABLE0 :  1;               /*!< Slave Address 0 Disable.                                              */
      __IO uint32_t  SLVADR0    :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled. The compare can be affected by the setting
                                                          of the SLVQUAL0 register.                                            */
           uint32_t             :  7;
      __IO uint32_t  AUTONACK   :  1;               /*!< Automatic NACK operation. Used in conjunction with AUTOACK and
                                                         AUTOMATCHREAD, allows software to ignore I2C traffic while handling
                                                          previous I2C data or other operations.                               */
    } SLVADR0_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR1;                         /*!< Slave address 1.                                                      */

    struct {
      __IO uint32_t  SADISABLE  :  1;               /*!< Slave Address 1 Disable.                                              */
      __IO uint32_t  SLVADR     :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled.                                                 */
    } SLVADR1_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR2;                         /*!< Slave address 2.                                                      */

    struct {
      __IO uint32_t  SADISABLE  :  1;               /*!< Slave Address 2 Disable.                                              */
      __IO uint32_t  SLVADR     :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled.                                                 */
    } SLVADR2_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR3;                         /*!< Slave address 3.                                                      */

    struct {
      __IO uint32_t  SADISABLE  :  1;               /*!< Slave Address 3 Disable.                                              */
      __IO uint32_t  SLVADR     :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled.                                                 */
    } SLVADR3_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVQUAL0;                        /*!< Slave Qualification for address 0.                                    */

    struct {
      __IO uint32_t  QUALMODE0  :  1;               /*!< Qualify mode for slave address 0.                                     */
      __IO uint32_t  SLVQUAL0   :  7;               /*!< Slave address Qualifier for address 0. A value of 0 causes the
                                                         address in SLVADR0 to be used as-is, assuming that it is enabled.
                                                          If QUALMODE0 = 0, any bit in this field which is set to 1 will
                                                          cause an automatic match of the corresponding bit of the received
                                                          address when it is compared to the SLVADR0 register. If QUALMODE0
                                                          = 1, an address range is matched for address 0. This range extends
                                                          from the value defined by SLVADR0 to the address defined by
                                                          SLVQUAL0 (address matches when SLVADR0[7:1] received address         */
    } SLVQUAL0_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[9];

  union {
    __I  uint32_t  MONRXDAT;                        /*!< Monitor receiver data register.                                       */

    struct {
      __I  uint32_t  MONRXDAT   :  8;               /*!< Monitor function Receiver Data. This reflects every data byte
                                                         that passes on the I2C pins.                                          */
      __I  uint32_t  MONSTART   :  1;               /*!< Monitor Received Start.                                               */
      __I  uint32_t  MONRESTART :  1;               /*!< Monitor Received Repeated Start.                                      */
      __I  uint32_t  MONNACK    :  1;               /*!< Monitor Received NACK.                                                */
    } MONRXDAT_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[990];

  union {
    __I  uint32_t  ID;                              /*!< I2C Module Identifier                                                 */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } ID_b;                                         /*!< BitSize                                                               */
  };
} u0_i2c_Type;


/* ================================================================================ */
/* ================                     u1_i2c                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component i2c It is an Inter IC with APB bus interface. More details will follow. (u1_i2c)
  */

typedef struct {                                    /*!< u1_i2c Structure                                                      */

  union {
    __IO uint32_t  CFG;                             /*!< Configuration for shared functions.                                   */

    struct {
      __IO uint32_t  MSTEN      :  1;               /*!< Master Enable. When disabled, configurations settings for the
                                                         Master function are not changed, but the Master function is
                                                          internally reset.                                                    */
      __IO uint32_t  SLVEN      :  1;               /*!< Slave Enable. When disabled, configurations settings for the
                                                         Slave function are not changed, but the Slave function is internally
                                                          reset.                                                               */
      __IO uint32_t  MONEN      :  1;               /*!< Monitor Enable. When disabled, configurations settings for the
                                                         Monitor function are not changed, but the Monitor function is
                                                          internally reset.                                                    */
      __IO uint32_t  TIMEOUT    :  1;               /*!< I2C bus Time-out Enable. When disabled, the time-out function
                                                         is internally reset.                                                  */
      __IO uint32_t  MONCLKSTR  :  1;               /*!< Monitor function Clock Stretching.                                    */
      __IO uint32_t  HSCAPABLE  :  1;               /*!< High-speed mode Capable enable. Since High Speed mode alters
                                                         the way I2C pins drive and filter, as well as the timing for
                                                          certain I2C signalling, enabling High-speed mode applies to
                                                          all functions: master, slave, and monitor.                           */
    } CFG_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STAT;                            /*!< Status register for Master, Slave, and Monitor functions.             */

    struct {
      __I  uint32_t  MSTPENDING :  1;               /*!< Master Pending. Indicates that the Master is waiting to continue
                                                         communication on the I2C-bus (pending) or is idle. When the
                                                          master is pending, the MSTSTATE bits indicate what type of software
                                                          service if any the master expects. This flag will cause an interrupt
                                                          when set if, enabled via the INTENSET register. The MSTPENDING
                                                          flag is not set when the DMA is handling an event (if the MSTDMA
                                                          bit in the MSTCTL register is set). If the master is in the
                                                          idle state, and no communication is needed, mask this interru        */
      __I  uint32_t  MSTSTATE   :  3;               /*!< Master State code. The master state code reflects the master
                                                         state when the MSTPENDING bit is set, that is the master is
                                                          pending or in the idle state. Each value of this field indicates
                                                          a specific required service for the Master function. All other
                                                          values are reserved.                                                 */
      __IO uint32_t  MSTARBLOSS :  1;               /*!< Master Arbitration Loss flag. This flag can be cleared by software
                                                         writing a 1 to this bit. It is also cleared automatically a
                                                          1 is written to MSTCONTINUE.                                         */
           uint32_t             :  1;
      __IO uint32_t  MSTSTSTPERR:  1;               /*!< Master Start/Stop Error flag. This flag can be cleared by software
                                                         writing a 1 to this bit. It is also cleared automatically a
                                                          1 is written to MSTCONTINUE.                                         */
           uint32_t             :  1;
      __I  uint32_t  SLVPENDING :  1;               /*!< Slave Pending. Indicates that the Slave function is waiting
                                                         to continue communication on the I2C-bus and needs software
                                                          service. This flag will cause an interrupt when set if enabled
                                                          via INTENSET. The SLVPENDING flag is not set when the DMA is
                                                          handling an event (if the SLVDMA bit in the SLVCTL register
                                                          is set). The SLVPENDING flag is read-only and is automatically
                                                          cleared when a 1 is written to the SLVCONTINUE bit in the SLVCTL
                                                          register. The point in time when SlvPending is set depends on
                                                          whether the I2C i                                                    */
      __I  uint32_t  SLVSTATE   :  2;               /*!< Slave State code. Each value of this field indicates a specific
                                                         required service for the Slave function. All other values are
                                                          reserved. See Table 393 for state values and actions. Remark:
                                                          note that the occurrence of some states and how they are handled
                                                          are affected by DMA mode and Automatic Operation modes.              */
      __I  uint32_t  SLVNOTSTR  :  1;               /*!< Slave Not Stretching. Indicates when the slave function is stretching
                                                         the I2C clock. This is needed in order to gracefully invoke
                                                          Deep Sleep or Power-down modes during slave operation. This
                                                          read-only flag reflects the slave function status in real time.      */
      __I  uint32_t  SLVIDX     :  2;               /*!< Slave address match Index. This field is valid when the I2C
                                                         slave function has been selected by receiving an address that
                                                          matches one of the slave addresses defined by any enabled slave
                                                          address registers, and provides an identification of the address
                                                          that was matched. It is possible that more than one address
                                                          could be matched, but only one match can be reported here.           */
      __IO uint32_t  SLVSEL     :  1;               /*!< Slave selected flag. SLVSEL is set after an address match when
                                                         software tells the Slave function to acknowledge the address,
                                                          or when the address has been automatically acknowledged. It
                                                          is cleared when another address cycle presents an address that
                                                          does not match an enabled address on the Slave function, when
                                                          slave software decides to NACK a matched address, when there
                                                          is a Stop detected on the bus, when the master NACKs slave data,
                                                          and in some combinations of Automatic Operation. SLVSEL is not
                                                          cleared if s                                                         */
      __IO uint32_t  SLVDESEL   :  1;               /*!< Slave Deselected flag. This flag will cause an interrupt when
                                                         set if enabled via INTENSET. This flag can be cleared by writing
                                                          a 1 to this bit.                                                     */
      __I  uint32_t  MONRDY     :  1;               /*!< Monitor Ready. This flag is cleared when the MONRXDAT register
                                                         is read.                                                              */
      __IO uint32_t  MONOV      :  1;               /*!< Monitor Overflow flag.                                                */
      __I  uint32_t  MONACTIVE  :  1;               /*!< Monitor Active flag. Indicates when the Monitor function considers
                                                         the I2C bus to be active. Active is defined here as when some
                                                          Master is on the bus: a bus Start has occurred more recently
                                                          than a bus Stop.                                                     */
      __IO uint32_t  MONIDLE    :  1;               /*!< Monitor Idle flag. This flag is set when the Monitor function
                                                         sees the I2C bus change from active to inactive. This can be
                                                          used by software to decide when to process data accumulated
                                                          by the Monitor function. This flag will cause an interrupt when
                                                          set if enabled via the INTENSET register. The flag can be cleared
                                                          by writing a 1 to this bit.                                          */
           uint32_t             :  4;
      __IO uint32_t  EVENTTIMEOUT:  1;              /*!< Event Time-out Interrupt flag. Indicates when the time between
                                                         events has been longer than the time specified by the TIMEOUT
                                                          register. Events include Start, Stop, and clock edges. The flag
                                                          is cleared by writing a 1 to this bit. No time-out is created
                                                          when the I2C-bus is idle.                                            */
      __IO uint32_t  SCLTIMEOUT :  1;               /*!< SCL Time-out Interrupt flag. Indicates when SCL has remained
                                                         low longer than the time specific by the TIMEOUT register. The
                                                          flag is cleared by writing a 1 to this bit.                          */
    } STAT_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENSET;                        /*!< Interrupt Enable Set and read register.                               */

    struct {
      __IO uint32_t  MSTPENDINGEN:  1;              /*!< Master Pending interrupt Enable.                                      */
           uint32_t             :  3;
      __IO uint32_t  MSTARBLOSSEN:  1;              /*!< Master Arbitration Loss interrupt Enable.                             */
           uint32_t             :  1;
      __IO uint32_t  MSTSTSTPERREN:  1;             /*!< Master Start/Stop Error interrupt Enable.                             */
           uint32_t             :  1;
      __IO uint32_t  SLVPENDINGEN:  1;              /*!< Slave Pending interrupt Enable.                                       */
           uint32_t             :  2;
      __IO uint32_t  SLVNOTSTREN:  1;               /*!< Slave Not Stretching interrupt Enable.                                */
           uint32_t             :  3;
      __IO uint32_t  SLVDESELEN :  1;               /*!< Slave Deselect interrupt Enable.                                      */
      __IO uint32_t  MONRDYEN   :  1;               /*!< Monitor data Ready interrupt Enable.                                  */
      __IO uint32_t  MONOVEN    :  1;               /*!< Monitor Overrun interrupt Enable.                                     */
           uint32_t             :  1;
      __IO uint32_t  MONIDLEEN  :  1;               /*!< Monitor Idle interrupt Enable.                                        */
           uint32_t             :  4;
      __IO uint32_t  EVENTTIMEOUTEN:  1;            /*!< Event time-out interrupt Enable.                                      */
      __IO uint32_t  SCLTIMEOUTEN:  1;              /*!< SCL time-out interrupt Enable.                                        */
    } INTENSET_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENCLR;                        /*!< Interrupt Enable Clear register.                                      */

    struct {
      __IO uint32_t  MSTPCLRDINGCLR:  1;            /*!< Master Pending interrupt clear.                                       */
           uint32_t             :  3;
      __IO uint32_t  MSTARBLOSSCLR:  1;             /*!< Master Arbitration Loss interrupt clear.                              */
           uint32_t             :  1;
      __IO uint32_t  MSTSTSTPERRCLR:  1;            /*!< Master Start/Stop Error interrupt clear.                              */
           uint32_t             :  1;
      __IO uint32_t  SLVPENDINGCLR:  1;             /*!< Slave Pending interrupt clear.                                        */
           uint32_t             :  2;
      __IO uint32_t  SLVNOTSTRCLR:  1;              /*!< Slave Not Stretching interrupt clear.                                 */
           uint32_t             :  3;
      __IO uint32_t  SLVDESELCLR:  1;               /*!< Slave Deselect interrupt clear.                                       */
      __IO uint32_t  MONRDYCLR  :  1;               /*!< Monitor data Ready interrupt clear.                                   */
      __IO uint32_t  MONOVCLR   :  1;               /*!< Monitor Overrun interrupt clear.                                      */
           uint32_t             :  1;
      __IO uint32_t  MONIDLECLR :  1;               /*!< Monitor Idle interrupt clear.                                         */
           uint32_t             :  4;
      __IO uint32_t  EVCLRTTIMEOUTCLR:  1;          /*!< Event time-out interrupt clear.                                       */
      __IO uint32_t  SCLTIMEOUTCLR:  1;             /*!< SCL time-out interrupt clear.                                         */
    } INTENCLR_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TIMEOUT;                         /*!< Time-out value register.                                              */

    struct {
      __IO uint32_t  TOMIN      :  4;               /*!< Time-out time value, bottom four bits. These are hard-wired
                                                         to 0xF. This gives a minimum time-out of 16 I2C function clocks
                                                          and also a time-out resolution of 16 I2C function clocks.            */
      __IO uint32_t  TO         : 12;               /*!< Time-out time value. Specifies the time-out interval value in
                                                         increments of 16 I2C function clocks, as defined by the CLKDIV
                                                          register. To change this value while I2C is in operation, disable
                                                          all time-outs, write a new value to TIMEOUT, then re-enable
                                                          time-outs. 0x000 = A time-out will occur after 16 counts of
                                                          the I2C function clock. 0x001 = A time-out will occur after
                                                          32 counts of the I2C function clock. ... 0xFFF = A time-out
                                                          will occur after 65,536 counts of the I2C function clock.            */
    } TIMEOUT_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CLKDIV;                          /*!< Clock pre-divider for the entire I2C interface. This determines
                                                         what time increments are used for the MSTTIME register, and
                                                          controls some timing of the Slave function.                          */

    struct {
      __IO uint32_t  DIVVAL     : 16;               /*!< This field controls how the I2C clock (FCLK) is used by the
                                                         I2C functions that need an internal clock in order to operate.
                                                          I2C block should be configured for 8MHz clock, this will limit
                                                          SCL master clock range from 444kHz to 2MHz. 0x0000 = FCLK is
                                                          used directly by the I2C. 0x0001 = FCLK is divided by 2 before
                                                          use. 0x0002 = FCLK is divided by 3 before use. ... 0xFFFF =
                                                          FCLK is divided by 65,536 before use.                                */
    } CLKDIV_b;                                     /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  INTSTAT;                         /*!< Interrupt Status register for Master, Slave, and Monitor functions.   */

    struct {
      __I  uint32_t  MSTPDING   :  1;               /*!< Master Pending interrupt.                                             */
           uint32_t             :  3;
      __I  uint32_t  MSTARBLOSS :  1;               /*!< Master Arbitration Loss interrupt.                                    */
           uint32_t             :  1;
      __I  uint32_t  MSTSTSTPERR:  1;               /*!< Master Start/Stop Error interrupt.                                    */
           uint32_t             :  1;
      __I  uint32_t  SLVPENDING :  1;               /*!< Slave Pending interrupt.                                              */
           uint32_t             :  2;
      __I  uint32_t  SLVNOTSTR  :  1;               /*!< Slave Not Stretching interrupt.                                       */
           uint32_t             :  3;
      __I  uint32_t  SLVDESEL   :  1;               /*!< Slave Deselect interrupt.                                             */
      __I  uint32_t  MONRDY     :  1;               /*!< Monitor data Ready interrupt.                                         */
      __I  uint32_t  MONOV      :  1;               /*!< Monitor Overrun interrupt.                                            */
           uint32_t             :  1;
      __I  uint32_t  MONIDLE    :  1;               /*!< Monitor Idle interrupt.                                               */
           uint32_t             :  4;
      __I  uint32_t  EVTTIMEOUT :  1;               /*!< Event time-out interrupt.                                             */
      __I  uint32_t  SCLTIMEOUT :  1;               /*!< SCL time-out interrupt.                                               */
    } INTSTAT_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;

  union {
    __IO uint32_t  MSTCTL;                          /*!< Master control register.                                              */

    struct {
      __IO uint32_t  MSTCONTINUE:  1;               /*!< Master Continue. This bit is write-only.                              */
      __IO uint32_t  MSTSTART   :  1;               /*!< Master Stop control. This bit is write-only.                          */
      __IO uint32_t  MSTSTOP    :  1;               /*!< Master Stop control. This bit is write-only.                          */
      __IO uint32_t  MSTDMA     :  1;               /*!< Master DMA enable. Data operations of the I2C can be performed
                                                         with DMA. Protocol type operations such as Start, address, Stop,
                                                          and address match must always be done with software, typically
                                                          via an interrupt. Address acknowledgement must also be done
                                                          by software except when the I2C is configured to be HSCAPABLE
                                                          (and address acknowledgement is handled entirely by hardware)
                                                          or when Automatic Operation is enabled. When a DMA data transfer
                                                          is complete, MSTDMA must be cleared prior to beginning the next
                                                          operati                                                              */
    } MSTCTL_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MSTTIME;                         /*!< Master timing configuration.                                          */

    struct {
      __IO uint32_t  MSTSCLLOW  :  3;               /*!< Master SCL Low time. Specifies the minimum low time that will
                                                         be asserted by this master on SCL. Other devices on the bus
                                                          (masters or slaves) could lengthen this time. This corresponds
                                                          to the parameter tLOW in the I2C bus specification. I2C bus
                                                          specification parameters tBUF and tSU;STA have the same values
                                                          and are also controlled by MSTSCLLOW.                                */
           uint32_t             :  1;
      __IO uint32_t  MSTSCLHIGH :  3;               /*!< Master SCL High time. Specifies the minimum high time that will
                                                         be asserted by this master on SCL. Other masters in a multi-master
                                                          system could shorten this time. This corresponds to the parameter
                                                          tHIGH in the I2C bus specification. I2C bus specification parameters
                                                          tSU;STO and tHD;STA have the same values and are also controlled
                                                          by MSTSCLHIGH.                                                       */
    } MSTTIME_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MSTDAT;                          /*!< Combined Master receiver and transmitter data register.               */

    struct {
      __IO uint32_t  DATA       :  8;               /*!< Master function data register. Read: read the most recently
                                                         received data for the Master function. Write: transmit data
                                                          using the Master function.                                           */
    } MSTDAT_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[5];

  union {
    __IO uint32_t  SLVCTL;                          /*!< Slave control register.                                               */

    struct {
      __IO uint32_t  SLVCONTINUE:  1;               /*!< Slave Continue.                                                       */
      __IO uint32_t  SLVNACK    :  1;               /*!< Slave NACK.                                                           */
           uint32_t             :  1;
      __IO uint32_t  SLVDMA     :  1;               /*!< Slave DMA enable.                                                     */
           uint32_t             :  4;
      __IO uint32_t  AUTOACK    :  1;               /*!< Automatic Acknowledge.When this bit is set, it will cause an
                                                         I2C header which matches SLVADR0 and the direction set by AUTOMATCHREAD
                                                          to be ACKed immediately; this is used with DMA to allow processing
                                                          of the data without intervention. If this bit is clear and a
                                                          header matches SLVADR0, the behavior is controlled by AUTONACK
                                                          in the SLVADR0 register: allowing NACK or interrupt.                 */
      __IO uint32_t  AUTOMATCHREAD:  1;             /*!< When AUTOACK is set, this bit controls whether it matches a
                                                         read or write request on the next header with an address matching
                                                          SLVADR0. Since DMA needs to be configured to match the transfer
                                                          direction, the direction needs to be specified. This bit allows
                                                          a direction to be chosen for the next operation.                     */
    } SLVCTL_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVDAT;                          /*!< Combined Slave receiver and transmitter data register.                */

    struct {
      __IO uint32_t  DATA       :  8;               /*!< Slave function data register. Read: read the most recently received
                                                         data for the Slave function. Write: transmit data using the
                                                          Slave function.                                                      */
    } SLVDAT_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR0;                         /*!< Slave address 0.                                                      */

    struct {
      __IO uint32_t  SADISABLE0 :  1;               /*!< Slave Address 0 Disable.                                              */
      __IO uint32_t  SLVADR0    :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled. The compare can be affected by the setting
                                                          of the SLVQUAL0 register.                                            */
           uint32_t             :  7;
      __IO uint32_t  AUTONACK   :  1;               /*!< Automatic NACK operation. Used in conjunction with AUTOACK and
                                                         AUTOMATCHREAD, allows software to ignore I2C traffic while handling
                                                          previous I2C data or other operations.                               */
    } SLVADR0_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR1;                         /*!< Slave address 1.                                                      */

    struct {
      __IO uint32_t  SADISABLE  :  1;               /*!< Slave Address 1 Disable.                                              */
      __IO uint32_t  SLVADR     :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled.                                                 */
    } SLVADR1_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR2;                         /*!< Slave address 2.                                                      */

    struct {
      __IO uint32_t  SADISABLE  :  1;               /*!< Slave Address 2 Disable.                                              */
      __IO uint32_t  SLVADR     :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled.                                                 */
    } SLVADR2_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR3;                         /*!< Slave address 3.                                                      */

    struct {
      __IO uint32_t  SADISABLE  :  1;               /*!< Slave Address 3 Disable.                                              */
      __IO uint32_t  SLVADR     :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled.                                                 */
    } SLVADR3_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVQUAL0;                        /*!< Slave Qualification for address 0.                                    */

    struct {
      __IO uint32_t  QUALMODE0  :  1;               /*!< Qualify mode for slave address 0.                                     */
      __IO uint32_t  SLVQUAL0   :  7;               /*!< Slave address Qualifier for address 0. A value of 0 causes the
                                                         address in SLVADR0 to be used as-is, assuming that it is enabled.
                                                          If QUALMODE0 = 0, any bit in this field which is set to 1 will
                                                          cause an automatic match of the corresponding bit of the received
                                                          address when it is compared to the SLVADR0 register. If QUALMODE0
                                                          = 1, an address range is matched for address 0. This range extends
                                                          from the value defined by SLVADR0 to the address defined by
                                                          SLVQUAL0 (address matches when SLVADR0[7:1] received address         */
    } SLVQUAL0_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[9];

  union {
    __I  uint32_t  MONRXDAT;                        /*!< Monitor receiver data register.                                       */

    struct {
      __I  uint32_t  MONRXDAT   :  8;               /*!< Monitor function Receiver Data. This reflects every data byte
                                                         that passes on the I2C pins.                                          */
      __I  uint32_t  MONSTART   :  1;               /*!< Monitor Received Start.                                               */
      __I  uint32_t  MONRESTART :  1;               /*!< Monitor Received Repeated Start.                                      */
      __I  uint32_t  MONNACK    :  1;               /*!< Monitor Received NACK.                                                */
    } MONRXDAT_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[990];

  union {
    __I  uint32_t  ID;                              /*!< I2C Module Identifier                                                 */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } ID_b;                                         /*!< BitSize                                                               */
  };
} u1_i2c_Type;


/* ================================================================================ */
/* ================                     u2_i2c                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component i2c It is an Inter IC with APB bus interface. More details will follow. (u2_i2c)
  */

typedef struct {                                    /*!< u2_i2c Structure                                                      */

  union {
    __IO uint32_t  CFG;                             /*!< Configuration for shared functions.                                   */

    struct {
      __IO uint32_t  MSTEN      :  1;               /*!< Master Enable. When disabled, configurations settings for the
                                                         Master function are not changed, but the Master function is
                                                          internally reset.                                                    */
      __IO uint32_t  SLVEN      :  1;               /*!< Slave Enable. When disabled, configurations settings for the
                                                         Slave function are not changed, but the Slave function is internally
                                                          reset.                                                               */
      __IO uint32_t  MONEN      :  1;               /*!< Monitor Enable. When disabled, configurations settings for the
                                                         Monitor function are not changed, but the Monitor function is
                                                          internally reset.                                                    */
      __IO uint32_t  TIMEOUT    :  1;               /*!< I2C bus Time-out Enable. When disabled, the time-out function
                                                         is internally reset.                                                  */
      __IO uint32_t  MONCLKSTR  :  1;               /*!< Monitor function Clock Stretching.                                    */
      __IO uint32_t  HSCAPABLE  :  1;               /*!< High-speed mode Capable enable. Since High Speed mode alters
                                                         the way I2C pins drive and filter, as well as the timing for
                                                          certain I2C signalling, enabling High-speed mode applies to
                                                          all functions: master, slave, and monitor.                           */
    } CFG_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STAT;                            /*!< Status register for Master, Slave, and Monitor functions.             */

    struct {
      __I  uint32_t  MSTPENDING :  1;               /*!< Master Pending. Indicates that the Master is waiting to continue
                                                         communication on the I2C-bus (pending) or is idle. When the
                                                          master is pending, the MSTSTATE bits indicate what type of software
                                                          service if any the master expects. This flag will cause an interrupt
                                                          when set if, enabled via the INTENSET register. The MSTPENDING
                                                          flag is not set when the DMA is handling an event (if the MSTDMA
                                                          bit in the MSTCTL register is set). If the master is in the
                                                          idle state, and no communication is needed, mask this interru        */
      __I  uint32_t  MSTSTATE   :  3;               /*!< Master State code. The master state code reflects the master
                                                         state when the MSTPENDING bit is set, that is the master is
                                                          pending or in the idle state. Each value of this field indicates
                                                          a specific required service for the Master function. All other
                                                          values are reserved.                                                 */
      __IO uint32_t  MSTARBLOSS :  1;               /*!< Master Arbitration Loss flag. This flag can be cleared by software
                                                         writing a 1 to this bit. It is also cleared automatically a
                                                          1 is written to MSTCONTINUE.                                         */
           uint32_t             :  1;
      __IO uint32_t  MSTSTSTPERR:  1;               /*!< Master Start/Stop Error flag. This flag can be cleared by software
                                                         writing a 1 to this bit. It is also cleared automatically a
                                                          1 is written to MSTCONTINUE.                                         */
           uint32_t             :  1;
      __I  uint32_t  SLVPENDING :  1;               /*!< Slave Pending. Indicates that the Slave function is waiting
                                                         to continue communication on the I2C-bus and needs software
                                                          service. This flag will cause an interrupt when set if enabled
                                                          via INTENSET. The SLVPENDING flag is not set when the DMA is
                                                          handling an event (if the SLVDMA bit in the SLVCTL register
                                                          is set). The SLVPENDING flag is read-only and is automatically
                                                          cleared when a 1 is written to the SLVCONTINUE bit in the SLVCTL
                                                          register. The point in time when SlvPending is set depends on
                                                          whether the I2C i                                                    */
      __I  uint32_t  SLVSTATE   :  2;               /*!< Slave State code. Each value of this field indicates a specific
                                                         required service for the Slave function. All other values are
                                                          reserved. See Table 393 for state values and actions. Remark:
                                                          note that the occurrence of some states and how they are handled
                                                          are affected by DMA mode and Automatic Operation modes.              */
      __I  uint32_t  SLVNOTSTR  :  1;               /*!< Slave Not Stretching. Indicates when the slave function is stretching
                                                         the I2C clock. This is needed in order to gracefully invoke
                                                          Deep Sleep or Power-down modes during slave operation. This
                                                          read-only flag reflects the slave function status in real time.      */
      __I  uint32_t  SLVIDX     :  2;               /*!< Slave address match Index. This field is valid when the I2C
                                                         slave function has been selected by receiving an address that
                                                          matches one of the slave addresses defined by any enabled slave
                                                          address registers, and provides an identification of the address
                                                          that was matched. It is possible that more than one address
                                                          could be matched, but only one match can be reported here.           */
      __IO uint32_t  SLVSEL     :  1;               /*!< Slave selected flag. SLVSEL is set after an address match when
                                                         software tells the Slave function to acknowledge the address,
                                                          or when the address has been automatically acknowledged. It
                                                          is cleared when another address cycle presents an address that
                                                          does not match an enabled address on the Slave function, when
                                                          slave software decides to NACK a matched address, when there
                                                          is a Stop detected on the bus, when the master NACKs slave data,
                                                          and in some combinations of Automatic Operation. SLVSEL is not
                                                          cleared if s                                                         */
      __IO uint32_t  SLVDESEL   :  1;               /*!< Slave Deselected flag. This flag will cause an interrupt when
                                                         set if enabled via INTENSET. This flag can be cleared by writing
                                                          a 1 to this bit.                                                     */
      __I  uint32_t  MONRDY     :  1;               /*!< Monitor Ready. This flag is cleared when the MONRXDAT register
                                                         is read.                                                              */
      __IO uint32_t  MONOV      :  1;               /*!< Monitor Overflow flag.                                                */
      __I  uint32_t  MONACTIVE  :  1;               /*!< Monitor Active flag. Indicates when the Monitor function considers
                                                         the I2C bus to be active. Active is defined here as when some
                                                          Master is on the bus: a bus Start has occurred more recently
                                                          than a bus Stop.                                                     */
      __IO uint32_t  MONIDLE    :  1;               /*!< Monitor Idle flag. This flag is set when the Monitor function
                                                         sees the I2C bus change from active to inactive. This can be
                                                          used by software to decide when to process data accumulated
                                                          by the Monitor function. This flag will cause an interrupt when
                                                          set if enabled via the INTENSET register. The flag can be cleared
                                                          by writing a 1 to this bit.                                          */
           uint32_t             :  4;
      __IO uint32_t  EVENTTIMEOUT:  1;              /*!< Event Time-out Interrupt flag. Indicates when the time between
                                                         events has been longer than the time specified by the TIMEOUT
                                                          register. Events include Start, Stop, and clock edges. The flag
                                                          is cleared by writing a 1 to this bit. No time-out is created
                                                          when the I2C-bus is idle.                                            */
      __IO uint32_t  SCLTIMEOUT :  1;               /*!< SCL Time-out Interrupt flag. Indicates when SCL has remained
                                                         low longer than the time specific by the TIMEOUT register. The
                                                          flag is cleared by writing a 1 to this bit.                          */
    } STAT_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENSET;                        /*!< Interrupt Enable Set and read register.                               */

    struct {
      __IO uint32_t  MSTPENDINGEN:  1;              /*!< Master Pending interrupt Enable.                                      */
           uint32_t             :  3;
      __IO uint32_t  MSTARBLOSSEN:  1;              /*!< Master Arbitration Loss interrupt Enable.                             */
           uint32_t             :  1;
      __IO uint32_t  MSTSTSTPERREN:  1;             /*!< Master Start/Stop Error interrupt Enable.                             */
           uint32_t             :  1;
      __IO uint32_t  SLVPENDINGEN:  1;              /*!< Slave Pending interrupt Enable.                                       */
           uint32_t             :  2;
      __IO uint32_t  SLVNOTSTREN:  1;               /*!< Slave Not Stretching interrupt Enable.                                */
           uint32_t             :  3;
      __IO uint32_t  SLVDESELEN :  1;               /*!< Slave Deselect interrupt Enable.                                      */
      __IO uint32_t  MONRDYEN   :  1;               /*!< Monitor data Ready interrupt Enable.                                  */
      __IO uint32_t  MONOVEN    :  1;               /*!< Monitor Overrun interrupt Enable.                                     */
           uint32_t             :  1;
      __IO uint32_t  MONIDLEEN  :  1;               /*!< Monitor Idle interrupt Enable.                                        */
           uint32_t             :  4;
      __IO uint32_t  EVENTTIMEOUTEN:  1;            /*!< Event time-out interrupt Enable.                                      */
      __IO uint32_t  SCLTIMEOUTEN:  1;              /*!< SCL time-out interrupt Enable.                                        */
    } INTENSET_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENCLR;                        /*!< Interrupt Enable Clear register.                                      */

    struct {
      __IO uint32_t  MSTPCLRDINGCLR:  1;            /*!< Master Pending interrupt clear.                                       */
           uint32_t             :  3;
      __IO uint32_t  MSTARBLOSSCLR:  1;             /*!< Master Arbitration Loss interrupt clear.                              */
           uint32_t             :  1;
      __IO uint32_t  MSTSTSTPERRCLR:  1;            /*!< Master Start/Stop Error interrupt clear.                              */
           uint32_t             :  1;
      __IO uint32_t  SLVPENDINGCLR:  1;             /*!< Slave Pending interrupt clear.                                        */
           uint32_t             :  2;
      __IO uint32_t  SLVNOTSTRCLR:  1;              /*!< Slave Not Stretching interrupt clear.                                 */
           uint32_t             :  3;
      __IO uint32_t  SLVDESELCLR:  1;               /*!< Slave Deselect interrupt clear.                                       */
      __IO uint32_t  MONRDYCLR  :  1;               /*!< Monitor data Ready interrupt clear.                                   */
      __IO uint32_t  MONOVCLR   :  1;               /*!< Monitor Overrun interrupt clear.                                      */
           uint32_t             :  1;
      __IO uint32_t  MONIDLECLR :  1;               /*!< Monitor Idle interrupt clear.                                         */
           uint32_t             :  4;
      __IO uint32_t  EVCLRTTIMEOUTCLR:  1;          /*!< Event time-out interrupt clear.                                       */
      __IO uint32_t  SCLTIMEOUTCLR:  1;             /*!< SCL time-out interrupt clear.                                         */
    } INTENCLR_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TIMEOUT;                         /*!< Time-out value register.                                              */

    struct {
      __IO uint32_t  TOMIN      :  4;               /*!< Time-out time value, bottom four bits. These are hard-wired
                                                         to 0xF. This gives a minimum time-out of 16 I2C function clocks
                                                          and also a time-out resolution of 16 I2C function clocks.            */
      __IO uint32_t  TO         : 12;               /*!< Time-out time value. Specifies the time-out interval value in
                                                         increments of 16 I2C function clocks, as defined by the CLKDIV
                                                          register. To change this value while I2C is in operation, disable
                                                          all time-outs, write a new value to TIMEOUT, then re-enable
                                                          time-outs. 0x000 = A time-out will occur after 16 counts of
                                                          the I2C function clock. 0x001 = A time-out will occur after
                                                          32 counts of the I2C function clock. ... 0xFFF = A time-out
                                                          will occur after 65,536 counts of the I2C function clock.            */
    } TIMEOUT_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CLKDIV;                          /*!< Clock pre-divider for the entire I2C interface. This determines
                                                         what time increments are used for the MSTTIME register, and
                                                          controls some timing of the Slave function.                          */

    struct {
      __IO uint32_t  DIVVAL     : 16;               /*!< This field controls how the I2C clock (FCLK) is used by the
                                                         I2C functions that need an internal clock in order to operate.
                                                          I2C block should be configured for 8MHz clock, this will limit
                                                          SCL master clock range from 444kHz to 2MHz. 0x0000 = FCLK is
                                                          used directly by the I2C. 0x0001 = FCLK is divided by 2 before
                                                          use. 0x0002 = FCLK is divided by 3 before use. ... 0xFFFF =
                                                          FCLK is divided by 65,536 before use.                                */
    } CLKDIV_b;                                     /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  INTSTAT;                         /*!< Interrupt Status register for Master, Slave, and Monitor functions.   */

    struct {
      __I  uint32_t  MSTPDING   :  1;               /*!< Master Pending interrupt.                                             */
           uint32_t             :  3;
      __I  uint32_t  MSTARBLOSS :  1;               /*!< Master Arbitration Loss interrupt.                                    */
           uint32_t             :  1;
      __I  uint32_t  MSTSTSTPERR:  1;               /*!< Master Start/Stop Error interrupt.                                    */
           uint32_t             :  1;
      __I  uint32_t  SLVPENDING :  1;               /*!< Slave Pending interrupt.                                              */
           uint32_t             :  2;
      __I  uint32_t  SLVNOTSTR  :  1;               /*!< Slave Not Stretching interrupt.                                       */
           uint32_t             :  3;
      __I  uint32_t  SLVDESEL   :  1;               /*!< Slave Deselect interrupt.                                             */
      __I  uint32_t  MONRDY     :  1;               /*!< Monitor data Ready interrupt.                                         */
      __I  uint32_t  MONOV      :  1;               /*!< Monitor Overrun interrupt.                                            */
           uint32_t             :  1;
      __I  uint32_t  MONIDLE    :  1;               /*!< Monitor Idle interrupt.                                               */
           uint32_t             :  4;
      __I  uint32_t  EVTTIMEOUT :  1;               /*!< Event time-out interrupt.                                             */
      __I  uint32_t  SCLTIMEOUT :  1;               /*!< SCL time-out interrupt.                                               */
    } INTSTAT_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;

  union {
    __IO uint32_t  MSTCTL;                          /*!< Master control register.                                              */

    struct {
      __IO uint32_t  MSTCONTINUE:  1;               /*!< Master Continue. This bit is write-only.                              */
      __IO uint32_t  MSTSTART   :  1;               /*!< Master Stop control. This bit is write-only.                          */
      __IO uint32_t  MSTSTOP    :  1;               /*!< Master Stop control. This bit is write-only.                          */
      __IO uint32_t  MSTDMA     :  1;               /*!< Master DMA enable. Data operations of the I2C can be performed
                                                         with DMA. Protocol type operations such as Start, address, Stop,
                                                          and address match must always be done with software, typically
                                                          via an interrupt. Address acknowledgement must also be done
                                                          by software except when the I2C is configured to be HSCAPABLE
                                                          (and address acknowledgement is handled entirely by hardware)
                                                          or when Automatic Operation is enabled. When a DMA data transfer
                                                          is complete, MSTDMA must be cleared prior to beginning the next
                                                          operati                                                              */
    } MSTCTL_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MSTTIME;                         /*!< Master timing configuration.                                          */

    struct {
      __IO uint32_t  MSTSCLLOW  :  3;               /*!< Master SCL Low time. Specifies the minimum low time that will
                                                         be asserted by this master on SCL. Other devices on the bus
                                                          (masters or slaves) could lengthen this time. This corresponds
                                                          to the parameter tLOW in the I2C bus specification. I2C bus
                                                          specification parameters tBUF and tSU;STA have the same values
                                                          and are also controlled by MSTSCLLOW.                                */
           uint32_t             :  1;
      __IO uint32_t  MSTSCLHIGH :  3;               /*!< Master SCL High time. Specifies the minimum high time that will
                                                         be asserted by this master on SCL. Other masters in a multi-master
                                                          system could shorten this time. This corresponds to the parameter
                                                          tHIGH in the I2C bus specification. I2C bus specification parameters
                                                          tSU;STO and tHD;STA have the same values and are also controlled
                                                          by MSTSCLHIGH.                                                       */
    } MSTTIME_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MSTDAT;                          /*!< Combined Master receiver and transmitter data register.               */

    struct {
      __IO uint32_t  DATA       :  8;               /*!< Master function data register. Read: read the most recently
                                                         received data for the Master function. Write: transmit data
                                                          using the Master function.                                           */
    } MSTDAT_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[5];

  union {
    __IO uint32_t  SLVCTL;                          /*!< Slave control register.                                               */

    struct {
      __IO uint32_t  SLVCONTINUE:  1;               /*!< Slave Continue.                                                       */
      __IO uint32_t  SLVNACK    :  1;               /*!< Slave NACK.                                                           */
           uint32_t             :  1;
      __IO uint32_t  SLVDMA     :  1;               /*!< Slave DMA enable.                                                     */
           uint32_t             :  4;
      __IO uint32_t  AUTOACK    :  1;               /*!< Automatic Acknowledge.When this bit is set, it will cause an
                                                         I2C header which matches SLVADR0 and the direction set by AUTOMATCHREAD
                                                          to be ACKed immediately; this is used with DMA to allow processing
                                                          of the data without intervention. If this bit is clear and a
                                                          header matches SLVADR0, the behavior is controlled by AUTONACK
                                                          in the SLVADR0 register: allowing NACK or interrupt.                 */
      __IO uint32_t  AUTOMATCHREAD:  1;             /*!< When AUTOACK is set, this bit controls whether it matches a
                                                         read or write request on the next header with an address matching
                                                          SLVADR0. Since DMA needs to be configured to match the transfer
                                                          direction, the direction needs to be specified. This bit allows
                                                          a direction to be chosen for the next operation.                     */
    } SLVCTL_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVDAT;                          /*!< Combined Slave receiver and transmitter data register.                */

    struct {
      __IO uint32_t  DATA       :  8;               /*!< Slave function data register. Read: read the most recently received
                                                         data for the Slave function. Write: transmit data using the
                                                          Slave function.                                                      */
    } SLVDAT_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR0;                         /*!< Slave address 0.                                                      */

    struct {
      __IO uint32_t  SADISABLE0 :  1;               /*!< Slave Address 0 Disable.                                              */
      __IO uint32_t  SLVADR0    :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled. The compare can be affected by the setting
                                                          of the SLVQUAL0 register.                                            */
           uint32_t             :  7;
      __IO uint32_t  AUTONACK   :  1;               /*!< Automatic NACK operation. Used in conjunction with AUTOACK and
                                                         AUTOMATCHREAD, allows software to ignore I2C traffic while handling
                                                          previous I2C data or other operations.                               */
    } SLVADR0_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR1;                         /*!< Slave address 1.                                                      */

    struct {
      __IO uint32_t  SADISABLE  :  1;               /*!< Slave Address 1 Disable.                                              */
      __IO uint32_t  SLVADR     :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled.                                                 */
    } SLVADR1_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR2;                         /*!< Slave address 2.                                                      */

    struct {
      __IO uint32_t  SADISABLE  :  1;               /*!< Slave Address 2 Disable.                                              */
      __IO uint32_t  SLVADR     :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled.                                                 */
    } SLVADR2_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVADR3;                         /*!< Slave address 3.                                                      */

    struct {
      __IO uint32_t  SADISABLE  :  1;               /*!< Slave Address 3 Disable.                                              */
      __IO uint32_t  SLVADR     :  7;               /*!< Slave Address. Seven bit slave address that is compared to received
                                                         addresses if enabled.                                                 */
    } SLVADR3_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SLVQUAL0;                        /*!< Slave Qualification for address 0.                                    */

    struct {
      __IO uint32_t  QUALMODE0  :  1;               /*!< Qualify mode for slave address 0.                                     */
      __IO uint32_t  SLVQUAL0   :  7;               /*!< Slave address Qualifier for address 0. A value of 0 causes the
                                                         address in SLVADR0 to be used as-is, assuming that it is enabled.
                                                          If QUALMODE0 = 0, any bit in this field which is set to 1 will
                                                          cause an automatic match of the corresponding bit of the received
                                                          address when it is compared to the SLVADR0 register. If QUALMODE0
                                                          = 1, an address range is matched for address 0. This range extends
                                                          from the value defined by SLVADR0 to the address defined by
                                                          SLVQUAL0 (address matches when SLVADR0[7:1] received address         */
    } SLVQUAL0_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[9];

  union {
    __I  uint32_t  MONRXDAT;                        /*!< Monitor receiver data register.                                       */

    struct {
      __I  uint32_t  MONRXDAT   :  8;               /*!< Monitor function Receiver Data. This reflects every data byte
                                                         that passes on the I2C pins.                                          */
      __I  uint32_t  MONSTART   :  1;               /*!< Monitor Received Start.                                               */
      __I  uint32_t  MONRESTART :  1;               /*!< Monitor Received Repeated Start.                                      */
      __I  uint32_t  MONNACK    :  1;               /*!< Monitor Received NACK.                                                */
    } MONRXDAT_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[990];

  union {
    __I  uint32_t  ID;                              /*!< I2C Module Identifier                                                 */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } ID_b;                                         /*!< BitSize                                                               */
  };
} u2_i2c_Type;


/* ================================================================================ */
/* ================                    u_iso7816                   ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component iso7816 It is an ISO7816 controller with APB bus interface. More details will follow. (u_iso7816)
  */

typedef struct {                                    /*!< u_iso7816 Structure                                                   */

  union {
    __IO uint32_t  SSR;                             /*!< Slot Select Register                                                  */

    struct {
      __IO uint32_t  SOFTRESETN :  1;               /*!< When set to logic 0 this bit resets the whole Contact UART (software
                                                         reset), sets to logic 1 automatically by hardware after after
                                                          one clock cycle if slot 1 is not activated else after one clock
                                                          cycle after slot 1 has been automatically deactivated. Software
                                                          should check soft reset is finished by reading SSR register
                                                          before any further action.                                           */
    } SSR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PDR1_LSB;                        /*!< Programmable Divider Register (LSB) slot 1. Least significant
                                                         byte of a 16-bit counter defining the ETU. The ETU counter counts
                                                          a number of cycles of the Contact Interface clock, this defines
                                                          the ETU. The minimum acceptable value is 0001 0000b.                 */

    struct {
      __IO uint32_t  PDR1_LSB   : 32;               /*!< Programmable Divider Register (LSB) slot 1. Least significant
                                                         byte of a 16-bit counter defining the ETU. The ETU counter counts
                                                          a number of cycles of the Contact Interface clock, this defines
                                                          the ETU. The minimum acceptable value is 0001 0000b.                 */
    } PDR1_LSB_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PDR1_MSB;                        /*!< Programmable Divider Register (MSB) slot 1. Most significant
                                                         byte of a 16-bit counter defining the ETU. The ETU counter counts
                                                          a number of cycles of the Contact Interface clock, this defines
                                                          the ETU                                                              */

    struct {
      __IO uint32_t  PDR1_MSB   : 32;               /*!< Programmable Divider Register (MSB) slot 1. Most significant
                                                         byte of a 16-bit counter defining the ETU. The ETU counter counts
                                                          a number of cycles of the Contact Interface clock, this defines
                                                          the ETU                                                              */
    } PDR1_MSB_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FCR;                             /*!< FIFO Control Register                                                 */

    struct {
      __IO uint32_t  FTC        :  5;               /*!< FIFO Threshold Configuration: Define the number of received
                                                         or transmitted characters in the FIFO triggering the ft bit
                                                          in USR1. The FIFO depth is 32 bytes. In reception mode, it enables
                                                          to know that a number equals to ftc(4:0) + 1 bytes have been
                                                          received. In transmission mode, ftc(4:0) equals to the number
                                                          of remaining bytes into the FIFO. Be careful: in reception mode
                                                          00000 = length 1, and in transmission mode 00000 = length 0.         */
      __IO uint32_t  PEC        :  3;               /*!< Parity Error Count - In protocol T = 0: Set the number of allowed
                                                         repetitions in reception or transmission mode before setting
                                                          pe in ct_usr1_reg. The value 000 indicates that, if only one
                                                          parity error has occurred, bit pe is set at logic 1; the value
                                                          111 indicates that bit pe will be set at logic 1 after 8 parity
                                                          errors. If a correct character is received before the programmed
                                                          error number is reached, the error counter will be reset. If
                                                          the programmed number of allowed parity errors is reached, bit
                                                          pe in r                                                              */
    } FCR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  GTR1;                            /*!< Guard Time Register slot 1. Value used by the Contact UART notably
                                                         in transmission mode. The Contact UART will wait this number
                                                          of ETUs before transmitting the character. In protocol T=1,
                                                          gtr = FFh means operation at 11 ETUs. In protocol T=0, gtr =
                                                          FFh means operation at 12 ETUs.                                      */

    struct {
      __IO uint32_t  GTR1       : 32;               /*!< Guard Time Register slot 1. Value used by the Contact UART notably
                                                         in transmission mode. The Contact UART will wait this number
                                                          of ETUs before transmitting the character. In protocol T=1,
                                                          gtr = FFh means operation at 11 ETUs. In protocol T=0, gtr =
                                                          FFh means operation at 12 ETUs.                                      */
    } GTR1_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  UCR11;                           /*!< UART Configuration Register 1 slot 1                                  */

    struct {
      __IO uint32_t  CONV       :  1;               /*!< CONVention: Bit CONV is set to logic 1 if the convention is
                                                         direct. Bit CONV is either automatically written by hardware
                                                          according to the convention detected during ATR, or by software
                                                          if the bit AUTOCONV in register ct_ucr1_reg is set to logic
                                                          1.                                                                   */
      __IO uint32_t  LCT        :  1;               /*!< Last Character to Transmit: Bit LCT is set to logic 1 by software
                                                         before writing the last character to be transmitted in register
                                                          ct_utr_reg. It allows automatic change to reception mode. It
                                                          is reset to logic 0 by hardware at the end of a successful transmission
                                                          after 11.75 ETUs in protocol T = 0 and after 10.75 ETUs in protocol
                                                          T = 1. When bit LCT is being reset to logic 0, bit T/R is also
                                                          reset to logic 0 and the UART is ready to receive a character.
                                                          LCT bit can be set to logic 1 by software not only whe               */
      __IO uint32_t  T_R        :  1;               /*!< Transmit/Receive: Defines the mode: logic 1 means transmission
                                                         and logic 0 reception. Bit T/R is set by software for transmission
                                                          mode. Bit T/R is automatically reset to logic 0 by hardware,
                                                          if bit LCT has been used before transmitting the last character.
                                                          Note that when switching from/to reception to/from transmission
                                                          mode, the FIFO is flushed. Any remaining bytes are lost.             */
      __IO uint32_t  PROT       :  1;               /*!< PROTocol: Selects the protocol: logic 1 means T=1 and logic
                                                         0 T=0.                                                                */
      __IO uint32_t  FC         :  1;               /*!< Described in a separated document.                                    */
      __IO uint32_t  FIP        :  1;               /*!< Force Inverse Parity: If bit FIP is set to logic 1, the Contact
                                                         UART will NAK a correctly received character, and will transmit
                                                          characters with wrong parity bits.                                   */
    } UCR11_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  UCR21;                           /*!< UART Configuration Register 2 slot 1                                  */

    struct {
      __IO uint32_t  AUTOCONVN  :  1;               /*!< AUTOmatically detected CONVention: If bit AUTOCONV = 1, then
                                                         the convention is set by software using bit CONV in register
                                                          ct_ucr1_reg. If the bit is reset to logic 0, then the configuration
                                                          is automatically detected on the first received character and
                                                          the bit automatically set after convention detection.                */
      __IO uint32_t  MANBGT     :  1;               /*!< MANual BGT: When set to logic 1, BGT is managed by software,
                                                         else by hardware.                                                     */
      __IO uint32_t  DISFT      :  1;               /*!< DISable Fifo Threshold interrupt bit: When set to logic 1 the
                                                         bit ft in register ct_usr1_reg will not generate interrupt.           */
      __IO uint32_t  DISPE      :  1;               /*!< DISable Parity Error interrupt bit: When set to logic 1, the
                                                         parity is not checked in both reception and transmission modes,
                                                          the bit pe in register ct_usr1_reg will not generate interrupt.      */
      __IO uint32_t  DISATRCOUNTER:  1;             /*!< DISable ATR counter: - Slot 1: When set to logic 1 the bits
                                                         EARLY and MUTE in register ct_usr1_reg will not generate interrupt.
                                                          This bit should be set before activating.                            */
           uint32_t             :  1;
      __IO uint32_t  FIFOFLUSH  :  1;               /*!< FIFO flush: When set to logic 1, the FIFO is flushed whatever
                                                         the mode (reception or transmission) is. It can be used before
                                                          any reception or transmission of characters but not while receiving
                                                          or transmitting a character. It is reset to logic 0 by hardware
                                                          after one clk_ip cycle.                                              */
      __IO uint32_t  WRDACC     :  1;               /*!< FIFO WoRD ACCess: When set to logic 1, the FIFO supports word
                                                         (4 bytes) access (read and write), access failure is indicated
                                                          by bit wrdaccerr in register USR2. When set to logic 0, the
                                                          FIFO supports byte access (read and write).                          */
    } UCR21_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CCR1;                            /*!< Clock Configuration Register slot 1                                   */

    struct {
      __IO uint32_t  ACC        :  3;               /*!< Asynchronous Card Clock: Defines the card clock frequency: 000:
                                                         card clock frequency = fclk_ip 001: card clock frequency = fclk_ip
                                                          /2 010: card clock frequency = fclk_ip /3 011: card clock frequency
                                                          = fclk_ip /4 100: card clock frequency = fclk_ip /5 101: card
                                                          clock frequency = fclk_ip /6 110: card clock frequency = fclk_ip
                                                          /8 111: card clock frequency = fclk_ip /16 All frequency changes
                                                          are synchronous, thus ensuring that no spikes or unwanted pulse
                                                          widths occur during changes. In conjunction with registe             */
      __IO uint32_t  SAN        :  1;               /*!< Synchronous/Asynchronous Card: - Slot 1: When set to logic 1,
                                                         the Contact UART supports synchronous card. The Contact UART
                                                          is then bypassed, only bit 0 of registers ct_urr_reg and ct_utr_reg
                                                          is connected to pin I/O. In this case, the card clock is controlled
                                                          by bit SHL and RST card is controlled by bit RSTIN in register
                                                          ct_pcr_reg. When set to logic 0, the Contact UART supports asynchronous
                                                          card. Dynamic change (while activated) is not supported. The
                                                          choice should be done before activating the card. - Slot             */
      __IO uint32_t  CST        :  1;               /*!< Clock STop: - Slot 1: In the case of an asynchronous card, bit
                                                         CST defines whether the clock to the card is stopped or not;
                                                          if bit CST is reset to logic 0, then the clock is determined
                                                          by bits ACC0, ACC1 and ACC2. - Slot AUX: This bit is not available
                                                          for the auxiliary slot (ct_ccr2_reg) since clock stop feature
                                                          is supported using CLKAUXen bit in ct_ssr_reg register.              */
      __IO uint32_t  SHL        :  1;               /*!< Stop HIGH or LOW: - Slot 1: If bits SAN = 0 and CST = 1, then
                                                         the clock is stopped at LOW level if bit SHL = 0, and at HIGH
                                                          level if bit SHL = 1. If bit SAN = 1, then contact CLK is the
                                                          copy of the value of bit SHL.                                        */
    } CCR1_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCR;                             /*!< Power Control Register                                                */

    struct {
      __IO uint32_t  PCR        : 32;               /*!< Power Control Register                                                */
    } PCR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ECR;                             /*!< Early answer Counter register                                         */

    struct {
      __IO uint32_t  ECR        : 32;               /*!< Early answer Counter register                                         */
    } ECR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MCRL_LSB;                        /*!< Mute card Counter RST Low register (LSB)                              */

    struct {
      __IO uint32_t  MCRL_LSB   : 32;               /*!< Mute card Counter RST Low register (LSB)                              */
    } MCRL_LSB_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MCRL_MSB;                        /*!< Mute card Counter RST Low register (MSB)                              */

    struct {
      __IO uint32_t  MCRL_MSB   : 32;               /*!< Mute card Counter RST Low register (MSB)                              */
    } MCRL_MSB_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MCRH_LSB;                        /*!< Mute card Counter RST High register (LSB)                             */

    struct {
      __IO uint32_t  MCRH_LSB   : 32;               /*!< Mute card Counter RST High register (LSB)                             */
    } MCRH_LSB_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MCRH_MSB;                        /*!< Mute card Counter RST High register (MSB)                             */

    struct {
      __IO uint32_t  MCRH_MSB   : 32;               /*!< Mute card Counter RST High register (MSB)                             */
    } MCRH_MSB_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SRR;                             /*!< Slew Rate configuration Register                                      */

    struct {
      __IO uint32_t  SRR        : 32;               /*!< Slew Rate configuration Register                                      */
    } SRR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  URR_UTR;                         /*!< UART Receive Register / UART Transmit Register                        */

    struct {
      __IO uint32_t  URR_UTR    : 32;               /*!< UART Receive Register / UART Transmit Register                        */
    } URR_UTR_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[3];

  union {
    __O  uint32_t  TOR1;                            /*!< Time-Out Register 1                                                   */

    struct {
      __O  uint32_t  TOR1       : 32;               /*!< Time-Out Register 1                                                   */
    } TOR1_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  TOR2;                            /*!< Time-Out Register 2                                                   */

    struct {
      __O  uint32_t  TOR2       : 32;               /*!< Time-Out Register 2                                                   */
    } TOR2_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  TOR3;                            /*!< Time-Out Register 3                                                   */

    struct {
      __O  uint32_t  TOR3       : 32;               /*!< Time-Out Register 3                                                   */
    } TOR3_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TOC;                             /*!< Time-Out Configuration register                                       */

    struct {
      __IO uint32_t  TOC        : 32;               /*!< Time-Out Configuration register                                       */
    } TOC_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FSR;                             /*!< FIFO Status Register                                                  */

    struct {
      __I  uint32_t  FSR        : 32;               /*!< FIFO Status Register                                                  */
    } FSR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  MSR;                             /*!< Mixed Status Register                                                 */

    struct {
      __I  uint32_t  MSR        : 32;               /*!< Mixed Status Register                                                 */
    } MSR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  USR1;                            /*!< UART Status Register 1                                                */

    struct {
      __I  uint32_t  USR1       : 32;               /*!< UART Status Register 1                                                */
    } USR1_b;                                       /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  USR2;                            /*!< UART Status Register 2                                                */

    struct {
      __I  uint32_t  USR2       : 32;               /*!< UART Status Register 2                                                */
    } USR2_b;                                       /*!< BitSize                                                               */
  };
} u_iso7816_Type;


/* ================================================================================ */
/* ================                    u_cic_irb                   ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component cic_irb. It is an Infra Red Blaster Controller with a VPB bus interface. More details will follow. (u_cic_irb)
  */

typedef struct {                                    /*!< u_cic_irb Structure                                                   */

  union {
    __IO uint32_t  CONF;                            /*!< IR Blaster configuration                                              */

    struct {
      __IO uint32_t  ENV_INI    :  1;               /*!< Initial envelope value. This is the level of the first envelope
                                                         after IR Blaster start or restart.                                    */
      __IO uint32_t  MODE       :  1;               /*!< Blaster mode                                                          */
      __IO uint32_t  OUT        :  2;               /*!< Output logic function                                                 */
      __IO uint32_t  NO_CAR     :  1;               /*!< No carrier                                                            */
      __IO uint32_t  CAR_INI    :  1;               /*!< Initial carrier value.                                                */
    } CONF_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CARRIER;                         /*!< IR Blaster carrier configuration                                      */

    struct {
      __IO uint32_t  CTU        : 16;               /*!< Carrier Time Unit (CTU) CTU = CTU * TIRCP, TIRCP = IR module
                                                         clock period = 1/48MHz. Value 0x0 is equivalent to 0x1. It is
                                                          recommended to modify this field when the blaster unit is disable
                                                          (i.e when ENA_ST = '0' in STATUS register)                           */
      __IO uint32_t  CLOW       :  3;               /*!< Carrier low period. Carrier low level duration = (CLOW + 1)
                                                         * CTU It is recommended to modify this field when the blaster
                                                          unit is disable (i.e when ENA_ST = '0' in STATUS register)           */
      __IO uint32_t  CHIGH      :  2;               /*!< Carrier high period Carrier high level duration = (CHIGH + 1)
                                                         * CTU It is recommended to modify this field when the blaster
                                                          unit is disable (i.e when ENA_ST = '0' in STATUS register)           */
    } CARRIER_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFO_IN;                         /*!< IR Blaster Envelope FIFO input                                        */

    struct {
      __IO uint32_t  ENV        : 12;               /*!< Envelope duration expressed in carrier period number. Tenvelope
                                                         = ENV * (CHIGH + CLOW + 2 ) * CTU Value 0x000 has the same behaviour
                                                          has value 0x001.                                                     */
      __IO uint32_t  ENV_INT    :  1;               /*!< Generate an interrupt when starting emission of the envelope          */
      __IO uint32_t  ENV_LAST   :  1;               /*!< Last envelope.                                                        */
    } FIFO_IN_b;                                    /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  STATUS;                          /*!< IR Blaster Status                                                     */

    struct {
      __I  uint32_t  FIFO_LVL   :  5;               /*!< Current IR Blaster FIFO level                                         */
      __I  uint32_t  FIFO_FULL  :  1;               /*!< IR Blaster FIFO full flag                                             */
      __I  uint32_t  FIFO_EMPTY :  1;               /*!< IR Blaster FIFO empty flag                                            */
      __I  uint32_t  ENA_ST     :  1;               /*!< IR Blaster status                                                     */
      __I  uint32_t  RUN_ST     :  1;               /*!< IR Blaster run status                                                 */
    } STATUS_b;                                     /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  CMD;                             /*!< IR Blaster Commands                                                   */

    struct {
      __O  uint32_t  ENA        :  1;               /*!< Enable IR Blaster. This bit is self clearing.                         */
      __O  uint32_t  DIS        :  1;               /*!< Disable IR Blaster. This bit is self clearing.                        */
      __O  uint32_t  START      :  1;               /*!< Start IR Blaster. This bit is self clearing.                          */
      __O  uint32_t  FIFO_RST   :  1;               /*!< Reset IR Blaster FIFO. This bit is self clearing.                     */
    } CMD_b;                                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[1011];

  union {
    __I  uint32_t  INT_STATUS;                      /*!< Interrupt Status                                                      */

    struct {
      __I  uint32_t  ENV_START_INT:  1;             /*!< IR Blaster has started to transmit an envelope with ENV_INT
                                                         bit = '1                                                              */
      __I  uint32_t  ENV_LAST_INT:  1;              /*!< IR Blaster has finished to transmit an envelope with ENV_LAST
                                                         bit = '1'.                                                            */
      __I  uint32_t  FIFO_UFL_INT:  1;              /*!< IR Blaster FIFO underflow. IR Blaster has tried to transmit
                                                         a data but the FIFO was empty.                                        */
    } INT_STATUS_b;                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INT_ENA;                         /*!< Interrupt Enable                                                      */

    struct {
      __IO uint32_t  ENV_START_ENA:  1;             /*!< Enable/Disable ENV_START interrupt                                    */
      __IO uint32_t  ENV_LAST_ENA:  1;              /*!< Enable/Disable ENV_LAST interrupt                                     */
      __IO uint32_t  FIFO_UFL_ENA:  1;              /*!< Enable/Disable FIFO_UFL interrupt                                     */
    } INT_ENA_b;                                    /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  INT_CLR;                         /*!< Interrupt Clear                                                       */

    struct {
      __O  uint32_t  ENV_START_CLR:  1;             /*!< Clear ENV_START interrupt                                             */
      __O  uint32_t  ENV_LAST_CLR:  1;              /*!< Clear ENV_LAST interrupt                                              */
      __O  uint32_t  FIFO_UFL_CLR:  1;              /*!< Clear FIFO_UFL interrupt                                              */
    } INT_CLR_b;                                    /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  INT_SET;                         /*!< Interrupt Set                                                         */

    struct {
      __O  uint32_t  ENV_START_SET:  1;             /*!< Set ENV_START interrupt                                               */
      __O  uint32_t  ENV_LAST_SET:  1;              /*!< Set ENV_LAST interrupt                                                */
      __O  uint32_t  FIFO_UFL_SET:  1;              /*!< Set FIFO_UFL interrupt                                                */
    } INT_SET_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[3];

  union {
    __I  uint32_t  MODULE_ID;                       /*!< IR Blaster Module Identifier                                          */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } MODULE_ID_b;                                  /*!< BitSize                                                               */
  };
} u_cic_irb_Type;


/* ================================================================================ */
/* ================                   u_codepatch                  ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component input mux. . More details will follow. (u_codepatch)
  */

typedef struct {                                    /*!< u_codepatch Structure                                                 */

  union {
    __IO uint32_t  PATCH_CONTROL_REG;               /*!< A bit to Enable/disable Patch operation                               */

    struct {
      __IO uint32_t  PATCH_EN   :  1;               /*!< Used to Enable/Disable patch operation. It is independent of
                                                         the Remap operation. If patch_en = 1 Patch operation is enabled.
                                                          If patch_en = 0 Patch operation is disabled.                         */
    } PATCH_CONTROL_REG_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CONTROL_1_REG;                   /*!< Commands to Enable/Disable the OFFSET_XX_REG (Patch 1 to Patch
                                                         32)                                                                   */

    struct {
      __IO uint32_t  ENABLE_PATCH_1:  1;            /*!< Enable/Disable Patch 1                                                */
      __IO uint32_t  ENABLE_PATCH_2:  1;            /*!< Enable/Disable Patch 2                                                */
      __IO uint32_t  ENABLE_PATCH_3:  1;            /*!< Enable/Disable Patch 3                                                */
      __IO uint32_t  ENABLE_PATCH_4:  1;            /*!< Enable/Disable Patch 4                                                */
      __IO uint32_t  ENABLE_PATCH_5:  1;            /*!< Enable/Disable Patch 5                                                */
      __IO uint32_t  ENABLE_PATCH_6:  1;            /*!< Enable/Disable Patch 6                                                */
      __IO uint32_t  ENABLE_PATCH_7:  1;            /*!< Enable/Disable Patch 7                                                */
      __IO uint32_t  ENABLE_PATCH_8:  1;            /*!< Enable/Disable Patch 8                                                */
      __IO uint32_t  ENABLE_PATCH_9:  1;            /*!< Enable/Disable Patch 9                                                */
      __IO uint32_t  ENABLE_PATCH_10:  1;           /*!< Enable/Disable Patch 10                                               */
      __IO uint32_t  ENABLE_PATCH_11:  1;           /*!< Enable/Disable Patch 11                                               */
      __IO uint32_t  ENABLE_PATCH_12:  1;           /*!< Enable/Disable Patch 12                                               */
      __IO uint32_t  ENABLE_PATCH_13:  1;           /*!< Enable/Disable Patch 13                                               */
      __IO uint32_t  ENABLE_PATCH_14:  1;           /*!< Enable/Disable Patch 14                                               */
      __IO uint32_t  ENABLE_PATCH_15:  1;           /*!< Enable/Disable Patch 15                                               */
      __IO uint32_t  ENABLE_PATCH_16:  1;           /*!< Enable/Disable Patch 16                                               */
      __IO uint32_t  ENABLE_PATCH_17:  1;           /*!< Enable/Disable Patch 17                                               */
      __IO uint32_t  ENABLE_PATCH_18:  1;           /*!< Enable/Disable Patch 18                                               */
      __IO uint32_t  ENABLE_PATCH_19:  1;           /*!< Enable/Disable Patch 19                                               */
      __IO uint32_t  ENABLE_PATCH_20:  1;           /*!< Enable/Disable Patch 20                                               */
      __IO uint32_t  ENABLE_PATCH_21:  1;           /*!< Enable/Disable Patch 21                                               */
      __IO uint32_t  ENABLE_PATCH_22:  1;           /*!< Enable/Disable Patch 22                                               */
      __IO uint32_t  ENABLE_PATCH_23:  1;           /*!< Enable/Disable Patch 23                                               */
      __IO uint32_t  ENABLE_PATCH_24:  1;           /*!< Enable/Disable Patch 24                                               */
      __IO uint32_t  ENABLE_PATCH_25:  1;           /*!< Enable/Disable Patch 25                                               */
      __IO uint32_t  ENABLE_PATCH_26:  1;           /*!< Enable/Disable Patch 26                                               */
      __IO uint32_t  ENABLE_PATCH_27:  1;           /*!< Enable/Disable Patch 27                                               */
      __IO uint32_t  ENABLE_PATCH_28:  1;           /*!< Enable/Disable Patch 28                                               */
      __IO uint32_t  ENABLE_PATCH_29:  1;           /*!< Enable/Disable Patch 29                                               */
      __IO uint32_t  ENABLE_PATCH_30:  1;           /*!< Enable/Disable Patch 30                                               */
      __IO uint32_t  ENABLE_PATCH_31:  1;           /*!< Enable/Disable Patch 31                                               */
      __IO uint32_t  ENABLE_PATCH_32:  1;           /*!< Enable/Disable Patch 32                                               */
    } CONTROL_1_REG_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CONTROL_2_REG;                   /*!< Commands to Enable/Disable the OFFSET_XX_REG (Patch 33 to Patch
                                                         48)                                                                   */

    struct {
      __IO uint32_t  ENABLE_PATCH_33:  1;           /*!< Enable/Disable Patch 33                                               */
      __IO uint32_t  ENABLE_PATCH_34:  1;           /*!< Enable/Disable Patch 34                                               */
      __IO uint32_t  ENABLE_PATCH_35:  1;           /*!< Enable/Disable Patch 35                                               */
      __IO uint32_t  ENABLE_PATCH_36:  1;           /*!< Enable/Disable Patch 36                                               */
      __IO uint32_t  ENABLE_PATCH_37:  1;           /*!< Enable/Disable Patch 37                                               */
      __IO uint32_t  ENABLE_PATCH_38:  1;           /*!< Enable/Disable Patch 38                                               */
      __IO uint32_t  ENABLE_PATCH_39:  1;           /*!< Enable/Disable Patch 39                                               */
      __IO uint32_t  ENABLE_PATCH_40:  1;           /*!< Enable/Disable Patch 40                                               */
      __IO uint32_t  ENABLE_PATCH_41:  1;           /*!< Enable/Disable Patch 41                                               */
      __IO uint32_t  ENABLE_PATCH_42:  1;           /*!< Enable/Disable Patch 42                                               */
      __IO uint32_t  ENABLE_PATCH_43:  1;           /*!< Enable/Disable Patch 43                                               */
      __IO uint32_t  ENABLE_PATCH_44:  1;           /*!< Enable/Disable Patch 44                                               */
      __IO uint32_t  ENABLE_PATCH_45:  1;           /*!< Enable/Disable Patch 45                                               */
      __IO uint32_t  ENABLE_PATCH_46:  1;           /*!< Enable/Disable Patch 46                                               */
      __IO uint32_t  ENABLE_PATCH_47:  1;           /*!< Enable/Disable Patch 47                                               */
      __IO uint32_t  ENABLE_PATCH_48:  1;           /*!< Enable/Disable Patch 48                                               */
    } CONTROL_2_REG_b;                              /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  TRAP_STATUS_REG;                 /*!< Status register to indicate the latest last 2 traps to the Code
                                                         patch Vector                                                          */

    struct {
      __I  uint32_t  LAST_TRAP_0:  7;               /*!< Indicates the Last trap code patch vector Number                      */
           uint32_t             :  1;
      __I  uint32_t  LAST_TRAP_1:  7;               /*!< Indicates the Last before one trap code patch vector Number           */
    } TRAP_STATUS_REG_b;                            /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  VT_REMAP_REG;                    /*!< Command to Enable/Disable the Vector Table Remap                      */

    struct {
      __IO uint32_t  VT_REMAP_EN:  1;               /*!< Bit used to Enable/Disable the Vector Table Remap                     */
    } VT_REMAP_REG_b;                               /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[2];

  union {
    __IO uint32_t  TESTBUS_SEL_REG;                 /*!< Register used for the Testbus Select line                             */

    struct {
      __IO uint32_t  TESTBUS_SEL_REG: 32;           /*!< Register used for the Testbus Select line                             */
    } TESTBUS_SEL_REG_b;                            /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  OFFSET_REG[48];                  /*!< Stores the offset address for Patch n with equivalent HEX value
                                                         of SVC n instruction                                                  */

    struct {
      __IO uint32_t  OFFSET_ADDR: 18;               /*!< Offset address for Patch                                              */
    } OFFSET_REG_b[48];                             /*!< BitSize                                                               */
  };
} u_codepatch_Type;


/* ================================================================================ */
/* ================                     u_flash                    ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component input mux. . More details will follow. (u_flash)
  */

typedef struct {                                    /*!< u_flash Structure                                                     */

  union {
    __O  uint32_t  CMD;                             /*!< command register                                                      */

    struct {
      __O  uint32_t  CMD        : 32;               /*!< command register                                                      */
    } CMD_b;                                        /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  EVENT;                           /*!< event register                                                        */

    struct {
      __O  uint32_t  RST        :  1;               /*!< When bit is set, the controller and flash are reset.                  */
      __O  uint32_t  WAKEUP     :  1;               /*!< When bit is set, the controller wakes up from whatever low power
                                                         or powerdown mode was active. If not in a powerdown mode, this
                                                          bit has no effect.                                                   */
      __O  uint32_t  ABORT      :  1;               /*!< When bit is set, a running program/erase command is aborted.          */
    } EVENT_b;                                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;

  union {
    __IO uint32_t  AUTOPROG;                        /*!< specifies what commands are performed on AHB write                    */

    struct {
      __IO uint32_t  AUTOPROG   :  2;               /*!< 00: auto programming switched off 01: execute write word 10:
                                                         execute write word then, if the last word in a page was written,
                                                          program page 11: reserved for future use / no action.                */
    } AUTOPROG_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STARTA;                          /*!< start (or only) address for next flash command                        */

    struct {
      __IO uint32_t  STARTA     : 18;               /*!< Address / Start address for commands that take an address (range)
                                                         as a parameter. The address is in units of memory words, not
                                                          bytes.                                                               */
    } STARTA_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STOPA;                           /*!< end address for next flash command, if command operates on address
                                                         ranges                                                                */

    struct {
      __IO uint32_t  STOPA      : 18;               /*!< Stop address for commands that take an address range as a parameter
                                                         (the word specified by STOPA is included in the address range).
                                                          The address is in units of memory words, not bytes.                  */
    } STOPA_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TEST;                            /*!< test configuration register                                           */

    struct {
      __IO uint32_t  DCM1       :  8;               /*!< These bit fields select which internal signal is brought onto
                                                         the DCM1/2 pads                                                       */
      __IO uint32_t  DCM2       :  8;               /*!< These bit fields select which internal signal is brought onto
                                                         the DCM1/2 pads                                                       */
      __IO uint32_t  EXT48      :  1;               /*!< This bit controls the extclk48mhz controller output                   */
    } TEST_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PARW;                            /*!< parity register; Memory parity data.                                  */

    struct {
      __IO uint32_t  PARW       : 32;               /*!< parity register; Memory parity data.                                  */
    } PARW_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FSQ[4];                          /*!< Flexible SeQuence register 0-3                                        */

    struct {
      __IO uint32_t  ST1        :  8;               /*!< Start state of sub-sequence 1                                         */
      __IO uint32_t  EN1        :  8;               /*!< End state of sub-sequence 1                                           */
      __IO uint32_t  ST2        :  8;               /*!< Start state of sub-sequence 2                                         */
      __IO uint32_t  EN2        :  8;               /*!< End state of sub-sequence 2                                           */
    } FSQ_b[4];                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[20];

  union {
    __IO uint32_t  DATAW[8];                        /*!< data register, word 0-7; Memory data, or command parameter,
                                                         or command result.                                                    */

    struct {
      __IO uint32_t  DATAW      : 32;               /*!< data register, word 0-7; Memory data, or command parameter,
                                                         or command result.                                                    */
    } DATAW_b[8];                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[974];

  union {
    __O  uint32_t  INT_CLR_ENABLE;                  /*!< Clear interrupt enable bits                                           */

    struct {
      __O  uint32_t  FAIL       :  1;               /*!< When a CLR_ENABLE bit is written to 1, the corresponding INT_ENABLE
                                                         bit is cleared                                                        */
      __O  uint32_t  ERR        :  1;               /*!< When a CLR_ENABLE bit is written to 1, the corresponding INT_ENABLE
                                                         bit is cleared                                                        */
      __O  uint32_t  DONE       :  1;               /*!< When a CLR_ENABLE bit is written to 1, the corresponding INT_ENABLE
                                                         bit is cleared                                                        */
      __O  uint32_t  ECC_ERR    :  1;               /*!< When a CLR_ENABLE bit is written to 1, the corresponding INT_ENABLE
                                                         bit is cleared                                                        */
    } INT_CLR_ENABLE_b;                             /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  INT_SET_ENABLE;                  /*!< Set interrupt enable bits                                             */

    struct {
      __O  uint32_t  FAIL       :  1;               /*!< When a SET_ENABLE bit is written to 1, the corresponding INT_ENABLE
                                                         bit is set                                                            */
      __O  uint32_t  ERR        :  1;               /*!< When a SET_ENABLE bit is written to 1, the corresponding INT_ENABLE
                                                         bit is set                                                            */
      __O  uint32_t  DONE       :  1;               /*!< When a SET_ENABLE bit is written to 1, the corresponding INT_ENABLE
                                                         bit is set                                                            */
      __O  uint32_t  ECC_ERR    :  1;               /*!< When a SET_ENABLE bit is written to 1, the corresponding INT_ENABLE
                                                         bit is set                                                            */
    } INT_SET_ENABLE_b;                             /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  INT_STATUS;                      /*!< Interrupt status bits                                                 */

    struct {
      __I  uint32_t  FAIL       :  1;               /*!< This status bit is set if execution of a (legal) command failed.
                                                         The flag can be set at any time during command execution, not
                                                          just at the end.                                                     */
      __I  uint32_t  ERR        :  1;               /*!< This status bit is set if execution of an illegal command is
                                                         detected. A command is illegal if it is unknown, or it is not
                                                          allowed in the current mode, or it is violating access restrictions,
                                                          or it has invalid parameters.                                        */
      __I  uint32_t  DONE       :  1;               /*!< This status bit is set at the end of command execution                */
      __I  uint32_t  ECC_ERR    :  1;               /*!< This status bit is set if, during a memory read operation (either
                                                         a user-requested read, or a speculative read, or reads performed
                                                          by a controller command), a correctable or uncorrectable error
                                                          is detected by ECC decoding logic.                                   */
    } INT_STATUS_b;                                 /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  INT_ENABLE;                      /*!< Interrupt enable bits                                                 */

    struct {
      __I  uint32_t  FAIL       :  1;               /*!< If an INT_ENABLE bit is set, an interrupt request will be generated
                                                         if the corresponding INT_STATUS bit is high.                          */
      __I  uint32_t  ERR        :  1;               /*!< If an INT_ENABLE bit is set, an interrupt request will be generated
                                                         if the corresponding INT_STATUS bit is high.                          */
      __I  uint32_t  DONE       :  1;               /*!< If an INT_ENABLE bit is set, an interrupt request will be generated
                                                         if the corresponding INT_STATUS bit is high.                          */
      __I  uint32_t  ECC_ERR    :  1;               /*!< If an INT_ENABLE bit is set, an interrupt request will be generated
                                                         if the corresponding INT_STATUS bit is high.                          */
    } INT_ENABLE_b;                                 /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  INT_CLR_STATUS;                  /*!< Clear interrupt status bits                                           */

    struct {
      __O  uint32_t  FAIL       :  1;               /*!< When a CLR_STATUS bit is written to 1, the corresponding INT_STATUS
                                                         bit is cleared                                                        */
      __O  uint32_t  ERR        :  1;               /*!< When a CLR_STATUS bit is written to 1, the corresponding INT_STATUS
                                                         bit is cleared                                                        */
      __O  uint32_t  DONE       :  1;               /*!< When a CLR_STATUS bit is written to 1, the corresponding INT_STATUS
                                                         bit is cleared                                                        */
      __O  uint32_t  ECC_ERR    :  1;               /*!< When a CLR_STATUS bit is written to 1, the corresponding INT_STATUS
                                                         bit is cleared                                                        */
    } INT_CLR_STATUS_b;                             /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  INT_SET_STATUS;                  /*!< Set interrupt status bits                                             */

    struct {
      __O  uint32_t  FAIL       :  1;               /*!< When a SET_STATUS bit is written to 1, the corresponding INT_STATUS
                                                         bit is set                                                            */
      __O  uint32_t  ERR        :  1;               /*!< When a SET_STATUS bit is written to 1, the corresponding INT_STATUS
                                                         bit is set                                                            */
      __O  uint32_t  DONE       :  1;               /*!< When a SET_STATUS bit is written to 1, the corresponding INT_STATUS
                                                         bit is set                                                            */
      __O  uint32_t  ECC_ERR    :  1;               /*!< When a SET_STATUS bit is written to 1, the corresponding INT_STATUS
                                                         bit is set                                                            */
    } INT_SET_STATUS_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[3];

  union {
    __I  uint32_t  MODULE_ID;                       /*!< Controller+Memory module identification                               */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MINOR_REV  :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJOR_REV  :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } MODULE_ID_b;                                  /*!< BitSize                                                               */
  };
} u_flash_Type;


/* ================================================================================ */
/* ================                     u_wwdt                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component wwdt It is an Windowed Watchdog Timer with APB bus interface. More details will follow. (u_wwdt)
  */

typedef struct {                                    /*!< u_wwdt Structure                                                      */

  union {
    __IO uint32_t  MOD;                             /*!< Watchdog mode register. This register contains the basic mode
                                                         and status of the Watchdog Timer.                                     */

    struct {
      __IO uint32_t  WDEN       :  1;               /*!< Watchdog enable bit. Once this bit is set to one and a watchdog
                                                         feed is performed, the watchdog timer will run permanently.
                                                          0 Stop. The watchdog timer is stopped. 1 Run. The watchdog timer
                                                          is running.                                                          */
      __IO uint32_t  WDRESET    :  1;               /*!< Watchdog reset enable bit. Once this bit has been written with
                                                         a 1 it cannot be re-written with a 0. 0 Interrupt. A watchdog
                                                          time-out will not cause a chip reset. 1 Reset. A watchdog time-out
                                                          will cause a chip reset.                                             */
      __IO uint32_t  WDTOF      :  1;               /*!< Watchdog time-out flag. Set when the watchdog timer times out,
                                                         by a feed error, or by events associated with WDPROTECT. Cleared
                                                          by software writing a 0 to this bit position. Causes a chip
                                                          reset if WDRESET = 1.                                                */
      __IO uint32_t  WDINT      :  1;               /*!< Warning interrupt flag. Set when the timer reaches the value
                                                         in WDWARNINT. Cleared by software writing a 1 to this bit position.
                                                          Note that this bit cannot be cleared while the WARNINT value
                                                          is equal to the value of the TV register. This can occur if
                                                          the value of WARNINT is 0 and the WDRESET bit is 0 when TV decrements
                                                          to 0.                                                                */
      __IO uint32_t  WDPROTECT  :  1;               /*!< Watchdog update mode. This bit can be set once by software and
                                                         is only cleared by a reset. 0 Flexible. The watchdog time-out
                                                          value (TC) can be changed at any time. 1 Threshold. The watchdog
                                                          time-out value (TC) can be changed only after the counter is
                                                          below the value of WDWARNINT and WDWINDOW.                           */
      __IO uint32_t  LOCK       :  1;               /*!< Once this bit is set to one and a watchdog feed is performed,
                                                         disabling or powering down the watchdog oscillator is prevented
                                                          by hardware. This bit can be set once by software and is only
                                                          cleared by any reset.                                                */
    } MOD_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TC;                              /*!< Watchdog timer constant register. This 24-bit register determines
                                                         the time-out value.                                                   */

    struct {
      __IO uint32_t  COUNT      : 24;               /*!< Watchdog time-out value.                                              */
    } TC_b;                                         /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  FEED;                            /*!< Watchdog feed sequence register. Writing 0xAA followed by 0x55
                                                         to this register reloads the Watchdog timer with the value contained
                                                          in TC.                                                               */

    struct {
      __O  uint32_t  FEED       :  8;               /*!< Feed value should be 0xAA followed by 0x55. Writing 0xAA followed
                                                         by 0x55 to this register will reload the Watchdog timer with
                                                          the TC value. This operation will also start the Watchdog if
                                                          it is enabled via the WDMOD register. Setting the WDEN bit in
                                                          the WDMOD register is not sufficient to enable the Watchdog.
                                                          A valid feed sequence must be completed after setting WDEN before
                                                          the Watchdog is capable of generating a reset. Until then, the
                                                          Watchdog will ignore feed errors.                                    */
    } FEED_b;                                       /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  TV;                              /*!< Watchdog timer value register. This 24-bit register reads out
                                                         the current value of the Watchdog timer.                              */

    struct {
      __I  uint32_t  COUNT      : 24;               /*!< Counter timer value. The TV register is used to read the current
                                                         value of Watchdog timer counter.                                      */
    } TV_b;                                         /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;

  union {
    __IO uint32_t  WARNINT;                         /*!< Watchdog Warning Interrupt compare value.                             */

    struct {
      __IO uint32_t  WARNINT    : 10;               /*!< Watchdog warning interrupt compare value.A match of the watchdog
                                                         timer counter to WARNINT occurs when the bottom 10 bits of the
                                                          counter have the same value as the 10 bits of WARNINT, and the
                                                          remaining upper bits of the counter are all 0. This gives a
                                                          maximum time of 1,023 watchdog timer counts (4,096 watchdog
                                                          clocks) for the interrupt to occur prior to a watchdog event.
                                                          If WARNINT is 0, the interrupt will occur at the same time as
                                                          the watchdog event.                                                  */
    } WARNINT_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  WINDOW;                          /*!< Watchdog Window compare value.                                        */

    struct {
      __IO uint32_t  WINDOW     : 24;               /*!< Watchdog window value. The WINDOW register determines the highest
                                                         TV value allowed when a watchdog feed is performed. If a feed
                                                          sequence occurs when TV is greater than the value in WINDOW,
                                                          a watchdog event will occur                                          */
    } WINDOW_b;                                     /*!< BitSize                                                               */
  };
} u_wwdt_Type;


/* ================================================================================ */
/* ================                      u_rtc                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component rtc It is Real Time Clock with APB bus interface. More details will follow. (u_rtc)
  */

typedef struct {                                    /*!< u_rtc Structure                                                       */

  union {
    __IO uint32_t  CTRL;                            /*!< RTC control register                                                  */

    struct {
      __IO uint32_t  SWRESET    :  1;               /*!< Software reset control. 0 Not in reset. The RTC is not held
                                                         in reset. This bit must be cleared prior to configuring or initiating
                                                          any operation of the RTC. 1 In reset. The RTC is held in reset.
                                                          All register bits within the RTC will be forced to their reset
                                                          value except the OFD bit. This bit must be cleared before writing
                                                          to any register in the RTC - including writes to set any of
                                                          the other bits within this register. Do not attempt to write
                                                          to any bits of this register at the same time that the reset
                                                          bit is                                                               */
           uint32_t             :  1;
      __IO uint32_t  ALARMT32B  :  1;               /*!< RTC 32-bit timer alarm flag status. 0 No match. No match has
                                                         occurred on the 32-bit RTC timer. Writing a 0 has no effect.
                                                          1 Match. A match condition has occurred on the 32-bit RTC timer.
                                                          This flag generates an RTC alarm interrupt request RTC_ALARM
                                                          which can also wake up the part from low power modes (excluding
                                                          deep power down mode). Writing a 1 clears this bit.                  */
      __IO uint32_t  WAKET16B   :  1;               /*!< RTC 16-bit timer wake-up flag status. 0 Run. The RTC 16-bit
                                                         timer is running. Writing a 0 has no effect. 1 Time-out. The
                                                          16-bit timer has timed out. This flag generates an RTC wake-up
                                                          interrupt request RTC-WAKE which can also wake up the part from
                                                          low power modes (excluding deep power down mode). Writing a
                                                          1 clears this bit.                                                   */
      __IO uint32_t  ALARMDPD_EN:  1;               /*!< RTC 32-bit timer alarm enable for Low power mode. 0 Disable.
                                                         A match on the 32-bit RTC timer will not bring the part out
                                                          of power-down modes. 1 Enable. A match on the 32-bit RTC timer
                                                          bring the part out of power-down modes.                              */
      __IO uint32_t  WAKEDPD_EN :  1;               /*!< RTC 16-bit timer wake-up enable for power-down modes. 0 Disable.
                                                         A match on the 16-bit RTC timer will not bring the part out
                                                          of power-down modes. 1 Enable. A match on the 16-bit RTC timer
                                                          bring the part out of power-down modes.                              */
      __IO uint32_t  RTCT16B_EN :  1;               /*!< RTC 16-bit timer clock enable. This bit can be set to 0 to conserve
                                                         power if the 16-bit timer is not used. This bit has no effect
                                                          when the RTC is disabled (bit 7 of this register is 0). 0 Disable.
                                                          A match on the 16-bit RTC timer will not bring the part out
                                                          of Deep power-down mode. 1 Enable. The 16-bit RTC timer is enabled.  */
      __IO uint32_t  RTC_EN     :  1;               /*!< RTC enable. 0 Disable. The RTC 32-bit timer and 16-bit timer
                                                         clocks are shut down and the RTC operation is disabled. This
                                                          bit should be 0 when writing to load a value in the RTC counter
                                                          register. 1 Enable. The 32-bit RTC clock is running and RTC
                                                          operation is enabled. This bit must be set to initiate operation
                                                          of the RTC. To also enable the 16-bit timer clock, set bit 6
                                                          in this register.                                                    */
    } CTRL_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MATCH;                           /*!< RTC 32-bit counter match register                                     */

    struct {
      __IO uint32_t  MATVAL     : 32;               /*!< Contains the match value against which the 1 Hz RTC timer will
                                                         be compared to generate set the alarm flag RTC_ALARM and generate
                                                          an alarm interrupt/wake-up if enabled.                               */
    } MATCH_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  COUNT;                           /*!< RTC 32-bit counter register                                           */

    struct {
      __IO uint32_t  VAL        : 32;               /*!< A read reflects the current value of the main,32-bit RTC timer.
                                                         A write loads a new initial value into the timer. The RTC 32-bit
                                                          counter will count up continuously at the 32-bit timer clock
                                                          rate once the RTC Software Reset is removed (by clearing bit
                                                          0 of the CTRL register). Remark: Only write to this register
                                                          when the RTC_EN bit in the RTC CTRL Register is 0.                   */
    } COUNT_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  WAKE;                            /*!< 16-bit RTC timer register                                             */

    struct {
      __IO uint32_t  VAL        : 16;               /*!< A read reflects the current value of 16-bit timer. A write pre-loads
                                                         a start count value into the 16-bit timer and initializes a
                                                          count-downsequence. Do not write to this register while counting
                                                          is in progress.                                                      */
    } WAKE_b;                                       /*!< BitSize                                                               */
  };
} u_rtc_Type;


/* ================================================================================ */
/* ================                      u_pwm                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component pwm. It is a Pulse Width Modulation Controller with an APB bus interface. More details will follow. (u_pwm)
  */

typedef struct {                                    /*!< u_pwm Structure                                                       */

  union {
    __IO uint32_t  CTRL0;                           /*!< PWM 1st Control Register (Channel 0 to Channel 10) for channel
                                                         enables and interrupt enables. Note if all interrupts arre enabled
                                                          with short period timings it will not be possible to manage
                                                          all the interrupts.                                                  */

    struct {
      __IO uint32_t  PWM_EN_0   :  1;               /*!< PWM channel 0 enable. 0 = Disable / 1 = Enable.                       */
      __IO uint32_t  PWM_EN_1   :  1;               /*!< PWM channel 1 enable. 0 = Disable / 1 = Enable.                       */
      __IO uint32_t  PWM_EN_2   :  1;               /*!< PWM channel 2 enable. 0 = Disable / 1 = Enable.                       */
      __IO uint32_t  PWM_EN_3   :  1;               /*!< PWM channel 3 enable. 0 = Disable / 1 = Enable.                       */
      __IO uint32_t  PWM_EN_4   :  1;               /*!< PWM channel 4 enable. 0 = Disable / 1 = Enable.                       */
      __IO uint32_t  PWM_EN_5   :  1;               /*!< PWM channel 5 enable. 0 = Disable / 1 = Enable.                       */
      __IO uint32_t  PWM_EN_6   :  1;               /*!< PWM channel 6 enable. 0 = Disable / 1 = Enable.                       */
      __IO uint32_t  PWM_EN_7   :  1;               /*!< PWM channel 7 enable. 0 = Disable / 1 = Enable.                       */
      __IO uint32_t  PWM_EN_8   :  1;               /*!< PWM channel 8 enable. 0 = Disable / 1 = Enable.                       */
      __IO uint32_t  PWM_EN_9   :  1;               /*!< PWM channel 9 enable. 0 = Disable / 1 = Enable.                       */
      __IO uint32_t  PWM_EN_10  :  1;               /*!< PWM channel 10 enable. 0 = Disable / 1 = Enable. Note, this
                                                         PWM channel can not be routed to a device pin.                        */
           uint32_t             :  5;
      __IO uint32_t  INT_EN_0   :  1;               /*!< PWM channel 0 interrupt enable. 0 = Disable / 1 = Enable.             */
      __IO uint32_t  INT_EN_1   :  1;               /*!< PWM channel 1 interrupt enable. 0 = Disable / 1 = Enable.             */
      __IO uint32_t  INT_EN_2   :  1;               /*!< PWM channel 2 interrupt enable. 0 = Disable / 1 = Enable.             */
      __IO uint32_t  INT_EN_3   :  1;               /*!< PWM channel 3 interrupt enable. 0 = Disable / 1 = Enable.             */
      __IO uint32_t  INT_EN_4   :  1;               /*!< PWM channel 4 interrupt enable. 0 = Disable / 1 = Enable.             */
      __IO uint32_t  INT_EN_5   :  1;               /*!< PWM channel 5 interrupt enable. 0 = Disable / 1 = Enable.             */
      __IO uint32_t  INT_EN_6   :  1;               /*!< PWM channel 6 interrupt enable. 0 = Disable / 1 = Enable.             */
      __IO uint32_t  INT_EN_7   :  1;               /*!< PWM channel 7 interrupt enable. 0 = Disable / 1 = Enable.             */
      __IO uint32_t  INT_EN_8   :  1;               /*!< PWM channel 8 interrupt enable. 0 = Disable / 1 = Enable.             */
      __IO uint32_t  INT_EN_9   :  1;               /*!< PWM channel 9 interrupt enable. 0 = Disable / 1 = Enable.             */
      __IO uint32_t  INT_EN_10  :  1;               /*!< PWM channel 10 interrupt enable. 0 = Disable / 1 = Enable.            */
    } CTRL0_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CTRL1;                           /*!< PWM 2nd Control Register (Channel 0 to Channel 10) for channel
                                                         polarity and output state for a disabled channel.                     */

    struct {
      __IO uint32_t  POL_0      :  1;               /*!< PWM channel 0 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
      __IO uint32_t  POL_1      :  1;               /*!< PWM channel 1 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
      __IO uint32_t  POL_2      :  1;               /*!< PWM channel 2 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
      __IO uint32_t  POL_3      :  1;               /*!< PWM channel 3 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
      __IO uint32_t  POL_4      :  1;               /*!< PWM channel 4 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
      __IO uint32_t  POL_5      :  1;               /*!< PWM channel 5 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
      __IO uint32_t  POL_6      :  1;               /*!< PWM channel 6 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
      __IO uint32_t  POL_7      :  1;               /*!< PWM channel 7 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
      __IO uint32_t  POL_8      :  1;               /*!< PWM channel 8 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
      __IO uint32_t  POL_9      :  1;               /*!< PWM channel 9 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
      __IO uint32_t  POL_10     :  1;               /*!< PWM channel 10 waveform Polarity control. 0 : Set high on compare
                                                         match, set low at the end of PWM period. 1 : Set low on compare
                                                          match, set high at the end of PWM period                             */
           uint32_t             :  5;
      __IO uint32_t  DIS_LEVEL_0:  1;               /*!< PWM channel 0 output level when PWM channel 0 is disable. 0
                                                         = Low Level / 1 = High Level.                                         */
      __IO uint32_t  DIS_LEVEL_1:  1;               /*!< PWM channel 1 output level when PWM channel 0 is disable. 0
                                                         = Low Level / 1 = High Level.                                         */
      __IO uint32_t  DIS_LEVEL_2:  1;               /*!< PWM channel 2 output level when PWM channel 0 is disable. 0
                                                         = Low Level / 1 = High Level.                                         */
      __IO uint32_t  DIS_LEVEL_3:  1;               /*!< PWM channel 3 output level when PWM channel 0 is disable. 0
                                                         = Low Level / 1 = High Level.                                         */
      __IO uint32_t  DIS_LEVEL_4:  1;               /*!< PWM channel 4 output level when PWM channel 0 is disable. 0
                                                         = Low Level / 1 = High Level.                                         */
      __IO uint32_t  DIS_LEVEL_5:  1;               /*!< PWM channel 5 output level when PWM channel 0 is disable. 0
                                                         = Low Level / 1 = High Level.                                         */
      __IO uint32_t  DIS_LEVEL_6:  1;               /*!< PWM channel 6 output level when PWM channel 0 is disable. 0
                                                         = Low Level / 1 = High Level.                                         */
      __IO uint32_t  DIS_LEVEL_7:  1;               /*!< PWM channel 7 output level when PWM channel 0 is disable. 0
                                                         = Low Level / 1 = High Level.                                         */
      __IO uint32_t  DIS_LEVEL_8:  1;               /*!< PWM channel 8 output level when PWM channel 0 is disable. 0
                                                         = Low Level / 1 = High Level.                                         */
      __IO uint32_t  DIS_LEVEL_9:  1;               /*!< PWM channel 9 output level when PWM channel 0 is disable. 0
                                                         = Low Level / 1 = High Level.                                         */
    } CTRL1_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PSCL01;                          /*!< PWM Channels 0 & 1 prescalers                                         */

    struct {
      __IO uint32_t  PSCL_0     : 10;               /*!< PWM channel 0 prescaler. The output frequency equals to clk/(PSCL_0
                                                         + 1)                                                                  */
           uint32_t             :  6;
      __IO uint32_t  PSCL_1     : 10;               /*!< PWM channel 1 prescaler. The output frequency equals to clk/(PSCL_1
                                                         + 1)                                                                  */
    } PSCL01_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PSCL23;                          /*!< PWM Channels 2 & 3 prescalers                                         */

    struct {
      __IO uint32_t  PSCL_2     : 10;               /*!< PWM channel 2 prescaler. The output frequency equals to clk/(PSCL_2
                                                         + 1)                                                                  */
           uint32_t             :  6;
      __IO uint32_t  PSCL_3     : 10;               /*!< PWM channel 3 prescaler. The output frequency equals to clk/(PSCL_3
                                                         + 1)                                                                  */
    } PSCL23_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PSCL45;                          /*!< PWM Channels 4 & 5 prescalers                                         */

    struct {
      __IO uint32_t  PSCL_4     : 10;               /*!< PWM channel 4 prescaler. The output frequency equals to clk/(PSCL_4
                                                         + 1)                                                                  */
           uint32_t             :  6;
      __IO uint32_t  PSCL_5     : 10;               /*!< PWM channel 5 prescaler. The output frequency equals to clk/(PSCL_5
                                                         + 1)                                                                  */
    } PSCL45_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PSCL67;                          /*!< PWM Channels 6 & 7 prescalers                                         */

    struct {
      __IO uint32_t  PSCL_6     : 10;               /*!< PWM channel 6 prescaler. The output frequency equals to clk/(PSCL_6
                                                         + 1)                                                                  */
           uint32_t             :  6;
      __IO uint32_t  PSCL_7     : 10;               /*!< PWM channel 7 prescaler. The output frequency equals to clk/(PSCL_7
                                                         + 1)                                                                  */
    } PSCL67_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PSCL89;                          /*!< PWM Channels 8 & 9 prescalers                                         */

    struct {
      __IO uint32_t  PSCL_8     : 10;               /*!< PWM channel 8 prescaler. The output frequency equals to clk/(PSCL_8
                                                         + 1)                                                                  */
           uint32_t             :  6;
      __IO uint32_t  PSCL_9     : 10;               /*!< PWM channel 9 prescaler. The output frequency equals to clk/(PSCL_9
                                                         + 1)                                                                  */
    } PSCL89_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PSCL1011;                        /*!< PWM Channel 10 prescaler                                              */

    struct {
      __IO uint32_t  PSCL_10    : 10;               /*!< PWM channel 10 prescaler. The output frequency equals to clk/(PSCL_10
                                                         + 1)                                                                  */
    } PSCL1011_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP0;                            /*!< PWM Channel 0 Period and Compare register. Counter will count
                                                         down from period to zero. When Comapre value is reached PWM
                                                          output will change on next counter decrement and be stable from
                                                          'Compare-1' to 0.                                                    */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 0 period register. The actual period equals to [PERIOD
                                                         + 1]. 'PERIOD' must not be 0x0.                                       */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 0 compare register. 'COMPARE' must not be 0x0.            */
    } PCP0_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP1;                            /*!< PWM Channel 1 Period and Compare register. Counter will count
                                                         down from period to zero. When Comapre value is reached PWM
                                                          output will change on next counter decrement and be stable from
                                                          'Compare-1' to 0.                                                    */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 1 period register. The actual period equals to [PERIOD
                                                         + 1]. 'PERIOD' must not be 0x0.                                       */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 1 compare register. 'COMPARE' must not be 0x0.            */
    } PCP1_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP2;                            /*!< PWM Channel 2 Period and Compare register. Counter will count
                                                         down from period to zero. When Comapre value is reached PWM
                                                          output will change on next counter decrement and be stable from
                                                          'Compare-1' to 0.                                                    */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 2 period register. The actual period equals to [PERIOD
                                                         + 1]. 'PERIOD' must not be 0x0.                                       */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 2 compare register. 'COMPARE' must not be 0x0.            */
    } PCP2_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP3;                            /*!< PWM Channel 3 Period and Compare register. Counter will count
                                                         down from period to zero. When Comapre value is reached PWM
                                                          output will change on next counter decrement and be stable from
                                                          'Compare-1' to 0.                                                    */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 3 period register. The actual period equals to [PERIOD
                                                         + 1]. 'PERIOD' must not be 0x0.                                       */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 3 compare register. 'COMPARE' must not be 0x0.            */
    } PCP3_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP4;                            /*!< PWM Channel 4 Period and Compare register. Counter will count
                                                         down from period to zero. When Comapre value is reached PWM
                                                          output will change on next counter decrement and be stable from
                                                          'Compare-1' to 0.                                                    */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 4 period register. The actual period equals to [PERIOD
                                                         + 1]. 'PERIOD' must not be 0x0.                                       */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 4 compare register. 'COMPARE' must not be 0x0.            */
    } PCP4_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP5;                            /*!< PWM Channel 5 Period and Compare register. Counter will count
                                                         down from period to zero. When Comapre value is reached PWM
                                                          output will change on next counter decrement and be stable from
                                                          'Compare-1' to 0.                                                    */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 5 period register. The actual period equals to [PERIOD
                                                         + 1]. 'PERIOD' must not be 0x0.                                       */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 5 compare register. 'COMPARE' must not be 0x0.            */
    } PCP5_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP6;                            /*!< PWM Channel 6 Period and Compare register. Counter will count
                                                         down from period to zero. When Comapre value is reached PWM
                                                          output will change on next counter decrement and be stable from
                                                          'Compare-1' to 0.                                                    */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 6 period register. The actual period equals to [PERIOD
                                                         + 1]. 'PERIOD' must not be 0x0.                                       */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 6 compare register. 'COMPARE' must not be 0x0.            */
    } PCP6_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP7;                            /*!< PWM Channel 7 Period and Compare register. Counter will count
                                                         down from period to zero. When Comapre value is reached PWM
                                                          output will change on next counter decrement and be stable from
                                                          'Compare-1' to 0.                                                    */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 7 period register. The actual period equals to [PERIOD
                                                         + 1]. 'PERIOD' must not be 0x0.                                       */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 7 compare register. 'COMPARE' must not be 0x0.            */
    } PCP7_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP8;                            /*!< PWM Channel 8 Period and Compare register. Counter will count
                                                         down from period to zero. When Comapre value is reached PWM
                                                          output will change on next counter decrement and be stable from
                                                          'Compare-1' to 0.                                                    */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 8 period register. The actual period equals to [PERIOD
                                                         + 1]. 'PERIOD' must not be 0x0.                                       */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 8 compare register. 'COMPARE' must not be 0x0.            */
    } PCP8_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP9;                            /*!< PWM Channel 9 Period and Compare register. Counter will count
                                                         down from period to zero. When Comapre value is reached PWM
                                                          output will change on next counter decrement and be stable from
                                                          'Compare-1' to 0.                                                    */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 9 period register. The actual period equals to [PERIOD
                                                         + 1]. 'PERIOD' must not be 0x0.                                       */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 9 compare register. 'COMPARE' must not be 0x0.            */
    } PCP9_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PCP10;                           /*!< PWM Channel 10 Period and Compare register. Counter will count
                                                         down from period to zero.                                             */

    struct {
      __IO uint32_t  PERIOD     : 16;               /*!< PWM channel 10 period register. The actual period equals to
                                                         [PERIOD + 1]. 'PERIOD' must not be 0x0.                               */
      __IO uint32_t  COMPARE    : 16;               /*!< PWM channel 10 compare register. 'COMPARE' must not be 0x0.           */
    } PCP10_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PST0;                            /*!< PWM 1st Status Register (Channel 0 to Channel 3)                      */

    struct {
      __IO uint32_t  INT_FLG_0  :  1;               /*!< PWM channel 0 interrupt flag. 0 : No interrupt pending 1 : Interrupt
                                                         pending. Write 1 to clear the interrupt.                              */
           uint32_t             :  7;
      __IO uint32_t  INT_FLG_1  :  1;               /*!< PWM channel 1 interrupt flag. 0 : No interrupt pending 1 : Interrupt
                                                         pending. Write 1 to clear the interrupt.                              */
           uint32_t             :  7;
      __IO uint32_t  INT_FLG_2  :  1;               /*!< PWM channel 2 interrupt flag. 0 : No interrupt pending 1 : Interrupt
                                                         pending. Write 1 to clear the interrupt.                              */
           uint32_t             :  7;
      __IO uint32_t  INT_FLG_3  :  1;               /*!< PWM channel 3 interrupt flag. 0 : No interrupt pending 1 : Interrupt
                                                         pending. Write 1 to clear the interrupt.                              */
    } PST0_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PST1;                            /*!< PWM 2nd Status Register (Channel 4 to Channel 7)                      */

    struct {
      __IO uint32_t  INT_FLG_4  :  1;               /*!< PWM channel 4 interrupt flag. 0 : No interrupt pending 1 : Interrupt
                                                         pending. Write 1 to clear the interrupt.                              */
           uint32_t             :  7;
      __IO uint32_t  INT_FLG_5  :  1;               /*!< PWM channel 5 interrupt flag. 0 : No interrupt pending 1 : Interrupt
                                                         pending. Write 1 to clear the interrupt.                              */
           uint32_t             :  7;
      __IO uint32_t  INT_FLG_6  :  1;               /*!< PWM channel 6 interrupt flag. 0 : No interrupt pending 1 : Interrupt
                                                         pending. Write 1 to clear the interrupt.                              */
           uint32_t             :  7;
      __IO uint32_t  INT_FLG_7  :  1;               /*!< PWM channel 7 interrupt flag. 0 : No interrupt pending 1 : Interrupt
                                                         pending. Write 1 to clear the interrupt.                              */
    } PST1_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PST2;                            /*!< PWM 3rd Status Register (Channel 8 to Channel 10)                     */

    struct {
      __IO uint32_t  INT_FLG_8  :  1;               /*!< PWM channel 8 interrupt flag. 0 : No interrupt pending 1 : Interrupt
                                                         pending. Write 1 to clear the interrupt.                              */
           uint32_t             :  7;
      __IO uint32_t  INT_FLG_9  :  1;               /*!< PWM channel 9 interrupt flag. 0 : No interrupt pending 1 : Interrupt
                                                         pending. Write 1 to clear the interrupt.                              */
           uint32_t             :  7;
      __IO uint32_t  INT_FLG_10 :  1;               /*!< PWM channel 10 interrupt flag. 0 : No interrupt pending 1 :
                                                         Interrupt pending. Write 1 to clear the interrupt.                    */
    } PST2_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[1001];

  union {
    __I  uint32_t  MODULE_ID;                       /*!< PWM Module Identifier (                                               */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } MODULE_ID_b;                                  /*!< BitSize                                                               */
  };
} u_pwm_Type;


/* ================================================================================ */
/* ================                      u_rng                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component rng. It is an Universal Synchrnous/Asynchrnous Receiver/Transmitter with APB bus interface. More details will follow. (u_rng)
  */

typedef struct {                                    /*!< u_rng Structure                                                       */

  union {
    __I  uint32_t  RANDOM_NUMBER;                   /*!< This register contains a random 32 bit number which is computed
                                                         on demand, at each time it is read. Weak cryptographic post-processing
                                                          is used to maximize throughput                                       */

    struct {
      __I  uint32_t  RANDOM_NUMBER: 32;             /*!< This register contains a random 32 bit number which is computed
                                                         on demand, at each time it is read. Weak cryptographic post-processing
                                                          is used to maximize throughput                                       */
    } RANDOM_NUMBER_b;                              /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  ENCRYPTED_NUMBER;                /*!< This register contains a random 32 bit number which is pre-computed.
                                                         Take care that throughput is limited by the latency of the strong
                                                          cryptographic module (AES). The bus is stalled till a new number
                                                          is available. Since pre-computed, first 4 requests of a burst
                                                          of requests will not stall the bus.                                  */

    struct {
      __I  uint32_t  ENCRYPTED_NUMBER: 32;          /*!< This register contains a random 32 bit number which is pre-computed.
                                                         Take care that throughput is limited by the latency of the strong
                                                          cryptographic module (AES). The bus is stalled till a new number
                                                          is available. Since pre-computed, first 4 requests of a burst
                                                          of requests will not stall the bus.                                  */
    } ENCRYPTED_NUMBER_b;                           /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  COUNTER_VAL;                     /*!< COUNTER_VAL                                                           */

    struct {
      __I  uint32_t  CLK_RATIO  :  8;               /*!< Gives the ratio between the internal clocks frequencies and
                                                         the register clock frequency for evaluation and certification
                                                          purposes. Internal clock frequencies are half the incoming ones:
                                                          COUNTER_VAL = round[ (intFreq/2)/regFreq*256*(1<<(4*shift4x))
                                                          ] MODULO 256 If shitf4x==0, intFreq ~= regFreq*COUNTER_VAL/256*2
                                                          Use clock_sel to select which clock you want to measure, in
                                                          this range: 1..5                                                     */
      __I  uint32_t  REFRESH_CNT:  5;               /*!< Incremented (till max possible value) each time COUNTER was
                                                         updated since last reading to any *_NUMBER. This gives an indication
                                                          on 'entropy refill'. Example, with 'mode'=10, 'clock_sel'=0,
                                                          'data_sel'=00: if 'chi' is correct then any increase in 'refresh_cnt'
                                                          gives the indication that at least 1 bit of entropy was generated
                                                          since last reading to any *_NUMBER. If 'data_sel'=01 and 'chi'
                                                          is still correct then this gives 8 bits of entropy. Clocks can
                                                          be tested separately (change 'clock_sel' to 1..5) to conclu          */
    } COUNTER_VAL_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  COUNTER_CFG;                     /*!< COUNTER_CFG                                                           */

    struct {
      __IO uint32_t  MODE       :  2;               /*!< 00: disabled 01: update once. Will return to 00 once done 10:
                                                         free running: updates countinuously. If associated to setting
                                                          'clock_sel'=0, this activates feature 'enhanced entropy refill',
                                                          with some spreading among all RNGs                                   */
      __IO uint32_t  CLOCK_SEL  :  3;               /*!< Selects the internal clock on which to compute statistics. 1
                                                         is for first one, 2 for second one, . And 0 is for a XOR of
                                                          results from all clocks                                              */
      __IO uint32_t  SHIFT4X    :  3;               /*!< To be used to add precision to clock_ratio and determine 'entropy
                                                         refill'. Supported range is 0..4 Used as well for ONLINE_TEST         */
      __IO uint32_t  DIS_ENH_ENTR_REFILL:  1;       /*!< Disable 'enhanced entropy refill' feature, which is enabled
                                                         by default when 'mode' > 00. This field should be configured
                                                          when 'mode'=00 (since considered pseudo-static). When this bit
                                                          is set, all other settings of this IP do not have any impact
                                                          on the generated numbers. Do not use: for evaluation purpose
                                                          only                                                                 */
      __IO uint32_t  FORCE_ENTR_SPREADING:  1;      /*!< Forces entropy spreading (interactions between RNGs) even when
                                                         'clock_sel'>0. Usefull to evaluate 'entropy refill' for one
                                                          clock separately. Meaningless when 'mode'=00. Do not use: for
                                                          evaluation purpose only                                              */
    } COUNTER_CFG_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ONLINE_TEST_CFG;                 /*!< ONLINE_TEST_CFG                                                       */

    struct {
      __IO uint32_t  ACTIVATE   :  1;               /*!< 0: disabled 1: activated Update rythm for VAL depends on COUNTER_CFG
                                                         if data_sel is set to COUNTER. Otherwise VAL is updated each
                                                          time RANDOM_NUMBER or ENCRYPTED_NUMBER is read                       */
      __IO uint32_t  DATA_SEL   :  2;               /*!< Selects source on which to apply online test: 00: LSB of COUNTER:
                                                         raw data from one or all sources of entropy 01: MSB of COUNTER:
                                                          raw data from one or all sources of entropy 10: RANDOM_NUMBER
                                                          11: ENCRYPTED_NUMBER 'activate' should be set to 'disabled'
                                                          before changing this field                                           */
    } ONLINE_TEST_CFG_b;                            /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  ONLINE_TEST_VAL;                 /*!< ONLINE_TEST_VAL                                                       */

    struct {
      __I  uint32_t  LIVE_CHI_SQUARED:  4;          /*!< This value is updated as described in field 'activate'. Low
                                                         value means good, high value means no good. If 'data_sel'<10,
                                                          increase 'shift4x' till 'chi' is correct and poll 'refresh_cnt'
                                                          before reading any *_NUMBER.                                         */
      __I  uint32_t  MIN_CHI_SQUARED:  4;           /*!< This field is reset when 'activate'==0                                */
      __I  uint32_t  MAX_CHI_SQUARED:  4;           /*!< This field is reset when 'activate'==0                                */
    } ONLINE_TEST_VAL_b;                            /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MISC_CFG;                        /*!< MISC_CFG                                                              */

    struct {
      __IO uint32_t  AES_RESEED :  1;               /*!< If set, ENCRYPTED_NUMBER generation becomes predictable, provided
                                                         all secrets and current internal state are known: independant
                                                          from entropy source. This mode is still FIPS 140-2 compliant.
                                                          Do not use: for evaluation purpose only                              */
      __IO uint32_t  AES_DT_CFG :  1;               /*!< Set this bit to re-seed AES. Then read few RANDOM_NUMBERs. Then
                                                         reset this bit.                                                       */
    } MISC_CFG_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[1014];

  union {
    __IO uint32_t  POWERDOWN;                       /*!< Powerdown mode (standard but certainly useless here)                  */

    struct {
      __IO uint32_t  SOFT_RESET :  1;               /*!< Request softreset that will go low automaticaly after acknowledge
                                                         from CORE                                                             */
      __IO uint32_t  FORCE_SOFT_RESET:  1;          /*!< When used with softreset it forces CORE_RESETN to low on acknowledge
                                                         from CORE                                                             */
           uint32_t             : 29;
      __IO uint32_t  POWERDOWN  :  1;               /*!< When set all accesses to standard registers are blocked               */
    } POWERDOWN_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1;

  union {
    __I  uint32_t  MODULEID;                        /*!< IP identifier                                                         */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } MODULEID_b;                                   /*!< BitSize                                                               */
  };
} u_rng_Type;


/* ================================================================================ */
/* ================                     u_inmux                    ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component input mux. . More details will follow. (u_inmux)
  */

typedef struct {                                    /*!< u_inmux Structure                                                     */
  __I  uint32_t  RESERVED0[48];

  union {
    __IO uint32_t  PINTSEL[8];                      /*!< Pin interrupt select register                                         */

    struct {
      __IO uint32_t  INTPIN     :  5;               /*!< Pin number select for pin interrupt or pattern match engine
                                                         input.                                                                */
    } PINTSEL_b[8];                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DMA_ITRIG_INMUX[19];             /*!< Trigger select register for DMA channel                               */

    struct {
      __IO uint32_t  INP        :  5;               /*!< Trigger input number (decimal value) for DMA channel n (n =
                                                         0 to 17). 0 = ADC0 Sequence A interrupt; 1 = ADC0 Sequence B
                                                          interrupt; 2 = Timer CT32B0 Match 0; 3 = Timer CT32B0 Match
                                                          1; 4 = Timer CT32B1 Match 0; 5 = Timer CT32B1 Match 1; 6 = Pin
                                                          interrupt 0; 7 = Pin interrupt 1; 8 = Pin interrupt 2; 9 = Pin
                                                          interrupt 3; 10 = AES RX; 11 = AES TX; 12 = Hash RX; 13 = Hash
                                                          TX; 14 = DMA output trigger mux 0; 15 = DMA output trigger mux
                                                          1; 16 = DMA output trigger mux 2; 17 = DMA output trigger mux
                                                          3.                                                                   */
    } DMA_ITRIG_INMUX_b[19];                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[13];

  union {
    __IO uint32_t  DMA_OTRIG_INMUX[4];              /*!< DMA output trigger selection to become DMA trigger                    */

    struct {
      __IO uint32_t  INP        :  5;               /*!< DMA trigger output number (decimal value) for DMA channel n
                                                         (n = 0 to 19).                                                        */
    } DMA_OTRIG_INMUX_b[4];                         /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[4];

  union {
    __IO uint32_t  FREQMEAS_REF;                    /*!< Selection for frequency measurement reference clock                   */

    struct {
      __IO uint32_t  CLKIN      :  4;               /*!< Clock source number (decimal value) for frequency measure function
                                                         ref clock: 0 = CLK_IN (must be enabled in functional mux); 1
                                                          = XTAL 32 MHz (must be enabled in clock_ctrl); 2 = FRO 1 MHz
                                                          (must be enabled in clock_ctrl); 3 = 32 kHz oscillator (either
                                                          FRO 32 KHz or XTAL 32 KHZ); 4 = Main clock (divided); 5 = PIO[4]
                                                          (must be configured as GPIO); 6 = PIO[20] (must be configured
                                                          as GPIO); 7 = PIO[16] (must be configured as GPIO); 8 = PIO[15]
                                                          (must be configured as GPIO).                                        */
    } FREQMEAS_REF_b;                               /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FREQMEAS_TARGET;                 /*!< Selection for frequency measurement target clock                      */

    struct {
      __IO uint32_t  CLKIN      :  4;               /*!< Clock source number (decimal value) for frequency measure function
                                                         target clock: 0 = CLK_IN (must be enabled in functional mux);
                                                          1 = XTAL 32 MHz (must be enabled in clock_ctrl); 2 = FRO 1 MHz
                                                          (must be enabled in clock_ctrl); 3 = 32 kHz oscillator (either
                                                          FRO 32 KHz or XTAL 32 KHZ); 4 = Main clock (divided); 5 = PIO[4]
                                                          (must be configured as GPIO); 6 = PIO[20] (must be configured
                                                          as GPIO); 7 = PIO[16] (must be configured as GPIO); 8 = PIO[15]
                                                          (must be configured as GPIO).                                        */
    } FREQMEAS_TARGET_b;                            /*!< BitSize                                                               */
  };
} u_inmux_Type;


/* ================================================================================ */
/* ================                     u_iocon                    ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component input mux. . More details will follow. (u_iocon)
  */

typedef struct {                                    /*!< u_iocon Structure                                                     */

  union {
    __IO uint32_t  PIO[22];                         /*!< Configuration array for PIO0 to PIO21. PIO[10] and PIO[11] use
                                                         a different IO cell type to the other PIO pins and so there
                                                          are some differences in the bit field descriptions of the PIO
                                                          register for these Ios. Reset values vary depending on whether
                                                          the IO is configured with a pull-up or pull-down resistor as
                                                          default. The value is also affected by the IO type. Reset value
                                                          0x180 for PIO 0,3,4,5,8,9,12,13,14,15,16,21. Reset value 0x198
                                                          for PIO 1,2,6,7,17,18,19,20. Reset value 0x188 for PIO 10,11.        */

    struct {
      __IO uint32_t  FUNC       :  3;               /*!< Selects pin function. 0 is for GPIO mode. For other values,
                                                         see IO mux                                                            */
      __IO uint32_t  MODE       :  2;               /*!< Selects function mode (on-chip pull-up/pull-down resistor control).
                                                         For MFIO type ONLY (all PIOs except PIO10 & 11): 0x0 : Pull-up.
                                                          Pull-up resistor enabled. 0x1 : Repeater mode (bus keeper) 0x2
                                                          : Plain Input 0x3 : Pull-down. Pull-down resistor enabled. FOR
                                                          IIC/GPIO type ONLY (PIO10 & 11); 0x0 : I2C S/F & FP transmit
                                                          mode (SDA and SCL) & I2C HS transmit mode (only SDAH) 0x1/0x3
                                                          : GPIO mode (high speed if EHS is high, low speed if EHS is
                                                          low: see SLEW0) 0x2 : I2C HS transmit mode (SCLH) Note: When
                                                          the regis                                                            */
      __IO uint32_t  SLEW0      :  1;               /*!< Driver slew rate. Note: -When the register is related to a general
                                                         purpose MFIO type pad (that is all PIOs except PIO10 & 11),
                                                          this bit field (Bit [5]) is connected to EHS0 input of the MFIO
                                                          pad. To be used in combination with SLEW1 'EHS1'. The higher
                                                          [EHS1,EHS0] the quicker -When the register is related to a combo
                                                          I2C/GPIO (IICFPGPIO) type pad (that is PIO10 & 11), this bit
                                                          field (Bit [5]) is connected to EHS input of the IICFPGPIO pad
                                                          ('Speed Selection bit': high for high speed GPIO, low for low
                                                          speed GP                                                             */
      __IO uint32_t  INVERT     :  1;               /*!< Input polarity. 0 Disabled. Input function is not inverted.
                                                         1 Enabled. Input is function inverted.                                */
      __IO uint32_t  DIGIMODE   :  1;               /*!< Select Analog/Digital mode. 0 Analog mode. 1 Digital mode. When
                                                         in analog mode, the receiver path in the IO cell is disabled.
                                                          In this mode, it is essential that the digital function (e.g.
                                                          GPIO) is not configured as an output. Otherwise it may conflict
                                                          with analog stuff (loopback of digital on analog input). In
                                                          other words, it's not because the IO is in analog mode that
                                                          the digital output is automatically switched off. As a consequence,
                                                          it is not possible to disable the receiver path when the IO
                                                          is used for                                                          */
      __IO uint32_t  FILTEROFF  :  1;               /*!< Controls input glitch filter. 0 Filter enabled. Noise pulses
                                                         below approximately 1ns (MFIO) or 3ns (I2C in GPIO mode *) are
                                                          filtered out. 1 Filter disabled. No input filtering is done.
                                                          (*) for PIO10&11 in I2C mode it's 50ns if 'FSEL' is 0, 10ns
                                                          if 'FSEL' is 1 iso 3ns                                               */
      __IO uint32_t  SLEW1      :  1;               /*!< Driver slew rate. Note: -When the register is related to a general
                                                         purpose MFIO type pad (that is all PIOs except PIO10 & 11),
                                                          this bit field (Bit [9]) is connected to EHS1 input of the MFIO
                                                          pad. To be used in combination with SLEW0 'EHS0'. The higher
                                                          [EHS1,EHS0] the quicker -When the register is related to a combo
                                                          I2C/GPIO (IICFPGPIO) type pad (that is PIO10 & 11), this bit
                                                          field (Bit [9]) is connected to FSEL input of the IICFPGPIO
                                                          pad ('Filter Select': 0 for 50ns, 1 for 10ns in I2C mode, no
                                                          effect in GP                                                         */
      __IO uint32_t  OD         :  1;               /*!< Controls open-drain mode. 0 : Normal. Normal push-pull output
                                                         1 : Open-drain. Simulated open-drain output (high drive disabled).    */
      __IO uint32_t  SSEL       :  1;               /*!< Supply Selection bit. Valid only for combo pad GPIO/IIC -When
                                                         the register is related to a combo I2C/GPIO (IICFPGPIO) type
                                                          pad (that is PIO10 & 11), this bit field (Bit [11]) is connected
                                                          to SSEL input of the IICFPGPIO pad ('Supply Selection bit').
                                                          Note for non combo pad: - IO_CLAMP When the register is related
                                                          to a general purpose MFIO type pad (that is all PIOs except
                                                          PIO10 & 11), this bit field (Bit [11])controls the io_clamp
                                                          function. Assert to freeze the IO. Also needs SYSCON:RETENTIONCTRL
                                                          set as well                                                          */
      __IO uint32_t  DBG_FUNC   :  4;               /*!< Select Debug function (for all PIOs expect PIO10 and PIO11).
                                                         Note : for PIO10 and PIO11. DBG_FUNC = bits [16:13] IO_CLAMP
                                                          = bit [12], assert to freeze the IO. Also needs SYSCON:RETENTIONCTRL
                                                          set as well. Useful in power down mode.                              */
      __IO uint32_t  DBG_MODE   :  1;               /*!< (null)                                                                */
    } PIO_b[22];                                    /*!< BitSize                                                               */
  };
} u_iocon_Type;


/* ================================================================================ */
/* ================                     u_pint                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component pint It is a Pin Interrupt & Pattern matching module with APB bus interface. More details will follow. (u_pint)
  */

typedef struct {                                    /*!< u_pint Structure                                                      */

  union {
    __IO uint32_t  ISEL;                            /*!< Pin Interrupt Mode register (only interrupts 0 to 3 supported
                                                         to processor)                                                         */

    struct {
      __IO uint32_t  PMODE_PIN0 :  1;               /*!< Selects the interrupt mode for pin interrupt 0 (selected in
                                                         PINTSEL0). 0 = Edge sensitive 1 = Level sensitive                     */
      __IO uint32_t  PMODE_PIN1 :  1;               /*!< Selects the interrupt mode for pin interrupt 1 (selected in
                                                         PINTSEL1). 0 = Edge sensitive 1 = Level sensitive                     */
      __IO uint32_t  PMODE_PIN2 :  1;               /*!< Selects the interrupt mode for pin interrupt 2 (selected in
                                                         PINTSEL2). 0 = Edge sensitive 1 = Level sensitive                     */
      __IO uint32_t  PMODE_PIN3 :  1;               /*!< Selects the interrupt mode for pin interrupt 3 (selected in
                                                         PINTSEL3). 0 = Edge sensitive 1 = Level sensitive                     */
      __IO uint32_t  PMODE_PIN4 :  1;               /*!< Selects the interrupt mode for pin interrupt 4 (selected in
                                                         PINTSEL4). [Note interrupt not supported to processor] 0 = Edge
                                                          sensitive 1 = Level sensitive                                        */
      __IO uint32_t  PMODE_PIN5 :  1;               /*!< Selects the interrupt mode for pin interrupt 5 (selected in
                                                         PINTSEL5). [Note interrupt not supported to processor] 0 = Edge
                                                          sensitive 1 = Level sensitive                                        */
      __IO uint32_t  PMODE_PIN6 :  1;               /*!< Selects the interrupt mode for pin interrupt 6 (selected in
                                                         PINTSEL6). [Note interrupt not supported to processor] 0 = Edge
                                                          sensitive 1 = Level sensitive                                        */
      __IO uint32_t  PMODE_PIN7 :  1;               /*!< Selects the interrupt mode for pin interrupt 7 (selected in
                                                         PINTSEL7). [Note interrupt not supported to processor] 0 = Edge
                                                          sensitive 1 = Level sensitive                                        */
    } ISEL_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  IENR;                            /*!< Pin interrupt level or rising edge interrupt enable register
                                                         (only interrupts 0 to 3 supported to processor)                       */

    struct {
      __IO uint32_t  ENRL_PIN0  :  1;               /*!< Enables the rising edge or level interrupt for pin interrupt
                                                         0 (selected in PINTSEL0). 0 = Disable rising edge or level interrupt.
                                                          1 = Enable rising edge or level interrupt.                           */
      __IO uint32_t  ENRL_PIN1  :  1;               /*!< Enables the rising edge or level interrupt for pin interrupt
                                                         1 (selected in PINTSEL1). 0 = Disable rising edge or level interrupt.
                                                          1 = Enable rising edge or level interrupt.                           */
      __IO uint32_t  ENRL_PIN2  :  1;               /*!< Enables the rising edge or level interrupt for pin interrupt
                                                         2 (selected in PINTSEL2). 0 = Disable rising edge or level interrupt.
                                                          1 = Enable rising edge or level interrupt.                           */
      __IO uint32_t  ENRL_PIN3  :  1;               /*!< Enables the rising edge or level interrupt for pin interrupt
                                                         3 (selected in PINTSEL3). 0 = Disable rising edge or level interrupt.
                                                          1 = Enable rising edge or level interrupt.                           */
      __IO uint32_t  ENRL_PIN4  :  1;               /*!< Enables the rising edge or level interrupt for pin interrupt
                                                         4 (selected in PINTSEL4). [Note interrupt not supported to processor]
                                                          0 = Disable rising edge or level interrupt. 1 = Enable rising
                                                          edge or level interrupt.                                             */
      __IO uint32_t  ENRL_PIN5  :  1;               /*!< Enables the rising edge or level interrupt for pin interrupt
                                                         5 (selected in PINTSEL5). [Note interrupt not supported to processor]
                                                          0 = Disable rising edge or level interrupt. 1 = Enable rising
                                                          edge or level interrupt.                                             */
      __IO uint32_t  ENRL_PIN6  :  1;               /*!< Enables the rising edge or level interrupt for pin interrupt
                                                         6 (selected in PINTSEL6). [Note interrupt not supported to processor]
                                                          0 = Disable rising edge or level interrupt. 1 = Enable rising
                                                          edge or level interrupt.                                             */
      __IO uint32_t  ENRL_PIN7  :  1;               /*!< Enables the rising edge or level interrupt for pin interrupt
                                                         7 (selected in PINTSEL7). [Note interrupt not supported to processor]
                                                          0 = Disable rising edge or level interrupt. 1 = Enable rising
                                                          edge or level interrupt.                                             */
    } IENR_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  SIENR;                           /*!< Pin interrupt level or rising edge interrupt set register (only
                                                         interrupts 0 to 3 supported to processor)                             */

    struct {
      __O  uint32_t  SETENRL_PIN0:  1;              /*!< Ones written to this address set bits in the IENR, thus enabling
                                                         interrupts. Bit 0 sets bit 0 in the IENR register. 0 = No operation.
                                                          1 = Enable rising edge or level interrupt.                           */
      __O  uint32_t  SETENRL_PIN1:  1;              /*!< Ones written to this address set bits in the IENR, thus enabling
                                                         interrupts. Bit 1 sets bit 1 in the IENR register. 0 = No operation.
                                                          1 = Enable rising edge or level interrupt.                           */
      __O  uint32_t  SETENRL_PIN2:  1;              /*!< Ones written to this address set bits in the IENR, thus enabling
                                                         interrupts. Bit 2 sets bit 2 in the IENR register. 0 = No operation.
                                                          1 = Enable rising edge or level interrupt.                           */
      __O  uint32_t  SETENRL_PIN3:  1;              /*!< Ones written to this address set bits in the IENR, thus enabling
                                                         interrupts. Bit 3 sets bit 3 in the IENR register. 0 = No operation.
                                                          1 = Enable rising edge or level interrupt.                           */
      __O  uint32_t  SETENRL_PIN4:  1;              /*!< Ones written to this address set bits in the IENR, thus enabling
                                                         interrupts. Bit 4 sets bit 4 in the IENR register. [Note interrupt
                                                          not supported to processor] 0 = No operation. 1 = Enable rising
                                                          edge or level interrupt.                                             */
      __O  uint32_t  SETENRL_PIN5:  1;              /*!< Ones written to this address set bits in the IENR, thus enabling
                                                         interrupts. Bit 5 sets bit 5 in the IENR register. [Note interrupt
                                                          not supported to processor] 0 = No operation. 1 = Enable rising
                                                          edge or level interrupt.                                             */
      __O  uint32_t  SETENRL_PIN6:  1;              /*!< Ones written to this address set bits in the IENR, thus enabling
                                                         interrupts. Bit 6 sets bit 6 in the IENR register. [Note interrupt
                                                          not supported to processor] 0 = No operation. 1 = Enable rising
                                                          edge or level interrupt.                                             */
      __O  uint32_t  SETENRL_PIN7:  1;              /*!< Ones written to this address set bits in the IENR, thus enabling
                                                         interrupts. Bit 7 sets bit 7 in the IENR register. [Note interrupt
                                                          not supported to processor] 0 = No operation. 1 = Enable rising
                                                          edge or level interrupt.                                             */
    } SIENR_b;                                      /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  CIENR;                           /*!< Pin interrupt level (rising edge interrupt) clear register (only
                                                         interrupts 0 to 3 supported to processor)                             */

    struct {
      __O  uint32_t  CLRENRL_PIN0:  1;              /*!< Ones written to this address clear bits in the IENR, thus disabling
                                                         the interrupts. Bit 0 clears bit 0 in the IENR register. 0 =
                                                          No operation. 1 = Disable rising edge or level interrupt.            */
      __O  uint32_t  CLRENRL_PIN1:  1;              /*!< Ones written to this address clear bits in the IENR, thus disabling
                                                         the interrupts. Bit 1 clears bit 1 in the IENR register. 0 =
                                                          No operation. 1 = Disable rising edge or level interrupt.            */
      __O  uint32_t  CLRENRL_PIN2:  1;              /*!< Ones written to this address clear bits in the IENR, thus disabling
                                                         the interrupts. Bit 2 clears bit 2 in the IENR register. 0 =
                                                          No operation. 1 = Disable rising edge or level interrupt.            */
      __O  uint32_t  CLRENRL_PIN3:  1;              /*!< Ones written to this address clear bits in the IENR, thus disabling
                                                         the interrupts. Bit 3 clears bit 3 in the IENR register. 0 =
                                                          No operation. 1 = Disable rising edge or level interrupt.            */
      __O  uint32_t  CLRENRL_PIN4:  1;              /*!< Ones written to this address clear bits in the IENR, thus disabling
                                                         the interrupts. Bit 4 clears bit 4 in the IENR register. [Note
                                                          interrupt not supported to processor] 0 = No operation. 1 =
                                                          Disable rising edge or level interrupt.                              */
      __O  uint32_t  CLRENRL_PIN5:  1;              /*!< Ones written to this address clear bits in the IENR, thus disabling
                                                         the interrupts. Bit 5 clears bit 5 in the IENR register. [Note
                                                          interrupt not supported to processor] 0 = No operation. 1 =
                                                          Disable rising edge or level interrupt.                              */
      __O  uint32_t  CLRENRL_PIN6:  1;              /*!< Ones written to this address clear bits in the IENR, thus disabling
                                                         the interrupts. Bit 6 clears bit 6 in the IENR register. [Note
                                                          interrupt not supported to processor] 0 = No operation. 1 =
                                                          Disable rising edge or level interrupt.                              */
      __O  uint32_t  CLRENRL_PIN7:  1;              /*!< Ones written to this address clear bits in the IENR, thus disabling
                                                         the interrupts. Bit 7 clears bit 7 in the IENR register. [Note
                                                          interrupt not supported to processor] 0 = No operation. 1 =
                                                          Disable rising edge or level interrupt.                              */
    } CIENR_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  IENF;                            /*!< Pin interrupt active level or falling edge interrupt enable
                                                         register                                                              */

    struct {
      __IO uint32_t  ENAF_PIN0  :  1;               /*!< Enables the falling edge or configures the active level interrupt
                                                         for pin interrupt 0 (selected in PINTSEL0). 0 = Disable falling
                                                          edge interrupt or set active interrupt level LOW. 1 = Enable
                                                          falling edge interrupt enabled or set active interrupt level
                                                          HIGH.                                                                */
      __IO uint32_t  ENAF_PIN1  :  1;               /*!< Enables the falling edge or configures the active level interrupt
                                                         for pin interrupt 1 (selected in PINTSEL1). 0 = Disable falling
                                                          edge interrupt or set active interrupt level LOW. 1 = Enable
                                                          falling edge interrupt enabled or set active interrupt level
                                                          HIGH.                                                                */
      __IO uint32_t  ENAF_PIN2  :  1;               /*!< Enables the falling edge or configures the active level interrupt
                                                         for pin interrupt 2 (selected in PINTSEL2). 0 = Disable falling
                                                          edge interrupt or set active interrupt level LOW. 1 = Enable
                                                          falling edge interrupt enabled or set active interrupt level
                                                          HIGH.                                                                */
      __IO uint32_t  ENAF_PIN3  :  1;               /*!< Enables the falling edge or configures the active level interrupt
                                                         for pin interrupt 3 (selected in PINTSEL3). 0 = Disable falling
                                                          edge interrupt or set active interrupt level LOW. 1 = Enable
                                                          falling edge interrupt enabled or set active interrupt level
                                                          HIGH.                                                                */
      __IO uint32_t  ENAF_PIN4  :  1;               /*!< Enables the falling edge or configures the active level interrupt
                                                         for pin interrupt 4 (selected in PINTSEL4). [Note interrupt
                                                          not supported to processor] 0 = Disable falling edge interrupt
                                                          or set active interrupt level LOW. 1 = Enable falling edge interrupt
                                                          enabled or set active interrupt level HIGH.                          */
      __IO uint32_t  ENAF_PIN5  :  1;               /*!< Enables the falling edge or configures the active level interrupt
                                                         for pin interrupt 5 (selected in PINTSEL5). [Note interrupt
                                                          not supported to processor] 0 = Disable falling edge interrupt
                                                          or set active interrupt level LOW. 1 = Enable falling edge interrupt
                                                          enabled or set active interrupt level HIGH.                          */
      __IO uint32_t  ENAF_PIN6  :  1;               /*!< Enables the falling edge or configures the active level interrupt
                                                         for pin interrupt 6 (selected in PINTSEL6). [Note interrupt
                                                          not supported to processor] 0 = Disable falling edge interrupt
                                                          or set active interrupt level LOW. 1 = Enable falling edge interrupt
                                                          enabled or set active interrupt level HIGH.                          */
      __IO uint32_t  ENAF_PIN7  :  1;               /*!< Enables the falling edge or configures the active level interrupt
                                                         for pin interrupt 7 (selected in PINTSEL7). [Note interrupt
                                                          not supported to processor] 0 = Disable falling edge interrupt
                                                          or set active interrupt level LOW. 1 = Enable falling edge interrupt
                                                          enabled or set active interrupt level HIGH.                          */
    } IENF_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  SIENF;                           /*!< Pin interrupt active level or falling edge interrupt set register     */

    struct {
      __O  uint32_t  SETENAF_PIN0:  1;              /*!< Ones written to this address set bits in the IENF, thus enabling
                                                         interrupts. Bit 0 sets bit 0 in the IENF register. 0 = No operation.
                                                          1 = Select HIGH-active interrupt or enable falling edge interrupt.   */
      __O  uint32_t  SETENAF_PIN1:  1;              /*!< Ones written to this address set bits in the IENF, thus enabling
                                                         interrupts. Bit 1 sets bit 1 in the IENF register. 0 = No operation.
                                                          1 = Select HIGH-active interrupt or enable falling edge interrupt.   */
      __O  uint32_t  SETENAF_PIN2:  1;              /*!< Ones written to this address set bits in the IENF, thus enabling
                                                         interrupts. Bit 2 sets bit 2 in the IENF register. 0 = No operation.
                                                          1 = Select HIGH-active interrupt or enable falling edge interrupt.   */
      __O  uint32_t  SETENAF_PIN3:  1;              /*!< Ones written to this address set bits in the IENF, thus enabling
                                                         interrupts. Bit 3 sets bit 3 in the IENF register. 0 = No operation.
                                                          1 = Select HIGH-active interrupt or enable falling edge interrupt.   */
      __O  uint32_t  SETENAF_PIN4:  1;              /*!< Ones written to this address set bits in the IENF, thus enabling
                                                         interrupts. Bit 4 sets bit 4 in the IENF register. 0 = No operation.
                                                          1 = Select HIGH-active interrupt or enable falling edge interrupt.   */
      __O  uint32_t  SETENAF_PIN5:  1;              /*!< Ones written to this address set bits in the IENF, thus enabling
                                                         interrupts. Bit 5 sets bit 5 in the IENF register. 0 = No operation.
                                                          1 = Select HIGH-active interrupt or enable falling edge interrupt.   */
      __O  uint32_t  SETENAF_PIN6:  1;              /*!< Ones written to this address set bits in the IENF, thus enabling
                                                         interrupts. Bit 6 sets bit 6 in the IENF register. 0 = No operation.
                                                          1 = Select HIGH-active interrupt or enable falling edge interrupt.   */
      __O  uint32_t  SETENAF_PIN7:  1;              /*!< Ones written to this address set bits in the IENF, thus enabling
                                                         interrupts. Bit 7 sets bit 7 in the IENF register. 0 = No operation.
                                                          1 = Select HIGH-active interrupt or enable falling edge interrupt.   */
    } SIENF_b;                                      /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  CIENF;                           /*!< Pin interrupt active level or falling edge interrupt clear register   */

    struct {
      __O  uint32_t  CLRENAF_PIN0:  1;              /*!< Ones written to this address clears bits in the IENF, thus disabling
                                                         interrupts. Bit 0 clears bit 0 in the IENF register. 0 = No
                                                          operation. 1 = LOW-active interrupt selected or falling edge
                                                          interrupt disabled.                                                  */
      __O  uint32_t  CLRENAF_PIN1:  1;              /*!< Ones written to this address clears bits in the IENF, thus disabling
                                                         interrupts. Bit 1 clears bit 1 in the IENF register. 0 = No
                                                          operation. 1 = LOW-active interrupt selected or falling edge
                                                          interrupt disabled.                                                  */
      __O  uint32_t  CLRENAF_PIN2:  1;              /*!< Ones written to this address clears bits in the IENF, thus disabling
                                                         interrupts. Bit 2 clears bit 2 in the IENF register. 0 = No
                                                          operation. 1 = LOW-active interrupt selected or falling edge
                                                          interrupt disabled.                                                  */
      __O  uint32_t  CLRENAF_PIN3:  1;              /*!< Ones written to this address clears bits in the IENF, thus disabling
                                                         interrupts. Bit 3 clears bit 3 in the IENF register. 0 = No
                                                          operation. 1 = LOW-active interrupt selected or falling edge
                                                          interrupt disabled.                                                  */
      __O  uint32_t  CLRENAF_PIN4:  1;              /*!< Ones written to this address clears bits in the IENF, thus disabling
                                                         interrupts. Bit 4 clears bit 4 in the IENF register. 0 = No
                                                          operation. 1 = LOW-active interrupt selected or falling edge
                                                          interrupt disabled.                                                  */
      __O  uint32_t  CLRENAF_PIN5:  1;              /*!< Ones written to this address clears bits in the IENF, thus disabling
                                                         interrupts. Bit 5 clears bit 5 in the IENF register. 0 = No
                                                          operation. 1 = LOW-active interrupt selected or falling edge
                                                          interrupt disabled.                                                  */
      __O  uint32_t  CLRENAF_PIN6:  1;              /*!< Ones written to this address clears bits in the IENF, thus disabling
                                                         interrupts. Bit 6 clears bit 6 in the IENF register. 0 = No
                                                          operation. 1 = LOW-active interrupt selected or falling edge
                                                          interrupt disabled.                                                  */
      __O  uint32_t  CLRENAF_PIN7:  1;              /*!< Ones written to this address clears bits in the IENF, thus disabling
                                                         interrupts. Bit 7 clears bit 7 in the IENF register. 0 = No
                                                          operation. 1 = LOW-active interrupt selected or falling edge
                                                          interrupt disabled.                                                  */
    } CIENF_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RISE;                            /*!< Pin interrupt rising edge register                                    */

    struct {
      __IO uint32_t  RDET_PIN0  :  1;               /*!< Rising edge detect. Bit 0 detects the rising edge of the pin
                                                         selected in PINTSEL0. Read 0: No rising edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a rising edge has been
                                                          detected since Reset or the last time a one was written to this
                                                          bit. Write 1: clear rising edge detection for this pin.              */
      __IO uint32_t  RDET_PIN1  :  1;               /*!< Rising edge detect. Bit 1 detects the rising edge of the pin
                                                         selected in PINTSEL1. Read 0: No rising edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a rising edge has been
                                                          detected since Reset or the last time a one was written to this
                                                          bit. Write 1: clear rising edge detection for this pin.              */
      __IO uint32_t  RDET_PIN2  :  1;               /*!< Rising edge detect. Bit 2 detects the rising edge of the pin
                                                         selected in PINTSEL2. Read 0: No rising edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a rising edge has been
                                                          detected since Reset or the last time a one was written to this
                                                          bit. Write 1: clear rising edge detection for this pin.              */
      __IO uint32_t  RDET_PIN3  :  1;               /*!< Rising edge detect. Bit 3 detects the rising edge of the pin
                                                         selected in PINTSEL3. Read 0: No rising edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a rising edge has been
                                                          detected since Reset or the last time a one was written to this
                                                          bit. Write 1: clear rising edge detection for this pin.              */
      __IO uint32_t  RDET_PIN4  :  1;               /*!< Rising edge detect. Bit 4 detects the rising edge of the pin
                                                         selected in PINTSEL4. Read 0: No rising edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a rising edge has been
                                                          detected since Reset or the last time a one was written to this
                                                          bit. Write 1: clear rising edge detection for this pin.              */
      __IO uint32_t  RDET_PIN5  :  1;               /*!< Rising edge detect. Bit 5 detects the rising edge of the pin
                                                         selected in PINTSEL5. Read 0: No rising edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a rising edge has been
                                                          detected since Reset or the last time a one was written to this
                                                          bit. Write 1: clear rising edge detection for this pin.              */
      __IO uint32_t  RDET_PIN6  :  1;               /*!< Rising edge detect. Bit 6 detects the rising edge of the pin
                                                         selected in PINTSEL6. Read 0: No rising edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a rising edge has been
                                                          detected since Reset or the last time a one was written to this
                                                          bit. Write 1: clear rising edge detection for this pin.              */
      __IO uint32_t  RDET_PIN7  :  1;               /*!< Rising edge detect. Bit 7 detects the rising edge of the pin
                                                         selected in PINTSEL7. Read 0: No rising edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a rising edge has been
                                                          detected since Reset or the last time a one was written to this
                                                          bit. Write 1: clear rising edge detection for this pin.              */
    } RISE_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FALL;                            /*!< Pin interrupt falling edge register                                   */

    struct {
      __IO uint32_t  FDET_PIN0  :  1;               /*!< Falling edge detect. Bit 0 detects the falling edge of the pin
                                                         selected in PINTSEL0. Read 0: No falling edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a falling edge has
                                                          been detected since Reset or the last time a one was written
                                                          to this bit. Write 1: clear falling edge detection for this
                                                          pin.                                                                 */
      __IO uint32_t  FDET_PIN1  :  1;               /*!< Falling edge detect. Bit 1 detects the falling edge of the pin
                                                         selected in PINTSEL1. Read 0: No falling edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a falling edge has
                                                          been detected since Reset or the last time a one was written
                                                          to this bit. Write 1: clear falling edge detection for this
                                                          pin.                                                                 */
      __IO uint32_t  FDET_PIN2  :  1;               /*!< Falling edge detect. Bit 2 detects the falling edge of the pin
                                                         selected in PINTSEL2. Read 0: No falling edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a falling edge has
                                                          been detected since Reset or the last time a one was written
                                                          to this bit. Write 1: clear falling edge detection for this
                                                          pin.                                                                 */
      __IO uint32_t  FDET_PIN3  :  1;               /*!< Falling edge detect. Bit 3 detects the falling edge of the pin
                                                         selected in PINTSEL3. Read 0: No falling edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a falling edge has
                                                          been detected since Reset or the last time a one was written
                                                          to this bit. Write 1: clear falling edge detection for this
                                                          pin.                                                                 */
      __IO uint32_t  FDET_PIN4  :  1;               /*!< Falling edge detect. Bit 4 detects the falling edge of the pin
                                                         selected in PINTSEL4. Read 0: No falling edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a falling edge has
                                                          been detected since Reset or the last time a one was written
                                                          to this bit. Write 1: clear falling edge detection for this
                                                          pin.                                                                 */
      __IO uint32_t  FDET_PIN5  :  1;               /*!< Falling edge detect. Bit 5 detects the falling edge of the pin
                                                         selected in PINTSEL5. Read 0: No falling edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a falling edge has
                                                          been detected since Reset or the last time a one was written
                                                          to this bit. Write 1: clear falling edge detection for this
                                                          pin.                                                                 */
      __IO uint32_t  FDET_PIN6  :  1;               /*!< Falling edge detect. Bit 6 detects the falling edge of the pin
                                                         selected in PINTSEL6. Read 0: No falling edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a falling edge has
                                                          been detected since Reset or the last time a one was written
                                                          to this bit. Write 1: clear falling edge detection for this
                                                          pin.                                                                 */
      __IO uint32_t  FDET_PIN7  :  1;               /*!< Falling edge detect. Bit 7 detects the falling edge of the pin
                                                         selected in PINTSEL7. Read 0: No falling edge has been detected
                                                          on this pin since Reset or the last time a one was written to
                                                          this bit. Write 0: no operation. Read 1: a falling edge has
                                                          been detected since Reset or the last time a one was written
                                                          to this bit. Write 1: clear falling edge detection for this
                                                          pin.                                                                 */
    } FALL_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  IST;                             /*!< Pin interrupt status register                                         */

    struct {
      __IO uint32_t  PSTAT_PIN0 :  1;               /*!< Pin interrupt status. Bit 0 returns the status, clears the edge
                                                         interrupt, or inverts the active level of the pin 0 (selected
                                                          in PINTSEL0). Read 0: interrupt is not being requested for this
                                                          interrupt pin. Write 0: no operation. Read 1: interrupt is being
                                                          requested for this interrupt pin. Write 1 (edge-sensitive):
                                                          clear rising- and falling-edge detection for this pin. Write
                                                          1 (level-sensitive): switch the active level for this pin (in
                                                          the IENF register).                                                  */
      __IO uint32_t  PSTAT_PIN1 :  1;               /*!< Pin interrupt status. Bit 1 returns the status, clears the edge
                                                         interrupt, or inverts the active level of the pin 1 (selected
                                                          in PINTSEL0). Read 0: interrupt is not being requested for this
                                                          interrupt pin. Write 0: no operation. Read 1: interrupt is being
                                                          requested for this interrupt pin. Write 1 (edge-sensitive):
                                                          clear rising- and falling-edge detection for this pin. Write
                                                          1 (level-sensitive): switch the active level for this pin (in
                                                          the IENF register).                                                  */
      __IO uint32_t  PSTAT_PIN2 :  1;               /*!< Pin interrupt status. Bit 2 returns the status, clears the edge
                                                         interrupt, or inverts the active level of the pin 2 (selected
                                                          in PINTSEL2). Read 0: interrupt is not being requested for this
                                                          interrupt pin. Write 0: no operation. Read 1: interrupt is being
                                                          requested for this interrupt pin. Write 1 (edge-sensitive):
                                                          clear rising- and falling-edge detection for this pin. Write
                                                          1 (level-sensitive): switch the active level for this pin (in
                                                          the IENF register).                                                  */
      __IO uint32_t  PSTAT_PIN3 :  1;               /*!< Pin interrupt status. Bit 3 returns the status, clears the edge
                                                         interrupt, or inverts the active level of the pin 3 (selected
                                                          in PINTSEL3). Read 0: interrupt is not being requested for this
                                                          interrupt pin. Write 0: no operation. Read 1: interrupt is being
                                                          requested for this interrupt pin. Write 1 (edge-sensitive):
                                                          clear rising- and falling-edge detection for this pin. Write
                                                          1 (level-sensitive): switch the active level for this pin (in
                                                          the IENF register).                                                  */
      __IO uint32_t  PSTAT_PIN4 :  1;               /*!< Pin interrupt status. Bit 4 returns the status, clears the edge
                                                         interrupt, or inverts the active level of the pin 4 (selected
                                                          in PINTSEL4). Read 0: interrupt is not being requested for this
                                                          interrupt pin. Write 0: no operation. Read 1: interrupt is being
                                                          requested for this interrupt pin. Write 1 (edge-sensitive):
                                                          clear rising- and falling-edge detection for this pin. Write
                                                          1 (level-sensitive): switch the active level for this pin (in
                                                          the IENF register).                                                  */
      __IO uint32_t  PSTAT_PIN5 :  1;               /*!< Pin interrupt status. Bit 5 returns the status, clears the edge
                                                         interrupt, or inverts the active level of the pin 5 (selected
                                                          in PINTSEL5). Read 0: interrupt is not being requested for this
                                                          interrupt pin. Write 0: no operation. Read 1: interrupt is being
                                                          requested for this interrupt pin. Write 1 (edge-sensitive):
                                                          clear rising- and falling-edge detection for this pin. Write
                                                          1 (level-sensitive): switch the active level for this pin (in
                                                          the IENF register).                                                  */
      __IO uint32_t  PSTAT_PIN6 :  1;               /*!< Pin interrupt status. Bit 6 returns the status, clears the edge
                                                         interrupt, or inverts the active level of the pin 6 (selected
                                                          in PINTSEL6). Read 0: interrupt is not being requested for this
                                                          interrupt pin. Write 0: no operation. Read 1: interrupt is being
                                                          requested for this interrupt pin. Write 1 (edge-sensitive):
                                                          clear rising- and falling-edge detection for this pin. Write
                                                          1 (level-sensitive): switch the active level for this pin (in
                                                          the IENF register).                                                  */
      __IO uint32_t  PSTAT_PIN7 :  1;               /*!< Pin interrupt status. Bit 7 returns the status, clears the edge
                                                         interrupt, or inverts the active level of the pin 7 (selected
                                                          in PINTSEL7). Read 0: interrupt is not being requested for this
                                                          interrupt pin. Write 0: no operation. Read 1: interrupt is being
                                                          requested for this interrupt pin. Write 1 (edge-sensitive):
                                                          clear rising- and falling-edge detection for this pin. Write
                                                          1 (level-sensitive): switch the active level for this pin (in
                                                          the IENF register).                                                  */
    } IST_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PMCTRL;                          /*!< Pattern match interrupt control register                              */

    struct {
      __IO uint32_t  SEL_PMATCH :  1;               /*!< Specifies whether the 8 pin interrupts are controlled by the
                                                         pin interrupt function or by the pattern match function. 0 Pin
                                                          interrupt. Interrupts are driven in response to the standard
                                                          pin interrupt function. 1 Pattern match. Interrupts are driven
                                                          in response to pattern matches.                                      */
      __IO uint32_t  ENA_RXEV   :  1;               /*!< Enables the RXEV output to the CPU and/or to a GPIO output when
                                                         the specified boolean expression evaluates to true. 0 Disabled.
                                                          RXEV output to the CPU is disabled. 1 Enabled. RXEV output to
                                                          the CPU is enabled.                                                  */
           uint32_t             : 22;
      __IO uint32_t  PMAT       :  8;               /*!< This field displays the current state of pattern matches. A
                                                         1 in any bit of this field indicates that the corresponding
                                                          product term is matched by the current state of the appropriate
                                                          inputs.                                                              */
    } PMCTRL_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PMSRC;                           /*!< Pattern match interrupt bit-slice source register                     */

    struct {
           uint32_t             :  8;
      __IO uint32_t  SRC0       :  3;               /*!< Selects the input source for bit slice 0 0x0 Input 0. Selects
                                                         the pin selected in the PINTSEL0 register as the source to bit
                                                          slice 0. 0x1 Input 1. Selects the pin selected in the PINTSEL1
                                                          register as the source to bit slice 0. 0x2 Input 2. Selects
                                                          the pin selected in the PINTSEL2 register as the source to bit
                                                          slice 0. 0x3 Input 3. Selects the pin selected in the PINTSEL3
                                                          register as the source to bit slice 0. 0x4 Input 4. Selects
                                                          the pin selected in the PINTSEL4 register as the source to bit
                                                          slice 0. 0x5 I                                                       */
      __IO uint32_t  SRC1       :  3;               /*!< Selects the input source for bit slice 1 0x0 Input 0. Selects
                                                         the pin selected in the PINTSEL0 register as the source to bit
                                                          slice 1. 0x1 Input 1. Selects the pin selected in the PINTSEL1
                                                          register as the source to bit slice 1. 0x2 Input 2. Selects
                                                          the pin selected in the PINTSEL2 register as the source to bit
                                                          slice 1. 0x3 Input 3. Selects the pin selected in the PINTSEL3
                                                          register as the source to bit slice 1. 0x4 Input 4. Selects
                                                          the pin selected in the PINTSEL4 register as the source to bit
                                                          slice 1. 0x5 I                                                       */
      __IO uint32_t  SRC2       :  3;               /*!< Selects the input source for bit slice 2 0x0 Input 0. Selects
                                                         the pin selected in the PINTSEL0 register as the source to bit
                                                          slice 2. 0x1 Input 1. Selects the pin selected in the PINTSEL1
                                                          register as the source to bit slice 2. 0x2 Input 2. Selects
                                                          the pin selected in the PINTSEL2 register as the source to bit
                                                          slice 2. 0x3 Input 3. Selects the pin selected in the PINTSEL3
                                                          register as the source to bit slice 2. 0x4 Input 4. Selects
                                                          the pin selected in the PINTSEL4 register as the source to bit
                                                          slice 2. 0x5 I                                                       */
      __IO uint32_t  SRC3       :  3;               /*!< Selects the input source for bit slice 3 0x0 Input 0. Selects
                                                         the pin selected in the PINTSEL0 register as the source to bit
                                                          slice 3. 0x1 Input 1. Selects the pin selected in the PINTSEL1
                                                          register as the source to bit slice 3. 0x2 Input 2. Selects
                                                          the pin selected in the PINTSEL2 register as the source to bit
                                                          slice 3. 0x3 Input 3. Selects the pin selected in the PINTSEL3
                                                          register as the source to bit slice 3. 0x4 Input 4. Selects
                                                          the pin selected in the PINTSEL4 register as the source to bit
                                                          slice 3. 0x5 I                                                       */
      __IO uint32_t  SRC4       :  3;               /*!< Selects the input source for bit slice 4 0x0 Input 0. Selects
                                                         the pin selected in the PINTSEL0 register as the source to bit
                                                          slice 4. 0x1 Input 1. Selects the pin selected in the PINTSEL1
                                                          register as the source to bit slice 4. 0x2 Input 2. Selects
                                                          the pin selected in the PINTSEL2 register as the source to bit
                                                          slice 4. 0x3 Input 3. Selects the pin selected in the PINTSEL3
                                                          register as the source to bit slice 4. 0x4 Input 4. Selects
                                                          the pin selected in the PINTSEL4 register as the source to bit
                                                          slice 4. 0x5 I                                                       */
      __IO uint32_t  SRC5       :  3;               /*!< Selects the input source for bit slice 5 0x0 Input 0. Selects
                                                         the pin selected in the PINTSEL0 register as the source to bit
                                                          slice 5. 0x1 Input 1. Selects the pin selected in the PINTSEL1
                                                          register as the source to bit slice 5. 0x2 Input 2. Selects
                                                          the pin selected in the PINTSEL2 register as the source to bit
                                                          slice 5. 0x3 Input 3. Selects the pin selected in the PINTSEL3
                                                          register as the source to bit slice 5. 0x4 Input 4. Selects
                                                          the pin selected in the PINTSEL4 register as the source to bit
                                                          slice 5. 0x5 I                                                       */
      __IO uint32_t  SRC6       :  3;               /*!< Selects the input source for bit slice 6 0x0 Input 0. Selects
                                                         the pin selected in the PINTSEL0 register as the source to bit
                                                          slice 6. 0x1 Input 1. Selects the pin selected in the PINTSEL1
                                                          register as the source to bit slice 6. 0x2 Input 2. Selects
                                                          the pin selected in the PINTSEL2 register as the source to bit
                                                          slice 6. 0x3 Input 3. Selects the pin selected in the PINTSEL3
                                                          register as the source to bit slice 6. 0x4 Input 4. Selects
                                                          the pin selected in the PINTSEL4 register as the source to bit
                                                          slice 6. 0x5 I                                                       */
      __IO uint32_t  SRC7       :  3;               /*!< Selects the input source for bit slice 7 0x0 Input 0. Selects
                                                         the pin selected in the PINTSEL0 register as the source to bit
                                                          slice 7. 0x1 Input 1. Selects the pin selected in the PINTSEL1
                                                          register as the source to bit slice 7. 0x2 Input 2. Selects
                                                          the pin selected in the PINTSEL2 register as the source to bit
                                                          slice 7. 0x3 Input 3. Selects the pin selected in the PINTSEL3
                                                          register as the source to bit slice 7. 0x4 Input 4. Selects
                                                          the pin selected in the PINTSEL4 register as the source to bit
                                                          slice 7. 0x5 I                                                       */
    } PMSRC_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PMCFG;                           /*!< Pattern match interrupt bit slice configuration register              */

    struct {
      __IO uint32_t  PROD_ENDPTS0:  1;              /*!< Determines whether slice 0 is an endpoint. 0 No effect. Slice
                                                         0 is not an endpoint. 1 endpoint. Slice 0 is the endpoint of
                                                          a product term (minterm). Pin interrupt 0 in the NVIC is raised
                                                          if the minterm evaluates as true.                                    */
      __IO uint32_t  PROD_ENDPTS1:  1;              /*!< Determines whether slice 1 is an endpoint. 0 No effect. Slice
                                                         1 is not an endpoint. 1 endpoint. Slice 1 is the endpoint of
                                                          a product term (minterm). Pin interrupt 1 in the NVIC is raised
                                                          if the minterm evaluates as true.                                    */
      __IO uint32_t  PROD_ENDPTS2:  1;              /*!< Determines whether slice 2 is an endpoint. 0 No effect. Slice
                                                         2 is not an endpoint. 1 endpoint. Slice 2 is the endpoint of
                                                          a product term (minterm). Pin interrupt 2 in the NVIC is raised
                                                          if the minterm evaluates as true.                                    */
      __IO uint32_t  PROD_ENDPTS3:  1;              /*!< Determines whether slice 3 is an endpoint. 0 No effect. Slice
                                                         3 is not an endpoint. 1 endpoint. Slice 3 is the endpoint of
                                                          a product term (minterm). Pin interrupt 3 in the NVIC is raised
                                                          if the minterm evaluates as true.                                    */
      __IO uint32_t  PROD_ENDPTS4:  1;              /*!< Determines whether slice 4 is an endpoint. 0 No effect. Slice
                                                         4 is not an endpoint. 1 endpoint. Slice 4 is the endpoint of
                                                          a product term (minterm). Pin interrupt 4 in the NVIC is raised
                                                          if the minterm evaluates as true.                                    */
      __IO uint32_t  PROD_ENDPTS5:  1;              /*!< Determines whether slice 5 is an endpoint. 0 No effect. Slice
                                                         5 is not an endpoint. 1 endpoint. Slice 5 is the endpoint of
                                                          a product term (minterm). Pin interrupt 5 in the NVIC is raised
                                                          if the minterm evaluates as true.                                    */
      __IO uint32_t  PROD_ENDPTS6:  1;              /*!< Determines whether slice 6 is an endpoint. 0 No effect. Slice
                                                         6 is not an endpoint. 1 endpoint. Slice 6 is the endpoint of
                                                          a product term (minterm). Pin interrupt 6 in the NVIC is raised
                                                          if the minterm evaluates as true.                                    */
           uint32_t             :  1;
      __IO uint32_t  CFG0       :  3;               /*!< Specifies the match contribution condition for bit slice 0.
                                                         0x0 Constant HIGH. This bit slice always contributes to a product
                                                          term match. 0x1 Sticky rising edge. Match occurs if a rising
                                                          edge on the specified input has occurred since the last time
                                                          the edge detection for this bit slice was cleared. This bit
                                                          is only cleared when the PMCFG or the PMSRC registers are written
                                                          to. 0x2 Sticky falling edge. Match occurs if a falling edge
                                                          on the specified input has occurred since the last time the
                                                          edge detection fo                                                    */
      __IO uint32_t  CFG1       :  3;               /*!< Specifies the match contribution condition for bit slice 1.
                                                         0x0 Constant HIGH. This bit slice always contributes to a product
                                                          term match. 0x1 Sticky rising edge. Match occurs if a rising
                                                          edge on the specified input has occurred since the last time
                                                          the edge detection for this bit slice was cleared. This bit
                                                          is only cleared when the PMCFG or the PMSRC registers are written
                                                          to. 0x2 Sticky falling edge. Match occurs if a falling edge
                                                          on the specified input has occurred since the last time the
                                                          edge detection fo                                                    */
      __IO uint32_t  CFG2       :  3;               /*!< Specifies the match contribution condition for bit slice 2.
                                                         0x0 Constant HIGH. This bit slice always contributes to a product
                                                          term match. 0x1 Sticky rising edge. Match occurs if a rising
                                                          edge on the specified input has occurred since the last time
                                                          the edge detection for this bit slice was cleared. This bit
                                                          is only cleared when the PMCFG or the PMSRC registers are written
                                                          to. 0x2 Sticky falling edge. Match occurs if a falling edge
                                                          on the specified input has occurred since the last time the
                                                          edge detection fo                                                    */
      __IO uint32_t  CFG3       :  3;               /*!< Specifies the match contribution condition for bit slice 3.
                                                         0x0 Constant HIGH. This bit slice always contributes to a product
                                                          term match. 0x1 Sticky rising edge. Match occurs if a rising
                                                          edge on the specified input has occurred since the last time
                                                          the edge detection for this bit slice was cleared. This bit
                                                          is only cleared when the PMCFG or the PMSRC registers are written
                                                          to. 0x2 Sticky falling edge. Match occurs if a falling edge
                                                          on the specified input has occurred since the last time the
                                                          edge detection fo                                                    */
      __IO uint32_t  CFG4       :  3;               /*!< Specifies the match contribution condition for bit slice 4.
                                                         0x0 Constant HIGH. This bit slice always contributes to a product
                                                          term match. 0x1 Sticky rising edge. Match occurs if a rising
                                                          edge on the specified input has occurred since the last time
                                                          the edge detection for this bit slice was cleared. This bit
                                                          is only cleared when the PMCFG or the PMSRC registers are written
                                                          to. 0x2 Sticky falling edge. Match occurs if a falling edge
                                                          on the specified input has occurred since the last time the
                                                          edge detection fo                                                    */
      __IO uint32_t  CFG5       :  3;               /*!< Specifies the match contribution condition for bit slice 5.
                                                         0x0 Constant HIGH. This bit slice always contributes to a product
                                                          term match. 0x1 Sticky rising edge. Match occurs if a rising
                                                          edge on the specified input has occurred since the last time
                                                          the edge detection for this bit slice was cleared. This bit
                                                          is only cleared when the PMCFG or the PMSRC registers are written
                                                          to. 0x2 Sticky falling edge. Match occurs if a falling edge
                                                          on the specified input has occurred since the last time the
                                                          edge detection fo                                                    */
      __IO uint32_t  CFG6       :  3;               /*!< Specifies the match contribution condition for bit slice 6.
                                                         0x0 Constant HIGH. This bit slice always contributes to a product
                                                          term match. 0x1 Sticky rising edge. Match occurs if a rising
                                                          edge on the specified input has occurred since the last time
                                                          the edge detection for this bit slice was cleared. This bit
                                                          is only cleared when the PMCFG or the PMSRC registers are written
                                                          to. 0x2 Sticky falling edge. Match occurs if a falling edge
                                                          on the specified input has occurred since the last time the
                                                          edge detection fo                                                    */
      __IO uint32_t  CFG7       :  3;               /*!< Specifies the match contribution condition for bit slice 7.
                                                         0x0 Constant HIGH. This bit slice always contributes to a product
                                                          term match. 0x1 Sticky rising edge. Match occurs if a rising
                                                          edge on the specified input has occurred since the last time
                                                          the edge detection for this bit slice was cleared. This bit
                                                          is only cleared when the PMCFG or the PMSRC registers are written
                                                          to. 0x2 Sticky falling edge. Match occurs if a falling edge
                                                          on the specified input has occurred since the last time the
                                                          edge detection fo                                                    */
    } PMCFG_b;                                      /*!< BitSize                                                               */
  };
} u_pint_Type;


/* ================================================================================ */
/* ================                     u_gint                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component gint It is an Global Interrupt with APB bus interface. More details will follow. (u_gint)
  */

typedef struct {                                    /*!< u_gint Structure                                                      */

  union {
    __IO uint32_t  CTRL;                            /*!< GPIO Grouped interrupt control register                               */

    struct {
      __IO uint32_t  INT        :  1;               /*!< Group interrupt status. This bit is cleared by writing a one
                                                         to it. Writing zero has no effect.                                    */
      __IO uint32_t  COMB       :  1;               /*!< Combine enabled inputs for group interrupt. 0 Or, OR functionality:
                                                         A grouped interrupt is generated when any one of the enabled
                                                          inputs is active (based on its programmed polarity) 1 And, AND
                                                          functionality: An interrupt is generated when all enabled bits
                                                          are active (based on their programmed polarity)                      */
      __IO uint32_t  TRIG       :  1;               /*!< Group interrupt trigger. 0 Edge Triggered. 1 Level Triggered.         */
    } CTRL_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[7];

  union {
    __IO uint32_t  PORT_POL0;                       /*!< GPIO Grouped Interrupt polrity register                               */

    struct {
      __IO uint32_t  POL_PIO0   :  1;               /*!< Configure pin polarity of pin PIO0. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO1   :  1;               /*!< Configure pin polarity of pin PIO1. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO2   :  1;               /*!< Configure pin polarity of pin PIO2. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO3   :  1;               /*!< Configure pin polarity of pin PIO3. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO4   :  1;               /*!< Configure pin polarity of pin PIO4. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO5   :  1;               /*!< Configure pin polarity of pin PIO5. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO6   :  1;               /*!< Configure pin polarity of pin PIO6. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO7   :  1;               /*!< Configure pin polarity of pin PIO7. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO8   :  1;               /*!< Configure pin polarity of pin PIO8. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO9   :  1;               /*!< Configure pin polarity of pin PIO9. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO10  :  1;               /*!< Configure pin polarity of pin PIO10. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO11  :  1;               /*!< Configure pin polarity of pin PIO11. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO12  :  1;               /*!< Configure pin polarity of pin PIO12. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO13  :  1;               /*!< Configure pin polarity of pin PIO13. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO14  :  1;               /*!< Configure pin polarity of pin PIO14. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO15  :  1;               /*!< Configure pin polarity of pin PIO15. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO16  :  1;               /*!< Configure pin polarity of pin PIO16. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO17  :  1;               /*!< Configure pin polarity of pin PIO17. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO18  :  1;               /*!< Configure pin polarity of pin PIO18. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO19  :  1;               /*!< Configure pin polarity of pin PIO19. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO20  :  1;               /*!< Configure pin polarity of pin PIO20. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
      __IO uint32_t  POL_PIO21  :  1;               /*!< Configure pin polarity of pin PIO21. 0 = the pin is active low.
                                                         If the level on this pin is LOW, the pin contributes to the
                                                          group interrupt. 1 = the pin is active HIGH. If the level on
                                                          this pin is HIGH, the pin contributes to the group interrupt.        */
    } PORT_POL0_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[7];

  union {
    __IO uint32_t  PORT_ENA0;                       /*!< GPIO Grouped Interrupt port enable register                           */

    struct {
      __IO uint32_t  ENA_PIO0   :  1;               /*!< Enable pin PIO0 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO1   :  1;               /*!< Enable pin PIO1 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO2   :  1;               /*!< Enable pin PIO2 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO3   :  1;               /*!< Enable pin PIO3 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO4   :  1;               /*!< Enable pin PIO4 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO5   :  1;               /*!< Enable pin PIO5 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO6   :  1;               /*!< Enable pin PIO6 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO7   :  1;               /*!< Enable pin PIO7 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO8   :  1;               /*!< Enable pin PIO8 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO9   :  1;               /*!< Enable pin PIO9 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO10  :  1;               /*!< Enable pin PIO10 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO11  :  1;               /*!< Enable pin PIO11 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO12  :  1;               /*!< Enable pin PIO12 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO13  :  1;               /*!< Enable pin PIO13 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO14  :  1;               /*!< Enable pin PIO14 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO15  :  1;               /*!< Enable pin PIO15 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO16  :  1;               /*!< Enable pin PIO16 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO17  :  1;               /*!< Enable pin PIO17 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO18  :  1;               /*!< Enable pin PIO18 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO19  :  1;               /*!< Enable pin PIO19 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO20  :  1;               /*!< Enable pin PIO20 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
      __IO uint32_t  ENA_PIO21  :  1;               /*!< Enable pin PIO21 for group interrupt. When set this pin contributes
                                                         to the grouped interupt function.                                     */
    } PORT_ENA0_b;                                  /*!< BitSize                                                               */
  };
} u_gint_Type;


/* ================================================================================ */
/* ================                      u_pmc                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component pmc. It is the Power Management Unit Controller. More details will follow. (u_pmc)
  */

typedef struct {                                    /*!< u_pmc Structure                                                       */

  union {
    __IO uint32_t  CTRL;                            /*!< Power Management Control [Reset by POR, RSTN, WDT ]                   */

    struct {
      __IO uint32_t  LPMODE     :  2;               /*!< Power Mode Control. 00 : Active 01 : Deep Sleep 10 : Power Down
                                                         11 : Deep Power Down                                                  */
      __IO uint32_t  SYSTEMRESETENABLE:  1;         /*!< ARM system reset request enable. If set enables the ARM system
                                                         reset to affect the system.                                           */
      __IO uint32_t  WDTRESETENABLE:  1;            /*!< Watchdog Timer reset enable. If set allow a watchdog timer reset
                                                         event to affect the system.                                           */
      __IO uint32_t  WAKUPRESETENABLE:  1;          /*!< Wake-up I/Os reset enable. When set, the I/O power domain is
                                                         not shutoff in deep powerdown mode.                                   */
      __IO uint32_t  NTAGWAKUPRESETENABLE:  1;      /*!< Wake-up NTAG reset enable. When set, the device can wake from
                                                         deep power down by edge on NTAG FD signal, even if I/O power
                                                          domain is off (see WAKUPRESETENABLE). Note that if I/O power
                                                          domain is ON, wake-up by NTAG FD is enabled by default thus
                                                          content of this bit does not care. Do not set unless entering
                                                          Deep Power Down.                                                     */
      __IO uint32_t  RESERVED6  :  1;               /*!< Reserved. User software should write zeroes to reserved bits.
                                                         The value read from a reserved bit is not defined.                    */
      __IO uint32_t  SELCLOCK   :  1;               /*!< Select PMC functional clock : 0 = 1 MHz FRO 1 = 12 MHz FRO            */
      __IO uint32_t  SELLDOVOLTAGE:  1;             /*!< 0 = all LDOs current output levels are determined by their associated
                                                         VADJ bitfield. 1 = all LDOs current output levels are determined
                                                          by their associated VADJ_2 bitfield.                                 */
      __IO uint32_t  SWRRESETENABLE:  1;            /*!< Software reset enable. If set enables the software reset to
                                                         affect the system.                                                    */
    } CTRL_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DCDC0;                           /*!< DCDC control register (1st) [Reset by all reset sources, except
                                                         ARM SystemReset]                                                      */

    struct {
      __IO uint32_t  RC         :  6;               /*!< Constant On-Time calibration                                          */
      __IO uint32_t  ICOMP      :  2;               /*!< Select the type of ZCD comparator                                     */
      __IO uint32_t  ISEL       :  2;               /*!< Alter Internal biasing currents                                       */
      __IO uint32_t  ICENABLE   :  1;               /*!< Selection of auto scaling of COT period with variations in VDD        */
      __IO uint32_t  TMOS       :  5;               /*!< One-shot generator reference current trimming signal                  */
      __IO uint32_t  DISABLEISENSE:  1;             /*!< Disable Current sensing                                               */
      __IO uint32_t  VOUT       :  3;               /*!< Set output regulation voltage                                         */
      __IO uint32_t  SLICINGENABLE:  1;             /*!< driver_par_en                                                         */
      __IO uint32_t  SLICINGPMOS:  2;               /*!< open                                                                  */
      __IO uint32_t  SLICINGNMOS:  2;               /*!< open                                                                  */
      __IO uint32_t  INDUCTORCLAMPENABLE:  1;       /*!< ind_shrt                                                              */
      __IO uint32_t  CONTINUOUSMODEENABLE:  1;      /*!< open                                                                  */
    } DCDC0_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DCDC1;                           /*!< DCDC control register (2nd) [Reset by all reset sources, except
                                                         ARM SystemReset]                                                      */

    struct {
      __IO uint32_t  RTRIMOFFET :  4;               /*!< Adjust the offset voltage of BJT based comparator                     */
      __IO uint32_t  RSENSETRIM :  4;               /*!< Adjust Max inductor peak current limiting                             */
      __IO uint32_t  USEEXTREF  :  1;               /*!< Select output bandgap value on tp1                                    */
      __IO uint32_t  DTESTENABLE:  1;               /*!< Enable Digital test signals                                           */
      __IO uint32_t  SETCURVE   :  2;               /*!< Bandgap calibration parameter                                         */
      __IO uint32_t  SETDC      :  4;               /*!< Bandgap calibration parameter                                         */
      __IO uint32_t  DTESTSEL   :  3;               /*!< Select the output signal for test                                     */
      __IO uint32_t  ISCALEENABLE:  1;              /*!< Modify COT behavior                                                   */
      __IO uint32_t  FORCEBYPASS:  1;               /*!< Force bypass mode                                                     */
      __IO uint32_t  TRIMAUTOCOT:  4;               /*!< TrimAutoCot setting                                                   */
      __IO uint32_t  LCENABLE   :  1;               /*!< LC enable                                                             */
      __IO uint32_t  FORCEFULLCYCLE:  1;            /*!< Force full cycle                                                      */
    } DCDC1_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  BIAS;                            /*!< Bias current source control register [Reset by POR, RSTN, WDT
                                                         ]                                                                     */

    struct {
      __IO uint32_t  DCBGAP     :  5;               /*!< trimming bits to adjust absolute voltage value                        */
      __IO uint32_t  CURVE      :  2;               /*!< trimming bits to adjust deviations in curvature on silicon            */
           uint32_t             :  1;
      __IO uint32_t  TRIM       :  4;               /*!< Control of additional current braches for PMU analog blocks           */
      __IO uint32_t  IREFTRIM   :  6;               /*!< (null)                                                                */
      __IO uint32_t  ATBENABLE  :  1;               /*!< (null)                                                                */
      __IO uint32_t  ATB        :  2;               /*!< (null)                                                                */
    } BIAS_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  LDOPMU;                          /*!< PMU & Always On domains LDO control [Reset by all reset sources,
                                                         except ARM SystemReset]                                               */

    struct {
      __IO uint32_t  VADJ       :  5;               /*!< Sets the LDO output level (1.1V). LDO output level, in active,
                                                         sleep and deep sleep modes, when CTRL.SELLDOVOLTAGE = 0               */
      __IO uint32_t  VADJ_PWD   :  5;               /*!< Sets the LDO output level in power down modes (0.8V)                  */
      __IO uint32_t  STAB       :  1;               /*!< (null)                                                                */
      __IO uint32_t  HIGHCUR    :  1;               /*!< (null)                                                                */
      __IO uint32_t  VADJ_BOOST :  5;               /*!< Sets the LDO Boost output level (1.0V). BOOSTADJ=1 mandatory          */
      __IO uint32_t  VADJ_BOOST_PWD:  5;            /*!< Sets the LDO Boost output level in power down modes (0.75V)           */
      __IO uint32_t  BOOSTADJ   :  1;               /*!< LDO boost enable in active, sleep and deep sleep mode, when
                                                         CTRL.SELLDOVOLTAGE = 0                                                */
      __IO uint32_t  BOOSTADJ_PWD:  1;              /*!< LDO boost enable in power down modes                                  */
      __IO uint32_t  VADJ_2     :  5;               /*!< LDO output level, in active, sleep and deep sleep modes, when
                                                         CTRL.SELLDOVOLTAGE = 1                                                */
      __IO uint32_t  BOOSTADJ_2 :  1;               /*!< LDO boost enable in active, sleep and deep sleep modes when
                                                         CTRL.SELLDOVOLTAGE = 1                                                */
    } LDOPMU_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  LDOMEM;                          /*!< Memories LDO control register [Reset by all reset sources, except
                                                         ARM SystemReset]                                                      */

    struct {
      __IO uint32_t  VADJ       :  5;               /*!< Sets the LDO output level (1.1V). LDO output level, in active
                                                         and sleep modes, when CTRL.SELLDOVOLTAGE = 0                          */
      __IO uint32_t  VADJ_PWD   :  5;               /*!< Sets the LDO output level (1.1V) in power down modes                  */
      __IO uint32_t  STAB       :  1;               /*!< (null)                                                                */
      __IO uint32_t  HIGHCUR    :  1;               /*!< (null)                                                                */
      __IO uint32_t  VADJ_BOOST :  5;               /*!< Sets the LDO Boost output level (1.05V)                               */
      __IO uint32_t  VADJ_BOOST_PWD:  5;            /*!< Sets the LDO Boost output level in power down modes (1.05V)           */
      __IO uint32_t  BLEED      :  1;               /*!< (null)                                                                */
      __IO uint32_t  VADJ_2     :  5;               /*!< LDO output level, in active and sleep modes, when CTRL.SELLDOVOLTAGE
                                                         = 1                                                                   */
    } LDOMEM_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  LDOCORE;                         /*!< Digital Core LDO control register [Reset by all reset sources,
                                                         except ARM SystemReset]                                               */

    struct {
      __IO uint32_t  VADJ       :  3;               /*!< Sets the LDO output level. LDO output level, in active and sleep
                                                         modes, when CTRL.SELLDOVOLTAGE = 0                                    */
      __IO uint32_t  VADJ_PWD   :  3;               /*!< Sets the LDO output level in deep sleep mode                          */
      __IO uint32_t  BYPASS     :  1;               /*!< Activate LDO bypass                                                   */
           uint32_t             :  1;
      __IO uint32_t  IBIAS      :  2;               /*!< Adjust the biasing current                                            */
      __IO uint32_t  STABMODE   :  2;               /*!< Stability configuration                                               */
      __IO uint32_t  VADJ_2     :  3;               /*!< LDO output level, in active and sleep modes, when CTRL.SELLDOVOLTAGE
                                                         = 1                                                                   */
    } LDOCORE_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  LDOFLASHNV;                      /*!< Flash LDO control register [Reset by all reset sources, except
                                                         ARM SystemReset]                                                      */

    struct {
      __IO uint32_t  VADJ       :  3;               /*!< Sets the LDO output level. LDO output level when CTRL.SELLDOVOLTAGE
                                                         = 0                                                                   */
      __IO uint32_t  BYPASS     :  1;               /*!< Activate LDO bypass                                                   */
      __IO uint32_t  HIGHZ      :  1;               /*!< Put the output in high impedance state                                */
      __IO uint32_t  IBIAS      :  2;               /*!< Adjust the biasing current                                            */
      __IO uint32_t  STABMODE   :  1;               /*!< Stability configuration                                               */
           uint32_t             :  2;
      __IO uint32_t  TRIMR      :  5;               /*!< [Not used within PMU - do not change] R trim word, use in Flash
                                                         reference current calibration scheme                                  */
      __IO uint32_t  VADJ_2     :  3;               /*!< LDO output level when CTRL.SELLDOVOLTAGE = 1                          */
    } LDOFLASHNV_b;                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  LDOFLASHCORE;                    /*!< Flash Core LDO control register [Reset by all reset sources,
                                                         except ARM SystemReset]                                               */

    struct {
      __IO uint32_t  VADJ       :  3;               /*!< Sets the LDO output level. LDO output level when CTRL.SELLDOVOLTAGE
                                                         = 0                                                                   */
      __IO uint32_t  BYPASS     :  1;               /*!< Activate LDO bypass                                                   */
      __IO uint32_t  HIGHZ      :  1;               /*!< Put the output in high impedance state                                */
      __IO uint32_t  IBIAS      :  2;               /*!< Adjust the biasing current                                            */
      __IO uint32_t  STABMODE   :  2;               /*!< Stability configuration                                               */
      __IO uint32_t  VADJ_2     :  3;               /*!< LDO output level when CTRL.SELLDOVOLTAGE = 1                          */
    } LDOFLASHCORE_b;                               /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  LDOADC;                          /*!< General Purpose ADC LDO control register [Reset by all reset
                                                         sources, except ARM SystemReset]                                      */

    struct {
      __IO uint32_t  VADJ       :  3;               /*!< Sets the LDO output level. LDO output level when CTRL.SELLDOVOLTAGE
                                                         = 0                                                                   */
      __IO uint32_t  BYPASS     :  1;               /*!< Activate LDO bypass                                                   */
      __IO uint32_t  HIGHZ      :  1;               /*!< Put the output in high impedance state                                */
      __IO uint32_t  IBIAS      :  2;               /*!< Adjust the biasing current                                            */
      __IO uint32_t  STABMODE   :  2;               /*!< Stability configuration                                               */
      __IO uint32_t  VADJ_2     :  3;               /*!< LDO output level when CTRL.SELLDOVOLTAGE = 1                          */
    } LDOADC_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[2];

  union {
    __IO uint32_t  BODVBAT;                         /*!< VBAT Brown Out Dectector control register [Reset by POR, RSTN,
                                                         WDT ]                                                                 */

    struct {
      __IO uint32_t  TRIGLVL    :  5;               /*!< BOD trigger level                                                     */
      __IO uint32_t  HYST       :  2;               /*!< BOD Hysteresis control                                                */
      __IO uint32_t  RESETENABLE:  1;               /*!< BOD reset enable. If set and BODVBAT LOW event occurs, then
                                                         the IC will go and stay in reset forever (till hard reset on
                                                          PAD RSTN). Suggestion is to not use this feature                     */
    } BODVBAT_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  BODMEM;                          /*!< Memories Brown Out Dectector control register [Reset by all
                                                         reset sources, except ARM SystemReset]                                */

    struct {
      __IO uint32_t  TRIGLVL    :  4;               /*!< BOD trigger level                                                     */
      __IO uint32_t  HYST       :  2;               /*!< BOD Hysteresis control                                                */
      __IO uint32_t  RESETENABLE:  1;               /*!< BOD reset enable                                                      */
    } BODMEM_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  BODCORE;                         /*!< Digital Core Brown Out Dectector control register [Reset by
                                                         all reset sources, except ARM SystemReset]                            */

    struct {
      __IO uint32_t  TRIGLVL    :  4;               /*!< BOD trigger level                                                     */
      __IO uint32_t  HYST       :  2;               /*!< BOD Hysteresis control                                                */
      __IO uint32_t  RESETENABLE:  1;               /*!< BOD reset enable                                                      */
    } BODCORE_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1;

  union {
    __IO uint32_t  FRO192M;                         /*!< 192 MHz Free Running Oscillator control register [Reset by POR,
                                                         RSTN, WDT ]                                                           */

    struct {
      __IO uint32_t  TEMPTRIM   :  6;               /*!< Temperature coefficient trimming bits                                 */
      __IO uint32_t  BIASTRIM   :  6;               /*!< Bias trimming bits (course frequency trimming)                        */
      __IO uint32_t  DACTRIM    :  8;               /*!< Curdac trimming bits (fine frequency trimming)                        */
      __IO uint32_t  DIVSEL     :  5;               /*!< Mode of operation (which clock to output). FRO192M always generated.
                                                         Bits then enable further clocks as shown. Enables are additive
                                                          meaning that two or more clocks can be enabled together. xxxx1
                                                          : 12MHz enabled xxx1x : 32MHz enabled xx1xx : 48MHz enabled
                                                          x1xxx : 64MHz enabled 1xxxx : 96MHz enabled Note: 192M and 96M
                                                          not connected in system                                              */
      __IO uint32_t  ATBCTRL    :  2;               /*!< Debug control bits to set the analog/digital test modes               */
    } FRO192M_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FRO1M;                           /*!< 1 MHz Free Running Oscillator control register [Reset by all
                                                         reset sources, except ARM SystemReset]                                */

    struct {
      __IO uint32_t  FREQSEL    :  7;               /*!< Frequency trimming bits                                               */
      __IO uint32_t  ATBCTRL    :  2;               /*!< Debug control bits to set the analog/digital test modes               */
      __IO uint32_t  DIVSEL     :  5;               /*!< Divider selection bits                                                */
    } FRO1M_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FRO32K;                          /*!< 32 KHz Free Running Oscillator (FRO) control register [Reset
                                                         by POR, RSTN, WDT ]                                                   */

    struct {
           uint32_t             :  1;
      __IO uint32_t  NTAT       :  3;               /*!< Temperature coefficient trimming bits                                 */
      __IO uint32_t  PTAT       :  3;               /*!< Bias trimming bits (course frequency trimming)                        */
      __IO uint32_t  CAPCAL     :  9;               /*!< Capacitive dac calibration bits (fine frequency trimming)             */
      __IO uint32_t  ATBCTRL    :  2;               /*!< Debug control bits to set the analog/digital test modes               */
    } FRO32K_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  XTAL32K;                         /*!< 32 KHz Chrystal oscillator (XTAL) control register [Reset by
                                                         all reset sources, except ARM SystemReset]                            */

    struct {
           uint32_t             :  1;
      __IO uint32_t  IREF       :  2;               /*!< reference output current selection inputs                             */
      __IO uint32_t  TEST       :  1;               /*!< Oscillator Test Mode                                                  */
      __IO uint32_t  IBIAS      :  2;               /*!< (null)                                                                */
      __IO uint32_t  AMPL       :  2;               /*!< (null)                                                                */
    } XTAL32K_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANAMUXCOMP;                      /*!< Analog Comparator and Analog Mux control register [Reset by
                                                         all reset sources, except ARM SystemReset]                            */

    struct {
           uint32_t             :  1;
      __IO uint32_t  COMP_HYST  :  1;               /*!< Hysteris when hyst = '1'                                              */
      __IO uint32_t  COMP_INNINT:  1;               /*!< inn_int input is selected when sel_inn_int = 1                        */
      __IO uint32_t  COMP_LOWPOWER:  1;             /*!< Low power mode                                                        */
      __IO uint32_t  COMP_INPUTSWAP:  1;            /*!< Input swap                                                            */
      __IO uint32_t  MUX_1_SEL  :  3;               /*!< Analog Mux1 sel                                                       */
      __IO uint32_t  MUX_2_SEL  :  3;               /*!< Analog Mux2 sel                                                       */
    } ANAMUXCOMP_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[3];

  union {
    __I  uint32_t  PWRSWACK;                        /*!< Power Switch acknowledge [Reset by all reset sources, except
                                                         ARM SystemReset]                                                      */

    struct {
      __I  uint32_t  RESERVED0  :  1;               /*!< Reserved. User software should write zeroes to reserved bits.
                                                         The value read from a reserved bit is not defined.                    */
      __I  uint32_t  PDCOMM0    :  1;               /*!< Comm0 (USART0, I2C0, SPI0) Power Domain power switch status           */
      __I  uint32_t  PDSYSTEM   :  1;               /*!< System Power Domain power switch status                               */
      __I  uint32_t  PDMCURETENTION:  1;            /*!< MCU Retention Power Domain power switch status                        */
      __I  uint32_t  RESERVED4  :  1;               /*!< Reserved. User software should write zeroes to reserved bits.
                                                         The value read from a reserved bit is not defined.                    */
    } PWRSWACK_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DPDWKSRC;                        /*!< Power Down and Deep Power Down wake-up source [Reset by POR,
                                                         RSTN, WDT ]                                                           */

    struct {
      __IO uint32_t  PIO0       :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO0 0 : Disable 1 : Enable                                 */
      __IO uint32_t  PIO1       :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO1 0 : Disable 1 : Enable                                 */
      __IO uint32_t  PIO2       :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO2 0 : Disable 1 : Enable                                 */
      __IO uint32_t  PIO3       :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO3 0 : Disable 1 : Enable                                 */
      __IO uint32_t  PIO4       :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO4 0 : Disable 1 : Enable                                 */
      __IO uint32_t  PIO5       :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO5 0 : Disable 1 : Enable                                 */
      __IO uint32_t  PIO6       :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO6 0 : Disable 1 : Enable                                 */
      __IO uint32_t  PIO7       :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO7 0 : Disable 1 : Enable                                 */
      __IO uint32_t  PIO8       :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO8 0 : Disable 1 : Enable                                 */
      __IO uint32_t  PIO9       :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO9 0 : Disable 1 : Enable                                 */
      __IO uint32_t  PIO10      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO10 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO11      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO11 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO12      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO12 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO13      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO13 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO14      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO14 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO15      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO15 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO16      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO16 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO17      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO17 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO18      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO18 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO19      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO19 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO20      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO20 0 : Disable 1 : Enable                                */
      __IO uint32_t  PIO21      :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by GPIO21 0 : Disable 1 : Enable                                */
      __IO uint32_t  NTAG_FD    :  1;               /*!< Enable / disable wakeup from Power down and Deep Power Down
                                                         modes by NTAG_FD 0 : Disable 1 : Enable                               */
    } DPDWKSRC_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  STATUSPWR;                       /*!< Power OK and Ready signals from various analog modules (DCDC,
                                                         LDO, ) [Reset by all reset sources, except ARM SystemReset]           */

    struct {
      __I  uint32_t  DCDCPWROK  :  1;               /*!< DCDC converter power OK                                               */
      __I  uint32_t  DCDCVXCTRLMON:  1;             /*!< Picture of the DCDC output state                                      */
      __I  uint32_t  LDOCOREPWROK:  1;              /*!< CORE LDO power OK. Max switch on time 2us                             */
      __I  uint32_t  LDOFLASHNVPWROK:  1;           /*!< Flash NV LDO power OK Max switch on time 20us                         */
      __I  uint32_t  LDOFLASHCOREPWROK:  1;         /*!< Flash Core LDO power OK Max switch on time should be considered
                                                         as 10us (8usec was seen in simplified environment)                    */
      __I  uint32_t  LDOADC1V1PWROK:  1;            /*!< General Purpose ADC LDO power OK. Max switch on time is 8us           */
    } STATUSPWR_b;                                  /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  STATUSCLK;                       /*!< FRO and XTAL status register [Reset by all reset sources, except
                                                         ARM SystemReset]                                                      */

    struct {
      __I  uint32_t  FRO192MCLKVALID:  1;           /*!< FRO 192 MHz clock valid signal.                                       */
      __I  uint32_t  XTAL32KOK  :  1;               /*!< XTAL oscillator 32 K OK signal. When the XTAL is stable, the
                                                         a transition from 1 to 0 will indicate a clock issue. Can not
                                                          be used to identify a stable clock during XTAL start.                */
      __I  uint32_t  FRO1MCLKVALID:  1;             /*!< FRO 1 MHz CCO voltage detector output                                 */
    } STATUSCLK_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RESETCAUSE;                      /*!< Reset Cause register [Reset by POR]                                   */

    struct {
      __IO uint32_t  POR        :  1;               /*!< 1 : The last chip reset was caused by a Power On Reset. Write
                                                         '1' to clear this bit                                                 */
      __IO uint32_t  PADRESET   :  1;               /*!< 1 : The last chip reset was caused by a Pad Reset. Write '1'
                                                         to clear this bit                                                     */
      __IO uint32_t  BODRESET   :  1;               /*!< 1 : The last chip reset was caused by a Brown Out Detector.
                                                         Write '1' to clear this bit                                           */
      __IO uint32_t  SYSTEMRESET:  1;               /*!< 1 : The last chip reset was caused by a System Reset requested
                                                         by the ARM CPU. Write '1' to clear this bit                           */
      __IO uint32_t  WDTRESET   :  1;               /*!< 1 : The last chip reset was caused by the Watchdog Timer. Write
                                                         '1' to clear this bit                                                 */
      __IO uint32_t  WAKEUPIORESET:  1;             /*!< 1 : The last chip reset was caused by a Wake-up I/O (GPIO or
                                                         internal NTAG FD INT). Write '1' to clear this bit                    */
      __IO uint32_t  WAKEUPPWDNRESET:  1;           /*!< 1 : The last CPU reset was caused by a Wake-up from Power down
                                                         (many sources possible: timer, IO, ...). Write '1' to clear
                                                          this bit. Check NVIC register if not waken-up by IO (NVIC_GetPendingIRQ) */
      __IO uint32_t  SWRRESET   :  1;               /*!< 1 : The last chip reset was caused by a Software. Write '1'
                                                         to clear this bit                                                     */
    } RESETCAUSE_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[3];

  union {
    __IO uint32_t  AOREG0;                          /*!< General purpose always on domain data storage [Reset by all
                                                         reset sources, except ARM SystemReset]                                */

    struct {
      __IO uint32_t  DATA31_0   : 32;               /*!< General purpose always on domain data storage. Only writable
                                                         1 time after any chip reset. After the 1st write, any further
                                                          writes are blocked. After any chip reset the write block is
                                                          disabled until after next write.                                     */
    } AOREG0_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AOREG1;                          /*!< General purpose always on domain data storage [Reset by POR,
                                                         RSTN]                                                                 */

    struct {
      __IO uint32_t  DATA31_0   : 32;               /*!< General purpose always on domain data storage. Only reinitialized
                                                         on Power On Reset and Pin reset.                                      */
    } AOREG1_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AOREG2;                          /*!< General purpose always on domain data storage [Reset by POR,
                                                         RSTN]                                                                 */

    struct {
      __IO uint32_t  DATA31_0   : 32;               /*!< General purpose always on domain data storage. Only reinitialized
                                                         on Power On Reset and Pin reset.                                      */
    } AOREG2_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4;

  union {
    __IO uint32_t  DUMMYCTRL;                       /*!< [Not in ES2] Dummy Control bus to PMU [Reset by all reset sources,
                                                         except ARM SystemReset]                                               */

    struct {
      __IO uint32_t  DUMMYCTRL  : 32;               /*!< [Not in ES2] Dummy Control bus to PMU [Reset by all reset sources,
                                                         except ARM SystemReset]                                               */
    } DUMMYCTRL_b;                                  /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  DUMMYSTATUS;                     /*!< Dummy Status bus from PMU [Not reset]                                 */

    struct {
      __I  uint32_t  DUMMYSTATUS:  8;               /*!< Dummy Status - unallocated status bits from analog PMC.               */
    } DUMMYSTATUS_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DPDCTRL;                         /*!< Configuration parameters for Power Down and Deep Power Down
                                                         mode [Reset by POR, RSTN, WDT ]                                       */

    struct {
      __IO uint32_t  XTAL32MSTARTENA:  1;           /*!< enable XTAL32MHz start up at power up. Reset value set by efuse
                                                         (wake-up by I/O only).                                                */
      __IO uint32_t  XTAL32MSTARTDLY:  2;           /*!< delay between xtal ldo enable and release of reset to xtal 0:16us
                                                         1:32us 2:48us 3:64us. LSB reset value set by efuse (wake-up
                                                          by I/O only). This delay is applied within PMC for Efuse controlled
                                                          XTAL start and also BLE link layer for BLE controlled auto-start     */
    } DPDCTRL_b;                                    /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  PIOPORCAP;                       /*!< The PIOPORCAP register captures the state of GPIO at power-on-reset
                                                         or pin reset. Each bit represents the power-on reset state of
                                                          one GPIO pin [Reset by POR, RSTN]                                    */

    struct {
      __I  uint32_t  PIOPORCAP  : 32;               /*!< The PIOPORCAP register captures the state of GPIO at power-on-reset
                                                         or pin reset. Each bit represents the power-on reset state of
                                                          one GPIO pin [Reset by POR, RSTN]                                    */
    } PIOPORCAP_b;                                  /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  PIORESCAP;                       /*!< The PIORESCAP0 register captures the state of GPIO port 0 when
                                                         a reset other than a power-on reset or pin reset occurs. Each
                                                          bit represents the reset state of one GPIO pin. [Reset by WDT,
                                                          BOD, WAKEUP IO, ARM System reset ]                                   */

    struct {
      __I  uint32_t  PIORESCAP  : 32;               /*!< The PIORESCAP0 register captures the state of GPIO port 0 when
                                                         a reset other than a power-on reset or pin reset occurs. Each
                                                          bit represents the reset state of one GPIO pin. [Reset by WDT,
                                                          BOD, WAKEUP IO, ARM System reset ]                                   */
    } PIORESCAP_b;                                  /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  TIMEOUTEVENTS;                   /*!< Record time-out errors that might occur at different stages
                                                         during IC power up. [Reset by all reset sources, except ARM
                                                          SystemReset]                                                         */

    struct {
      __I  uint32_t  TIMEOUTEVENTS: 32;             /*!< Record time-out errors that might occur at different stages
                                                         during IC power up. [Reset by all reset sources, except ARM
                                                          SystemReset]                                                         */
    } TIMEOUTEVENTS_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TIMEOUT;                         /*!< Various time out values used by PMC state machines. [Reset by
                                                         all reset sources, except ARM SystemReset]                            */

    struct {
      __IO uint32_t  PMUPOWEROK : 13;               /*!< (400 s @ 1 MHz as default) Maximum value the PMC state machine
                                                         will wait for an acknowledge ('Power OK') coming from any module
                                                          in PMU before setting an error flag (in TIMEOUTEVENTS) an move
                                                          forward                                                              */
      __IO uint32_t  LDOFLASHNVDEACTIVATE:  9;      /*!< (25 s @ 1 MHz as default) Time out value used when shutting
                                                         down Flash LDOs                                                       */
    } TIMEOUT_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5;

  union {
    __IO uint32_t  PDSLEEPCFG;                      /*!< Controls the power to various modules in Low Power modes [Reset
                                                         by all reset sources, except ARM SystemReset]                         */

    struct {
      __IO uint32_t  PDEN_DCDC  :  1;               /*!< Controls DCDC power in Power down and Deep Power down modes.
                                                         0: DCDC is disable in Power down and Deep Power down modes 1:
                                                          DCDC is enable in Power down and Deep Power down modes               */
      __IO uint32_t  PDEN_BIAS  :  1;               /*!< Controls Bias power in Power down and Deep Power down modes.
                                                         0: Bias is disable in Power down and Deep Power down modes 1:
                                                          Bias is enable in Power down and Deep Power down modes               */
      __IO uint32_t  PDEN_LDO_MEM:  1;              /*!< Controls LDO memories power in Power down mode. 0: LDO is disable
                                                         in Power down mode 1: LDO is enable in Power down mode                */
      __IO uint32_t  PDEN_VBAT_BOD:  1;             /*!< Controls VBAT BOD power in Power down and Deep Power down modes.
                                                         0: VBAT BOD is disable in Power down and Deep Power down modes
                                                          1: VBAT BOD is enable in Power down and Deep Power down modes        */
      __IO uint32_t  PDEN_FRO192M:  1;              /*!< Controls FRO192M power in Deep Sleep, Power down and Deep Power
                                                         down modes. 0: FRO192M is disable 1: FRO192M is enable                */
      __IO uint32_t  PDEN_FRO1M :  1;               /*!< Controls FRO1M power in Deep Sleep, Power down and Deep Power
                                                         down modes. 0: FRO1M is disable 1: FRO1M is enable                    */
      __IO uint32_t  PDEN_PD_FLASH:  1;             /*!< Enable Flash power domain Power Down mode (power shutoff) when
                                                         entering in DeepSleep. In PowerDown modes this domain is automatically
                                                          powered off.                                                         */
      __IO uint32_t  PDEN_PD_COMM0:  1;             /*!< Enable Comm0 power domain (USART0, I2C0, SPI0) Power Down mode
                                                         when entering in Powerdown mode                                       */
      __IO uint32_t  EN_PDMCU_RETENTION:  1;        /*!< Enable MCU Power Domain state retention when entering in 'Powerdown'
                                                         mode for modem and radio cal values                                   */
      __IO uint32_t  RESERVED9  :  1;               /*!< Reserved. User software should write zeroes to reserved bits.
                                                         The value read from a reserved bit is not defined.                    */
      __IO uint32_t  PDEN_PD_MEM0:  1;              /*!< Enable Power Down mode of SRAM 0 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM1:  1;              /*!< Enable Power Down mode of SRAM 1 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM2:  1;              /*!< Enable Power Down mode of SRAM 2 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM3:  1;              /*!< Enable Power Down mode of SRAM 3 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM4:  1;              /*!< Enable Power Down mode of SRAM 4 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM5:  1;              /*!< Enable Power Down mode of SRAM 5 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM6:  1;              /*!< Enable Power Down mode of SRAM 6 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM7:  1;              /*!< Enable Power Down mode of SRAM 7 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM8:  1;              /*!< Enable Power Down mode of SRAM 8 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM9:  1;              /*!< Enable Power Down mode of SRAM 9 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM10:  1;             /*!< Enable Power Down mode of SRAM 10 when entering in Powerdown
                                                         mode                                                                  */
      __IO uint32_t  PDEN_PD_MEM11:  1;             /*!< Enable Power Down mode of SRAM 11 when entering in Powerdown
                                                         mode                                                                  */
    } PDSLEEPCFG_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6;

  union {
    __IO uint32_t  PDRUNCFG;                        /*!< Controls the power to various analog blocks [Reset by all reset
                                                         sources, except ARM SystemReset]                                      */

    struct {
           uint32_t             : 22;
      __IO uint32_t  ENA_LDO_ADC:  1;               /*!< LDO ADC enable. See STATUSPWR.LDOADC1V1PWROK for when the power
                                                         domain is ready.                                                      */
      __IO uint32_t  ENA_BOD_MEM:  1;               /*!< BOD MEM enable                                                        */
      __IO uint32_t  ENA_BOD_CORE:  1;              /*!< BOD CORE enable                                                       */
      __IO uint32_t  ENA_FRO32K :  1;               /*!< FRO32K enable                                                         */
      __IO uint32_t  ENA_XTAL32K:  1;               /*!< XTAL32K enable                                                        */
      __IO uint32_t  ENA_ANA_COMP:  1;              /*!< Analog Comparator enable                                              */
    } PDRUNCFG_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  WAKEIOCAUSE;                     /*!< Wake-up source from Power Down and Deep Power Down modes. Allow
                                                         to identify the Wake-up source from Power-Down mode or Deep
                                                          Power Down mode.[Reset by POR, RSTN, WDT ]                           */

    struct {
      __I  uint32_t  GPIO00     :  1;               /*!< Wake up was triggered by GPIO 00                                      */
      __I  uint32_t  GPIO01     :  1;               /*!< Wake up was triggered by GPIO 01                                      */
      __I  uint32_t  GPIO02     :  1;               /*!< Wake up was triggered by GPIO 02                                      */
      __I  uint32_t  GPIO03     :  1;               /*!< Wake up was triggered by GPIO 03                                      */
      __I  uint32_t  GPIO04     :  1;               /*!< Wake up was triggered by GPIO 04                                      */
      __I  uint32_t  GPIO05     :  1;               /*!< Wake up was triggered by GPIO 05                                      */
      __I  uint32_t  GPIO06     :  1;               /*!< Wake up was triggered by GPIO 06                                      */
      __I  uint32_t  GPIO07     :  1;               /*!< Wake up was triggered by GPIO 07                                      */
      __I  uint32_t  GPIO08     :  1;               /*!< Wake up was triggered by GPIO 08                                      */
      __I  uint32_t  GPIO09     :  1;               /*!< Wake up was triggered by GPIO 09                                      */
      __I  uint32_t  GPIO10     :  1;               /*!< Wake up was triggered by GPIO 10                                      */
      __I  uint32_t  GPIO11     :  1;               /*!< Wake up was triggered by GPIO 11                                      */
      __I  uint32_t  GPIO12     :  1;               /*!< Wake up was triggered by GPIO 12                                      */
      __I  uint32_t  GPIO13     :  1;               /*!< Wake up was triggered by GPIO 13                                      */
      __I  uint32_t  GPIO14     :  1;               /*!< Wake up was triggered by GPIO 14                                      */
      __I  uint32_t  GPIO15     :  1;               /*!< Wake up was triggered by GPIO 15                                      */
      __I  uint32_t  GPIO16     :  1;               /*!< Wake up was triggered by GPIO 16                                      */
      __I  uint32_t  GPIO17     :  1;               /*!< Wake up was triggered by GPIO 17                                      */
      __I  uint32_t  GPIO18     :  1;               /*!< Wake up was triggered by GPIO 18                                      */
      __I  uint32_t  GPIO19     :  1;               /*!< Wake up was triggered by GPIO 19                                      */
      __I  uint32_t  GPIO20     :  1;               /*!< Wake up was triggered by GPIO 20                                      */
      __I  uint32_t  GPIO21     :  1;               /*!< Wake up was triggered by GPIO 21                                      */
      __I  uint32_t  NTAG_FD    :  1;               /*!< Wake up was triggered by NTAG FD                                      */
    } WAKEIOCAUSE_b;                                /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  EFUSE0;                          /*!< Read back decoded data from eFuse, after ECC removed. First
                                                         48 bits correspond to real config & trimming data (AUTO,AESR,...),
                                                          the rest being unused RAW bits in between: 3,7, ,4*n+3, (n<(80-48))  */

    struct {
      __I  uint32_t  EFUSE0_VAL : 32;               /*!< Read back decoded data from eFuse, after ECC removed. First
                                                         32 bits of the decoded data corresponding to real config & trimming
                                                          data (AUTO,AESR,...). ONLY VALID AFTER INITIAL POWER-UP, AND
                                                          RESET TO 0 AFTER ANY POWERDOWN OR DEEPPOWERDOWN                      */
    } EFUSE0_b;                                     /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  EFUSE1;                          /*!< Read back decoded data from eFuse, after ECC removed. First
                                                         48 bits correspond to real config & trimming data (AUTO,AESR,...),
                                                          the rest being unused RAW bits in between: 3,7, ,4*n+3, (n<(80-48))  */

    struct {
      __I  uint32_t  EFUSE1_VAL : 32;               /*!< Bits [23:0] correspond to Read back of decoded data from eFuse
                                                         for data bits [53:32], after ECC removed. Bits [31:24] are unused
                                                          RAW bits in between: 3,7, ,4*n+3, (n<(80-48)) from first 6 rows
                                                          of efuse map. ONLY VALID AFTER INITIAL POWER-UP, AND RESET TO
                                                          0 AFTER ANY POWERDOWN OR DEEPPOWERDOWN                               */
    } EFUSE1_b;                                     /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  EFUSE2;                          /*!< Read back decoded data from eFuse, after ECC removed. First
                                                         48 bits correspond to real config & trimming data (AUTO,AESR,...),
                                                          the rest being unused RAW bits in between: 3,7, ,4*n+3, (n<(80-48))  */

    struct {
      __I  uint32_t  EFUSE2_VAL : 16;               /*!< Continuing from EFUSE1_VAL[31:24], these are unused RAW bits
                                                         in between: 3,7, ,4*n+3, (n<(80-48)) from first 6 rows in efuse
                                                          map. ONLY VALID AFTER INITIAL POWER-UP, AND RESET TO 0 AFTER
                                                          ANY POWERDOWN OR DEEPPOWERDOWN                                       */
    } EFUSE2_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CTRLNORST;                       /*!< Extension of CTRL register, but never reset except by POR             */

    struct {
      __IO uint32_t  FASTLDOENABLE:  3;             /*!< Fast LDO wake-up enable. 3 bits for the different wake-up sources:
                                                         {generic async wake up event as selected by SLEEPCON/STARTER0&1,
                                                          IO wake-up event, RSTN pad event}                                    */
    } CTRLNORST_b;                                  /*!< BitSize                                                               */
  };
} u_pmc_Type;


/* ================================================================================ */
/* ================                  u_ble_dp_top                  ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component ble_dp_top. It is Bluetooth Low Energy Data Path module APB bus interface. More details will follow. (u_ble_dp_top)
  */

typedef struct {                                    /*!< u_ble_dp_top Structure                                                */

  union {
    __IO uint32_t  DP_TOP_SYSTEM_CTRL;              /*!< Base address of the link layer exchange memory in RAM                 */

    struct {
      __IO uint32_t  RX_PDU_LEN_IN: 14;             /*!< pdu length user programmed, header+payload, unit is bit.              */
      __IO uint32_t  AA_SEL     :  1;               /*!< access address selection. 0 : from ble ip 1 : user program.           */
      __IO uint32_t  PDU_LEN_SEL:  1;               /*!< pdu length selection. 0 : from ble ip 1 : user program.               */
      __IO uint32_t  H_IDX      :  8;               /*!< h index,from 0.25 to 0.75,default is 0.5.                             */
      __IO uint32_t  RX_EN_SEL  :  1;               /*!< rx enable select signal 0:from ble ip, 1:user programmed.             */
      __IO uint32_t  TX_EN_SEL  :  1;               /*!< tx enable select signal 0:from ble ip, 1:user programmed.             */
      __IO uint32_t  RX_REQ     :  1;               /*!< rx request                                                            */
      __IO uint32_t  TX_REQ     :  1;               /*!< tx request                                                            */
      __IO uint32_t  RX_MODE    :  2;               /*!< rx mode: 00:ble, 01:base rate, 10:ant, 11:prop                        */
      __IO uint32_t  ANT_DATA_START:  1;            /*!< ant mode, data start signal, need write 0 first, then to 1.           */
      __IO uint32_t  DET_MODE   :  1;               /*!< detection mode,0:low ppwer mode,1:high performance mode.              */
    } DP_TOP_SYSTEM_CTRL_b;                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PROP_MODE_CTRL;                  /*!< Prop mode control                                                     */

    struct {
      __IO uint32_t  PROP_MODE_CTRL: 32;            /*!< Prop mode control                                                     */
    } PROP_MODE_CTRL_b;                             /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ACCESS_ADDRESS;                  /*!< Access address                                                        */

    struct {
      __IO uint32_t  AA_ADDR_IN : 32;               /*!< access address user programmed.                                       */
    } ACCESS_ADDRESS_b;                             /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANT_PDU_DATA0;                   /*!< Ant pdu data0                                                         */

    struct {
      __IO uint32_t  ANT_PDU_DATA0: 32;             /*!< Ant pdu data0                                                         */
    } ANT_PDU_DATA0_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANT_PDU_DATA1;                   /*!< Ant pdu data1                                                         */

    struct {
      __IO uint32_t  ANT_PDU_DATA1: 32;             /*!< Ant pdu data1                                                         */
    } ANT_PDU_DATA1_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANT_PDU_DATA2;                   /*!< Ant pdu data2                                                         */

    struct {
      __IO uint32_t  ANT_PDU_DATA2: 32;             /*!< Ant pdu data2                                                         */
    } ANT_PDU_DATA2_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANT_PDU_DATA3;                   /*!< Ant pdu data3                                                         */

    struct {
      __IO uint32_t  ANT_PDU_DATA3: 32;             /*!< Ant pdu data3                                                         */
    } ANT_PDU_DATA3_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANT_PDU_DATA4;                   /*!< Ant pdu data4                                                         */

    struct {
      __IO uint32_t  ANT_PDU_DATA4: 32;             /*!< Ant pdu data4                                                         */
    } ANT_PDU_DATA4_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANT_PDU_DATA5;                   /*!< Ant pdu data5                                                         */

    struct {
      __IO uint32_t  ANT_PDU_DATA5: 32;             /*!< Ant pdu data5                                                         */
    } ANT_PDU_DATA5_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANT_PDU_DATA6;                   /*!< Ant pdu data6                                                         */

    struct {
      __IO uint32_t  ANT_PDU_DATA6: 32;             /*!< Ant pdu data6                                                         */
    } ANT_PDU_DATA6_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANT_PDU_DATA7;                   /*!< Ant pdu data7                                                         */

    struct {
      __IO uint32_t  ANT_PDU_DATA7: 32;             /*!< Ant pdu data7                                                         */
    } ANT_PDU_DATA7_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CRC_SEED;                        /*!< Crc seed                                                              */

    struct {
      __IO uint32_t  CRC_SEED_IN: 24;               /*!< user programmed crc seed                                              */
      __IO uint32_t  CRC_SEED_WEN:  1;              /*!< when high,enable manual program crc seed                              */
    } CRC_SEED_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DP_FUNCTION_CTRL;                /*!< Datapath function control                                             */

    struct {
      __IO uint32_t  DP_STATISTICS_SEL:  3;         /*!< datapath statistics selection.                                        */
      __IO uint32_t  CHF_COEF_WEN:  1;              /*!< manual select channel filter coefficent                               */
      __IO uint32_t  CHF_COEF_IDX:  2;              /*!< 0:lp coef, 1:hp32 2:hp5.                                              */
      __IO uint32_t  LP_SNR_LEN_AUTO:  1;           /*!< when enable, auto adjust lp mode snr acc length, otherwise,
                                                         the legnth fixed.                                                     */
      __IO uint32_t  DOUT_ADJ_DIS:  1;              /*!< data delay adjust disable.                                            */
      __IO uint32_t  LP_ADJ_MODE:  1;               /*!< lp mode delay adjust mode, 0: smae as lp, 58us, 1, 49us.              */
      __IO uint32_t  FR_OFFSET_EN:  1;              /*!< pdu frequency offset track enable.                                    */
      __IO uint32_t  DC_AVE_EN  :  1;               /*!< when high, enable cfo estimation average.                             */
      __IO uint32_t  FIX_DELAY_EN:  1;              /*!< 1 fix delay between max_par and burst_det,0 for bitmatch.             */
      __IO uint32_t  TRACK_LEN  :  2;               /*!< track length, 0:0, 1:16, 2:24, 3:32                                   */
      __IO uint32_t  TRACK_LEN_WEN:  1;             /*!< when high, manual track length.                                       */
           uint32_t             :  1;
      __IO uint32_t  XCORR_FILT_EN:  1;             /*!< when high, enable xcorr filter.                                       */
      __IO uint32_t  XCORR_FULLWIN_EN:  1;          /*!< when xcorr_win_auto_en low, full sync enable.                         */
      __IO uint32_t  XCORR_AA_LEN:  1;              /*!< select access address bit number,0:16, 1:32.                          */
      __IO uint32_t  XCORR_AA_LEN_WEN:  1;          /*!< enable manual correlation aa length.                                  */
      __IO uint32_t  XCORR_WIN_AUTO_EN:  1;         /*!< correlation window size auto selection enable.                        */
      __IO uint32_t  RESAMPLER_TAP:  1;             /*!< resampler tap number, 0:2, 1:9.                                       */
      __IO uint32_t  RESAMPLER_TAP_WEN:  1;         /*!< when high, enable manual resampler tap number, otherwise,auto
                                                         selection.                                                            */
      __IO uint32_t  RESAMPLER_BP:  1;              /*!< resampler enable or bypass, 0:enable, 1:bypass.                       */
      __IO uint32_t  FAGC_WIN_LEN:  1;              /*!< select estimation length,0:l,1:2xl.                                   */
      __IO uint32_t  FAGC_WEN   :  1;               /*!< when high, enable manual fine agc gain.                               */
      __IO uint32_t  HP_CFO_EN  :  1;               /*!< when hp mode, cfo estimation enable,0:disable,1:enable                */
      __IO uint32_t  CFO_TRACK_EN:  1;              /*!< tracking cfo enable                                                   */
      __IO uint32_t  CFO_INI_EN :  1;               /*!< initial cfo enable                                                    */
      __IO uint32_t  ADC_IN_FLIP:  1;               /*!< when 1 exchange i and q signals.                                      */
      __IO uint32_t  TX_EN_MODE :  1;               /*!< transmit mode, 0, start one transmit use tx_req, 1: start repetitious
                                                         transmit use tx_req                                                   */
      __IO uint32_t  RX_EN_MODE :  1;               /*!< receiver mode, 0, start one receiver use rx_req, 1: start repetitious
                                                         reciver use rx_req                                                    */
    } DP_FUNCTION_CTRL_b;                           /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DP_TEST_CTRL;                    /*!< Datapath test control                                                 */

    struct {
      __IO uint32_t  DP_TEST_CTRL: 32;              /*!< Datapath test control                                                 */
    } DP_TEST_CTRL_b;                               /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  BLE_DP_STATUS1;                  /*!< Datapath status1                                                      */

    struct {
      __I  uint32_t  SNR_EST    :  8;               /*!< snr estimation                                                        */
      __I  uint32_t  CNR_EST    :  6;               /*!< cnr estimation                                                        */
           uint32_t             :  2;
      __I  uint32_t  AGC_RSSI   :  8;               /*!< signal rssi db value                                                  */
      __I  uint32_t  AGC_RSSI_READY:  1;            /*!< signal rssi valid                                                     */
      __I  uint32_t  SNR_VLD    :  1;               /*!< snr estimation valid                                                  */
      __I  uint32_t  CNR_VLD    :  1;               /*!< cnr estimation valid                                                  */
      __I  uint32_t  TX_BUSY    :  1;               /*!< tx busy signal                                                        */
    } BLE_DP_STATUS1_b;                             /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  BLE_DP_STATUS2;                  /*!< Datapath status2                                                      */

    struct {
      __I  uint32_t  VALID_PCK_NUM: 16;             /*!< received valid packet number                                          */
      __I  uint32_t  AA_ERR_NUM :  6;               /*!< access address error number                                           */
           uint32_t             :  7;
      __I  uint32_t  CRC_ERROR  :  1;               /*!< indicator of packet crc error                                         */
      __I  uint32_t  BURST_DET  :  1;               /*!< indicator of burst detection, 0:not sync, 1:sync                      */
      __I  uint32_t  DP_STATUS_VLD_0:  1;           /*!< data path status valid after access address valid.                    */
    } BLE_DP_STATUS2_b;                             /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  BLE_DP_STATUS3;                  /*!< Datapath status3                                                      */

    struct {
      __I  uint32_t  FD_CFO_TRACK: 11;              /*!< normalized cfo tracking estimation                                    */
           uint32_t             :  5;
      __I  uint32_t  CFO_EST_FD : 11;               /*!< normalized lp cfo initial estimation.                                 */
    } BLE_DP_STATUS3_b;                             /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  BLE_DP_STATUS4;                  /*!< Datapath status4                                                      */

    struct {
      __I  uint32_t  RESAMPLER_PH: 10;              /*!< resampler phase.                                                      */
           uint32_t             :  6;
      __I  uint32_t  HP_CFO     : 12;               /*!< normalized hp cfo estimation                                          */
           uint32_t             :  3;
      __I  uint32_t  HP_CFO_VLD :  1;               /*!< hp mode cfo estimation result valid                                   */
    } BLE_DP_STATUS4_b;                             /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RX_FRONT_END_CTRL1;              /*!< Rx front end control1                                                 */

    struct {
      __IO uint32_t  CFO_COMP   : 15;               /*!< cfo user programmed                                                   */
           uint32_t             :  1;
      __IO uint32_t  DCNOTCH_GIN:  2;               /*!< dc notch coefficient,00:2^-3,01:2^-4,10,2^-5,11:2^-6                  */
    } RX_FRONT_END_CTRL1_b;                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RX_FRONT_END_CTRL2;              /*!< Rx front end control2                                                 */

    struct {
      __IO uint32_t  FAGC_GAIN  : 11;               /*!< fine agc gain                                                         */
      __IO uint32_t  FAGC_INI_VAL:  1;              /*!< fagc gain initial value                                               */
      __IO uint32_t  CNR_IDX_DELTA:  4;             /*!< cnr index delta                                                       */
      __IO uint32_t  FAGC_REF   :  8;               /*!< fine agc signal reference                                             */
      __IO uint32_t  CORDIC_MIN_VIN_TH:  4;         /*!< cordic input signal min threshold                                     */
      __IO uint32_t  FREQ_TRADE_EN:  1;             /*!< enable frequency trade when cordic input signal small than cordic_min_vin_
                                                         th                                                                    */
      __IO uint32_t  CHN_SHIFT  :  3;               /*!< channel filter shift, 0, not any shift, 1:x2, 2:x4, 3:x8, 4:16        */
    } RX_FRONT_END_CTRL2_b;                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FREQ_DOMAIN_CTRL1;               /*!< Frequency domain control1                                             */

    struct {
      __IO uint32_t  SYNC_WORD_IN0:  8;             /*!< manul sync word [39:32]                                               */
      __IO uint32_t  SYNC_WORD_WEN:  1;             /*!< when high, enable manul sync word                                     */
           uint32_t             :  6;
      __IO uint32_t  SYNC_P_SEL :  1;               /*!< 0: datapath will not reset if sync_p is out of syncwin, 1: datapath
                                                         will reset, and sync_p will not upload to bleip                       */
      __IO uint32_t  RD_EXBIT_EN:  1;               /*!< when high, read an extra bit(8 samples) from dp buffer                */
      __IO uint32_t  RFAGC_TRACK_DLY:  3;           /*!< Rfagc track delay, range is [0,7],so the track bit num is [0,
                                                         8:32]                                                                 */
           uint32_t             :  4;
      __IO uint32_t  PROP_DF_16US:  8;              /*!< prop mode direct found, waiting 16 us.                                */
    } FREQ_DOMAIN_CTRL1_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FREQ_DOMAIN_CTRL2;               /*!< Frequency domain control2                                             */

    struct {
      __IO uint32_t  SYNC_WORD_IN1: 32;             /*!< manul sync word [31:0]                                                */
    } FREQ_DOMAIN_CTRL2_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FREQ_DOMAIN_CTRL3;               /*!< Frequency domain control3                                             */

    struct {
      __IO uint32_t  XCORR_PAR_TH3:  6;             /*!< xcorr trigger par threshold3                                          */
           uint32_t             :  2;
      __IO uint32_t  XCORR_PAR_TH2:  6;             /*!< xcorr trigger par threshold2                                          */
           uint32_t             :  2;
      __IO uint32_t  XCORR_PAR_TH1:  6;             /*!< xcorr trigger par threshold1                                          */
           uint32_t             :  2;
      __IO uint32_t  XCORR_PAR_TH0:  6;             /*!< xcorr trigger par threshold0                                          */
    } FREQ_DOMAIN_CTRL3_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FREQ_DOMAIN_CTRL4;               /*!< Frequency domain control4                                             */

    struct {
      __IO uint32_t  XCORR_POW_TH3:  6;             /*!< xcorr power threshold3                                                */
           uint32_t             :  2;
      __IO uint32_t  XCORR_POW_TH2:  6;             /*!< xcorr power threshold2                                                */
           uint32_t             :  2;
      __IO uint32_t  XCORR_POW_TH1:  6;             /*!< xcorr power threshold1                                                */
           uint32_t             :  2;
      __IO uint32_t  XCORR_POW_TH0:  6;             /*!< xcorr power threshold0                                                */
    } FREQ_DOMAIN_CTRL4_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FREQ_DOMAIN_CTRL5;               /*!< Frequency domain control5                                             */

    struct {
      __IO uint32_t  GAIN_TED   :  2;               /*!< ted gain.00:2^-2;01:2^-3;10:2^-4;11:2^-5                              */
           uint32_t             :  2;
      __IO uint32_t  SYNC_DIN_SAT_VALUE:  3;        /*!< sync din amplitude limit value, 0 to 1.75 correspond to 2 to
                                                         3.75                                                                  */
      __IO uint32_t  SYNC_DIN_SAT_EN:  1;           /*!< sync din amplitude limit enable                                       */
      __IO uint32_t  CNT_SETTLE_IDX:  3;            /*!< buffer settle threshold from 32 to 256, step is 32                    */
           uint32_t             :  1;
      __IO uint32_t  TRIG_XCORR_CNT:  4;            /*!< correlation search window size                                        */
      __IO uint32_t  XCORR_RSSI_TH3:  4;            /*!< xcorr triger rssi threshold3                                          */
      __IO uint32_t  XCORR_RSSI_TH2:  4;            /*!< xcorr triger rssi threshold2                                          */
      __IO uint32_t  XCORR_RSSI_TH1:  4;            /*!< xcorr triger rssi threshold1                                          */
      __IO uint32_t  XCORR_RSSI_TH0:  4;            /*!< xcorr triger rssi threshold0                                          */
    } FREQ_DOMAIN_CTRL5_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FREQ_DOMAIN_CTRL6;               /*!< Frequency domain control6                                             */

    struct {
      __IO uint32_t  HP_TRAIN_SIZ:  5;              /*!< hp mode training size                                                 */
           uint32_t             :  3;
      __IO uint32_t  HP_HIDX_GAIN:  8;              /*!< h index reference gain when hp mode, default is 1.0                   */
      __IO uint32_t  H_REF_GAIN :  6;               /*!< h index reference gain when frequency offset track, default
                                                         is 1.0                                                                */
           uint32_t             :  2;
      __IO uint32_t  DET_FR_IDX :  2;               /*!< pdu cfo tracking loop gain: 2'b00:2^-4;2'b01:2^-5;2'b10:2^-6;2'b11:2^-7; */
           uint32_t             :  2;
      __IO uint32_t  CFO_FR_IDX :  2;               /*!< aa cfo tracking loop gain: 2'b00:2^-4;2'b01:2^-5;2'b10:2^-6;2'b11:2^-7; */
    } FREQ_DOMAIN_CTRL6_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  HP_MODE_CTRL1;                   /*!< High performance mode control                                         */

    struct {
      __IO uint32_t  HP_BMC_P_TRACK:  6;            /*!< p paramter in search period of frequency offset iir of bmc            */
           uint32_t             :  2;
      __IO uint32_t  HP_BMC_P_TRAIN:  6;            /*!< p paramter in training period of frequency offset iir of bmc          */
           uint32_t             :  2;
      __IO uint32_t  HP_BMC_CZ1 :  6;               /*!< cz1 parameter.                                                        */
           uint32_t             :  2;
      __IO uint32_t  BUF_IDX_DELTA:  4;             /*!< buffer index delta                                                    */
      __IO uint32_t  WMF2_DSAMP_IDX:  3;            /*!< wmf2 down sampling position, -4 to 3                                  */
      __IO uint32_t  HP_TRAIN_SIZ_FIX:  1;          /*!< when high, hp mode training size same as cfo tracking                 */
    } HP_MODE_CTRL1_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  HP_MODE_CTRL2;                   /*!< High performance mode control                                         */

    struct {
      __IO uint32_t  SNR_EST_REF:  8;               /*!< signal amplitude used in snr estimation,whose unit is db              */
      __IO uint32_t  SNR_EST_LEN:  2;               /*!< symbol number used in snr estimation,when pdu length is less
                                                         than 4 8,32 will be used,otherwise the value configured from
                                                          register will be used,00 : 32,01 : 64,10 : 128,11 : rsvd             */
           uint32_t             :  2;
      __IO uint32_t  SNR_EST_EN :  1;               /*!< snr estimation in time domain enbale,0 : disable,1 : enable           */
           uint32_t             :  3;
      __IO uint32_t  HP_BMC_Q_TRACK:  8;            /*!< q paramter in search period of phase offset iir of bmc                */
      __IO uint32_t  HP_BMC_Q_TRAIN:  8;            /*!< q paramter in training period of phase offset iir of bmc              */
    } HP_MODE_CTRL2_b;                              /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FREQ_DOMAIN_STATUS1;             /*!< Frequency domain status1                                              */

    struct {
      __I  uint32_t  MAX_XCORR  : 10;               /*!< xcorr_org value at the max par position                               */
           uint32_t             :  6;
      __I  uint32_t  PKT_OFFSET_COM:  9;            /*!< time from access addres last bit to trigger finish                    */
           uint32_t             :  3;
      __I  uint32_t  NIDX       :  4;               /*!< noise db buffer index                                                 */
    } FREQ_DOMAIN_STATUS1_b;                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FREQ_DOMAIN_STATUS2;             /*!< Frequency domain status2                                              */

    struct {
      __I  uint32_t  MAX_PAR_SPWR: 10;              /*!< spwr value at the max par position                                    */
           uint32_t             :  6;
      __I  uint32_t  MAX_PAR_XCORR: 10;             /*!< xcorr*xcorr value at the max par position                             */
    } FREQ_DOMAIN_STATUS2_b;                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[3];

  union {
    __IO uint32_t  DP_AA_ERROR_CTRL;                /*!< Datapath aa error control                                             */

    struct {
      __IO uint32_t  IQSWAP_SEL :  1;               /*!< when high, adc data iq swap with analog iqswap. datapath mixer
                                                         nco if selection changed with analog iqswap.                          */
      __IO uint32_t  AA_ERROR_EN:  1;               /*!< when high, it will reset datapath when aa error                       */
      __IO uint32_t  AA_ERROR_CNR_EN:  1;           /*!< when high, the aa error reset condition is cnr > threshold and
                                                         aa error. when low, it don care cnr                                   */
      __IO uint32_t  AA_ERROR_CNR_SEL:  1;          /*!< when high, the cnr threshold is 24. when low, the cnr threshold
                                                         is 32                                                                 */
    } DP_AA_ERROR_CTRL_b;                           /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DP_INT;                          /*!< Datapath interrupt                                                    */

    struct {
      __IO uint32_t  DP_INTERRUPT0:  1;             /*!< datapath interrupt0                                                   */
      __IO uint32_t  DP_INTERRUPT1:  1;             /*!< datapath interrupt1                                                   */
      __IO uint32_t  DP_INTERRUPT2:  1;             /*!< datapath interrupt2                                                   */
      __IO uint32_t  DP_INTERRUPT:  1;              /*!< datapath interrupt                                                    */
           uint32_t             : 12;
      __IO uint32_t  DP_INTERRUPT0_SEL:  4;         /*!< datapath interrupt0 selection                                         */
      __IO uint32_t  DP_INTERRUPT1_SEL:  4;         /*!< datapath interrupt1 selection                                         */
      __IO uint32_t  DP_INTERRUPT2_SEL:  4;         /*!< datapath interrupt2 selection                                         */
      __IO uint32_t  DP_INTERRUPT0_MSK:  1;         /*!< datapath interrupt0 msk                                               */
      __IO uint32_t  DP_INTERRUPT1_MSK:  1;         /*!< datapath interrupt1 msk                                               */
      __IO uint32_t  DP_INTERRUPT2_MSK:  1;         /*!< datapath interrupt2 msk                                               */
      __IO uint32_t  DP_INTERRUPT_MSK:  1;          /*!< datapath interrupt msk                                                */
    } DP_INT_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DP_AA_ERROR_TH;                  /*!< Datapath aa error threshold control                                   */

    struct {
      __IO uint32_t  HP_TRAIN_POSITION:  1;         /*!< when high, use the bits just ahead of pdu for rsve training.
                                                         when low, the training bit starts at the track                        */
      __IO uint32_t  CORDIC_IN_SCALE:  1;           /*!< when high, cordic input will be auto scaled(shift) according
                                                         to the magnitude of real/imag data                                    */
      __IO uint32_t  PAR_AUTO_HIGHER_SEL:  1;       /*!< when high, par auto higher 1/4, when low, par auto higher 1/8,
                                                         it will work together with par_auto_higher_en and rssi_good_dbm       */
      __IO uint32_t  PAR_AUTO_HIGHER_EN:  1;        /*!< when high, when signal is good ( rssi large than rssi_good_dbm),
                                                         it will auto higher the par threshold                                 */
      __IO uint32_t  SNR_GOOD_TH:  3;               /*!< threshold for snr(fd mode calculated use aa) to reset datapath
                                                         cooperate with cnr, snr, and aa error                                 */
           uint32_t             :  1;
      __IO uint32_t  CNR_GOOD_TH:  6;               /*!< threshold for cnr to reset datapath cooperate with cnr, snr,
                                                         and aa error                                                          */
           uint32_t             :  2;
      __IO uint32_t  RSSI_GOOD_TH:  8;              /*!< threshold for rssi to reset datapath cooperate with cnr, snr,
                                                         and aa error.                                                         */
      __IO uint32_t  RSSI_GOOD_DBM:  8;             /*!< when rssi dbm large than the -rssi_good_dbm, the signal is good
                                                         enough to higher the par threshold if the function enable             */
    } DP_AA_ERROR_TH_b;                             /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DP_ANTENNA_CTRL;                 /*!< Direction founding antenna control                                    */

    struct {
      __IO uint32_t  SWITCH_MAP_SEL_8F:  2;         /*!< switch antenna map selection 8 to f                                   */
      __IO uint32_t  SWITCH_MAP_SEL_07:  2;         /*!< switch antenna map selection 0 to 7                                   */
      __IO uint32_t  EXT_ANTENNA_NUM:  4;           /*!< user programmed switch antenna number                                 */
      __IO uint32_t  EXT_ANTENNA_NUM_WEN:  1;       /*!< user programmed switch antenna enable                                 */
           uint32_t             :  7;
      __IO uint32_t  BUFFER_BP  :  1;               /*!< when high, bypass buffer, and not write/read buffer for datapath
                                                         power test                                                            */
      __IO uint32_t  TEST_TD_POWER:  1;             /*!< when high, test rfe, td detector power, other module dont work,
                                                         the cordic work or not decided by resampler_bp                        */
      __IO uint32_t  TEST_FD_POWER:  1;             /*!< when high, test rfe, cordic and fd detector power, other module
                                                         dont work                                                             */
      __IO uint32_t  TEST_SYNC_POWER:  1;           /*!< when high, test rfe, cordic and sync power, other module dont
                                                         work                                                                  */
      __IO uint32_t  TEST_RFE_CORDIC_POWER:  1;     /*!< when high, test rfe and cordic power, other module dont work          */
      __IO uint32_t  TEST_RFE_POWER:  1;            /*!< when high, test rfe power, other module dont work.                    */
      __IO uint32_t  ADC01_SAMPLE_TIME:  1;         /*!< when high, will exchange the adc0/adc1 sample time, to avoid
                                                         the error sample time for adc0/adc1                                   */
      __IO uint32_t  PHY_RATE_MUX:  1;              /*!< ble data rate used in chip, 0: 1mbps mode, 1: 2mbps mode              */
      __IO uint32_t  PHY_RATE_REG:  1;              /*!< 0: user programmed phy data rate, 0: 1mbps mode, 1: 2mbps mode        */
      __IO uint32_t  PHY_RATE_WEN:  1;              /*!< 0: phy_rate come from ble ip, 1: phy_rate come from register
                                                         phy_rate_reg                                                          */
      __IO uint32_t  PDU_RSSI_WAIT_TIME:  1;        /*!< 0: wait 0us, 1: wait 4us                                              */
      __IO uint32_t  PDU_RSSI_WIN_LEN:  1;          /*!< select estimation length for pdu rssi calculate,0:l,1:2xl             */
      __IO uint32_t  CAL_PDU_RSSI_EN:  1;           /*!< calculate rssi use pdu data enbale                                    */
      __IO uint32_t  PROP_CRC_AA_DIS:  1;           /*!< prop mode crc check, disable check access address                     */
      __IO uint32_t  PROP_AA_LSB_FIRST:  1;         /*!< prop mode access address lsb first, for cbt test                      */
      __IO uint32_t  PRE_NUM_WEN:  1;               /*!< preamble number write enable                                          */
    } DP_ANTENNA_CTRL_b;                            /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANTENNA_MAP01;                   /*!< Direction founding antenna map 01                                     */

    struct {
      __IO uint32_t  ANTENNA_MAP01: 32;             /*!< Direction founding antenna map 01                                     */
    } ANTENNA_MAP01_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANTENNA_MAP23;                   /*!< Direction founding antenna map 23                                     */

    struct {
      __IO uint32_t  ANTENNA_MAP23: 32;             /*!< Direction founding antenna map 23                                     */
    } ANTENNA_MAP23_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANTENNA_MAP45;                   /*!< Direction founding antenna map 45                                     */

    struct {
      __IO uint32_t  ANTENNA_MAP45: 32;             /*!< Direction founding antenna map 45                                     */
    } ANTENNA_MAP45_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANTENNA_MAP67;                   /*!< Direction founding antenna map 67                                     */

    struct {
      __IO uint32_t  ANTENNA_MAP67: 32;             /*!< Direction founding antenna map 67                                     */
    } ANTENNA_MAP67_b;                              /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1;

  union {
    __IO uint32_t  LL_EM_BASE_ADDRESS;              /*!< Exchange memory base address for Link Layer                           */

    struct {
      __IO uint32_t  LL_EM_BASE_ADDRESS: 32;        /*!< Exchange memory base address for Link Layer                           */
    } LL_EM_BASE_ADDRESS_b;                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RX_EARLY_EOP;                    /*!< Early end of packet setting                                           */

    struct {
      __IO uint32_t  rx_early_eop:  8;              /*!< Early end of packet setting, in bits from the end of the packet       */
    } RX_EARLY_EOP_b;                               /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ANT_DIVERSITY;                   /*!< Antenna diversity                                                     */

    struct {
      __IO uint32_t  ble_ant_selected:  1;          /*!< 0: ADE is asserted 1: ADE de-asserted                                 */
      __IO uint32_t  ble_ant_mode:  1;              /*!< 0:BLE antenna diversity controlled from a register bit ble_ant_selected
                                                         [0: ADE is asserted; 1: ADE de-asserted] 1:BLE selects same
                                                          antenna that is selected by ZB (capture at the point of going
                                                          into RX or TX in case ZB is trying to use the radio simultaneously
                                                          with BLE)                                                            */
    } ANT_DIVERSITY_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TX_M_TEST_CTRL;                  /*!< Test stream control on TX path                                        */

    struct {
      __IO uint32_t  tx_test_mode:  4;              /*!< 0 : PRBS9 (defined in BLE spec) [BLL-RS-401] 1 : Repeated 11110000
                                                         sequence [BLL-RS-406] 2 : Repeated 10101010 sequence [BLL-RS-407]
                                                          3 : PRBS15 (defined in BLE spec) [BLL-RS-408] 4 : Repeated 11111111
                                                          sequence [BLL-RS-409] 5 : Repeated 11111111 sequence [BLL-RS-409]
                                                          6 : Repeated 00001111 sequence [BLL-RS-411] 7 : Repeated 01010101
                                                          sequence [BLL-RS-412]                                                */
      __IO uint32_t  tx_test_speed:  1;             /*!< 0:BLE=1Mbps 1:BLE=2Mbps                                               */
      __IO uint32_t  tx_test_en :  1;               /*!< 0 : test pattern insertion disabled. BLE TX path uses data from
                                                         link layer 1 : tx test pattern insertion enabled.                     */
    } TX_M_TEST_CTRL_b;                             /*!< BitSize                                                               */
  };
} u_ble_dp_top_Type;


/* ================================================================================ */
/* ================                      u_pvt                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component pvt It is an PVT (Process Voltage Temperature) sensor (Rinogs + Delay Lines) with APB bus interface. More details will follow. (u_pvt)
  */

typedef struct {                                    /*!< u_pvt Structure                                                       */

  union {
    __IO uint32_t  RED_DEL_CTRL_0;                  /*!< RED_0 Delay line value step of 250ps in typical case                  */

    struct {
      __IO uint32_t  RED_DEL_CTRL_0: 32;            /*!< RED_0 Delay line value step of 250ps in typical case                  */
    } RED_DEL_CTRL_0_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[2];

  union {
    __IO uint32_t  RED_REGION_CNT_0;                /*!< RED_0 counter                                                         */

    struct {
      __IO uint32_t  RED_REGION_CNT_0: 32;          /*!< RED_0 counter                                                         */
    } RED_REGION_CNT_0_b;                           /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RED_REGION_CNT_CTRL_0;           /*!< RED_0 counter enable                                                  */

    struct {
      __IO uint32_t  RED_REGION_CNT_CTRL_0: 32;     /*!< RED_0 counter enable                                                  */
    } RED_REGION_CNT_CTRL_0_b;                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[3];

  union {
    __IO uint32_t  AMBER_DEL_CTRL_0;                /*!< AMBER_0 Delay line value step of 250ps in typical case                */

    struct {
      __IO uint32_t  AMBER_DEL_CTRL_0: 32;          /*!< AMBER_0 Delay line value step of 250ps in typical case                */
    } AMBER_DEL_CTRL_0_b;                           /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AMBER_RINGO_0;                   /*!< RINGO_0 control                                                       */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< 1: enable RINGO clock generation                                      */
      __IO uint32_t  CNT_ENABLE :  1;               /*!< 1: start RINGO counter                                                */
      __IO uint32_t  CNT_RESET  :  1;               /*!< 1: reset RINGO counter                                                */
    } AMBER_RINGO_0_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AMBER_RINGO_CNT_0;               /*!< RINGO_0 counter                                                       */

    struct {
      __IO uint32_t  AMBER_RINGO_CNT_0: 32;         /*!< RINGO_0 counter                                                       */
    } AMBER_RINGO_CNT_0_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AMBER_REGION_CNT_0;              /*!< AMBER_0 counter                                                       */

    struct {
      __IO uint32_t  AMBER_REGION_CNT_0: 32;        /*!< AMBER_0 counter                                                       */
    } AMBER_REGION_CNT_0_b;                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AMBER_REGION_CNT_CTRL_0;         /*!< AMBER_0 counter enable                                                */

    struct {
      __IO uint32_t  AMBER_REGION_CNT_CTRL_0: 32;   /*!< AMBER_0 counter enable                                                */
    } AMBER_REGION_CNT_CTRL_0_b;                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[3];

  union {
    __IO uint32_t  DFT_CTRL_0;                      /*!< RED_0 and AMBER_0 Delay line DFT control                              */

    struct {
      __IO uint32_t  DFT_CTRL_0 : 32;               /*!< RED_0 and AMBER_0 Delay line DFT control                              */
    } DFT_CTRL_0_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[495];

  union {
    __IO uint32_t  RED_DEL_CTRL_1;                  /*!< RED_1 Delay line value step of 250ps in typical case                  */

    struct {
      __IO uint32_t  RED_DEL_CTRL_1: 32;            /*!< RED_1 Delay line value step of 250ps in typical case                  */
    } RED_DEL_CTRL_1_b;                             /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[2];

  union {
    __IO uint32_t  RED_REGION_CNT_1;                /*!< RED_0 counter                                                         */

    struct {
      __IO uint32_t  RED_REGION_CNT_1: 32;          /*!< RED_0 counter                                                         */
    } RED_REGION_CNT_1_b;                           /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  RED_REGION_CNT_CTRL_1;           /*!< RED_0 counter enable                                                  */

    struct {
      __IO uint32_t  RED_REGION_CNT_CTRL_1: 32;     /*!< RED_0 counter enable                                                  */
    } RED_REGION_CNT_CTRL_1_b;                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[3];

  union {
    __IO uint32_t  AMBER_DEL_CTRL_1;                /*!< AMBER_1 Delay line value step of 250ps in typical case                */

    struct {
      __IO uint32_t  AMBER_DEL_CTRL_1: 32;          /*!< AMBER_1 Delay line value step of 250ps in typical case                */
    } AMBER_DEL_CTRL_1_b;                           /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AMBER_RINGO_1;                   /*!< RINGO_1 control                                                       */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< 1: enable RINGO clock generation                                      */
      __IO uint32_t  CNT_ENABLE :  1;               /*!< 1: start RINGO counter                                                */
      __IO uint32_t  CNT_RESET  :  1;               /*!< 1: reset RINGO counter                                                */
    } AMBER_RINGO_1_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AMBER_RINGO_CNT_1;               /*!< RINGO_1 counter                                                       */

    struct {
      __IO uint32_t  AMBER_RINGO_CNT_1: 32;         /*!< RINGO_1 counter                                                       */
    } AMBER_RINGO_CNT_1_b;                          /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AMBER_REGION_CNT_1;              /*!< AMBER_1 counter                                                       */

    struct {
      __IO uint32_t  AMBER_REGION_CNT_1: 32;        /*!< AMBER_1 counter                                                       */
    } AMBER_REGION_CNT_1_b;                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  AMBER_REGION_CNT_CTRL_1;         /*!< AMBER_1 counter enable                                                */

    struct {
      __IO uint32_t  AMBER_REGION_CNT_CTRL_1: 32;   /*!< AMBER_1 counter enable                                                */
    } AMBER_REGION_CNT_CTRL_1_b;                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[3];

  union {
    __IO uint32_t  DFT_CTRL_1;                      /*!< RED_1 and AMBER_1 Delay line DFT control                              */

    struct {
      __IO uint32_t  DFT_CTRL_1 : 32;               /*!< RED_1 and AMBER_1 Delay line DFT control                              */
    } DFT_CTRL_1_b;                                 /*!< BitSize                                                               */
  };
} u_pvt_Type;


/* ================================================================================ */
/* ================                 u_async_syscon                 ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component async_syscon (u_async_syscon)
  */

typedef struct {                                    /*!< u_async_syscon Structure                                              */

  union {
    __IO uint32_t  ASYNCPRESETCTRL;                 /*!< Asynchronous peripherals reset control. The ASYNCPRESETCTRL
                                                         register allows software to reset specific peripherals attached
                                                          to the async APB bridge. Writing a zero to any assigned bit
                                                          in this register clears the reset and allows the specified peripheral
                                                          to operate. Writing a one asserts the reset.                         */

    struct {
           uint32_t             :  1;
      __IO uint32_t  CT32B0     :  1;               /*!< Controls the reset for Counter/Timer CT32B0                           */
      __IO uint32_t  CT32B1     :  1;               /*!< Controls the reset for Counter/Timer CT32B1                           */
    } ASYNCPRESETCTRL_b;                            /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  ASYNCPRESETCTRLSET;              /*!< Set bits in ASYNCPRESETCTRL. Writing ones to this register sets
                                                         the corresponding bit or bits in the ASYNCPRESETCTRL register,
                                                          if they are implemented                                              */

    struct {
           uint32_t             :  1;
      __O  uint32_t  CT32B0     :  1;               /*!< Writing 1 to this register sets the bit ASYNCPRESETCTRL.CT32B0        */
      __O  uint32_t  CT32B1     :  1;               /*!< Writing 1 to this register sets the bit ASYNCPRESETCTRL.CT32B1        */
    } ASYNCPRESETCTRLSET_b;                         /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  ASYNCPRESETCTRLCLR;              /*!< Clear bits in ASYNCPRESETCTRL. Writing ones to this register
                                                         clears the corresponding bit or bits in the ASYNCPRESETCTRL
                                                          register, if they are implemented                                    */

    struct {
           uint32_t             :  1;
      __O  uint32_t  CT32B0     :  1;               /*!< Writing 1 to this register clears the bit ASYNCPRESETCTRL.CT32B0      */
      __O  uint32_t  CT32B1     :  1;               /*!< Writing 1 to this register clears the bit ASYNCPRESETCTRL.CT32B1      */
    } ASYNCPRESETCTRLCLR_b;                         /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;

  union {
    __IO uint32_t  ASYNCAPBCLKCTRL;                 /*!< Asynchronous peripherals clock control. This register controls
                                                         how the clock selected for the asynchronous APB peripherals
                                                          is divided to provide the clock to the asynchronous peripherals      */

    struct {
           uint32_t             :  1;
      __IO uint32_t  CT32B0     :  1;               /*!< Controls the clock for Counter/Timer CT32B0                           */
      __IO uint32_t  CT32B1     :  1;               /*!< Controls the clock for Counter/Timer CT32B1                           */
    } ASYNCAPBCLKCTRL_b;                            /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  ASYNCAPBCLKCTRLSET;              /*!< Set bits in ASYNCAPBCLKCTRL. Writing ones to this register sets
                                                         the corresponding bit or bits in the ASYNCAPBCLKCTRLSET register,
                                                          if they are implemented                                              */

    struct {
           uint32_t             :  1;
      __O  uint32_t  CT32B0     :  1;               /*!< Writing 1 to this register sets the bit ASYNCAPBCLKCTRL.CT32B0        */
      __O  uint32_t  CT32B1     :  1;               /*!< Writing 1 to this register sets the bit ASYNCAPBCLKCTRL.CT32B1        */
    } ASYNCAPBCLKCTRLSET_b;                         /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  ASYNCAPBCLKCTRLCLR;              /*!< Clear bits in ASYNCAPBCLKCTRL. Writing ones to this register
                                                         sets the corresponding bit or bits in the ASYNCAPBCLKCTRLSET
                                                          register, if they are implemented                                    */

    struct {
           uint32_t             :  1;
      __O  uint32_t  CT32B0     :  1;               /*!< Writing 1 to this register clears the bit ASYNCAPBCLKCTRL.CT32B0      */
      __O  uint32_t  CT32B1     :  1;               /*!< Writing 1 to this register clears the bit ASYNCAPBCLKCTRL.CT32B1      */
    } ASYNCAPBCLKCTRLCLR_b;                         /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1;

  union {
    __IO uint32_t  ASYNCAPBCLKSELA;                 /*!< Asynchronous APB clock source select                                  */

    struct {
      __IO uint32_t  SEL        :  2;               /*!< Clock source for modules beyond asynchronous Bus bridge: ASYNC_SYSCON
                                                         itself, timers 0/1 0: main (gated) clock 1: XTAL32M 2: FRO32M
                                                          3: FRO48M                                                            */
    } ASYNCAPBCLKSELA_b;                            /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2;

  union {
    __IO uint32_t  ASYNCAPBCLKDIV;                  /*!< Asynchronous APB clock division select [ES1 only]                     */

    struct {
      __IO uint32_t  DIV        :  8;               /*!< [ES1 only] Clock divider value. 0: Divide by 1. 255: Divide
                                                         by 256                                                                */
           uint32_t             : 21;
      __IO uint32_t  RESET      :  1;               /*!< [ES1 only] Resets the divider counter. Can be used to make sure
                                                         a new divider value is used right away rather than completing
                                                          the previous count                                                   */
      __IO uint32_t  HALT       :  1;               /*!< [ES1 only] Halts the divider counter. The intent is to allow
                                                         the divider s clock source to be changed without the risk of
                                                          a glitch at the output                                               */
      __IO uint32_t  REQFLAG    :  1;               /*!< [ES1 only] Divider status flag. Set when a change is made to
                                                         the divider value, cleared when the change is complete                */
    } ASYNCAPBCLKDIV_b;                             /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ASYNCCLKOVERRIDE;                /*!< Asynchronous APB automatic clock gating override                      */

    struct {
           uint32_t             : 15;
      __IO uint32_t  ASYNCSYSREGBANK:  1;           /*!< Override automatic clock gating of Asynchronous System Controller
                                                         registers bank when set (i.e. always clock). Default setting
                                                          (0) is to use clock gating.                                          */
      __O  uint32_t  ENABLEUPDATE: 16;              /*!< The value 0xC0DE must be written for ASYNCCLKOVERRIDE registers
                                                         fields updates to have effect.                                        */
    } ASYNCCLKOVERRIDE_b;                           /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[28];

  union {
    __IO uint32_t  TEMPSENSORCTRL;                  /*!< Temperature Sensor controls                                           */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< Temperature sensor enable                                             */
      __IO uint32_t  SLOPE      :  1;               /*!< Temperature sensor sloe selection. 0x0: Unity gain slope. 0x1:
                                                         Double gain slope. Only setting 0 should be used.                     */
      __IO uint32_t  CM         :  2;               /*!< Temerature sensor common mode output voltage selection: 0x0:
                                                         high negative offset added. 0x1: intermediate negative offset
                                                          added. 0x2: no offset added. 0x3: low positive offset added.
                                                          Only setting 0x2 should be used.                                     */
    } TEMPSENSORCTRL_b;                             /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  NFCTAGPADSCTRL;                  /*!< NFC Tag pads control : I2C interface + 1 interrupt input pad          */

    struct {
      __IO uint32_t  I2C_SDA_EPD:  1;               /*!< Enable weak pull down on IO pad                                       */
      __IO uint32_t  I2C_SDA_EPUN:  1;              /*!< Enable weak pull up on IO pad, active low                             */
      __IO uint32_t  I2C_SDA_EHS0:  1;              /*!< Driver slew rate.                                                     */
      __IO uint32_t  I2C_SDA_INVERT:  1;            /*!< Input polarity. 0 : Input function is not inverted. 1 : Input
                                                         function is inverted.                                                 */
      __IO uint32_t  I2C_SDA_ENZI:  1;              /*!< Receiver enable                                                       */
      __IO uint32_t  I2C_SDA_FILTEROFF:  1;         /*!< Controls input glitch filter 0 Filter enabled. Noise pulses
                                                         below approximately 10 ns are filtered out. 1 Filter disabled.
                                                          No input filtering is done.                                          */
      __IO uint32_t  I2C_SDA_EHS1:  1;              /*!< Driver slew rate.                                                     */
      __IO uint32_t  I2C_SDA_OD :  1;               /*!< Controls open-drain mode. 0 Normal. Normal push-pull output
                                                         1 Open-drain. Simulated open-drain output (high drive disabled).      */
      __IO uint32_t  I2C_SCL_EPD:  1;               /*!< Enable weak pull down on IO pad                                       */
      __IO uint32_t  I2C_SCL_EPUN:  1;              /*!< Enable weak pull up on IO pad, active low                             */
      __IO uint32_t  I2C_SCL_EHS0:  1;              /*!< Driver slew rate.                                                     */
      __IO uint32_t  I2C_SCL_INVERT:  1;            /*!< Input polarity. 0 : Input function is not inverted. 1 : Input
                                                         function is inverted.                                                 */
      __IO uint32_t  I2C_SCL_ENZI:  1;              /*!< Receiver enable                                                       */
      __IO uint32_t  I2C_SCL_FILTEROFF:  1;         /*!< Controls input glitch filter 0 Filter enabled. Noise pulses
                                                         below approximately 10 ns are filtered out. 1 Filter disabled.
                                                          No input filtering is done.                                          */
      __IO uint32_t  I2C_SCL_EHS1:  1;              /*!< Driver slew rate.                                                     */
      __IO uint32_t  I2C_SCL_OD :  1;               /*!< Controls open-drain mode. 0 Normal. Normal push-pull output
                                                         1 Open-drain. Simulated open-drain output (high drive disabled).      */
      __IO uint32_t  INT_EPD    :  1;               /*!< Reserved. IO cell no longer supports pull-down                        */
      __IO uint32_t  INT_EPUN   :  1;               /*!< Reserved. IO cell pull-up always on, not configurable                 */
      __IO uint32_t  INT_INVERT :  1;               /*!< Input polarity. 0 : Input function is not inverted. 1 : Input
                                                         function is inverted.                                                 */
      __IO uint32_t  INT_ENZI   :  1;               /*!< Reserved. IO cell always enabled, not configurable                    */
      __IO uint32_t  INT_FILTEROFF:  1;             /*!< Reserved. IO cell always filters signal, not configurable             */
      __IO uint32_t  VDD_EPD    :  1;               /*!< Enable weak pull down on IO pad                                       */
      __IO uint32_t  VDD_EPUN   :  1;               /*!< Enable weak pull up on IO pad, active low                             */
      __IO uint32_t  VDD_EHS0   :  1;               /*!< Driver slew rate.                                                     */
      __IO uint32_t  VDD_INVERT :  1;               /*!< Input polarity. 0 : Input function is not inverted. 1 : Input
                                                         function is inverted.                                                 */
      __IO uint32_t  VDD_ENZI   :  1;               /*!< Receiver enable                                                       */
      __IO uint32_t  VDD_FILTEROFF:  1;             /*!< Controls input glitch filter 0 Filter enabled. Noise pulses
                                                         below approximately 10 ns are filtered out. 1 Filter disabled.
                                                          No input filtering is done.                                          */
      __IO uint32_t  VDD_EHS1   :  1;               /*!< Driver slew rate.                                                     */
      __IO uint32_t  VDD_OD     :  1;               /*!< Controls open-drain mode. 0 Normal. Normal push-pull output
                                                         1 Open-drain. Simulated open-drain output (high drive disabled).      */
    } NFCTAGPADSCTRL_b;                             /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  XTAL32MLDOCTRL;                  /*!< XTAL 32 MHz LDO control register. If XTAL has been auto started
                                                         due to EFUSE XTAL32MSTART_ENA or BLE low power timers then the
                                                          effect of these need disabling via SYSCON.XTAL32MCTRL before
                                                          the full control by this register is possible.                       */

    struct {
      __IO uint32_t  BYPASS     :  1;               /*!< Activate LDO bypass                                                   */
      __IO uint32_t  ENABLE     :  1;               /*!< Enable the LDO                                                        */
      __IO uint32_t  HIGHZ      :  1;               /*!< Put the output in high impedance state                                */
      __IO uint32_t  VOUT       :  3;               /*!< Adjust the output voltage level                                       */
      __IO uint32_t  IBIAS      :  2;               /*!< Adjust the biasing current                                            */
      __IO uint32_t  STABMODE   :  2;               /*!< Stability configuration                                               */
    } XTAL32MLDOCTRL_b;                             /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  XTAL32MCTRL;                     /*!< XTAL 32 MHz control register. If XTAL has been auto started
                                                         due to EFUSE XTAL32MSTART_ENA or BLE low power timers then the
                                                          effect of these need disabling via SYSCON.XTAL32MCTRL before
                                                          the full control by this register is possible.                       */

    struct {
      __IO uint32_t  XO_ACBUF_PASS_ENABLE:  1;      /*!< Bypass enable of xo AC buffer enable in pll and top level             */
      __IO uint32_t  XO_AMP     :  3;               /*!< Amplitude selection , Min amp : 001, Max amp : 110                    */
      __IO uint32_t  XO_OSC_CAP_IN:  7;             /*!< Tune cap in Xi                                                        */
      __IO uint32_t  XO_OSC_CAP_OUT:  7;            /*!< Tune cap in Xo                                                        */
           uint32_t             :  4;
      __IO uint32_t  XO_ENABLE  :  1;               /*!< Enable signal for xo                                                  */
      __IO uint32_t  XO_GM      :  3;               /*!< Gm value for Xo                                                       */
      __IO uint32_t  XO_SLAVE   :  1;               /*!< Xo in slave mode                                                      */
      __IO uint32_t  XO_STANDALONE_ENABLE:  1;      /*!< Reduce the current in XO in sleep mode                                */
      __IO uint32_t  XO32M_TO_MCU_ENABLE:  1;       /*!< Enable the 32MHz clock to MCU                                         */
      __IO uint32_t  CLK_TO_GPADC_ENABLE:  1;       /*!< Enable the 16MHz clock to gpadc (pmu)                                 */
    } XTAL32MCTRL_b;                                /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  ANALOGID;                        /*!< Analog Interfaces (PMU and Radio) identity registers                  */

    struct {
      __I  uint32_t  PMUID      :  6;               /*!< PMU Identitty register [ES1 was 0x5]                                  */
      __I  uint32_t  RADIOID    :  6;               /*!< Radio Identity register [ES2 not supported]                           */
    } ANALOGID_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  RADIOSTATUS;                     /*!< All Radio Analog modules status register.                             */

    struct {
      __I  uint32_t  PLLXOREADY :  1;               /*!< (null)                                                                */
    } RADIOSTATUS_b;                                /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  DIGITALSTATUS;                   /*!< All Digital modules global status register.                           */

    struct {
      __I  uint32_t  FLASHINITERROR:  1;            /*!< Flash Init Error                                                      */
    } DIGITALSTATUS_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DCBUSCTRL;                       /*!< DC Bus control registers                                              */

    struct {
      __IO uint32_t  ADDR       :  9;               /*!< (null)                                                                */
      __IO uint32_t  MUX1       :  4;               /*!< (null)                                                                */
      __IO uint32_t  MUX2       :  4;               /*!< (null)                                                                */
    } DCBUSCTRL_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FREQMECTRL;                      /*!< Frequency measure register                                            */

    struct {
      __IO uint32_t  CAPVAL_SCALE: 31;              /*!< CAPVAL = FREQMECTRL[30:0] (Read-only) : Stores the target counter
                                                         result from the last frequency measure activiation, this is
                                                          used in the calculation of the unknown clock frequency of the
                                                          reference or target clock. SCALE = FREQMECTRL[4:0] (Write-only)
                                                          : define the count duration, (2^SCALE)-1, that reference counter
                                                          counts to during measurement. Note that the value is 2 giving
                                                          a minimum count 2^2-1 = 3. The result of freq_me_plus can be
                                                          calculated as follows : freq_targetclk =freq_refclk* (CAPVAL+1)
                                                          / ((2^S                                                              */
      __IO uint32_t  PROG       :  1;               /*!< Set this bit to one to initiate a frequency measurement cycle.
                                                         Hardware clears this bit when the measurement cycle has completed
                                                          and there is valid capture data in the CAPVAL field (bits 13:0).     */
    } FREQMECTRL_b;                                 /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  NFCTAGINTSTATUS;                 /*!< NFC Tag interrupt status register.                                    */

    struct {
      __I  uint32_t  NFCTAGINT  :  1;               /*!< NFC Tag interrupt status bit. Reset when read. 0 : No interrupt
                                                         has raised 1 : Interrupt has raised                                   */
    } NFCTAGINTSTATUS_b;                            /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  NFCTAG_VDD;                      /*!< NFCTAG VDD output control                                             */

    struct {
      __IO uint32_t  NFCTAG_VDD_OUT:  1;            /*!< Output value for the NFC Tag Vdd IO, if enabled with NFCTAG_VDD_OE    */
      __IO uint32_t  NFCTAG_VDD_OE:  1;             /*!< Output enable for the NFC Tag Vdd IO cell                             */
    } NFCTAG_VDD_b;                                 /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  SWRESETCTRL;                     /*!< Full IC reset request (from Software application).                    */

    struct {
      __O  uint32_t  ICRESETREQ :  1;               /*!< IC reset request: 0 : No effect 1 : Request a fulll IC reset
                                                         level reset                                                           */
           uint32_t             : 15;
      __O  uint32_t  VECTKEY    : 16;               /*!< Register Key: On write, write 0x05FA to VECTKEY, otherwise the
                                                         write is ignored.                                                     */
    } SWRESETCTRL_b;                                /*!< BitSize                                                               */
  };
} u_async_syscon_Type;


/* ================================================================================ */
/* ================                    u0_timer                    ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component ct32b It is standard 32-bit Counter/Timer with APB bus interface. More details will follow. (u0_timer)
  */

typedef struct {                                    /*!< u0_timer Structure                                                    */

  union {
    __IO uint32_t  IR;                              /*!< Interrupt Register. The IR can be written to clear interrupts.
                                                         The IR can be read to identify which of eight possible interrupt
                                                          sources are pending.                                                 */

    struct {
      __IO uint32_t  MR0INT     :  1;               /*!< Interrupt flag for match channel 0.                                   */
      __IO uint32_t  MR1INT     :  1;               /*!< Interrupt flag for match channel 1.                                   */
      __IO uint32_t  MR2INT     :  1;               /*!< Interrupt flag for match channel 2.                                   */
      __IO uint32_t  MR3INT     :  1;               /*!< Interrupt flag for match channel 3.                                   */
      __IO uint32_t  CR0INT     :  1;               /*!< Interrupt flag for capture channel 0 event.                           */
      __IO uint32_t  CR1INT     :  1;               /*!< Interrupt flag for capture channel 1 event.                           */
      __IO uint32_t  CR2INT     :  1;               /*!< Interrupt flag for capture channel 2 event.                           */
      __IO uint32_t  CR3INT     :  1;               /*!< Interrupt flag for capture channel 3 event.                           */
    } IR_b;                                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TCR;                             /*!< Timer Control Register. The TCR is used to control the Timer
                                                         Counter functions. The Timer Counter can be disabled or reset
                                                          through the TCR.                                                     */

    struct {
      __IO uint32_t  CEN        :  1;               /*!< Counter enable. 0 Disabled.The counters are disabled. 1 Enabled.
                                                         The Timer Counter and Prescale Counter are enabled.                   */
      __IO uint32_t  CRST       :  1;               /*!< Counter reset. 0 Disabled. Do nothing. 1 Enabled. The Timer
                                                         Counter and the Prescale Counter are synchronously reset on
                                                          the next positive edge of the APB bus clock. The counters remain
                                                          reset until TCR[1] is returned to zero.                              */
    } TCR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TC;                              /*!< Timer Counter. The 32 bit TC is incremented every PR+1 cycles
                                                         of the APB bus clock. The TC is controlled through the TCR.           */

    struct {
      __IO uint32_t  TCVAL      : 32;               /*!< Timer counter value.                                                  */
    } TC_b;                                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PR;                              /*!< Prescale Register. When the Prescale Counter (PC) is equal to
                                                         this value, the next clock increments the TC and clears the
                                                          PC.                                                                  */

    struct {
      __IO uint32_t  PRVAL      : 32;               /*!< Prescale counter value.                                               */
    } PR_b;                                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PC;                              /*!< Prescale Counter. The 32 bit PC is a counter which is incremented
                                                         to the value stored in PR. When the value in PR is reached,
                                                          the TC is incremented and the PC is cleared. The PC is observable
                                                          and controllable through the bus interface.                          */

    struct {
      __IO uint32_t  PCVAL      : 32;               /*!< Prescale counter value.                                               */
    } PC_b;                                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MCR;                             /*!< Match Control Register. The MCR is used to control if an interrupt
                                                         is generated and if the TC is reset when a Match occurs.              */

    struct {
      __IO uint32_t  MR0I       :  1;               /*!< Interrupt on MR0: an interrupt is generated when MR0 matches
                                                         the value in the TC. 0 = disabled. 1 = enabled.                       */
      __IO uint32_t  MR0R       :  1;               /*!< Reset on MR0: the TC will be reset if MR0 matches it. 0 = disabled.
                                                         1 = enabled.                                                          */
      __IO uint32_t  MR0S       :  1;               /*!< Stop on MR0: the TC and PC will be stopped and TCR[0] will be
                                                         set to 0 if MR0 matches the TC. 0 = disabled. 1 = enabled.            */
      __IO uint32_t  MR1I       :  1;               /*!< Interrupt on MR1: an interrupt is generated when MR1 matches
                                                         the value in the TC. 0 = disabled. 1 = enabled.                       */
      __IO uint32_t  MR1R       :  1;               /*!< Reset on MR1: the TC will be reset if MR1 matches it. 0 = disabled.
                                                         1 = enabled.                                                          */
      __IO uint32_t  MR1S       :  1;               /*!< Stop on MR1: the TC and PC will be stopped and TCR[0] will be
                                                         set to 0 if MR1 matches the TC. 0 = disabled. 1 = enabled.            */
      __IO uint32_t  MR2I       :  1;               /*!< Interrupt on MR2: an interrupt is generated when MR2 matches
                                                         the value in the TC. 0 = disabled. 1 = enabled.                       */
      __IO uint32_t  MR2R       :  1;               /*!< Reset on MR2: the TC will be reset if MR2 matches it. 0 = disabled.
                                                         1 = enabled.                                                          */
      __IO uint32_t  MR2S       :  1;               /*!< Stop on MR2: the TC and PC will be stopped and TCR[0] will be
                                                         set to 0 if MR2 matches the TC. 0 = disabled. 1 = enabled.            */
      __IO uint32_t  MR3I       :  1;               /*!< Interrupt on MR3: an interrupt is generated when MR3 matches
                                                         the value in the TC. 0 = disabled. 1 = enabled.                       */
      __IO uint32_t  MR3R       :  1;               /*!< Reset on MR3: the TC will be reset if MR3 matches it. 0 = disabled.
                                                         1 = enabled.                                                          */
      __IO uint32_t  MR3S       :  1;               /*!< Stop on MR3: the TC and PC will be stopped and TCR[0] will be
                                                         set to 0 if MR3 matches the TC. 0 = disabled. 1 = enabled.            */
    } MCR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MR0;                             /*!< Match Register 0. MR0 can be enabled through the MCR to reset
                                                         the TC, stop both the TC and PC, and/or generate an interrupt
                                                          every time MR0 matches the TC.                                       */

    struct {
      __IO uint32_t  MATCH      : 32;               /*!< Timer counter match value.                                            */
    } MR0_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MR1;                             /*!< Match Register 1. See MR0 description.                                */

    struct {
      __IO uint32_t  MATCH      : 32;               /*!< Timer counter match value.                                            */
    } MR1_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MR2;                             /*!< Match Register 2. See MR0 description.                                */

    struct {
      __IO uint32_t  MATCH      : 32;               /*!< Timer counter match value.                                            */
    } MR2_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MR3;                             /*!< Match Register 3. See MR0 description.                                */

    struct {
      __IO uint32_t  MATCH      : 32;               /*!< Timer counter match value.                                            */
    } MR3_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CCR;                             /*!< Capture Control Register. The CCR controls which edges of the
                                                         capture inputs are used to load the Capture Registers and whether
                                                          or not an interrupt is generated when a capture takes place.         */

    struct {
      __IO uint32_t  CAP0RE     :  1;               /*!< Rising edge of capture channel 0: a sequence of 0 then 1 causes
                                                         CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP0FE     :  1;               /*!< Falling edge of capture channel 0: a sequence of 1 then 0 causes
                                                         CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP0I      :  1;               /*!< Generate interrupt on channel 0 capture event: a CR0 load generates
                                                         an interrupt.                                                         */
      __IO uint32_t  CAP1RE     :  1;               /*!< Rising edge of capture channel 1: a sequence of 0 then 1 causes
                                                         CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP1FE     :  1;               /*!< Falling edge of capture channel 1: a sequence of 1 then 0 causes
                                                         CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP1I      :  1;               /*!< Generate interrupt on channel 1 capture event: a CR1 load generates
                                                         an interrupt.                                                         */
      __IO uint32_t  CAP2RE     :  1;               /*!< Rising edge of capture channel 2: a sequence of 0 then 1 causes
                                                         CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP2FE     :  1;               /*!< Falling edge of capture channel 2: a sequence of 1 then 0 causes
                                                         CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP2I      :  1;               /*!< Generate interrupt on channel 2 capture event: a CR2 load generates
                                                         an interrupt.                                                         */
      __IO uint32_t  CAP3RE     :  1;               /*!< Rising edge of capture channel 3: a sequence of 0 then 1 causes
                                                         CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP3FE     :  1;               /*!< Falling edge of capture channel 3: a sequence of 1 then 0 causes
                                                         CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP3I      :  1;               /*!< Generate interrupt on channel 3 capture event: a CR3 load generates
                                                         an interrupt.                                                         */
    } CCR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  CR0;                             /*!< Capture Register 0. CR0 is loaded with the value of TC when
                                                         there is an event on the CAPn.0 input.                                */

    struct {
      __I  uint32_t  CAP        : 32;               /*!< Timer counter capture value.                                          */
    } CR0_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  CR1;                             /*!< Capture Register 1. See CR0 description.                              */

    struct {
      __I  uint32_t  CAP        : 32;               /*!< Timer counter capture value.                                          */
    } CR1_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  CR2;                             /*!< Capture Register 2. See CR0 description.                              */

    struct {
      __I  uint32_t  CAP        : 32;               /*!< Timer counter capture value.                                          */
    } CR2_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  CR3;                             /*!< Capture Register 3. See CR0 description.                              */

    struct {
      __I  uint32_t  CAP        : 32;               /*!< Timer counter capture value.                                          */
    } CR3_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  EMR;                             /*!< External Match Register. The EMR controls the match function
                                                         and the external match pins.                                          */

    struct {
      __IO uint32_t  EM0        :  1;               /*!< External Match 0. This bit reflects the state of output MAT0,
                                                         whether or not this output is connected to a pin. When a match
                                                          occurs between the TC and MR0, this bit can either toggle, go
                                                          LOW, go HIGH, or do nothing, as selected by EMR[5:4]. This bit
                                                          is driven to the MAT pins if the match function is selected
                                                          via IOCON. 0 = LOW. 1 = HIGH.                                        */
      __IO uint32_t  EM1        :  1;               /*!< External Match 1. This bit reflects the state of output MAT1,
                                                         whether or not this output is connected to a pin. When a match
                                                          occurs between the TC and MR1, this bit can either toggle, go
                                                          LOW, go HIGH, or do nothing, as selected by EMR[7:6]. This bit
                                                          is driven to the MAT pins if the match function is selected
                                                          via IOCON. 0 = LOW. 1 = HIGH.                                        */
      __IO uint32_t  EM2        :  1;               /*!< External Match 2. This bit reflects the state of output MAT2,
                                                         whether or not this output is connected to a pin. When a match
                                                          occurs between the TC and MR2, this bit can either toggle, go
                                                          LOW, go HIGH, or do nothing, as selected by EMR[9:8]. This bit
                                                          is driven to the MAT pins if the match function is selected
                                                          via IOCON. 0 = LOW. 1 = HIGH                                         */
      __IO uint32_t  EM3        :  1;               /*!< External Match 3. This bit reflects the state of output MAT3,
                                                         whether or not this output is connected to a pin. When a match
                                                          occurs between the TC and MR3, this bit can either toggle, go
                                                          LOW, go HIGH, or do nothing, as selected by MR[11:10]. This
                                                          bit is driven to the MAT pins if the match function is selected
                                                          via IOCON. 0 = LOW. 1 = HIGH.                                        */
      __IO uint32_t  EMC0       :  2;               /*!< External Match Control 0. Determines the functionality of External
                                                         Match 0. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding
                                                          External Match bit/output to 0 (MAT0 pin is LOW if pinned out).
                                                          0x2 Set. Set the corresponding External Match bit/output to
                                                          1 (MAT0 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding
                                                          External Match bit/output.                                           */
      __IO uint32_t  EMC1       :  2;               /*!< External Match Control 1. Determines the functionality of External
                                                         Match 1. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding
                                                          External Match bit/output to 0 (MAT1 pin is LOW if pinned out).
                                                          0x2 Set. Set the corresponding External Match bit/output to
                                                          1 (MAT1 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding
                                                          External Match bit/output.                                           */
      __IO uint32_t  EMC2       :  2;               /*!< External Match Control 2. Determines the functionality of External
                                                         Match 2. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding
                                                          External Match bit/output to 0 (MAT2 pin is LOW if pinned out).
                                                          0x2 Set. Set the corresponding External Match bit/output to
                                                          1 (MAT2 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding
                                                          External Match bit/output.                                           */
      __IO uint32_t  EMC3       :  2;               /*!< External Match Control 3. Determines the functionality of External
                                                         Match 3. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding
                                                          External Match bit/output to 0 (MAT3 pin is LOW if pinned out).
                                                          0x2 Set. Set the corresponding External Match bit/output to
                                                          1 (MAT3 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding
                                                          External Match bit/output.                                           */
    } EMR_b;                                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[12];

  union {
    __IO uint32_t  CTCR;                            /*!< Count Control Register. The CTCR selects between Timer and Counter
                                                         mode, and in Counter mode selects the signal and edge(s) for
                                                          counting.                                                            */

    struct {
      __IO uint32_t  CTMODE     :  2;               /*!< Counter/Timer Mode This field selects which rising APB bus clock
                                                         edges can increment Timer s Prescale Counter (PC), or clear
                                                          PC and increment Timer Counter (TC). Timer Mode: the TC is incremented
                                                          when the Prescale Counter matches the Prescale Register. 0x0
                                                          Timer Mode. Incremented every rising APB bus clock edge. 0x1
                                                          Counter Mode rising edge. TC is incremented on rising edges
                                                          on the CAP input selected by bits 3:2. 0x2 Counter Mode falling
                                                          edge. TC is incremented on falling edges on the CAP input selected
                                                          by                                                                   */
      __IO uint32_t  CINSEL     :  2;               /*!< Count Input Select When bits 1:0 in this register are not 00,
                                                         these bits select which CAP pin is sampled for clocking. Note:
                                                          If Counter mode is selected for a particular CAPn input in the
                                                          CTCR, the 3 bits for that input in the Capture Control Register
                                                          (CCR) must be programmed as 000. However, capture and/or interrupt
                                                          can be selected for the other 3 CAPn inputs in the same timer.
                                                          0x0 Channel 0. CAPn.0 for CT32Bn 0x1 Channel 1. CAPn.1 for CT32Bn
                                                          0x2 Channel 2. CAPn.2 for CT32Bn 0x3 Channel 3. CAPn.3 for CT32      */
      __IO uint32_t  ENCC       :  1;               /*!< Setting this bit to 1 enables clearing of the timer and the
                                                         prescaler when the capture-edge event specified in bits 7:5
                                                          occurs.                                                              */
      __IO uint32_t  SELCC      :  3;               /*!< Edge select. When bit 4 is 1, these bits select which capture
                                                         input edge will cause the timer and prescaler to be cleared.
                                                          These bits have no effect when bit 4 is low. Values 0x2 to 0x3
                                                          and 0x6 to 0x7 are reserved. 0 0x0 Channel 0 Rising Edge. Rising
                                                          edge of the signal on capture channel 0 clears the timer (if
                                                          bit 4 is set). 0x1 Channel 0 Falling Edge. Falling edge of the
                                                          signal on capture channel 0 clears the timer (if bit 4 is set).
                                                          0x2 Channel 1 Rising Edge. Rising edge of the signal on capture
                                                          channel                                                              */
    } CTCR_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PWMC;                            /*!< PWM Control Register. The PWMCON enables PWM mode for the external
                                                         match pins.                                                           */

    struct {
      __IO uint32_t  PWMEN0     :  1;               /*!< PWM mode enable for channel0. 0 Match. CT32Bn_MAT0 is controlled
                                                         by EM0. 1 PWM. PWM mode is enabled for CT32Bn_MAT0.                   */
      __IO uint32_t  PWMEN1     :  1;               /*!< PWM mode enable for channel1. 0 Match. CT32Bn_MAT01 is controlled
                                                         by EM1. 1 PWM. PWM mode is enabled for CT32Bn_MAT1.                   */
      __IO uint32_t  PWMEN2     :  1;               /*!< PWM mode enable for channel2. 0 Match. CT32Bn_MAT2 is controlled
                                                         by EM2. 1 PWM. PWM mode is enabled for CT32Bn_MAT2.                   */
      __IO uint32_t  PWMEN3     :  1;               /*!< PWM mode enable for channel3. Note: It is recommended to use
                                                         match channel 3 to set the PWM cycle. 0 Match. CT32Bn_MAT3 is
                                                          controlled by EM3. 1 PWM. PWM mode is enabled for CT132Bn_MAT3       */
    } PWMC_b;                                       /*!< BitSize                                                               */
  };
} u0_timer_Type;


/* ================================================================================ */
/* ================                    u1_timer                    ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component ct32b It is standard 32-bit Counter/Timer with APB bus interface. More details will follow. (u1_timer)
  */

typedef struct {                                    /*!< u1_timer Structure                                                    */

  union {
    __IO uint32_t  IR;                              /*!< Interrupt Register. The IR can be written to clear interrupts.
                                                         The IR can be read to identify which of eight possible interrupt
                                                          sources are pending.                                                 */

    struct {
      __IO uint32_t  MR0INT     :  1;               /*!< Interrupt flag for match channel 0.                                   */
      __IO uint32_t  MR1INT     :  1;               /*!< Interrupt flag for match channel 1.                                   */
      __IO uint32_t  MR2INT     :  1;               /*!< Interrupt flag for match channel 2.                                   */
      __IO uint32_t  MR3INT     :  1;               /*!< Interrupt flag for match channel 3.                                   */
      __IO uint32_t  CR0INT     :  1;               /*!< Interrupt flag for capture channel 0 event.                           */
      __IO uint32_t  CR1INT     :  1;               /*!< Interrupt flag for capture channel 1 event.                           */
      __IO uint32_t  CR2INT     :  1;               /*!< Interrupt flag for capture channel 2 event.                           */
      __IO uint32_t  CR3INT     :  1;               /*!< Interrupt flag for capture channel 3 event.                           */
    } IR_b;                                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TCR;                             /*!< Timer Control Register. The TCR is used to control the Timer
                                                         Counter functions. The Timer Counter can be disabled or reset
                                                          through the TCR.                                                     */

    struct {
      __IO uint32_t  CEN        :  1;               /*!< Counter enable. 0 Disabled.The counters are disabled. 1 Enabled.
                                                         The Timer Counter and Prescale Counter are enabled.                   */
      __IO uint32_t  CRST       :  1;               /*!< Counter reset. 0 Disabled. Do nothing. 1 Enabled. The Timer
                                                         Counter and the Prescale Counter are synchronously reset on
                                                          the next positive edge of the APB bus clock. The counters remain
                                                          reset until TCR[1] is returned to zero.                              */
    } TCR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  TC;                              /*!< Timer Counter. The 32 bit TC is incremented every PR+1 cycles
                                                         of the APB bus clock. The TC is controlled through the TCR.           */

    struct {
      __IO uint32_t  TCVAL      : 32;               /*!< Timer counter value.                                                  */
    } TC_b;                                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PR;                              /*!< Prescale Register. When the Prescale Counter (PC) is equal to
                                                         this value, the next clock increments the TC and clears the
                                                          PC.                                                                  */

    struct {
      __IO uint32_t  PRVAL      : 32;               /*!< Prescale counter value.                                               */
    } PR_b;                                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PC;                              /*!< Prescale Counter. The 32 bit PC is a counter which is incremented
                                                         to the value stored in PR. When the value in PR is reached,
                                                          the TC is incremented and the PC is cleared. The PC is observable
                                                          and controllable through the bus interface.                          */

    struct {
      __IO uint32_t  PCVAL      : 32;               /*!< Prescale counter value.                                               */
    } PC_b;                                         /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MCR;                             /*!< Match Control Register. The MCR is used to control if an interrupt
                                                         is generated and if the TC is reset when a Match occurs.              */

    struct {
      __IO uint32_t  MR0I       :  1;               /*!< Interrupt on MR0: an interrupt is generated when MR0 matches
                                                         the value in the TC. 0 = disabled. 1 = enabled.                       */
      __IO uint32_t  MR0R       :  1;               /*!< Reset on MR0: the TC will be reset if MR0 matches it. 0 = disabled.
                                                         1 = enabled.                                                          */
      __IO uint32_t  MR0S       :  1;               /*!< Stop on MR0: the TC and PC will be stopped and TCR[0] will be
                                                         set to 0 if MR0 matches the TC. 0 = disabled. 1 = enabled.            */
      __IO uint32_t  MR1I       :  1;               /*!< Interrupt on MR1: an interrupt is generated when MR1 matches
                                                         the value in the TC. 0 = disabled. 1 = enabled.                       */
      __IO uint32_t  MR1R       :  1;               /*!< Reset on MR1: the TC will be reset if MR1 matches it. 0 = disabled.
                                                         1 = enabled.                                                          */
      __IO uint32_t  MR1S       :  1;               /*!< Stop on MR1: the TC and PC will be stopped and TCR[0] will be
                                                         set to 0 if MR1 matches the TC. 0 = disabled. 1 = enabled.            */
      __IO uint32_t  MR2I       :  1;               /*!< Interrupt on MR2: an interrupt is generated when MR2 matches
                                                         the value in the TC. 0 = disabled. 1 = enabled.                       */
      __IO uint32_t  MR2R       :  1;               /*!< Reset on MR2: the TC will be reset if MR2 matches it. 0 = disabled.
                                                         1 = enabled.                                                          */
      __IO uint32_t  MR2S       :  1;               /*!< Stop on MR2: the TC and PC will be stopped and TCR[0] will be
                                                         set to 0 if MR2 matches the TC. 0 = disabled. 1 = enabled.            */
      __IO uint32_t  MR3I       :  1;               /*!< Interrupt on MR3: an interrupt is generated when MR3 matches
                                                         the value in the TC. 0 = disabled. 1 = enabled.                       */
      __IO uint32_t  MR3R       :  1;               /*!< Reset on MR3: the TC will be reset if MR3 matches it. 0 = disabled.
                                                         1 = enabled.                                                          */
      __IO uint32_t  MR3S       :  1;               /*!< Stop on MR3: the TC and PC will be stopped and TCR[0] will be
                                                         set to 0 if MR3 matches the TC. 0 = disabled. 1 = enabled.            */
    } MCR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MR0;                             /*!< Match Register 0. MR0 can be enabled through the MCR to reset
                                                         the TC, stop both the TC and PC, and/or generate an interrupt
                                                          every time MR0 matches the TC.                                       */

    struct {
      __IO uint32_t  MATCH      : 32;               /*!< Timer counter match value.                                            */
    } MR0_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MR1;                             /*!< Match Register 1. See MR0 description.                                */

    struct {
      __IO uint32_t  MATCH      : 32;               /*!< Timer counter match value.                                            */
    } MR1_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MR2;                             /*!< Match Register 2. See MR0 description.                                */

    struct {
      __IO uint32_t  MATCH      : 32;               /*!< Timer counter match value.                                            */
    } MR2_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MR3;                             /*!< Match Register 3. See MR0 description.                                */

    struct {
      __IO uint32_t  MATCH      : 32;               /*!< Timer counter match value.                                            */
    } MR3_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CCR;                             /*!< Capture Control Register. The CCR controls which edges of the
                                                         capture inputs are used to load the Capture Registers and whether
                                                          or not an interrupt is generated when a capture takes place.         */

    struct {
      __IO uint32_t  CAP0RE     :  1;               /*!< Rising edge of capture channel 0: a sequence of 0 then 1 causes
                                                         CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP0FE     :  1;               /*!< Falling edge of capture channel 0: a sequence of 1 then 0 causes
                                                         CR0 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP0I      :  1;               /*!< Generate interrupt on channel 0 capture event: a CR0 load generates
                                                         an interrupt.                                                         */
      __IO uint32_t  CAP1RE     :  1;               /*!< Rising edge of capture channel 1: a sequence of 0 then 1 causes
                                                         CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP1FE     :  1;               /*!< Falling edge of capture channel 1: a sequence of 1 then 0 causes
                                                         CR1 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP1I      :  1;               /*!< Generate interrupt on channel 1 capture event: a CR1 load generates
                                                         an interrupt.                                                         */
      __IO uint32_t  CAP2RE     :  1;               /*!< Rising edge of capture channel 2: a sequence of 0 then 1 causes
                                                         CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP2FE     :  1;               /*!< Falling edge of capture channel 2: a sequence of 1 then 0 causes
                                                         CR2 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP2I      :  1;               /*!< Generate interrupt on channel 2 capture event: a CR2 load generates
                                                         an interrupt.                                                         */
      __IO uint32_t  CAP3RE     :  1;               /*!< Rising edge of capture channel 3: a sequence of 0 then 1 causes
                                                         CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP3FE     :  1;               /*!< Falling edge of capture channel 3: a sequence of 1 then 0 causes
                                                         CR3 to be loaded with the contents of TC. 0 = disabled. 1 =
                                                          enabled.                                                             */
      __IO uint32_t  CAP3I      :  1;               /*!< Generate interrupt on channel 3 capture event: a CR3 load generates
                                                         an interrupt.                                                         */
    } CCR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  CR0;                             /*!< Capture Register 0. CR0 is loaded with the value of TC when
                                                         there is an event on the CAPn.0 input.                                */

    struct {
      __I  uint32_t  CAP        : 32;               /*!< Timer counter capture value.                                          */
    } CR0_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  CR1;                             /*!< Capture Register 1. See CR0 description.                              */

    struct {
      __I  uint32_t  CAP        : 32;               /*!< Timer counter capture value.                                          */
    } CR1_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  CR2;                             /*!< Capture Register 2. See CR0 description.                              */

    struct {
      __I  uint32_t  CAP        : 32;               /*!< Timer counter capture value.                                          */
    } CR2_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  CR3;                             /*!< Capture Register 3. See CR0 description.                              */

    struct {
      __I  uint32_t  CAP        : 32;               /*!< Timer counter capture value.                                          */
    } CR3_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  EMR;                             /*!< External Match Register. The EMR controls the match function
                                                         and the external match pins.                                          */

    struct {
      __IO uint32_t  EM0        :  1;               /*!< External Match 0. This bit reflects the state of output MAT0,
                                                         whether or not this output is connected to a pin. When a match
                                                          occurs between the TC and MR0, this bit can either toggle, go
                                                          LOW, go HIGH, or do nothing, as selected by EMR[5:4]. This bit
                                                          is driven to the MAT pins if the match function is selected
                                                          via IOCON. 0 = LOW. 1 = HIGH.                                        */
      __IO uint32_t  EM1        :  1;               /*!< External Match 1. This bit reflects the state of output MAT1,
                                                         whether or not this output is connected to a pin. When a match
                                                          occurs between the TC and MR1, this bit can either toggle, go
                                                          LOW, go HIGH, or do nothing, as selected by EMR[7:6]. This bit
                                                          is driven to the MAT pins if the match function is selected
                                                          via IOCON. 0 = LOW. 1 = HIGH.                                        */
      __IO uint32_t  EM2        :  1;               /*!< External Match 2. This bit reflects the state of output MAT2,
                                                         whether or not this output is connected to a pin. When a match
                                                          occurs between the TC and MR2, this bit can either toggle, go
                                                          LOW, go HIGH, or do nothing, as selected by EMR[9:8]. This bit
                                                          is driven to the MAT pins if the match function is selected
                                                          via IOCON. 0 = LOW. 1 = HIGH                                         */
      __IO uint32_t  EM3        :  1;               /*!< External Match 3. This bit reflects the state of output MAT3,
                                                         whether or not this output is connected to a pin. When a match
                                                          occurs between the TC and MR3, this bit can either toggle, go
                                                          LOW, go HIGH, or do nothing, as selected by MR[11:10]. This
                                                          bit is driven to the MAT pins if the match function is selected
                                                          via IOCON. 0 = LOW. 1 = HIGH.                                        */
      __IO uint32_t  EMC0       :  2;               /*!< External Match Control 0. Determines the functionality of External
                                                         Match 0. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding
                                                          External Match bit/output to 0 (MAT0 pin is LOW if pinned out).
                                                          0x2 Set. Set the corresponding External Match bit/output to
                                                          1 (MAT0 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding
                                                          External Match bit/output.                                           */
      __IO uint32_t  EMC1       :  2;               /*!< External Match Control 1. Determines the functionality of External
                                                         Match 1. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding
                                                          External Match bit/output to 0 (MAT1 pin is LOW if pinned out).
                                                          0x2 Set. Set the corresponding External Match bit/output to
                                                          1 (MAT1 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding
                                                          External Match bit/output.                                           */
      __IO uint32_t  EMC2       :  2;               /*!< External Match Control 2. Determines the functionality of External
                                                         Match 2. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding
                                                          External Match bit/output to 0 (MAT2 pin is LOW if pinned out).
                                                          0x2 Set. Set the corresponding External Match bit/output to
                                                          1 (MAT2 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding
                                                          External Match bit/output.                                           */
      __IO uint32_t  EMC3       :  2;               /*!< External Match Control 3. Determines the functionality of External
                                                         Match 3. 0x0 Do Nothing. 0x1 Clear. Clear the corresponding
                                                          External Match bit/output to 0 (MAT3 pin is LOW if pinned out).
                                                          0x2 Set. Set the corresponding External Match bit/output to
                                                          1 (MAT3 pin is HIGH if pinned out). 0x3 Toggle. Toggle the corresponding
                                                          External Match bit/output.                                           */
    } EMR_b;                                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[12];

  union {
    __IO uint32_t  CTCR;                            /*!< Count Control Register. The CTCR selects between Timer and Counter
                                                         mode, and in Counter mode selects the signal and edge(s) for
                                                          counting.                                                            */

    struct {
      __IO uint32_t  CTMODE     :  2;               /*!< Counter/Timer Mode This field selects which rising APB bus clock
                                                         edges can increment Timer s Prescale Counter (PC), or clear
                                                          PC and increment Timer Counter (TC). Timer Mode: the TC is incremented
                                                          when the Prescale Counter matches the Prescale Register. 0x0
                                                          Timer Mode. Incremented every rising APB bus clock edge. 0x1
                                                          Counter Mode rising edge. TC is incremented on rising edges
                                                          on the CAP input selected by bits 3:2. 0x2 Counter Mode falling
                                                          edge. TC is incremented on falling edges on the CAP input selected
                                                          by                                                                   */
      __IO uint32_t  CINSEL     :  2;               /*!< Count Input Select When bits 1:0 in this register are not 00,
                                                         these bits select which CAP pin is sampled for clocking. Note:
                                                          If Counter mode is selected for a particular CAPn input in the
                                                          CTCR, the 3 bits for that input in the Capture Control Register
                                                          (CCR) must be programmed as 000. However, capture and/or interrupt
                                                          can be selected for the other 3 CAPn inputs in the same timer.
                                                          0x0 Channel 0. CAPn.0 for CT32Bn 0x1 Channel 1. CAPn.1 for CT32Bn
                                                          0x2 Channel 2. CAPn.2 for CT32Bn 0x3 Channel 3. CAPn.3 for CT32      */
      __IO uint32_t  ENCC       :  1;               /*!< Setting this bit to 1 enables clearing of the timer and the
                                                         prescaler when the capture-edge event specified in bits 7:5
                                                          occurs.                                                              */
      __IO uint32_t  SELCC      :  3;               /*!< Edge select. When bit 4 is 1, these bits select which capture
                                                         input edge will cause the timer and prescaler to be cleared.
                                                          These bits have no effect when bit 4 is low. Values 0x2 to 0x3
                                                          and 0x6 to 0x7 are reserved. 0 0x0 Channel 0 Rising Edge. Rising
                                                          edge of the signal on capture channel 0 clears the timer (if
                                                          bit 4 is set). 0x1 Channel 0 Falling Edge. Falling edge of the
                                                          signal on capture channel 0 clears the timer (if bit 4 is set).
                                                          0x2 Channel 1 Rising Edge. Rising edge of the signal on capture
                                                          channel                                                              */
    } CTCR_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PWMC;                            /*!< PWM Control Register. The PWMCON enables PWM mode for the external
                                                         match pins.                                                           */

    struct {
      __IO uint32_t  PWMEN0     :  1;               /*!< PWM mode enable for channel0. 0 Match. CT32Bn_MAT0 is controlled
                                                         by EM0. 1 PWM. PWM mode is enabled for CT32Bn_MAT0.                   */
      __IO uint32_t  PWMEN1     :  1;               /*!< PWM mode enable for channel1. 0 Match. CT32Bn_MAT01 is controlled
                                                         by EM1. 1 PWM. PWM mode is enabled for CT32Bn_MAT1.                   */
      __IO uint32_t  PWMEN2     :  1;               /*!< PWM mode enable for channel2. 0 Match. CT32Bn_MAT2 is controlled
                                                         by EM2. 1 PWM. PWM mode is enabled for CT32Bn_MAT2.                   */
      __IO uint32_t  PWMEN3     :  1;               /*!< PWM mode enable for channel3. Note: It is recommended to use
                                                         match channel 3 to set the PWM cycle. 0 Match. CT32Bn_MAT3 is
                                                          controlled by EM3. 1 PWM. PWM mode is enabled for CT132Bn_MAT3       */
    } PWMC_b;                                       /*!< BitSize                                                               */
  };
} u1_timer_Type;


/* ================================================================================ */
/* ================                     u_gpio                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component gpio It is General Purpose I/O with APB bus interface. More details will follow. (u_gpio)
  */

typedef struct {                                    /*!< u_gpio Structure                                                      */

  union {
    __IO uint8_t   B[22];                           /*!< Byte pin registers Read 0: pin PIOn is LOW. Write 0: clear output
                                                         bit. Read 0x01: pin PIOn is HIGH. Write any value 0x01 to 0xFF:
                                                          set output bit. Remark: Only 0 or 0xFF can be read. Writing
                                                          any value other than 0 will set the output bit. Supported pins
                                                          depends on the specific device and package. Reset values reflects
                                                          the state of pin given by the relevant bit of PIN reset value        */

    struct {
      __IO uint8_t   B          :  8;               /*!< Byte pin registers Read 0: pin PIOn is LOW. Write 0: clear output
                                                         bit. Read 0x01: pin PIOn is HIGH. Write any value 0x01 to 0xFF:
                                                          set output bit. Remark: Only 0 or 0xFF can be read. Writing
                                                          any value other than 0 will set the output bit. Supported pins
                                                          depends on the specific device and package. Reset values reflects
                                                          the state of pin given by the relevant bit of PIN reset value        */
    } B_b[22];                                      /*!< BitSize                                                               */
  };
  __I  uint16_t  RESERVED0[2037];

  union {
    __IO uint32_t  W[22];                           /*!< Word pin registers Read 0: pin PIOn is LOW. Write 0: clear output
                                                         bit. Read 0xFFFF FFFF: pin PIOn is HIGH. Write any value 0x0000
                                                          0001 to 0xFFFF FFFF: set output bit. Remark: Only 0 or 0xFFFF
                                                          FFFF can be read. Writing any value other than 0 will set the
                                                          output bit. Supported pins depends on the specific device and
                                                          package. Reset values reflects the state of pin given by the
                                                          relevant bit of PIN reset value                                      */

    struct {
      __IO uint32_t  W          : 32;               /*!< Word pin registers Read 0: pin PIOn is LOW. Write 0: clear output
                                                         bit. Read 0xFFFF FFFF: pin PIOn is HIGH. Write any value 0x0000
                                                          0001 to 0xFFFF FFFF: set output bit. Remark: Only 0 or 0xFFFF
                                                          FFFF can be read. Writing any value other than 0 will set the
                                                          output bit. Supported pins depends on the specific device and
                                                          package. Reset values reflects the state of pin given by the
                                                          relevant bit of PIN reset value                                      */
    } W_b[22];                                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[1002];

  union {
    __IO uint32_t  DIR;                             /*!< Direction register                                                    */

    struct {
      __IO uint32_t  DIRP_PIO0  :  1;               /*!< Selects pin direction for pin PIO0 . 0 = input. 1 = output.           */
      __IO uint32_t  DIRP_PIO1  :  1;               /*!< Selects pin direction for pin PIO1 . 0 = input. 1 = output.           */
      __IO uint32_t  DIRP_PIO2  :  1;               /*!< Selects pin direction for pin PIO2 . 0 = input. 1 = output.           */
      __IO uint32_t  DIRP_PIO3  :  1;               /*!< Selects pin direction for pin PIO3 . 0 = input. 1 = output.           */
      __IO uint32_t  DIRP_PIO4  :  1;               /*!< Selects pin direction for pin PIO4 . 0 = input. 1 = output.           */
      __IO uint32_t  DIRP_PIO5  :  1;               /*!< Selects pin direction for pin PIO5 . 0 = input. 1 = output.           */
      __IO uint32_t  DIRP_PIO6  :  1;               /*!< Selects pin direction for pin PIO6 . 0 = input. 1 = output.           */
      __IO uint32_t  DIRP_PIO7  :  1;               /*!< Selects pin direction for pin PIO7 . 0 = input. 1 = output.           */
      __IO uint32_t  DIRP_PIO8  :  1;               /*!< Selects pin direction for pin PIO8 . 0 = input. 1 = output.           */
      __IO uint32_t  DIRP_PIO9  :  1;               /*!< Selects pin direction for pin PIO9 . 0 = input. 1 = output.           */
      __IO uint32_t  DIRP_PIO10 :  1;               /*!< Selects pin direction for pin PIO10 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO11 :  1;               /*!< Selects pin direction for pin PIO11 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO12 :  1;               /*!< Selects pin direction for pin PIO12 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO13 :  1;               /*!< Selects pin direction for pin PIO13 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO14 :  1;               /*!< Selects pin direction for pin PIO14 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO15 :  1;               /*!< Selects pin direction for pin PIO15 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO16 :  1;               /*!< Selects pin direction for pin PIO16 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO17 :  1;               /*!< Selects pin direction for pin PIO17 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO18 :  1;               /*!< Selects pin direction for pin PIO18 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO19 :  1;               /*!< Selects pin direction for pin PIO19 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO20 :  1;               /*!< Selects pin direction for pin PIO20 . 0 = input. 1 = output.          */
      __IO uint32_t  DIRP_PIO21 :  1;               /*!< Selects pin direction for pin PIO21 . 0 = input. 1 = output.          */
    } DIR_b;                                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[31];

  union {
    __IO uint32_t  MASK;                            /*!< Mask register                                                         */

    struct {
      __IO uint32_t  MASKP_PIO0 :  1;               /*!< Controls if PIO0 is active in MPIN register MPIN register. 0
                                                         = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO1 :  1;               /*!< Controls if PIO1 is active in MPIN register MPIN register. 0
                                                         = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO2 :  1;               /*!< Controls if PIO2 is active in MPIN register MPIN register. 0
                                                         = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO3 :  1;               /*!< Controls if PIO3 is active in MPIN register MPIN register. 0
                                                         = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO4 :  1;               /*!< Controls if PIO4 is active in MPIN register MPIN register. 0
                                                         = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO5 :  1;               /*!< Controls if PIO5 is active in MPIN register MPIN register. 0
                                                         = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO6 :  1;               /*!< Controls if PIO6 is active in MPIN register MPIN register. 0
                                                         = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO7 :  1;               /*!< Controls if PIO7 is active in MPIN register MPIN register. 0
                                                         = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO8 :  1;               /*!< Controls if PIO8 is active in MPIN register MPIN register. 0
                                                         = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO9 :  1;               /*!< Controls if PIO9 is active in MPIN register MPIN register. 0
                                                         = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO10:  1;               /*!< Controls if PIO10 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO11:  1;               /*!< Controls if PIO11 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO12:  1;               /*!< Controls if PIO12 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO13:  1;               /*!< Controls if PIO13 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO14:  1;               /*!< Controls if PIO14 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO15:  1;               /*!< Controls if PIO150 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO16:  1;               /*!< Controls if PIO16 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO17:  1;               /*!< Controls if PIO17 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO18:  1;               /*!< Controls if PIO18 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO19:  1;               /*!< Controls if PIO19 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO20:  1;               /*!< Controls if PIO20 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
      __IO uint32_t  MASKP_PIO21:  1;               /*!< Controls if PIO21 is active in MPIN register MPIN register.
                                                         0 = Read MPIN: pin state; write MPIN: load output bit. 1 = Read
                                                          MPIN: 0; write MPIN: output bit not affected.                        */
    } MASK_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[31];

  union {
    __IO uint32_t  PIN;                             /*!< Pin register                                                          */

    struct {
      __IO uint32_t  PORT_PIO0  :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO1  :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO2  :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO3  :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO4  :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO5  :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO6  :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO7  :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO8  :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO9  :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO10 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO11 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO12 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO13 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO14 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO15 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO16 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO17 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO18 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO19 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO20 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
      __IO uint32_t  PORT_PIO21 :  1;               /*!< Reads pin states or loads output bits. 0 = Read: pin is low;
                                                         write: clear output bit. 1 = Read: pin is high; write: set output
                                                          bit.                                                                 */
    } PIN_b;                                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[31];

  union {
    __IO uint32_t  MPIN;                            /*!< Masked Pin register                                                   */

    struct {
      __IO uint32_t  MPORT_PIO0 :  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO1 :  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO2 :  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO3 :  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO4 :  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO5 :  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO6 :  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO7 :  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO8 :  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO9 :  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO10:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO11:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO12:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO13:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO14:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO15:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO16:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO17:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO18:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO19:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO20:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
      __IO uint32_t  MPORT_PIO21:  1;               /*!< Masked pin register. 0 = Read: pin is LOW and/or the corresponding
                                                         bit in the MASK register is 1; write: clear output bit if the
                                                          corresponding bit in the MASK register is 0. 1 = Read: pin is
                                                          HIGH and the corresponding bit in the MASK register is 0; write:
                                                          set output bit if the corresponding bit in the MASK register
                                                          is 0.                                                                */
    } MPIN_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[31];

  union {
    __IO uint32_t  SET;                             /*!< Write: Set Pin register bits Read: output bits                        */

    struct {
      __IO uint32_t  SETP_PIO0  :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO1  :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO2  :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO3  :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO4  :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO5  :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO6  :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO7  :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO8  :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO9  :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO10 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO11 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO12 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO13 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO14 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO15 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO16 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO17 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO18 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO19 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO20 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
      __IO uint32_t  SETP_PIO21 :  1;               /*!< Read or set output bits. 0 = Read: output bit: write: no operation.
                                                         1 = Read: output bit; write: set output bit.                          */
    } SET_b;                                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[31];

  union {
    __O  uint32_t  CLR;                             /*!< Clear Pin register bits                                               */

    struct {
      __O  uint32_t  CLRP_PIO0  :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO1  :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO2  :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO3  :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO4  :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO5  :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO6  :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO7  :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO8  :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO9  :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO10 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO11 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO12 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO13 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO14 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO15 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO16 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO17 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO18 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO19 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO20 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
      __O  uint32_t  CLRP_PIO21 :  1;               /*!< Clear output bits. 0 = No operation. 1 = Clear output bit.            */
    } CLR_b;                                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7[31];

  union {
    __O  uint32_t  NOT;                             /*!< Toggle Pin register bits                                              */

    struct {
      __O  uint32_t  NOTP_PIO0  :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO1  :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO2  :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO3  :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO4  :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO5  :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO6  :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO7  :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO8  :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO9  :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO10 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO11 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO12 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO13 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO14 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO15 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO16 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO17 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO18 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO19 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO20 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
      __O  uint32_t  NOTP_PIO21 :  1;               /*!< Toggle output bits. 0 = no operation. 1 = Toggle output bit.          */
    } NOT_b;                                        /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED8[31];

  union {
    __O  uint32_t  DIRSET;                          /*!< Set pin direction bits                                                */

    struct {
      __O  uint32_t  DIRSETP_PIO0:  1;              /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO1:  1;              /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO2:  1;              /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO3:  1;              /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO4:  1;              /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO5:  1;              /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO6:  1;              /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO7:  1;              /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO8:  1;              /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO9:  1;              /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO10:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO11:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO12:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO13:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO14:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO15:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO16:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO17:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO18:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO19:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO20:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
      __O  uint32_t  DIRSETP_PIO21:  1;             /*!< Set direction bits. 0 = no operation. 1 = Set direction bit.          */
    } DIRSET_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED9[31];

  union {
    __O  uint32_t  DIRCLR;                          /*!< Clear pin direction bits                                              */

    struct {
      __O  uint32_t  DIRCLRP_PIO0:  1;              /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO1:  1;              /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO2:  1;              /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO3:  1;              /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO4:  1;              /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO5:  1;              /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO6:  1;              /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO7:  1;              /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO8:  1;              /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO9:  1;              /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO10:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO11:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO12:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO13:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO14:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO15:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO16:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO17:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO18:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO19:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO20:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRCLRP_PIO21:  1;             /*!< Clear direction bits. 0 = no operation. 1 = Clear direction
                                                         bit.                                                                  */
    } DIRCLR_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED10[31];

  union {
    __O  uint32_t  DIRNOT;                          /*!< Toggle pin direction bits                                             */

    struct {
      __O  uint32_t  DIRNOTP_PIO0:  1;              /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO1:  1;              /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO2:  1;              /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO3:  1;              /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO4:  1;              /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO5:  1;              /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO6:  1;              /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO7:  1;              /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO8:  1;              /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO9:  1;              /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO10:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO11:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO12:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO13:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO14:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO15:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO16:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO17:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO18:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO19:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO20:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
      __O  uint32_t  DIRNOTP_PIO21:  1;             /*!< Toggle direction bits. 0 = no operation. 1 = Toggle direction
                                                         bit.                                                                  */
    } DIRNOT_b;                                     /*!< BitSize                                                               */
  };
} u_gpio_Type;


/* ================================================================================ */
/* ================                     u_spifi                    ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component spifi It is General Purpose I/O with APB bus interface. More details will follow. (u_spifi)
  */

typedef struct {                                    /*!< u_spifi Structure                                                     */

  union {
    __IO uint32_t  CTRL;                            /*!< SPIFI control register                                                */

    struct {
      __IO uint32_t  TIMEOUT    : 16;               /*!< This field contains the number of serial clock periods without
                                                         the processor reading data in memory mode, which will cause
                                                          the SPIFI hardware to terminate the command by driving the CS
                                                          pin high and negating the CMD bit in the Status register. (This
                                                          allows the flash memory to enter a lower-power state.) If the
                                                          processor reads data from the flash region after a time-out,
                                                          the command in the Memory Command Register is issued again.          */
      __IO uint32_t  CSHIGH     :  4;               /*!< This field controls the minimum CS high time, expressed as a
                                                         number of serial clock periods minus one.                             */
           uint32_t             :  1;
      __IO uint32_t  D_PRFTCH_DIS:  1;              /*!< This bit allows conditioning of memory mode prefetches based
                                                         on the AHB HPROT (instruction/data) access information. A 1
                                                          in this register means that the SPIFI will not attempt a speculative
                                                          prefetch when it encounters data accesses.                           */
      __IO uint32_t  INTEN      :  1;               /*!< If this bit is 1 when a command ends, the SPIFI will assert
                                                         its interrupt request output. See INTRQ in the status register
                                                          for further details.                                                 */
      __IO uint32_t  MODE3      :  1;               /*!< SPI Mode 3 select. 0 SCK LOW. The SPIFI drives SCK low after
                                                         the rising edge at which the last bit of each command is captured,
                                                          and keeps it low while CS is HIGH. 1 SCK HIGH. the SPIFI keeps
                                                          SCK high after the rising edge for the last bit of each command
                                                          and while CS is HIGH, and drives it low after it drives CS LOW.
                                                          (Known serial flash devices can handle either mode, but some
                                                          devices may require a particular mode for proper operation.)
                                                          Remark: MODE3, RFCLK, and FBCLK should not all be 1, because
                                                          in this c                                                            */
           uint32_t             :  3;
      __IO uint32_t  PRFTCH_DIS :  1;               /*!< Cache prefetching enable. The SPIFI includes an internal cache.
                                                         A 1 in this bit disables prefetching of cache lines. 0 Enable.
                                                          Cache prefetching enabled. 1 Disable. Disables prefetching of
                                                          cache lines.                                                         */
      __IO uint32_t  DUAL       :  1;               /*!< Select dual protocol. 0 Quad protocol. This protocol uses IO3:0.
                                                         1 Dual protocol. This protocol uses IO1:0.                            */
      __IO uint32_t  RFCLK      :  1;               /*!< Select active clock edge for input data. 0 Rising edge. Read
                                                         data is sampled on rising edges on the clock, as in classic
                                                          SPI operation. 1 Falling edge. Read data is sampled on falling
                                                          edges of the clock, allowing a full serial clock of of time
                                                          in order to maximize the serial clock frequency. Remark: MODE3,
                                                          RFCLK, and FBCLK should not all be 1, because in this case there
                                                          is no final falling edge on SCK on which to sample the last
                                                          data bit of the frame.                                               */
      __IO uint32_t  FBCLK      :  1;               /*!< Feedback clock select. 0 Internal clock. The SPIFI samples read
                                                         data using an internal clock. 1 Feedback clock. Read data is
                                                          sampled using a feedback clock from the SCK pin. This allows
                                                          slightly more time for each received bit. Remark: MODE3, RFCLK,
                                                          and FBCLK should not all be 1, because in this case there is
                                                          no final falling edge on SCK on which to sample the last data
                                                          bit of the frame.                                                    */
      __IO uint32_t  DMAEN      :  1;               /*!< A 1 in this bit enables the DMA Request output from the SPIFI.
                                                         Set this bit only when a DMA channel is used to transfer data
                                                          in peripheral mode. Do not set this bit when a DMA channel is
                                                          used for memory-to-memory transfers from the SPIFI memory area.
                                                          DRQEN should only be used in Command mode.                           */
    } CTRL_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CMD;                             /*!< SPIFI command register                                                */

    struct {
      __IO uint32_t  DATALEN    : 14;               /*!< Except when the POLL bit in this register is 1, this field controls
                                                         how many data bytes are in the command. 0 indicates that the
                                                          command does not contain a data field.                               */
      __IO uint32_t  POLL       :  1;               /*!< This bit should be written as 1 only with an opcode that a)
                                                         contains an input data field, and b) causes the serial flash
                                                          device to return byte status repetitively (e.g., a Read Status
                                                          command). When this bit is 1, the SPIFI hardware continues to
                                                          read bytes until the test specified by the DATALEN field is
                                                          met. The hardware tests the bit in each status byte selected
                                                          by DATALEN bits 2:0, until a bit is found that is equal to DATALEN
                                                          bit 3. When the test succeeds, the SPIFI captures the byte that
                                                          meets this te                                                        */
      __IO uint32_t  DOUT       :  1;               /*!< If the DATALEN field is not zero, this bit controls the direction
                                                         of the data: 0 Input from serial flash. 1 Output to serial flash.     */
      __IO uint32_t  INTLEN     :  3;               /*!< This field controls how many intermediate bytes precede the
                                                         data. (Each such byte may require 8 or 2 SCK cycles, depending
                                                          on whether the intermediate field is in serial, 2-bit, or 4-bit
                                                          format.) Intermediate bytes are output by the SPIFI, and include
                                                          post-address control information, dummy and delay bytes. See
                                                          the description of the Intermediate Data register for the contents
                                                          of such bytes.                                                       */
      __IO uint32_t  FIELDFORM  :  2;               /*!< This field controls how the fields of the command are sent.
                                                         0x0 All serial. All fields of the command are serial. 0x1 Quad/dual
                                                          data. Data field is quad/dual, other fields are serial. 0x2
                                                          Serial opcode. Opcode field is serial. Other fields are quad/dual.
                                                          0x3 All quad/dual. All fields of the command are in quad/dual
                                                          format.                                                              */
      __IO uint32_t  FRAMEFORM  :  3;               /*!< This field controls the opcode and address fields. 0x0 Reserved.
                                                         0x1 Opcode. Opcode only, no address. 0x2 Opcode one byte. Opcode,
                                                          least significant byte of address. 0x3 Opcode two bytes. Opcode,
                                                          two least significant bytes of address. 0x4 Opcode three bytes.
                                                          Opcode, three least significant bytes of address. 0x5 Opcode
                                                          four bytes. Opcode, 4 bytes of address. 0x6 No opcode three
                                                          bytes. No opcode, 3 least significant bytes of address. 0x7
                                                          No opcode four bytes. No opcode, 4 bytes of address.                 */
      __IO uint32_t  OPCODE     :  8;               /*!< The opcode of the command (not used for some FRAMEFORM values).       */
    } CMD_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ADDR;                            /*!< SPIFI address register                                                */

    struct {
      __IO uint32_t  ADDR       : 32;               /*!< SPIFI address register                                                */
    } ADDR_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  IDATA;                           /*!< SPIFI intermediate data register                                      */

    struct {
      __IO uint32_t  IDATA      : 32;               /*!< SPIFI intermediate data register                                      */
    } IDATA_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CLIMIT;                          /*!< SPIFI limit register                                                  */

    struct {
      __IO uint32_t  CLIMIT     : 32;               /*!< SPIFI limit register                                                  */
    } CLIMIT_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DATA;                            /*!< SPIFI data register. Input or output data                             */

    struct {
      __IO uint32_t  DATA       : 32;               /*!< SPIFI data register. Input or output data                             */
    } DATA_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MCMD;                            /*!< SPIFI memory command register                                         */

    struct {
           uint32_t             : 14;
      __IO uint32_t  POLL       :  1;               /*!< This bit should be written as 0.                                      */
      __IO uint32_t  DOUT       :  1;               /*!< This bit should be written as 0.                                      */
      __IO uint32_t  INTLEN     :  3;               /*!< This field controls how many intermediate bytes precede the
                                                         data. (Each such byte may require 8 or 2 SCK cycles, depending
                                                          on whether the intermediate field is in serial, 2-bit, or 4-bit
                                                          format.) Intermediate bytes are output by the SPIFI, and include
                                                          post-address control information, dummy and delay bytes. See
                                                          the description of the Intermediate Data register for the contents
                                                          of such bytes.                                                       */
      __IO uint32_t  FIELDFORM  :  2;               /*!< This field controls how the fields of the command are sent.
                                                         0x0 All serial. All fields of the command are serial. 0x1 Quad/dual
                                                          data. Data field is quad/dual, other fields are serial. 0x2
                                                          Serial opcode. Opcode field is serial. Other fields are quad/dual.
                                                          0x3 All quad/dual. All fields of the command are in quad/dual
                                                          format.                                                              */
      __IO uint32_t  FRAMEFORM  :  3;               /*!< This field controls the opcode and address fields. 0x0 Reserved.
                                                         0x1 Opcode. Opcode only, no address. 0x2 Opcode one byte. Opcode,
                                                          least-significant byte of address. 0x3 Opcode two bytes. Opcode,
                                                          2 least-significant bytes of address. 0x4 Opcode three bytes.
                                                          Opcode, 3 least-significant bytes of address. 0x5 Opcode four
                                                          bytes. Opcode, 4 bytes of address. 0x6 No opcode three bytes.
                                                          No opcode, 3 least-significant bytes of address. 0x7 No opcode,
                                                          4 bytes of address.                                                  */
      __IO uint32_t  OPCODE     :  8;               /*!< The opcode of the command (not used for some FRAMEFORM values).       */
    } MCMD_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STAT;                            /*!< SPIFI status register                                                 */

    struct {
      __IO uint32_t  MCINIT     :  1;               /*!< This bit is set when software successfully writes the Memory
                                                         Command register, and is cleared by Reset or by writing a 1
                                                          to the RESET bit in this register.                                   */
      __IO uint32_t  CMD        :  1;               /*!< This bit is 1 when the Command register is written. It is cleared
                                                         by a hardware reset, a write to the RESET bit in this register,
                                                          or the deassertion of CS which indicates that the command has
                                                          completed communication with the SPI Flash.                          */
           uint32_t             :  2;
      __IO uint32_t  RESET      :  1;               /*!< Write a 1 to this bit to abort a current command or memory mode.
                                                         This bit is cleared when the hardware is ready for a new command
                                                          to be written to the Command register.                               */
      __IO uint32_t  INTRQ      :  1;               /*!< This bit reflects the SPIFI interrupt request. Write a 1 to
                                                         this bit to clear it. This bit is set when a CMD was previously
                                                          1 and has been cleared due to the deassertion of CS.                 */
           uint32_t             : 18;
      __IO uint32_t  VERSION    :  8;               /*!< (null)                                                                */
    } STAT_b;                                       /*!< BitSize                                                               */
  };
} u_spifi_Type;


/* ================================================================================ */
/* ================                      u_dma                     ================ */
/* ================================================================================ */


/**
  * @brief dma (u_dma)
  */

typedef struct {                                    /*!< u_dma Structure                                                       */

  union {
    __IO uint32_t  CTRL;                            /*!< DMA control.                                                          */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< DMA controller master enable. 0 Disabled. The DMA controller
                                                         is disabled. This clears any triggers that were asserted at
                                                          the point when disabled, but does not prevent re-triggering
                                                          when the DMA controller is re-enabled. 1 Enabled. The DMA controller
                                                          is enabled.                                                          */
    } CTRL_b;                                       /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  INTSTAT;                         /*!< Interrupt status.                                                     */

    struct {
           uint32_t             :  1;
      __I  uint32_t  ACTIVEINT  :  1;               /*!< Summarizes whether any enabled interrupts (other than error
                                                         interrupts) are pending. 0 Not pending. No enabled interrupts
                                                          are pending. 1 Pending. At least one enabled interrupt is pending.   */
      __I  uint32_t  ACTIVEERRINT:  1;              /*!< Summarizes whether any error interrupts are pending. 0 Not pending.
                                                         No error interrupts are pending. 1 Pending. At least one error
                                                          interrupt is pending.                                                */
    } INTSTAT_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SRAMBASE;                        /*!< SRAM address of the channel configuration table.                      */

    struct {
           uint32_t             :  9;
      __IO uint32_t  OFFSET     : 23;               /*!< Address bits 31:9 of the beginning of the DMA descriptor table.
                                                         For 19 channels, the table must begin on a 512 byte boundary.         */
    } SRAMBASE_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[5];

  union {
    __IO uint32_t  ENABLESET0;                      /*!< Channel Enable read and Set for all DMA channels                      */

    struct {
      __IO uint32_t  ENA_CH0    :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH1    :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH2    :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH3    :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH4    :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH5    :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH6    :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH7    :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH8    :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH9    :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH10   :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH11   :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH12   :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH13   :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH14   :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH15   :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH16   :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH17   :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
      __IO uint32_t  ENA_CH18   :  1;               /*!< Enable for DMA channels. Bit n enables or disables DMA channel
                                                         n. 0 = disabled. 1 = enabled.                                         */
    } ENABLESET0_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1;

  union {
    __O  uint32_t  ENABLECLR0;                      /*!< Channel Enable Clear for all DMA channels.                            */

    struct {
      __O  uint32_t  CLR_CH0    :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH1    :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH2    :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH3    :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH4    :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH5    :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH6    :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH7    :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH8    :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH9    :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH10   :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH11   :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH12   :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH13   :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH14   :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH15   :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH16   :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH17   :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
      __O  uint32_t  CLR_CH18   :  1;               /*!< Writing ones to this register clears the corresponding bits
                                                         in ENABLESET0. Bit n clears the channel enable bit n.                 */
    } ENABLECLR0_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2;

  union {
    __I  uint32_t  ACTIVE0;                         /*!< Channel Active status for all DMA channels.                           */

    struct {
      __I  uint32_t  ACT_CH0    :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH1    :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH2    :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH3    :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH4    :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH5    :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH6    :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH7    :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH8    :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH9    :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH10   :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH11   :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH12   :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH13   :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH14   :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH15   :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH16   :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH17   :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
      __I  uint32_t  ACT_CH18   :  1;               /*!< Active flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not active. 1 = active.                                        */
    } ACTIVE0_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3;

  union {
    __I  uint32_t  BUSY0;                           /*!< Channel Busy status for all DMA channels.                             */

    struct {
      __I  uint32_t  BSY_CH0    :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH1    :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH2    :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH3    :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH4    :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH5    :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH6    :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH7    :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH8    :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH9    :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH10   :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH11   :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH12   :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH13   :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH14   :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH15   :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH16   :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH17   :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
      __I  uint32_t  BSY_CH18   :  1;               /*!< Busy flag for DMA channel n. Bit n corresponds to DMA channel
                                                         n. 0 = not busy. 1 = busy.                                            */
    } BUSY0_b;                                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4;

  union {
    __IO uint32_t  ERRINT0;                         /*!< Error Interrupt status for all DMA channels.                          */

    struct {
      __IO uint32_t  ERR_CH0    :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH1    :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH2    :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH3    :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH4    :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH5    :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH6    :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH7    :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH8    :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH9    :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH10   :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH11   :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH12   :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH13   :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH14   :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH15   :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH16   :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH17   :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
      __IO uint32_t  ERR_CH18   :  1;               /*!< Error Interrupt flag for DMA channel n. Bit n corresponds to
                                                         DMA channel n. 0 = error interrupt is not active. 1 = error
                                                          interrupt is active.                                                 */
    } ERRINT0_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5;

  union {
    __IO uint32_t  INTENSET0;                       /*!< Interrupt Enable read and Set for all DMA channels.                   */

    struct {
      __IO uint32_t  INTEN_CH0  :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH1  :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH2  :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH3  :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH4  :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH5  :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH6  :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH7  :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH8  :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH9  :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH10 :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH11 :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH12 :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH13 :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH14 :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH15 :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH16 :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH17 :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
      __IO uint32_t  INTEN_CH18 :  1;               /*!< Interrupt Enable read and set for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = interrupt for DMA channel is disabled.
                                                          1 = interrupt for DMA channel is enabled.                            */
    } INTENSET0_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6;

  union {
    __O  uint32_t  INTENCLR0;                       /*!< Interrupt Enable Clear for all DMA channels.                          */

    struct {
      __O  uint32_t  CLR_CH0    :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH1    :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH2    :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH3    :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH4    :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH5    :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH6    :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH7    :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH8    :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH9    :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH10   :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH11   :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH12   :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH13   :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH14   :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH15   :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH16   :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH17   :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
      __O  uint32_t  CLR_CH18   :  1;               /*!< Writing ones to this register clears corresponding bits in the
                                                         INTENSET0. Bit n corresponds to DMA channel n.                        */
    } INTENCLR0_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7;

  union {
    __IO uint32_t  INTA0;                           /*!< Interrupt A status for all DMA channels.                              */

    struct {
      __IO uint32_t  IA_CH0     :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH1     :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH2     :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH3     :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH4     :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH5     :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH6     :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH7     :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH8     :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH9     :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH10    :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH11    :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH12    :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH13    :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH14    :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH15    :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH16    :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH17    :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
      __IO uint32_t  IA_CH18    :  1;               /*!< Interrupt A status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt A is not active. 1
                                                          = the DMA channel interrupt A is active.                             */
    } INTA0_b;                                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED8;

  union {
    __IO uint32_t  INTB0;                           /*!< Interrupt B status for all DMA channels.                              */

    struct {
      __IO uint32_t  IB_CH0     :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH1     :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH2     :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH3     :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH4     :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH5     :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH6     :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH7     :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH8     :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH9     :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH10    :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH11    :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH12    :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH13    :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH14    :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH15    :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH16    :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH17    :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
      __IO uint32_t  IB_CH18    :  1;               /*!< Interrupt B status for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = the DMA channel interrupt B is not active. 1
                                                          = the DMA channel interrupt B is active.                             */
    } INTB0_b;                                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED9;

  union {
    __O  uint32_t  SETVALID0;                       /*!< Set ValidPending control bits for all DMA channels.                   */

    struct {
      __O  uint32_t  SV_CH0     :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH1     :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH2     :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH3     :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH4     :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH5     :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH6     :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH7     :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH8     :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH9     :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH10    :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH11    :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH12    :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH13    :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH14    :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH15    :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH16    :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH17    :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
      __O  uint32_t  SV_CH18    :  1;               /*!< SETVALID control for DMA channel n. Bit n corresponds to DMA
                                                         channel n. 0 = no effect. 1 = sets the VALIDPENDING control
                                                          bit for DMA channel n                                                */
    } SETVALID0_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED10;

  union {
    __O  uint32_t  SETTRIG0;                        /*!< Set Trigger control bits for all DMA channels.                        */

    struct {
      __O  uint32_t  TRIG_CH0   :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH1   :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH2   :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH3   :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH4   :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH5   :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH6   :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH7   :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH8   :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH9   :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH10  :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH11  :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH12  :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH13  :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH14  :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH15  :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH16  :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH17  :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
      __O  uint32_t  TRIG_CH18  :  1;               /*!< Set Trigger control bit for DMA channel n. Bit n corresponds
                                                         to DMA channel n. 0 = no effect. 1 = sets the TRIG bit for DMA
                                                          channel n.                                                           */
    } SETTRIG0_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED11;

  union {
    __O  uint32_t  ABORT0;                          /*!< Channel Abort control for all DMA channels.                           */

    struct {
      __O  uint32_t  ABORTCTRL_CH0:  1;             /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH1:  1;             /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH2:  1;             /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH3:  1;             /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH4:  1;             /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH5:  1;             /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH6:  1;             /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH7:  1;             /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH8:  1;             /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH9:  1;             /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH10:  1;            /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH11:  1;            /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH12:  1;            /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH13:  1;            /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH14:  1;            /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH15:  1;            /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH16:  1;            /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH17:  1;            /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
      __O  uint32_t  ABORTCTRL_CH18:  1;            /*!< Abort control for DMA channel 0. Bit n corresponds to DMA channel
                                                         n. 0 = no effect. 1 = aborts DMA operations on channel n.             */
    } ABORT0_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED12[225];
  u_dma_Channel_Type Regs_Channel[19];                   /*!< No description available                                              */
} u_dma_Type;


/* ================================================================================ */
/* ================                    u_aes256                    ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component aes256 It is AES 128-192-256 with GCM mode. More details will follow. (u_aes256)
  */

typedef struct {                                    /*!< u_aes256 Structure                                                    */

  union {
    __IO uint32_t  CFG;                             /*!< Configuration                                                         */

    struct {
      __IO uint32_t  PROC_EN    :  2;               /*!< 00 Reserved 01 Encrypt/Decrypt Only 10 GF128 Hash Only 11 Encrypt/Decrypt
                                                         and Hash                                                              */
      __IO uint32_t  GF128_SEL  :  1;               /*!< 0 GF128 Hash Input Text 1 GF128 Hash Output Text                      */
           uint32_t             :  1;
      __IO uint32_t  INT_BSWAP  :  1;               /*!< Input Text Byte Swap                                                  */
      __IO uint32_t  INT_WSWAP  :  1;               /*!< Input Text Word Swap                                                  */
      __IO uint32_t  OUTT_BSWAP :  1;               /*!< Output Text Byte Swap                                                 */
      __IO uint32_t  OUTT_WSWAP :  1;               /*!< Output Text Word Swap                                                 */
      __IO uint32_t  KEY_CFG    :  2;               /*!< 00 128 Bit Key 01 192 Bit Key 10 256 Bit Key 11 Reserved              */
           uint32_t             :  6;
      __IO uint32_t  INB_FSEL   :  2;               /*!< Input Block Selection From: 00 Reserved 01 Input Text 10 Holding
                                                         11 Input Text XOR Holding                                             */
           uint32_t             :  2;
      __IO uint32_t  HOLD_FSEL  :  2;               /*!< Holding Select From: 00 Counter 01 Input Text 10 Output Block
                                                         11 Input Text XOR Output Block                                        */
           uint32_t             :  2;
      __IO uint32_t  OUTT_FSEL  :  2;               /*!< Output Text Selection From: 00 Output Block 01 Output Block
                                                         XOR Input Text 10 Output Block XOR Holding 11 Reserved                */
    } CFG_b;                                        /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  CMD;                             /*!< Command                                                               */

    struct {
      __O  uint32_t  COPY_SKEY  :  1;               /*!< Copies Secret Key and enables cipher. Secret key is typically
                                                         held in OTP or other secure memory.                                   */
      __O  uint32_t  COPY_TO_Y  :  1;               /*!< Copies Output Text to GF128 Y. Typically used for GCM where
                                                         the Hash requires a Y input which is the result of an ECB encryption
                                                          of 0s. Should be performed after encryption of 0s.                   */
           uint32_t             :  2;
      __O  uint32_t  SWITCH_MODE:  1;               /*!< Switches mode from Forward to Reverse or from Reverse to Forward.
                                                         Must wait for Idle after command. Typically used for non-counter
                                                          modes (ECB, CBC, CFB, OFB) to switch from forward to reverse
                                                          mode for decryption.                                                 */
           uint32_t             :  3;
      __O  uint32_t  ABORT      :  1;               /*!< Aborts Encrypt/Decrypt and GF128 Hash Clears INTEXT Clears OUTTEXT
                                                         Clears HOLDING                                                        */
      __O  uint32_t  WIPE       :  1;               /*!< Performs Abort Clears KEY Disables cipher Clears GF128_Y              */
    } CMD_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  STAT;                            /*!< Status                                                                */

    struct {
      __I  uint32_t  IDLE       :  1;               /*!< All state machines are idle                                           */
      __I  uint32_t  IN_READY   :  1;               /*!< Input Text can be written                                             */
      __I  uint32_t  OUT_READY  :  1;               /*!< Output Text can be read                                               */
           uint32_t             :  1;
      __I  uint32_t  REVERSE    :  1;               /*!< Cipher in reverse mode                                                */
      __I  uint32_t  KEY_VALID  :  1;               /*!< Key is valid                                                          */
    } STAT_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CTR_INCR;                        /*!< Counter Increment. Increment value for HOLDING when in Counter
                                                         modes                                                                 */

    struct {
      __IO uint32_t  CTR_INCR   : 32;               /*!< Counter Increment. Increment value for HOLDING when in Counter
                                                         modes                                                                 */
    } CTR_INCR_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[4];

  union {
    __O  uint32_t  KEY0;                            /*!< Key [31:0]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */

    struct {
      __O  uint32_t  KEY0       : 32;               /*!< Key [31:0]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */
    } KEY0_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  KEY1;                            /*!< Key [63:32]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */

    struct {
      __O  uint32_t  KEY1       : 32;               /*!< Key [63:32]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */
    } KEY1_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  KEY2;                            /*!< Key [95:64]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */

    struct {
      __O  uint32_t  KEY2       : 32;               /*!< Key [95:64]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */
    } KEY2_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  KEY3;                            /*!< Key [127:96]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */

    struct {
      __O  uint32_t  KEY3       : 32;               /*!< Key [127:96]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */
    } KEY3_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  KEY4;                            /*!< Key [159:128]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */

    struct {
      __O  uint32_t  KEY4       : 32;               /*!< Key [159:128]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */
    } KEY4_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  KEY5;                            /*!< Key [191:160]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */

    struct {
      __O  uint32_t  KEY5       : 32;               /*!< Key [191:160]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */
    } KEY5_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  KEY6;                            /*!< Key [223:192]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */

    struct {
      __O  uint32_t  KEY6       : 32;               /*!< Key [223:192]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */
    } KEY6_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  KEY7;                            /*!< Key [255:224]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */

    struct {
      __O  uint32_t  KEY7       : 32;               /*!< Key [255:224]. The key will be enabled by writing sequentially
                                                         KEY0, KEY1, KEY2,                                                     */
    } KEY7_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  IN0;                             /*!< Input Text [31:0]. Contains the input data for processing. Typically
                                                         holds plaintext when encrypting and ciphertext when decrypting        */

    struct {
      __O  uint32_t  IN0        : 32;               /*!< Input Text [31:0]. Contains the input data for processing. Typically
                                                         holds plaintext when encrypting and ciphertext when decrypting        */
    } IN0_b;                                        /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  IN1;                             /*!< Input Text [63:32]. Contains the input data for processing.
                                                         Typically holds plaintext when encrypting and ciphertext when
                                                          decrypting                                                           */

    struct {
      __O  uint32_t  IN1        : 32;               /*!< Input Text [63:32]. Contains the input data for processing.
                                                         Typically holds plaintext when encrypting and ciphertext when
                                                          decrypting                                                           */
    } IN1_b;                                        /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  IN2;                             /*!< Input Text [95:64]. Contains the input data for processing.
                                                         Typically holds plaintext when encrypting and ciphertext when
                                                          decrypting                                                           */

    struct {
      __O  uint32_t  IN2        : 32;               /*!< Input Text [95:64]. Contains the input data for processing.
                                                         Typically holds plaintext when encrypting and ciphertext when
                                                          decrypting                                                           */
    } IN2_b;                                        /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  IN3;                             /*!< Input Text [127:96]. Contains the input data for processing.
                                                         Typically holds plaintext when encrypting and ciphertext when
                                                          decrypting                                                           */

    struct {
      __O  uint32_t  IN3        : 32;               /*!< Input Text [127:96]. Contains the input data for processing.
                                                         Typically holds plaintext when encrypting and ciphertext when
                                                          decrypting                                                           */
    } IN3_b;                                        /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  HOLDING0;                        /*!< Holding [31:0]. Temporary storage used for processing. Begins
                                                         with Initialization Vector (IV).                                      */

    struct {
      __O  uint32_t  HOLDING0   : 32;               /*!< Holding [31:0]. Temporary storage used for processing. Begins
                                                         with Initialization Vector (IV).                                      */
    } HOLDING0_b;                                   /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  HOLDING1;                        /*!< Holding [63:32]. Temporary storage used for processing. Begins
                                                         with Initialization Vector (IV).                                      */

    struct {
      __O  uint32_t  HOLDING1   : 32;               /*!< Holding [63:32]. Temporary storage used for processing. Begins
                                                         with Initialization Vector (IV).                                      */
    } HOLDING1_b;                                   /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  HOLDING2;                        /*!< Holding [95:64]. Temporary storage used for processing. Begins
                                                         with Initialization Vector (IV).                                      */

    struct {
      __O  uint32_t  HOLDING2   : 32;               /*!< Holding [95:64]. Temporary storage used for processing. Begins
                                                         with Initialization Vector (IV).                                      */
    } HOLDING2_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  HOLDING3;                        /*!< Holding [127:96]. Temporary storage used for processing. Begins
                                                         with Initialization Vector (IV).                                      */

    struct {
      __IO uint32_t  HOLDING3   : 32;               /*!< Holding [127:96]. Temporary storage used for processing. Begins
                                                         with Initialization Vector (IV).                                      */
    } HOLDING3_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  OUT0;                            /*!< Output Text [31:0]. Contains the output data from processing.
                                                         Typically holds ciphertext when encrypting and plaintext when
                                                          decrypting.                                                          */

    struct {
      __I  uint32_t  OUT0       : 32;               /*!< Output Text [31:0]. Contains the output data from processing.
                                                         Typically holds ciphertext when encrypting and plaintext when
                                                          decrypting.                                                          */
    } OUT0_b;                                       /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  OUT1;                            /*!< Output Text [63:32]. Contains the output data from processing.
                                                         Typically holds ciphertext when encrypting and plaintext when
                                                          decrypting.                                                          */

    struct {
      __I  uint32_t  OUT1       : 32;               /*!< Output Text [63:32]. Contains the output data from processing.
                                                         Typically holds ciphertext when encrypting and plaintext when
                                                          decrypting.                                                          */
    } OUT1_b;                                       /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  OUT2;                            /*!< Output Text [95:64]. Contains the output data from processing.
                                                         Typically holds ciphertext when encrypting and plaintext when
                                                          decrypting.                                                          */

    struct {
      __I  uint32_t  OUT2       : 32;               /*!< Output Text [95:64]. Contains the output data from processing.
                                                         Typically holds ciphertext when encrypting and plaintext when
                                                          decrypting.                                                          */
    } OUT2_b;                                       /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  OUT3;                            /*!< Output Text [127:96]. Contains the output data from processing.
                                                         Typically holds ciphertext when encrypting and plaintext when
                                                          decrypting.                                                          */

    struct {
      __I  uint32_t  OUT3       : 32;               /*!< Output Text [127:96]. Contains the output data from processing.
                                                         Typically holds ciphertext when encrypting and plaintext when
                                                          decrypting.                                                          */
    } OUT3_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  GF128_Y0;                        /*!< GF128 Y [31:0]. Contains Y input of GF128 hash.                       */

    struct {
      __O  uint32_t  GF128_Y0   : 32;               /*!< GF128 Y [31:0]. Contains Y input of GF128 hash.                       */
    } GF128_Y0_b;                                   /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  GF128_Y1;                        /*!< GF128 Y [63:32]. Contains Y input of GF128 hash.                      */

    struct {
      __O  uint32_t  GF128_Y1   : 32;               /*!< GF128 Y [63:32]. Contains Y input of GF128 hash.                      */
    } GF128_Y1_b;                                   /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  GF128_Y2;                        /*!< GF128 Y [95:64]. Contains Y input of GF128 hash.                      */

    struct {
      __O  uint32_t  GF128_Y2   : 32;               /*!< GF128 Y [95:64]. Contains Y input of GF128 hash.                      */
    } GF128_Y2_b;                                   /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  GF128_Y3;                        /*!< GF128 Y [127:96]. Contains Y input of GF128 hash.                     */

    struct {
      __O  uint32_t  GF128_Y3   : 32;               /*!< GF128 Y [127:96]. Contains Y input of GF128 hash.                     */
    } GF128_Y3_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  GF128_Z0;                        /*!< GF128 Z [31:0]. Holds the results of the GF-128 hash. Used in
                                                         GCM modes for authentication.                                         */

    struct {
      __I  uint32_t  GF128_Z0   : 32;               /*!< GF128 Z [31:0]. Holds the results of the GF-128 hash. Used in
                                                         GCM modes for authentication.                                         */
    } GF128_Z0_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  GF128_Z1;                        /*!< GF128 Z [63:32]. Holds the results of the GF-128 hash. Used
                                                         in GCM modes for authentication.                                      */

    struct {
      __I  uint32_t  GF128_Z1   : 32;               /*!< GF128 Z [63:32]. Holds the results of the GF-128 hash. Used
                                                         in GCM modes for authentication.                                      */
    } GF128_Z1_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  GF128_Z2;                        /*!< GF128 Z [95:64]. Holds the results of the GF-128 hash. Used
                                                         in GCM modes for authentication.                                      */

    struct {
      __I  uint32_t  GF128_Z2   : 32;               /*!< GF128 Z [95:64]. Holds the results of the GF-128 hash. Used
                                                         in GCM modes for authentication.                                      */
    } GF128_Z2_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  GF128_Z3;                        /*!< GF128 Z [127:96]. Holds the results of the GF-128 hash. Used
                                                         in GCM modes for authentication.                                      */

    struct {
      __I  uint32_t  GF128_Z3   : 32;               /*!< GF128 Z [127:96]. Holds the results of the GF-128 hash. Used
                                                         in GCM modes for authentication.                                      */
    } GF128_Z3_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  GCM_TAG0;                        /*!< GCM Tag [31:0]. Calculated by XORing Output Text and GF128 Z.         */

    struct {
      __I  uint32_t  GCM_TAG0   : 32;               /*!< GCM Tag [31:0]. Calculated by XORing Output Text and GF128 Z.         */
    } GCM_TAG0_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  GCM_TAG1;                        /*!< GCM Tag [63:32]. Calculated by XORing Output Text and GF128
                                                         Z.                                                                    */

    struct {
      __I  uint32_t  GCM_TAG1   : 32;               /*!< GCM Tag [63:32]. Calculated by XORing Output Text and GF128
                                                         Z.                                                                    */
    } GCM_TAG1_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  GCM_TAG2;                        /*!< GCM Tag [95:64]. Calculated by XORing Output Text and GF128
                                                         Z.                                                                    */

    struct {
      __I  uint32_t  GCM_TAG2   : 32;               /*!< GCM Tag [95:64]. Calculated by XORing Output Text and GF128
                                                         Z.                                                                    */
    } GCM_TAG2_b;                                   /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  GCM_TAG3;                        /*!< GCM Tag [127:96]. Calculated by XORing Output Text and GF128
                                                         Z.                                                                    */

    struct {
      __I  uint32_t  GCM_TAG3   : 32;               /*!< GCM Tag [127:96]. Calculated by XORing Output Text and GF128
                                                         Z.                                                                    */
    } GCM_TAG3_b;                                   /*!< BitSize                                                               */
  };
} u_aes256_Type;


/* ================================================================================ */
/* ================                    u_mailbox                   ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component mailbox It is a Mailbox for inter CPU communication with AHB bus interface. More details will follow. (u_mailbox)
  */

typedef struct {                                    /*!< u_mailbox Structure                                                   */

  union {
    __IO uint32_t  IRQ0;                            /*!< Interrupt request register for the Cortex-M4 0 CPU.                   */

    struct {
      __IO uint32_t  INTREQ0    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ1    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ2    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ3    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ4    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ5    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ6    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ7    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ8    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ9    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ10   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ11   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ12   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ13   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ14   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ15   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ16   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ17   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ18   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ19   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ20   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ21   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ22   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ23   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ24   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ25   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ26   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ27   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ28   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ29   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ30   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
      __IO uint32_t  INTREQ31   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         1 interrupt controller.                                               */
    } IRQ0_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  IRQ0SET;                         /*!< Set bits in IRQ0                                                      */

    struct {
      __O  uint32_t  INTREQSET0 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET1 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET2 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET3 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET4 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET5 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET6 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET7 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET8 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET9 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET10:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET11:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET12:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET13:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET14:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET15:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET16:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET17:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET18:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET19:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET20:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET21:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET22:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET23:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET24:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET25:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET26:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET27:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET28:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET29:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET30:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
      __O  uint32_t  INTREQSET31:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ0 register.            */
    } IRQ0SET_b;                                    /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  IRQ0CLR;                         /*!< Clear bits in IRQ0                                                    */

    struct {
      __O  uint32_t  INTREQCLR0 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR1 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR2 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR3 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR4 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR5 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR6 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR7 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR8 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR9 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR10:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR11:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR12:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR13:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR14:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR15:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR16:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR17:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR18:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR19:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR20:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR21:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR22:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR23:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR24:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR25:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR26:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR27:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR28:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR29:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR30:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
      __O  uint32_t  INTREQCLR31:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ0 register.          */
    } IRQ0CLR_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0;

  union {
    __IO uint32_t  IRQ1;                            /*!< Interrupt request register for the Cortex-M4 1 CPU.                   */

    struct {
      __IO uint32_t  INTREQ0    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ1    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ2    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ3    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ4    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ5    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ6    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ7    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ8    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ9    :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ10   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ11   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ12   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ13   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ14   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ15   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ16   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ17   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ18   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ19   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ20   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ21   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ22   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ23   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ24   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ25   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ26   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ27   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ28   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ29   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ30   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
      __IO uint32_t  INTREQ31   :  1;               /*!< If any bit is set, an interrupt request is sent to the Cortex-M4
                                                         0 interrupt controller.                                               */
    } IRQ1_b;                                       /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  IRQ1SET;                         /*!< Set bits in IRQ1                                                      */

    struct {
      __O  uint32_t  INTREQSET0 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET1 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET2 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET3 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET4 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET5 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET6 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET7 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET8 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET9 :  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET10:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET11:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET12:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET13:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET14:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET15:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET16:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET17:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET18:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET19:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET20:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET21:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET22:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET23:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET24:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET25:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET26:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET27:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET28:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET29:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET30:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
      __O  uint32_t  INTREQSET31:  1;               /*!< Writing 1 sets the corresponding bit in the IRQ1 register.            */
    } IRQ1SET_b;                                    /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  IRQ1CLR;                         /*!< Clear bits in IRQ1                                                    */

    struct {
      __O  uint32_t  INTREQCLR0 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR1 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR2 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR3 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR4 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR5 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR6 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR7 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR8 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR9 :  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR10:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR11:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR12:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR13:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR14:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR15:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR16:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR17:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR18:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR19:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR20:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR21:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR22:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR23:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR24:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR25:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR26:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR27:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR28:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR29:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR30:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
      __O  uint32_t  INTREQCLR31:  1;               /*!< Writing 1 clears the corresponding bit in the IRQ1 register.          */
    } IRQ1CLR_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[55];

  union {
    __IO uint32_t  MUTEX;                           /*!< Mutual exclusion register                                             */

    struct {
      __IO uint32_t  EX         :  1;               /*!< Cleared when read, set when written. This register provides
                                                         an Inter-Processor Communication handshake. When read for any
                                                          reason, the current value will be returned and the bit will
                                                          be cleared. The bit will be set again following any write.           */
    } MUTEX_b;                                      /*!< BitSize                                                               */
  };
} u_mailbox_Type;


/* ================================================================================ */
/* ================                      u_adc                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component adc It is General Purpose ADC. More details will follow. (u_adc)
  */

typedef struct {                                    /*!< u_adc Structure                                                       */

  union {
    __IO uint32_t  CTRL;                            /*!< ADC Control register. Contains the clock divide value, resolution
                                                         selection, sampling time selection, and mode controls.                */

    struct {
      __IO uint32_t  CLKDIV     :  8;               /*!< In synchronous mode only, the system clock is divided by this
                                                         value plus one to produce the clock for the ADC converter, which
                                                          should be less than or equal to 4 MHz. (default value base on
                                                          32MHz system clock) Typically, software should program the smallest
                                                          value in this field that yields this maximum clock rate or slightly
                                                          less, but in certain cases (such as a high-impedance analog
                                                          source) a slower clock may be desirable. Remark: This field
                                                          is ignored in the asynchronous operating mode.                       */
      __IO uint32_t  ASYNMODE   :  1;               /*!< Select clock mode. 0 Synchronous mode. The ADC clock is derived
                                                         from the system clock based on the divide value selected in
                                                          the CLKDIV field. The ADC clock will be started in a controlled
                                                          fashion in response to a trigger to eliminate any uncertainty
                                                          in the launching of an ADC conversion in response to any synchronous
                                                          (on-chip) trigger. In Synchronous mode with the SYNCBYPASS bit
                                                          (in a sequence control register) set, sampling of the ADC input
                                                          and start of conversion will initiate 2 system clocks after
                                                          the l                                                                */
      __IO uint32_t  RESOL      :  2;               /*!< The number of bits of ADC resolution. Accuracy can be reduced
                                                         to achieve higher conversion rates. A single conversion (including
                                                          one conversion in a burst or sequence) requires the selected
                                                          number of bits of resolution plus 3 ADC clocks. Remark: This
                                                          field must only be altered when the ADC is fully idle. Changing
                                                          it during any kind of ADC operation may have unpredictable results.
                                                          Remark: ADC clock frequencies for various resolutions must not
                                                          exceed: - 5x the system clock rate for 12-bit resolution - 4.3x
                                                          t                                                                    */
      __IO uint32_t  RESOL_MASK_DIS:  1;            /*!< According RESOL bit LSB bits are automatickly masked if RESOL_MASK_DIS
                                                         = 0. If RESOL_MASK_DIS = 1, the 12bits comming from ADC are
                                                          directly connect to register RESULT                                  */
      __IO uint32_t  TSAMP      :  3;               /*!< Sample Time. The default sampling period (TSAMP = 000 ) at the
                                                         start of each conversion is 2.5 ADC clock periods. Depending
                                                          on a variety of factors, including operating conditions and
                                                          the output impedance of the analog source, longer sampling times
                                                          may be required. The TSAMP field specifies the number of additional
                                                          ADC clock cycles, from zero to seven, by which the sample period
                                                          will be extended. The total conversion time will increase by
                                                          the same number of clocks. 000 - The sample period will be the
                                                          defau                                                                */
    } CTRL_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INSEL;                           /*!< Input Select. Allows selection input to ADC channel X.                */

    struct {
      __IO uint32_t  INSEL      : 32;               /*!< Input Select. Allows selection input to ADC channel X.                */
    } INSEL_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SEQA_CTRL;                       /*!< ADC Conversion Sequence-A control register: Controls triggering
                                                         and channel selection for conversion sequence-A. Also specifies
                                                          interrupt mode for sequence-A.                                       */

    struct {
      __IO uint32_t  CHANNELS   :  8;               /*!< Selects which one or more of the ADC channels will be sampled
                                                         and converted when this sequence is launched. A 1 in any bit
                                                          of this field will cause the corresponding channel to be included
                                                          in the conversion sequence, where bit 0 corresponds to channel
                                                          0, bit 1 to channel 1 and so forth. When this conversion sequence
                                                          is triggered, either by a hardware trigger or via software command,
                                                          ADC conversions will be performed on each enabled channel, in
                                                          sequence, beginning with the lowest-ordered channel. Remark:
                                                          Th                                                                   */
           uint32_t             :  4;
      __IO uint32_t  TRIGGER    :  6;               /*!< Selects which of the available hardware trigger sources will
                                                         cause this conversion sequence to be initiated. Program the
                                                          trigger input number in this field. See 0 : PINT0 1 : PWM8 2
                                                          : PWM9 3 : ARM TX EV Remark: In order to avoid generating a
                                                          spurious trigger, it is recommended writing to this field only
                                                          when SEQA_ENA (bit 31) is low. It is safe to change this field
                                                          and set bit 31 in the same write.                                    */
      __IO uint32_t  TRIGPOL    :  1;               /*!< Select the polarity of the selected input trigger for this conversion
                                                         sequence. Remark: In order to avoid generating a spurious trigger,
                                                          it is recommended writing to this field only when SEQA_ENA (bit
                                                          31) is low. It is safe to change this field and set bit 31 in
                                                          the same write. 0 Negative edge. A negative edge launches the
                                                          conversion sequence on the selected trigger input. 1 Positive
                                                          edge. A positive edge launches the conversion sequence on the
                                                          selected trigger input.                                              */
      __IO uint32_t  SYNCBYPASS :  1;               /*!< Setting this bit allows the hardware trigger input to bypass
                                                         synchronization flip-flop stages and therefore shorten the time
                                                          between the trigger input signal and the start of a conversion.
                                                          There are slightly different criteria for whether or not this
                                                          bit can be set depending on the clock operating mode: Synchronous
                                                          mode (the ASYNMODE in the CTRL register = 0): Synchronization
                                                          may be bypassed (this bit may be set) if the selected trigger
                                                          source is already synchronous with the main system clock (eg.
                                                          coming f                                                             */
           uint32_t             :  5;
      __IO uint32_t  START_BEHAVIOUR:  1;           /*!< the Start behavior used on gpadc, writing 0 for repeat start
                                                         after each inselection changed, writing 1 for continuous start
                                                          Remark: with 1 the word rate is divided by two.                      */
      __O  uint32_t  START      :  1;               /*!< Writing a 1 to this field will launch one pass through this
                                                         conversion sequence. The behavior will be identical to a sequence
                                                          triggered by a hardware trigger. Do not write 1 to this bit
                                                          if the BURST bit is set. Remark: This bit is only set to a 1
                                                          momentarily when written to launch a conversion sequence. It
                                                          will consequently always read back as a zero.                        */
      __IO uint32_t  BURST      :  1;               /*!< Writing a 1 to this bit will cause this conversion sequence
                                                         to be continuously cycled through. Other sequence A triggers
                                                          will be ignored while this bit is set. Repeated conversions
                                                          can be halted by clearing this bit. The sequence currently in
                                                          progress will be completed before conversions are terminated.
                                                          Note that a new sequence could begin just before BURST is cleared.   */
      __IO uint32_t  SINGLESTEP :  1;               /*!< When this bit is set, a hardware trigger or a write to the START
                                                         bit will launch a single conversion on the next channel in the
                                                          sequence instead of the default response of launching an entire
                                                          sequence of conversions. Once all of the channels comprising
                                                          a sequence have been converted, a subsequent trigger will repeat
                                                          the sequence beginning with the first enabled channel. Interrupt
                                                          generation will still occur either after each individual conversion
                                                          or at the end of the entire sequence, depending on the state         */
      __IO uint32_t  LOWPRIO    :  1;               /*!< Set priority for sequence A. 0 Low priority. Any B trigger which
                                                         occurs while an A conversion sequence is active will be ignored
                                                          and lost. 1 High priority. Setting this bit to a 1 will permit
                                                          any enabled B sequence trigger (including a B sequence software
                                                          start) to immediately interrupt sequence A and launch a B sequence
                                                          in it s place. The conversion currently in progress will be
                                                          terminated. The A sequence that was interrupted will automatically
                                                          resume after the B sequence completes. The channel whose conv        */
      __IO uint32_t  MODE       :  1;               /*!< Indicates whether the primary method for retrieving conversion
                                                         results for this sequence will be accomplished via reading the
                                                          global data register (SEQA_GDAT) at the end of each conversion,
                                                          or the individual channel result registers at the end of the
                                                          entire sequence. Impacts when conversion-complete interrupt/DMA
                                                          trigger for sequence-A will be generated and which overrun conditions
                                                          contribute to an overrun interrupt as described below. 0 End
                                                          of conversion. The sequence A interrupt/DMA trigger will be
                                                          set a                                                                */
      __IO uint32_t  SEQA_ENA   :  1;               /*!< Sequence Enable. In order to avoid spuriously triggering the
                                                         sequence, care should be taken to only set the SEQA_ENA bit
                                                          when the selected trigger input is in its INACTIVE state (as
                                                          defined by the TRIGPOL bit). If this condition is not met, the
                                                          sequence will be triggered immediately upon being enabled. Remark:
                                                          In order to avoid spuriously triggering the sequence, care should
                                                          be taken to only set the SEQA_ENA bit when the selected trigger
                                                          input is in its INACTIVE state (as defined by the TRIGPOL bit).
                                                          If th                                                                */
    } SEQA_CTRL_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  SEQB_CTRL;                       /*!< ADC Conversion Sequence-B Control register: Controls triggering
                                                         and channel selection for conversion sequence-B. Also specifies
                                                          interrupt mode for sequence-B.                                       */

    struct {
      __IO uint32_t  CHANNELS   :  8;               /*!< Selects which one or more of the ADC channels will be sampled
                                                         and converted when this sequence is launched. A 1 in any bit
                                                          of this field will cause the corresponding channel to be included
                                                          in the conversion sequence, where bit 0 corresponds to channel
                                                          0, bit 1 to channel 1 and so forth. When this conversion sequence
                                                          is triggered, either by a hardware trigger or via software command,
                                                          ADC conversions will be performed on each enabled channel, in
                                                          sequence, beginning with the lowest-ordered channel. Remark:
                                                          Th                                                                   */
           uint32_t             :  4;
      __IO uint32_t  TRIGGER    :  6;               /*!< Selects which of the available hardware trigger sources will
                                                         cause this conversion sequence to be initiated. Program the
                                                          trigger input number in this field. See 0 : PINT0 1 : PWM8 2
                                                          : PWM9 3 : ARM TX EV Remark: In order to avoid generating a
                                                          spurious trigger, it is recommended writing to this field only
                                                          when SEQB_ENA (bit 31) is low. It is safe to change this field
                                                          and set bit 31 in the same write.                                    */
      __IO uint32_t  TRIGPOL    :  1;               /*!< Select the polarity of the selected input trigger for this conversion
                                                         sequence. Remark: In order to avoid generating a spurious trigger,
                                                          it is recommended writing to this field only when SEQB_ENA (bit
                                                          31) is low. It is safe to change this field and set bit 31 in
                                                          the same write. 0 Negative edge. A negative edge launches the
                                                          conversion sequence on the selected trigger input. 1 Positive
                                                          edge. A positive edge launches the conversion sequence on the
                                                          selected trigger input.                                              */
      __IO uint32_t  SYNCBYPASS :  1;               /*!< Setting this bit allows the hardware trigger input to bypass
                                                         synchronization flip-flop stages and therefore shorten the time
                                                          between the trigger input signal and the start of a conversion.
                                                          There are slightly different criteria for whether or not this
                                                          bit can be set depending on the clock operating mode: Synchronous
                                                          mode (the ASYNMODE in the CTRL register = 0): Synchronization
                                                          may be bypassed (this bit may be set) if the selected trigger
                                                          source is already synchronous with the main system clock (eg.
                                                          coming f                                                             */
           uint32_t             :  5;
      __IO uint32_t  START_BEHAVIOUR:  1;           /*!< the Start behavior used on gpadc, writing 0 for repeat start
                                                         after each inselection changed, writing 1 for continuous start
                                                          Remark: with 1 the word rate is divided by two.                      */
      __O  uint32_t  START      :  1;               /*!< Writing a 1 to this field will launch one pass through this
                                                         conversion sequence. The behavior will be identical to a sequence
                                                          triggered by a hardware trigger. Do not write 1 to this bit
                                                          if the BURST bit is set. Remark: This bit is only set to a 1
                                                          momentarily when written to launch a conversion sequence. It
                                                          will consequently always read back as a zero.                        */
      __IO uint32_t  BURST      :  1;               /*!< Writing a 1 to this bit will cause this conversion sequence
                                                         to be continuously cycled through. Other sequence A triggers
                                                          will be ignored while this bit is set. Repeated conversions
                                                          can be halted by clearing this bit. The sequence currently in
                                                          progress will be completed before conversions are terminated.
                                                          Note that a new sequence could begin just before BURST is cleared.   */
      __IO uint32_t  SINGLESTEP :  1;               /*!< When this bit is set, a hardware trigger or a write to the START
                                                         bit will launch a single conversion on the next channel in the
                                                          sequence instead of the default response of launching an entire
                                                          sequence of conversions. Once all of the channels comprising
                                                          a sequence have been converted, a subsequent trigger will repeat
                                                          the sequence beginning with the first enabled channel. Interrupt
                                                          generation will still occur either after each individual conversion
                                                          or at the end of the entire sequence, depending on the state         */
           uint32_t             :  1;
      __IO uint32_t  MODE       :  1;               /*!< Indicates whether the primary method for retrieving conversion
                                                         results for this sequence will be accomplished via reading the
                                                          global data register (SEQB_GDAT) at the end of each conversion,
                                                          or the individual channel result registers at the end of the
                                                          entire sequence. Impacts when conversion-complete interrupt/DMA
                                                          trigger for sequence-A will be generated and which overrun conditions
                                                          contribute to an overrun interrupt as described below. 0 End
                                                          of conversion. The sequence A interrupt/DMA trigger will be
                                                          set a                                                                */
      __IO uint32_t  SEQB_ENA   :  1;               /*!< Sequence Enable. In order to avoid spuriously triggering the
                                                         sequence, care should be taken to only set the SEQB_ENA bit
                                                          when the selected trigger input is in its INACTIVE state (as
                                                          defined by the TRIGPOL bit). If this condition is not met, the
                                                          sequence will be triggered immediately upon being enabled. Remark:
                                                          In order to avoid spuriously triggering the sequence, care should
                                                          be taken to only set the SEQB_ENA bit when the selected trigger
                                                          input is in its INACTIVE state (as defined by the TRIGPOL bit).
                                                          If th                                                                */
    } SEQB_CTRL_b;                                  /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  SEQA_GDAT;                       /*!< ADC Sequence-A Global Data register. This register contains
                                                         the result of the most recent ADC conversion performed under
                                                          sequence-A.                                                          */

    struct {
           uint32_t             :  4;
      __I  uint32_t  RESULT     : 12;               /*!< This field contains the 12-bit ADC conversion result from the
                                                         most recent conversion performed under conversion sequence associated
                                                          with this register. The result is a binary fraction representing
                                                          the voltage on the currently-selected input channel as it falls
                                                          within the range of VREFP to VREFN. Zero in the field indicates
                                                          that the voltage on the input pin was less than, equal to, or
                                                          close to that on VREFN, while 0xFFF indicates that the voltage
                                                          on the input was close to, equal to, or greater than that on
                                                                                                                               */
      __I  uint32_t  THCMPRANGE :  2;               /*!< Threshold Range Comparison result. 0x0 = In Range: The last
                                                         completed conversion was greater than or equal to the value
                                                          programmed into the designated LOW threshold register (THRn_LOW)
                                                          but less than or equal to the value programmed into the designated
                                                          HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The
                                                          last completed conversion on was less than the value programmed
                                                          into the designated LOW threshold register (THRn_LOW). 0x2 =
                                                          Above Range: The last completed conversion was greater than
                                                          the value prog                                                       */
      __I  uint32_t  THCMPCROSS :  2;               /*!< Threshold Crossing Comparison result. 0x0 = No threshold Crossing
                                                         detected: The most recent completed conversion on this channel
                                                          had the same relationship (above or below) to the threshold
                                                          value established by the designated LOW threshold register (THRn_LOW)
                                                          as did the previous conversion on this channel. 0x1 = Reserved.
                                                          0x2 = Downward Threshold Crossing Detected. Indicates that a
                                                          threshold crossing in the downward direction has occurred -
                                                          i.e. the previous sample on this channel was above the threshold
                                                          va                                                                   */
           uint32_t             :  6;
      __I  uint32_t  CHN        :  4;               /*!< These bits contain the channel from which the RESULT bits were
                                                         converted (e.g. 0000 identifies channel 0, 0001 channel 1, etc.).     */
      __I  uint32_t  OVERRUN    :  1;               /*!< This bit is set if a new conversion result is loaded into the
                                                         RESULT field before a previous result has been read - i.e. while
                                                          the DATAVALID bit is set. This bit is cleared, along with the
                                                          DATAVALID bit, whenever this register is read. This bit will
                                                          contribute to an overrun interrupt/DMA trigger if the MODE bit
                                                          (in SEQA_CTRL) for the corresponding sequence is set to 0 (and
                                                          if the overrun interrupt is enabled).                                */
      __I  uint32_t  DATAVALID  :  1;               /*!< This bit is set to 1 at the end of each conversion when a new
                                                         result is loaded into the RESULT field. It is cleared whenever
                                                          this register is read. This bit will cause a conversion-complete
                                                          interrupt for the corresponding sequence if the MODE bit (in
                                                          SEQA_CTRL) for that sequence is set to 0 (and if the interrupt
                                                          is enabled).                                                         */
    } SEQA_GDAT_b;                                  /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  SEQB_GDAT;                       /*!< ADC Sequence-B Global Data register. This register contains
                                                         the result of the most recent ADC conversion performed under
                                                          sequence-B.                                                          */

    struct {
           uint32_t             :  4;
      __I  uint32_t  RESULT     : 12;               /*!< This field contains the 12-bit ADC conversion result from the
                                                         most recent conversion performed under conversion sequence associated
                                                          with this register. The result is a binary fraction representing
                                                          the voltage on the currently-selected input channel as it falls
                                                          within the range of VREFP to VREFN. Zero in the field indicates
                                                          that the voltage on the input pin was less than, equal to, or
                                                          close to that on VREFN, while 0xFFF indicates that the voltage
                                                          on the input was close to, equal to, or greater than that on
                                                                                                                               */
      __I  uint32_t  THCMPRANGE :  2;               /*!< Threshold Range Comparison result. 0x0 = In Range: The last
                                                         completed conversion was greater than or equal to the value
                                                          programmed into the designated LOW threshold register (THRn_LOW)
                                                          but less than or equal to the value programmed into the designated
                                                          HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The
                                                          last completed conversion on was less than the value programmed
                                                          into the designated LOW threshold register (THRn_LOW). 0x2 =
                                                          Above Range: The last completed conversion was greater than
                                                          the value prog                                                       */
      __I  uint32_t  THCMPCROSS :  2;               /*!< Threshold Crossing Comparison result. 0x0 = No threshold Crossing
                                                         detected: The most recent completed conversion on this channel
                                                          had the same relationship (above or below) to the threshold
                                                          value established by the designated LOW threshold register (THRn_LOW)
                                                          as did the previous conversion on this channel. 0x1 = Reserved.
                                                          0x2 = Downward Threshold Crossing Detected. Indicates that a
                                                          threshold crossing in the downward direction has occurred -
                                                          i.e. the previous sample on this channel was above the threshold
                                                          va                                                                   */
           uint32_t             :  6;
      __I  uint32_t  CHN        :  4;               /*!< These bits contain the channel from which the RESULT bits were
                                                         converted (e.g. 0000 identifies channel 0, 0001 channel 1, etc.).     */
      __I  uint32_t  OVERRUN    :  1;               /*!< This bit is set if a new conversion result is loaded into the
                                                         RESULT field before a previous result has been read - i.e. while
                                                          the DATAVALID bit is set. This bit is cleared, along with the
                                                          DATAVALID bit, whenever this register is read. This bit will
                                                          contribute to an overrun interrupt/DMA trigger if the MODE bit
                                                          (in SEQB_CTRL) for the corresponding sequence is set to 0 (and
                                                          if the overrun interrupt is enabled).                                */
      __I  uint32_t  DATAVALID  :  1;               /*!< This bit is set to 1 at the end of each conversion when a new
                                                         result is loaded into the RESULT field. It is cleared whenever
                                                          this register is read. This bit will cause a conversion-complete
                                                          interrupt for the corresponding sequence if the MODE bit (in
                                                          SEQB_CTRL) for that sequence is set to 0 (and if the interrupt
                                                          is enabled).                                                         */
    } SEQB_GDAT_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[2];

  union {
    __I  uint32_t  DAT[8];                          /*!< ADC Channel X [0:7] Data register. This register contains the
                                                         result of the most recent conversion completed on channel X
                                                          [0:7] .                                                              */

    struct {
           uint32_t             :  4;
      __I  uint32_t  RESULT     : 12;               /*!< This field contains the 12-bit ADC conversion result from the
                                                         last conversion performed on this channel. This will be a binary
                                                          fraction representing the voltage on the AD0[n] pin, as it falls
                                                          within the range of VREFP to VREFN. Zero in the field indicates
                                                          that the voltage on the input pin was less than, equal to, or
                                                          close to that on VREFN, while 0xFFF indicates that the voltage
                                                          on the input was close to, equal to, or greater than that on
                                                          VREFP.                                                               */
      __I  uint32_t  THCMPRANGE :  2;               /*!< Threshold Range Comparison result. 0x0 = In Range: The last
                                                         completed conversion was greater than or equal to the value
                                                          programmed into the designated LOW threshold register (THRn_LOW)
                                                          but less than or equal to the value programmed into the designated
                                                          HIGH threshold register (THRn_HIGH). 0x1 = Below Range: The
                                                          last completed conversion on was less than the value programmed
                                                          into the designated LOW threshold register (THRn_LOW). 0x2 =
                                                          Above Range: The last completed conversion was greater than
                                                          the value prog                                                       */
      __I  uint32_t  THCMPCROSS :  2;               /*!< Threshold Crossing Comparison result. 0x0 = No threshold Crossing
                                                         detected: The most recent completed conversion on this channel
                                                          had the same relationship (above or below) to the threshold
                                                          value established by the designated LOW threshold register (THRn_LOW)
                                                          as did the previous conversion on this channel. 0x1 = Reserved.
                                                          0x2 = Downward Threshold Crossing Detected. Indicates that a
                                                          threshold crossing in the downward direction has occurred -
                                                          i.e. the previous sample on this channel was above the threshold
                                                          va                                                                   */
           uint32_t             :  6;
      __I  uint32_t  CHN        :  4;               /*!< This field is hard-coded to contain the channel number that
                                                         this particular register relates to (i.e. this field will contain
                                                          0b0000 for the DAT0 register, 0b0001 for the DAT1 register,
                                                          etc)                                                                 */
      __I  uint32_t  OVERRUN    :  1;               /*!< This bit will be set to a 1 if a new conversion on this channel
                                                         completes and overwrites the previous contents of the RESULT
                                                          field before it has been read - i.e. while the DONE bit is set.
                                                          This bit is cleared, along with the DONE bit, whenever this
                                                          register is read or when the data related to this channel is
                                                          read from either of the global SEQn_GDAT registers. This bit
                                                          (in any of the 12 registers) will cause an overrun interrupt/DMA
                                                          trigger to be asserted if the overrun interrupt is enabled.
                                                          Remark: While i                                                      */
      __I  uint32_t  DATAVALID  :  1;               /*!< This bit is set to 1 when an ADC conversion on this channel
                                                         completes. This bit is cleared whenever this register is read
                                                          or when the data related to this channel is read from either
                                                          of the global SEQn_GDAT registers. Remark: While it is allowed
                                                          to include the same channels in both conversion sequences, doing
                                                          so may cause erratic behavior of the DONE and OVERRUN bits in
                                                          the data registers associated with any of the channels that
                                                          are shared between the two sequences. Any erratic OVERRUN behavior
                                                          will also a                                                          */
    } DAT_b[8];                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[4];

  union {
    __IO uint32_t  THR0_LOW;                        /*!< ADC Low Compare Threshold register 0: Contains the lower threshold
                                                         level for automatic threshold comparison for any channels linked
                                                          to threshold pair 0.                                                 */

    struct {
           uint32_t             :  4;
      __IO uint32_t  THRLOW     : 12;               /*!< Low threshold value against which ADC results will be compared        */
    } THR0_LOW_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  THR1_LOW;                        /*!< ADC Low Compare Threshold register 1: Contains the lower threshold
                                                         level for automatic threshold comparison for any channels linked
                                                          to threshold pair 1.                                                 */

    struct {
           uint32_t             :  4;
      __IO uint32_t  THRLOW     : 12;               /*!< Low threshold value against which ADC results will be compared        */
    } THR1_LOW_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  THR0_HIGH;                       /*!< ADC High Compare Threshold register 0: Contains the upper threshold
                                                         level for automatic threshold comparison for any channels linked
                                                          to threshold pair 0.                                                 */

    struct {
           uint32_t             :  4;
      __IO uint32_t  THRHIGH    : 12;               /*!< High threshold value against which ADC results will be compared       */
    } THR0_HIGH_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  THR1_HIGH;                       /*!< ADC High Compare Threshold register 1: Contains the upper threshold
                                                         level for automatic threshold comparison for any channels linked
                                                          to threshold pair 1.                                                 */

    struct {
           uint32_t             :  4;
      __IO uint32_t  THRHIGH    : 12;               /*!< High threshold value against which ADC results will be compared       */
    } THR1_HIGH_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CHAN_THRSEL;                     /*!< ADC Channel-Threshold Select register. Specifies which set of
                                                         threshold compare registers are to be used for each channel           */

    struct {
      __IO uint32_t  CH0_THRSEL :  1;               /*!< Threshold select for channel 0. 0 Threshold 0. Results for this
                                                         channel will be compared against the threshold levels indicated
                                                          in the THR0_LOW and THR0_HIGH registers. 1 Threshold 1. Results
                                                          for this channel will be compared against the threshold levels
                                                          indicated in the THR1_LOW and THR1_HIGH registers.                   */
      __IO uint32_t  CH1_THRSEL :  1;               /*!< Threshold select for channel 1. See description for channel
                                                         0.                                                                    */
      __IO uint32_t  CH2_THRSEL :  1;               /*!< Threshold select for channel 2. See description for channel
                                                         0.                                                                    */
      __IO uint32_t  CH3_THRSEL :  1;               /*!< Threshold select for channel 3. See description for channel
                                                         0.                                                                    */
      __IO uint32_t  CH4_THRSEL :  1;               /*!< Threshold select for channel 4. See description for channel
                                                         0.                                                                    */
      __IO uint32_t  CH5_THRSEL :  1;               /*!< Threshold select for channel 5. See description for channel
                                                         0.                                                                    */
      __IO uint32_t  CH6_THRSEL :  1;               /*!< Threshold select for channel 6. See description for channel
                                                         0.                                                                    */
      __IO uint32_t  CH7_THRSEL :  1;               /*!< Threshold select for channel 7. See description for channel
                                                         0.                                                                    */
    } CHAN_THRSEL_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTEN;                           /*!< ADC Interrupt Enable register. This register contains enable
                                                         bits that enable the sequence-A, sequence-B, threshold compare
                                                          and data overrun interrupts to be generated.                         */

    struct {
      __IO uint32_t  SEQA_INTEN :  1;               /*!< Sequence A interrupt enable. 0 Disabled. The sequence A interrupt/DMA
                                                         trigger is disabled. 1 Enabled. The sequence A interrupt/DMA
                                                          trigger is enabled and will be asserted either upon completion
                                                          of each individual conversion performed as part of sequence
                                                          A, or upon completion of the entire A sequence of conversions,
                                                          depending on the MODE bit in the SEQA_CTRL register.                 */
      __IO uint32_t  SEQB_INTEN :  1;               /*!< Sequence B interrupt enable. 0 Disabled. The sequence B interrupt/DMA
                                                         trigger is disabled. 1 Enabled. The sequence B interrupt/DMA
                                                          trigger is enabled and will be asserted either upon completion
                                                          of each individual conversion performed as part of sequence
                                                          B, or upon completion of the entire B sequence of conversions,
                                                          depending on the MODE bit in the SEQB_CTRL register.                 */
      __IO uint32_t  OVR_INTEN  :  1;               /*!< Overrun interrupt enable. 0 Disabled. The overrun interrupt
                                                         is disabled. 1 Enabled. The overrun interrupt is enabled. Detection
                                                          of an overrun condition on any of the 12 channel data registers
                                                          will cause an overrun interrupt/DMA trigger. In addition, if
                                                          the MODE bit for a particular sequence is 0, then an overrun
                                                          in the global data register for that sequence will also cause
                                                          this interrupt/DMA trigger to be asserted.                           */
      __IO uint32_t  ADCMPINTEN0:  2;               /*!< Threshold comparison interrupt enable for channel 0. 0x0 Disabled.
                                                         0x1 Outside threshold. 0x2 Crossing threshold. 0x3 Reserved           */
      __IO uint32_t  ADCMPINTEN1:  2;               /*!< Channel 1 threshold comparison interrupt enable. See description
                                                         for channel 0.                                                        */
      __IO uint32_t  ADCMPINTEN2:  2;               /*!< Channel 2 threshold comparison interrupt enable. See description
                                                         for channel 0.                                                        */
      __IO uint32_t  ADCMPINTEN3:  2;               /*!< Channel 3 threshold comparison interrupt enable. See description
                                                         for channel 0.                                                        */
      __IO uint32_t  ADCMPINTEN4:  2;               /*!< Channel 4 threshold comparison interrupt enable. See description
                                                         for channel 0.                                                        */
      __IO uint32_t  ADCMPINTEN5:  2;               /*!< Channel 5 threshold comparison interrupt enable. See description
                                                         for channel 0.                                                        */
      __IO uint32_t  ADCMPINTEN6:  2;               /*!< Channel 6 threshold comparison interrupt enable. See description
                                                         for channel 0.                                                        */
      __IO uint32_t  ADCMPINTEN7:  2;               /*!< Channel 7 threshold comparison interrupt enable. See description
                                                         for channel 0.                                                        */
    } INTEN_b;                                      /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FLAGS;                           /*!< ADC Flags register. Contains the four interrupt/DMA trigger
                                                         flags and the individual component overrun and threshold-compare
                                                          flags. (The overrun bits replicate information stored in the
                                                          result registers).                                                   */

    struct {
      __I  uint32_t  THCMP0     :  1;               /*!< Threshold comparison event on Channel 0. Set to 1 upon either
                                                         an out-of-range result or a threshold-crossing result if enabled
                                                          to do so in the INTEN register. This bit is cleared by writing
                                                          a 1.                                                                 */
      __I  uint32_t  THCMP1     :  1;               /*!< Threshold comparison event on Channel 1. See description for
                                                         channel 0.                                                            */
      __I  uint32_t  THCMP2     :  1;               /*!< Threshold comparison event on Channel 2. See description for
                                                         channel 0.                                                            */
      __I  uint32_t  THCMP3     :  1;               /*!< Threshold comparison event on Channel 3. See description for
                                                         channel 0.                                                            */
      __I  uint32_t  THCMP4     :  1;               /*!< Threshold comparison event on Channel 4. See description for
                                                         channel 0.                                                            */
      __I  uint32_t  THCMP5     :  1;               /*!< Threshold comparison event on Channel 5. See description for
                                                         channel 0.                                                            */
      __I  uint32_t  THCMP6     :  1;               /*!< Threshold comparison event on Channel 6. See description for
                                                         channel 0.                                                            */
      __I  uint32_t  THCMP7     :  1;               /*!< Threshold comparison event on Channel 7. See description for
                                                         channel 0.                                                            */
           uint32_t             :  4;
      __I  uint32_t  OVERRUN0   :  1;               /*!< Mirrors the OVERRRUN status flag from the result register for
                                                         ADC channel 0                                                         */
      __I  uint32_t  OVERRUN1   :  1;               /*!< Mirrors the OVERRRUN status flag from the result register for
                                                         ADC channel 1                                                         */
      __I  uint32_t  OVERRUN2   :  1;               /*!< Mirrors the OVERRRUN status flag from the result register for
                                                         ADC channel 2                                                         */
      __I  uint32_t  OVERRUN3   :  1;               /*!< Mirrors the OVERRRUN status flag from the result register for
                                                         ADC channel 3                                                         */
      __I  uint32_t  OVERRUN4   :  1;               /*!< Mirrors the OVERRRUN status flag from the result register for
                                                         ADC channel 4                                                         */
      __I  uint32_t  OVERRUN5   :  1;               /*!< Mirrors the OVERRRUN status flag from the result register for
                                                         ADC channel 5                                                         */
      __I  uint32_t  OVERRUN6   :  1;               /*!< Mirrors the OVERRRUN status flag from the result register for
                                                         ADC channel 6                                                         */
      __I  uint32_t  OVERRUN7   :  1;               /*!< Mirrors the OVERRRUN status flag from the result register for
                                                         ADC channel 7                                                         */
           uint32_t             :  4;
      __I  uint32_t  SEQA_OVR   :  1;               /*!< Mirrors the global OVERRUN status flag in the SEQA_GDAT register      */
      __I  uint32_t  SEQB_OVR   :  1;               /*!< Mirrors the global OVERRUN status flag in the SEQB_GDAT register      */
           uint32_t             :  2;
      __I  uint32_t  SEQA_INT   :  1;               /*!< Sequence A interrupt/DMA trigger. If the MODE bit in the SEQA_CTRL
                                                         register is 0, this flag will mirror the DATAVALID bit in the
                                                          sequence A global data register (SEQA_GDAT), which is set at
                                                          the end of every ADC conversion performed as part of sequence
                                                          A. It will be cleared automatically when the SEQA_GDAT register
                                                          is read. If the MODE bit in the SEQA_CTRL register is 1, this
                                                          flag will be set upon completion of an entire A sequence. In
                                                          this case it must be cleared by writing a 1 to this SEQA_INT
                                                          bit. This i                                                          */
      __I  uint32_t  SEQB_INT   :  1;               /*!< Sequence A interrupt/DMA trigger. If the MODE bit in the SEQB_CTRL
                                                         register is 0, this flag will mirror the DATAVALID bit in the
                                                          sequence A global data register (SEQB_GDAT), which is set at
                                                          the end of every ADC conversion performed as part of sequence
                                                          B. It will be cleared automatically when the SEQB_GDAT register
                                                          is read. If the MODE bit in the SEQB_CTRL register is 1, this
                                                          flag will be set upon completion of an entire B sequence. In
                                                          this case it must be cleared by writing a 1 to this SEQB_INT
                                                          bit. This i                                                          */
      __I  uint32_t  THCMP_INT  :  1;               /*!< Threshold Comparison Interrupt. This bit will be set if any
                                                         of the THCMP flags in the lower bits of this register are set
                                                          to 1 (due to an enabled out-of-range or threshold-crossing event
                                                          on any channel). Each type of threshold comparison interrupt
                                                          on each channel must be individually enabled in the INTEN register
                                                          to cause this interrupt. This bit will be cleared when all of
                                                          the individual threshold flags are cleared via writing 1s to
                                                          those bits.                                                          */
      __I  uint32_t  OVR_INT    :  1;               /*!< Overrun Interrupt flag. Any overrun bit in any of the individual
                                                         channel data registers will cause this interrupt. In addition,
                                                          if the MODE bit in either of the SEQn_CTRL registers is 0 then
                                                          the OVERRUN bit in the corresponding SEQn_GDAT register will
                                                          also cause this interrupt. This interrupt must be enabled in
                                                          the INTEN register. This bit will be cleared when all of the
                                                          individual overrun bits have been cleared via reading the corresponding
                                                          data registers.                                                      */
    } FLAGS_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STARTUP;                         /*!< ADC Startup register (typically only used by the ADC API).            */

    struct {
      __IO uint32_t  ADC_ENA    :  1;               /*!< ADC Enable bit. This bit can only be set to a 1 by software.
                                                         It is cleared automatically whenever the ADC is powered down.
                                                          This bit must not be set until at least 10 microseconds after
                                                          the ADC is powered up (typically by altering a system-level
                                                          ADC power control bit).                                              */
    } STARTUP_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  GPADC_CTRL0;                     /*!< Second ADC Control register : ADC internal LDO                        */

    struct {
      __IO uint32_t  LDO_POWER_EN:  1;              /*!< LDO Power enable signal (active high)                                 */
           uint32_t             :  2;
      __IO uint32_t  LDO_SEL_OUT:  5;               /*!< Select LDO output voltage (10mV step) [between 0.64V and 0.95V]       */
      __IO uint32_t  PASS_ENABLE:  1;               /*!< Enable pass mode when set to high                                     */
      __IO uint32_t  GPADC_TSAMP:  5;               /*!< 10100                                                                 */
      __IO uint32_t  TEST       :  2;               /*!< test mode selection: '00': Normal functional mode '01': Multiplexer
                                                         test mode '10': ADC in unity gain mode '11': Not used                 */
      __IO uint32_t  SEL_ATB    :  2;               /*!< Select analog test bus '00': normal mode '01': atb_p = out_ana(LDO_output)
                                                         atb_n = Vssa (LDO analog ground) '10': atb_p = out_ref (LDO
                                                          output) atb_n = Vrefn (ADC negative reference) '11': atb_p =
                                                          out_ana (LDO output) atb_n = ADC (ADC analog ground)                 */
    } GPADC_CTRL0_b;                                /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  GPADC_CTRL1;                     /*!< Third ADC Control register : ADC internal gain and offset             */

    struct {
      __IO uint32_t  OFFSET_CAL : 10;               /*!< offset_cal                                                            */
      __IO uint32_t  GAIN_CAL   : 10;               /*!< gain_cal                                                              */
    } GPADC_CTRL1_b;                                /*!< BitSize                                                               */
  };
} u_adc_Type;


/* ================================================================================ */
/* ================                     u_dmic                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component dmic It is General Purpose I/O with APB bus interface. More details will follow. (u_dmic)
  */

typedef struct {                                    /*!< u_dmic Structure                                                      */

  union {
    __IO uint32_t  OSR0;                            /*!< Oversample Rate register 0                                            */

    struct {
      __IO uint32_t  OSR        :  8;               /*!< Selects the oversample rate for the related input channel.            */
    } OSR0_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DIVHFCLK0;                       /*!< DMIC Clock Register 0                                                 */

    struct {
      __IO uint32_t  PDMDIV     :  4;               /*!< PDM clock divider value. 0 = divide by 1 1 = divide by 2 2 =
                                                         divide by 3 3 = divide by 4 4 = divide by 6 5 = divide by 8
                                                          6 = divide by 12 7 = divide by 16 8 = divide by 24 9 = divide
                                                          by 32 10 = divide by 48 11 = divide by 64 12 = divide by 96
                                                          13 = divide by 128 others = reserved.                                */
    } DIVHFCLK0_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PREAC2FSCOEF0;                   /*!< Pre-Emphasis Filter Coefficient for 2 FS register                     */

    struct {
      __IO uint32_t  COMP       :  2;               /*!< Pre-emphasis filer coefficient for 2 FS mode. 0 = Compensation
                                                         = 0 1 = Compensation = 16 2 = Compensation = 15 3 = Compensation
                                                          = 13                                                                 */
    } PREAC2FSCOEF0_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PREAC4FSCOEF0;                   /*!< Pre-Emphasis Filter Coefficient for 4 FS register                     */

    struct {
      __IO uint32_t  COMP       :  2;               /*!< Pre-emphasis filer coefficient for 4 FS mode. 0 = Compensation
                                                         = 0 1 = Compensation = 16 2 = Compensation = 15 3 = Compensation
                                                          = 13                                                                 */
    } PREAC4FSCOEF0_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  GAINSHIFT0;                      /*!< Decimator Gain Shift register                                         */

    struct {
      __IO uint32_t  GAIN       :  6;               /*!< Gain control, as a positive or negative (two s complement) number
                                                         of bits to shift.                                                     */
    } GAINSHIFT0_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[27];

  union {
    __IO uint32_t  FIFOCTRL0;                       /*!< FIFO Control register 0                                               */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< FIFO enable. 0 : FIFO is not enabled. Enabling a DMIC channel
                                                         with the FIFO disabled could be useful while data is being streamed
                                                          to the I2S, or in order to avoid a filter settling delay when
                                                          a channel is re-enabled after a period when the data was not
                                                          needed. 1 : FIFO is enabled. The FIFO must be enabled in order
                                                          for the CPU or DMA to read data from the DMIC via the FIFODATA
                                                          register.                                                            */
      __IO uint32_t  RESET      :  1;               /*!< FIFO reset. 0 : Normal operation 1 : Reset the FIFO. This bit
                                                         must be cleared before resuming operation                             */
      __IO uint32_t  INTEN      :  1;               /*!< Interrupt enable. 0: FIFO level interrupts are not enabled.
                                                         1: FIFO level interrupts are enabled.                                 */
      __IO uint32_t  DMAEN      :  1;               /*!< DMA enable 0 : DMA requests are not enabled. 1 : DMA requests
                                                         based on FIFO level are enabled.                                      */
           uint32_t             : 12;
      __IO uint32_t  TRIGLVL    :  5;               /*!< FIFO trigger level. Selects the data trigger level for interrupt
                                                         or DMA operation. If enabled to do so, the FIFO level can wake
                                                          up the device just enough to perform DMA, then return to the
                                                          reduced power mode See Section 4.5.66 Hardware Wake-up control
                                                          register . 0 = trigger when the FIFO has received one entry
                                                          (is no longer empty). 1 = trigger when the FIFO has received
                                                          two entries. 15 = trigger when the FIFO has received 16 entries
                                                          (has become full).                                                   */
    } FIFOCTRL0_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFOSTAT0;                       /*!< FIFO Status register 0                                                */

    struct {
      __IO uint32_t  INT        :  1;               /*!< Interrupt flag. Asserted when FIFO data reaches the level specified
                                                         in the FIFOCTRL register. Writing a one to this bit clears the
                                                          flag. Remark: note that the bus clock to the DMIC subsystem
                                                          must be running in order for an interrupt to occur.                  */
      __IO uint32_t  OVERRUN    :  1;               /*!< Overrun flag. Indicates that a FIFO overflow has occurred at
                                                         some point. Writing a one to this bit clears the flag. This
                                                          flag does not cause an interrupt.                                    */
      __IO uint32_t  UNDERRUN   :  1;               /*!< Underrun flag. Indicates that a FIFO underflow has occurred
                                                         at some point. Writing a one to this bit clears the flag.             */
    } FIFOSTAT0_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFODATA0;                       /*!< FIFO Data Register 0                                                  */

    struct {
      __IO uint32_t  DATA       : 24;               /*!< Data from the top of the input filter FIFO.                           */
    } FIFODATA0_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PDMSRCCFG0;                      /*!< PDM Source Configuration register 0                                   */

    struct {
      __IO uint32_t  PHY_FALL   :  1;               /*!< Capture PDM_DATA 0 : Capture PDM_DATA on the rising edge of
                                                         PDM_CLK. 1 : Capture PDM_DATA on the falling edge of PDM_CLK.         */
      __IO uint32_t  PHY_HALF   :  1;               /*!< Half rate sampling 0 : Standard half rate sampling. The clock
                                                         to the DMIC is sent at the same rate as the decimator is providing.
                                                          1 : Use half rate sampling. The clock to the DMIC is sent at
                                                          half the rate as the decimator is providing.                         */
    } PDMSRCCFG0_b;                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DCCTRL0;                         /*!< DC Control register 0                                                 */

    struct {
      __IO uint32_t  DCPOLE     :  2;               /*!< DC block filter 0: Flat response, no filter. 1:155 Hz. 2:78
                                                         Hz. 3:39 Hz                                                           */
           uint32_t             :  2;
      __IO uint32_t  DCGAIN     :  4;               /*!< Fine gain adjustment in the form of a number of bits to downshift.    */
      __IO uint32_t  SATURATEAT16BIT:  1;           /*!< Selects 16-bit saturation. 0:Results roll over if out range
                                                         and do not saturate. 1:If the result overflows, it saturates
                                                          at 0xFFFF for positive overflow and 0x8000 for negative overflow.    */
    } DCCTRL0_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[27];

  union {
    __IO uint32_t  OSR1;                            /*!< Oversample Rate register 1                                            */

    struct {
      __IO uint32_t  OSR        :  8;               /*!< Selects the oversample rate for the related input channel.            */
    } OSR1_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DIVHFCLK1;                       /*!< DMIC Clock Register 1                                                 */

    struct {
      __IO uint32_t  PDMDIV     :  4;               /*!< PDM clock divider value. 0 = divide by 1 1 = divide by 2 2 =
                                                         divide by 3 3 = divide by 4 4 = divide by 6 5 = divide by 8
                                                          6 = divide by 12 7 = divide by 16 8 = divide by 24 9 = divide
                                                          by 32 10 = divide by 48 11 = divide by 64 12 = divide by 96
                                                          13 = divide by 128 others = reserved.                                */
    } DIVHFCLK1_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PREAC2FSCOEF1;                   /*!< Pre-Emphasis Filter Coefficient for 2 FS register                     */

    struct {
      __IO uint32_t  COMP       :  2;               /*!< Pre-emphasis filer coefficient for 2 FS mode. 0 = Compensation
                                                         = 0 1 = Compensation = 16 2 = Compensation = 15 3 = Compensation
                                                          = 13                                                                 */
    } PREAC2FSCOEF1_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PREAC4FSCOEF1;                   /*!< Pre-Emphasis Filter Coefficient for 4 FS register                     */

    struct {
      __IO uint32_t  COMP       :  2;               /*!< Pre-emphasis filer coefficient for 4 FS mode. 0 = Compensation
                                                         = 0 1 = Compensation = 16 2 = Compensation = 15 3 = Compensation
                                                          = 13                                                                 */
    } PREAC4FSCOEF1_b;                              /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  GAINSHIFT1;                      /*!< Decimator Gain Shift register                                         */

    struct {
      __IO uint32_t  GAIN       :  6;               /*!< Gain control, as a positive or negative (two s complement) number
                                                         of bits to shift.                                                     */
    } GAINSHIFT1_b;                                 /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[27];

  union {
    __IO uint32_t  FIFOCTRL1;                       /*!< FIFO Control register 1                                               */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< FIFO enable. 0 : FIFO is not enabled. Enabling a DMIC channel
                                                         with the FIFO disabled could be useful while data is being streamed
                                                          to the I2S, or in order to avoid a filter settling delay when
                                                          a channel is re-enabled after a period when the data was not
                                                          needed. 1 : FIFO is enabled. The FIFO must be enabled in order
                                                          for the CPU or DMA to read data from the DMIC via the FIFODATA
                                                          register.                                                            */
      __IO uint32_t  RESET      :  1;               /*!< FIFO reset. 0 : Normal operation 1 : Reset the FIFO. This bit
                                                         must be cleared before resuming operation                             */
      __IO uint32_t  INTEN      :  1;               /*!< Interrupt enable. 0: FIFO level interrupts are not enabled.
                                                         1: FIFO level interrupts are enabled.                                 */
      __IO uint32_t  DMAEN      :  1;               /*!< DMA enable 0 : DMA requests are not enabled. 1 : DMA requests
                                                         based on FIFO level are enabled.                                      */
           uint32_t             : 12;
      __IO uint32_t  TRIGLVL    :  5;               /*!< FIFO trigger level. Selects the data trigger level for interrupt
                                                         or DMA operation. If enabled to do so, the FIFO level can wake
                                                          up the device just enough to perform DMA, then return to the
                                                          reduced power mode See Section 4.5.66 Hardware Wake-up control
                                                          register . 0 = trigger when the FIFO has received one entry
                                                          (is no longer empty). 1 = trigger when the FIFO has received
                                                          two entries. 15 = trigger when the FIFO has received 16 entries
                                                          (has become full).                                                   */
    } FIFOCTRL1_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFOSTAT1;                       /*!< FIFO Status register 1                                                */

    struct {
      __IO uint32_t  INT        :  1;               /*!< Interrupt flag. Asserted when FIFO data reaches the level specified
                                                         in the FIFOCTRL register. Writing a one to this bit clears the
                                                          flag. Remark: note that the bus clock to the DMIC subsystem
                                                          must be running in order for an interrupt to occur.                  */
      __IO uint32_t  OVERRUN    :  1;               /*!< Overrun flag. Indicates that a FIFO overflow has occurred at
                                                         some point. Writing a one to this bit clears the flag. This
                                                          flag does not cause an interrupt.                                    */
      __IO uint32_t  UNDERRUN   :  1;               /*!< Underrun flag. Indicates that a FIFO underflow has occurred
                                                         at some point. Writing a one to this bit clears the flag.             */
    } FIFOSTAT1_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFODATA1;                       /*!< FIFO Data Register 1                                                  */

    struct {
      __IO uint32_t  DATA       : 24;               /*!< Data from the top of the input filter FIFO.                           */
    } FIFODATA1_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  PDMSRCCFG1;                      /*!< PDM Source Configuration register 1                                   */

    struct {
      __IO uint32_t  PHY_FALL   :  1;               /*!< Capture PDM_DATA                                                      */
      __IO uint32_t  PHY_HALF   :  1;               /*!< Half rate sampling                                                    */
    } PDMSRCCFG1_b;                                 /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DCCTRL1;                         /*!< DC Control register 1                                                 */

    struct {
      __IO uint32_t  DCPOLE     :  2;               /*!< DC block filter                                                       */
           uint32_t             :  2;
      __IO uint32_t  DCGAIN     :  4;               /*!< Fine gain adjustment in the form of a number of bits to downshift.    */
      __IO uint32_t  SATURATEAT16BIT:  1;           /*!< Selects 16-bit saturation.                                            */
    } DCCTRL1_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[859];

  union {
    __IO uint32_t  CHANEN;                          /*!< Channel Enable register                                               */

    struct {
      __IO uint32_t  EN_CH0     :  1;               /*!< Enable channel 0. When 1, PDM channel 0 is enabled.                   */
      __IO uint32_t  EN_CH1     :  1;               /*!< Enable channel 1. When 1, PDM channel 1 is enabled.                   */
    } CHANEN_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[2];

  union {
    __IO uint32_t  IOCFG;                           /*!< I/O Configuration register                                            */

    struct {
      __IO uint32_t  CLK_BYPASS0:  1;               /*!< Bypass CLK0. When 1, PDM_DATA1 becomes the clock for PDM channel
                                                         0. This provides for the possibility of an external codec taking
                                                          over the PDM bus.                                                    */
      __IO uint32_t  CLK_BYPASS1:  1;               /*!< Bypass CLK1. When 1, PDM_DATA1 becomes the clock for PDM channel
                                                         1. This provides for the possibility of an external codec taking
                                                          over the PDM bus.                                                    */
      __IO uint32_t  STEREO_DATA0:  1;              /*!< Stereo PDM select. When 1, PDM_DATA0 is routed to both PDM channels
                                                         in a configuration that supports a single stereo digital microphone.  */
    } IOCFG_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  USE2FS;                          /*!< Use 2FS register                                                      */

    struct {
      __IO uint32_t  USE2FS     :  1;               /*!< Use 2FS register 0:Use 1FS output for PCM data. 1:Use 2FS output
                                                         for PCM data.                                                         */
    } USE2FS_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[27];

  union {
    __IO uint32_t  HWVADGAIN;                       /*!< HWVAD input gain register                                             */

    struct {
      __IO uint32_t  INPUTGAIN  :  4;               /*!< Shift value for input bits 0x00 -10 bits 0x01 -8 bits 0x02 -6
                                                         bits 0x03 -4 bits 0x04 -2 bits 0x05 0 bits (default) 0x06 +2
                                                          bits 0x07 +4 bits 0x08 +6 bits 0x09 +8 bits 0x0A +10 bits 0x0B
                                                          +12 bits 0x0C +14 bits 0x0D to 0x0F Reserved.                        */
    } HWVADGAIN_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  HWVADHPFS;                       /*!< HWVAD filter control register                                         */

    struct {
      __IO uint32_t  HPFS       :  2;               /*!< High pass filter 0:First filter by-pass. 1:High pass filter
                                                         with -3dB cut-off at 1750Hz. 2:High pass filter with -3dB cut-off
                                                          at 215Hz. 3:Reserved.                                                */
    } HWVADHPFS_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  HWVADST10;                       /*!< HWVAD control register                                                */

    struct {
      __IO uint32_t  ST10       :  1;               /*!< Stage 0 0: Normal operation, waiting for HWVAD trigger event
                                                         (stage 0). 1: Reset internal interrupt flag by writing a 1 pulse.     */
    } HWVADST10_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  HWVADRSTT;                       /*!< HWVAD filter reset register                                           */

    struct {
      __IO uint32_t  RSTT       :  1;               /*!< Writing a 1 resets all filter values                                  */
    } HWVADRSTT_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  HWVADTHGN;                       /*!< HWVAD noise estimator gain register                                   */

    struct {
      __IO uint32_t  THGN       :  4;               /*!< Gain value for the noise estimator. Values 0 to 14. 0 corresponds
                                                         to a gain of 1.                                                       */
    } HWVADTHGN_b;                                  /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  HWVADTHGS;                       /*!< HWVAD signal estimator gain register                                  */

    struct {
      __IO uint32_t  THGS       :  4;               /*!< Gain value for the signal estimator. Values 0 to 14. 0 corresponds
                                                         to a gain of 1.                                                       */
    } HWVADTHGS_b;                                  /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  HWVADLOWZ;                       /*!< HWVAD noise envelope estimator register                               */

    struct {
      __I  uint32_t  LOWZ       : 16;               /*!< Noise envelope estimator value.                                       */
    } HWVADLOWZ_b;                                  /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[24];

  union {
    __I  uint32_t  ID;                              /*!< Module Identification register                                        */

    struct {
      __I  uint32_t  ID         : 32;               /*!< Indicates module ID and the number of channels in this DMIC
                                                         interface.                                                            */
    } ID_b;                                         /*!< BitSize                                                               */
  };
} u_dmic_Type;


/* ================================================================================ */
/* ================                    u0_usart                    ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component usart. It is an Universal Synchrnous/Asynchrnous Receiver/Transmitter with APB bus interface. More details will follow. (u0_usart)
  */

typedef struct {                                    /*!< u0_usart Structure                                                    */

  union {
    __IO uint32_t  CFG;                             /*!< USART Configuration register. Basic USART configuration settings
                                                         that typically are not changed during operation.                      */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< USART Enable.                                                         */
           uint32_t             :  1;
      __IO uint32_t  DATALEN    :  2;               /*!< Selects the data size for the USART.                                  */
      __IO uint32_t  PARITYSEL  :  2;               /*!< Selects what type of parity is used by the USART.                     */
      __IO uint32_t  STOPLEN    :  1;               /*!< Number of stop bits appended to transmitted data. Only a single
                                                         stop bit is required for received data.                               */
      __IO uint32_t  MODE32K    :  1;               /*!< Selects standard or 32 kHz clocking mode.                             */
      __IO uint32_t  LINMODE    :  1;               /*!< LIN bus break mode enable.                                            */
      __IO uint32_t  CTSEN      :  1;               /*!< CTS Enable. Determines whether CTS is used for flow control.
                                                         CTS can be from the input pin, or from the USART s own RTS if
                                                          loopback mode is enabled.                                            */
           uint32_t             :  1;
      __IO uint32_t  SYNCEN     :  1;               /*!< Selects synchronous or asynchronous operation.                        */
      __IO uint32_t  CLKPOL     :  1;               /*!< Selects the clock polarity and sampling edge of received data
                                                         in synchronous mode.                                                  */
           uint32_t             :  1;
      __IO uint32_t  SYNCMST    :  1;               /*!< Synchronous mode Master select.                                       */
      __IO uint32_t  LOOP       :  1;               /*!< Selects data loopback mode.                                           */
      __IO uint32_t  IOMODE     :  1;               /*!< I/O output mode.                                                      */
           uint32_t             :  1;
      __IO uint32_t  OETA       :  1;               /*!< Output Enable Turnaround time enable for RS-485 operation.            */
      __IO uint32_t  AUTOADDR   :  1;               /*!< Automatic Address matching enable.                                    */
      __IO uint32_t  OESEL      :  1;               /*!< Output Enable Select.                                                 */
      __IO uint32_t  OEPOL      :  1;               /*!< Output Enable Polarity.                                               */
      __IO uint32_t  RXPOL      :  1;               /*!< Receive data polarity.                                                */
      __IO uint32_t  TXPOL      :  1;               /*!< Transmit data polarity.                                               */
    } CFG_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CTL;                             /*!< USART Control register. USART control settings that are more
                                                         likely to change during operation.                                    */

    struct {
           uint32_t             :  1;
      __IO uint32_t  TXBRKEN    :  1;               /*!< Break Enable.                                                         */
      __IO uint32_t  ADDRDET    :  1;               /*!< Enable address detect mode.                                           */
           uint32_t             :  3;
      __IO uint32_t  TXDIS      :  1;               /*!< Transmit Disable.                                                     */
           uint32_t             :  1;
      __IO uint32_t  CC         :  1;               /*!< Continuous Clock generation. By default, SCLK is only output
                                                         while data is being transmitted in synchronous mode.                  */
      __IO uint32_t  CLRCCONRX  :  1;               /*!< Clear Continuous Clock.                                               */
           uint32_t             :  6;
      __IO uint32_t  AUTOBAUD   :  1;               /*!< Autobaud enable.                                                      */
    } CTL_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STAT;                            /*!< USART Status register. The complete status value can be read
                                                         here. Writing ones clears some bits in the register. Some bits
                                                          can be cleared by writing a 1 to them.                               */

    struct {
           uint32_t             :  1;
      __I  uint32_t  RXIDLE     :  1;               /*!< Receiver Idle. When 0, indicates that the receiver is currently
                                                         in the process of receiving data. When 1, indicates that the
                                                          receiver is not currently in the process of receiving data.          */
           uint32_t             :  1;
      __I  uint32_t  TXIDLE     :  1;               /*!< Transmitter Idle. When 0, indicates that the transmitter is
                                                         currently in the process of sending data.When 1, indicate that
                                                          the transmitter is not currently in the process of sending data.     */
      __I  uint32_t  CTS        :  1;               /*!< This bit reflects the current state of the CTS signal, regardless
                                                         of the setting of the CTSEN bit in the CFG register. This will
                                                          be the value of the CTS input pin unless loopback mode is enabled.   */
      __IO uint32_t  DELTACTS   :  1;               /*!< This bit is set when a change in the state is detected for the
                                                         CTS flag above. This bit is cleared by software.                      */
      __I  uint32_t  TXDISSTAT  :  1;               /*!< Transmitter Disabled Status flag. When 1, this bit indicates
                                                         that the USART transmitter is fully idle after being disabled
                                                          via the TXDIS bit in the CFG register (TXDIS = 1).                   */
           uint32_t             :  1;
      __IO uint32_t  OVERRUNINT :  1;               /*!< Overrun Error interrupt flag. This flag is set when a new character
                                                         is received while the receiver buffer is still in use. If this
                                                          occurs, the newly received character in the shift register is
                                                          lost.                                                                */
           uint32_t             :  1;
      __I  uint32_t  RXBRK      :  1;               /*!< Received Break. This bit reflects the current state of the receiver
                                                         break detection logic. It is set when the Un_RXD pin remains
                                                          low for 16 bit times. Note that FRAMERRINT will also be set
                                                          when this condition occurs because the stop bit(s) for the character
                                                          would be missing. RXBRK is cleared when the Un_RXD pin goes
                                                          high.                                                                */
      __IO uint32_t  DELTARXBRK :  1;               /*!< This bit is set when a change in the state of receiver break
                                                         detection occurs. Cleared by software.                                */
      __IO uint32_t  START      :  1;               /*!< This bit is set when a start is detected on the receiver input.
                                                         Its purpose is primarily to allow wake-up from Deep sleep or
                                                          Power-down mode immediately when a start is detected. Cleared
                                                          by software.                                                         */
      __IO uint32_t  FRAMERRINT :  1;               /*!< Framing Error interrupt flag. This flag is set when a character
                                                         is received with a missing stop bit at the expected location.
                                                          This could be an indication of a baud rate or configuration
                                                          mismatch with the transmitting source.                               */
      __IO uint32_t  PARITYERRINT:  1;              /*!< Parity Error interrupt flag. This flag is set when a parity
                                                         error is detected in a received character.                            */
      __IO uint32_t  RXNOISEINT :  1;               /*!< Received Noise interrupt flag. Three samples of received data
                                                         are taken in order to determine the value of each received data
                                                          bit, except in synchronous mode. This acts as a noise filter
                                                          if one sample disagrees. This flag is set when a received data
                                                          bit contains one disagreeing sample. This could indicate line
                                                          noise, a baud rate or character format mismatch, or loss of
                                                          synchronization during data reception.                               */
      __IO uint32_t  ABERR      :  1;               /*!< Auto baud Error. An auto baud error can occur if the BRG counts
                                                         to its limit before the end of the start bit that is being measured,
                                                          essentially an auto baud time-out.                                   */
    } STAT_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENSET;                        /*!< Interrupt Enable read and Set register for USART (not FIFO)
                                                         status. Contains individual interrupt enable bits for each potential
                                                          USART interrupt. A complete value may be read from this register.
                                                          Writing a 1 to any implemented bit position causes that bit
                                                          to be set.                                                           */

    struct {
      __IO uint32_t  RXRDYEN    :  1;               /*!< When 1, enables an interrupt when RX becomes ready                    */
           uint32_t             :  1;
      __IO uint32_t  TXRDTEN    :  1;               /*!< When 1, enables an interrupt when TX becomes ready                    */
      __IO uint32_t  TXIDLEEN   :  1;               /*!< When 1, enables an interrupt when the transmitter becomes idle
                                                         (TXIDLE = 1).                                                         */
           uint32_t             :  1;
      __IO uint32_t  DELTACTSEN :  1;               /*!< Transmitter Idle. When 0, indicates that the transmitter is
                                                         currently in the process of sending data.When 1, indicate that
                                                          the transmitter is not currently in the process of sending data.     */
      __IO uint32_t  TXDISEN    :  1;               /*!< When 1, enables an interrupt when the transmitter is fully disabled
                                                         as indicated by the TXDISINT flag in STAT. See description of
                                                          the TXDISINT bit for details.                                        */
           uint32_t             :  1;
      __IO uint32_t  OVERRUNEN  :  1;               /*!< When 1, enables an interrupt when an overrun error occurred.          */
           uint32_t             :  2;
      __IO uint32_t  DELTARXBRKEN:  1;              /*!< When 1, enables an interrupt when a change of state has occurred
                                                         in the detection of a received break condition (break condition
                                                          asserted or deasserted).                                             */
      __IO uint32_t  STARTEN    :  1;               /*!< When 1, enables an interrupt when a received start bit has been
                                                         detected.                                                             */
      __IO uint32_t  FRAMERREN  :  1;               /*!< When 1, enables an interrupt when a framing error has been detected.  */
      __IO uint32_t  PARITYERREN:  1;               /*!< When 1, enables an interrupt when a parity error has been detected.   */
      __IO uint32_t  RXNOISEEN  :  1;               /*!< When 1, enables an interrupt when noise is detected.                  */
      __IO uint32_t  ABERREN    :  1;               /*!< When 1, enables an interrupt when an auto baud error occurs.          */
    } INTENSET_b;                                   /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  INTENCLR;                        /*!< Interrupt Enable Clear register. Allows clearing any combination
                                                         of bits in the INTENSET register. Writing a 1 to any implemented
                                                          bit position causes the corresponding bit to be cleared.             */

    struct {
      __O  uint32_t  RXRDYCLR   :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
           uint32_t             :  1;
      __O  uint32_t  TXRDYCLR   :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  TXIDLECLR  :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
           uint32_t             :  1;
      __O  uint32_t  DELTACTSCLR:  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  TXDISCLR   :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
           uint32_t             :  1;
      __O  uint32_t  OVERRUNCLR :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
           uint32_t             :  2;
      __O  uint32_t  DELTARXBRKCLR:  1;             /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  STARTCLR   :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  FRAMERRCLR :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  PARITYERRCLR:  1;              /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  RXNOISECLR :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  ABERRCLR   :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
    } INTENCLR_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[3];

  union {
    __IO uint32_t  BRG;                             /*!< Baud Rate Generator register. 16-bit integer baud rate divisor
                                                         value.                                                                */

    struct {
      __IO uint32_t  BRGVAL     : 16;               /*!< This value is used to divide the USART input clock to determine
                                                         the baud rate, based on the input clock from the FRG. 0 = FCLK
                                                          is used directly by the USART function. 1 = FCLK is divided
                                                          by 2 before use by the USART function. 2 = FCLK is divided by
                                                          3 before use by the USART function. ... 0xFFFF = FCLK is divided
                                                          by 65,536 before use by the USART function.                          */
    } BRG_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  INTSTAT;                         /*!< Interrupt status register. Reflects interrupts that are currently
                                                         enabled.                                                              */

    struct {
      __I  uint32_t  RX_RDY     :  1;               /*!< Receiver Ready Status                                                 */
      __I  uint32_t  RXIDLE     :  1;               /*!< Receiver Idle Status                                                  */
      __I  uint32_t  TX_RDY     :  1;               /*!< Transmitter Ready Status                                              */
      __I  uint32_t  TXIDLE     :  1;               /*!< Transmitter Idle status.                                              */
           uint32_t             :  1;
      __I  uint32_t  DELTACTS   :  1;               /*!< This bit is set when a change in the state of the CTS input
                                                         is detected.                                                          */
      __I  uint32_t  TXDIS      :  1;               /*!< Transmitter Disabled Interrupt flag.                                  */
           uint32_t             :  1;
      __I  uint32_t  OVERRUN    :  1;               /*!< Overrun Error interrupt flag.                                         */
           uint32_t             :  2;
      __I  uint32_t  DELTARXBRK :  1;               /*!< This bit is set when a change in the state of receiver break
                                                         detection occurs.                                                     */
      __I  uint32_t  START      :  1;               /*!< This bit is set when a start is detected on the receiver input.       */
      __I  uint32_t  FRAMERR    :  1;               /*!< Framing Error interrupt flag.                                         */
      __I  uint32_t  PARITYERR  :  1;               /*!< Parity Error interrupt flag.                                          */
      __I  uint32_t  RXNOISE    :  1;               /*!< Received Noise interrupt flag.                                        */
      __I  uint32_t  ABERR      :  1;               /*!< Auto baud Error Interrupt flag.                                       */
    } INTSTAT_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  OSR;                             /*!< Oversample selection register for asynchronous communication.         */

    struct {
      __IO uint32_t  OSRVAL     :  4;               /*!< Oversample Selection Value. 0 to 3 = not supported 0x4 = 5 function
                                                         clocks are used to transmit and receive each data bit. 0x5 =
                                                          6 function clocks are used to transmit and receive each data
                                                          bit. ... 0xF= 16 function clocks are used to transmit and receive
                                                          each data bit.                                                       */
    } OSR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ADDR;                            /*!< Address register for automatic address matching.                      */

    struct {
      __IO uint32_t  ADDRESS    :  8;               /*!< 8-bit address used with automatic address matching. Used when
                                                         address detection is enabled (ADDRDET in CTL = 1) and automatic
                                                          address matching is enabled (AUTOADDR in CFG = 1).                   */
    } ADDR_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[884];

  union {
    __IO uint32_t  FIFOCFG;                         /*!< FIFO configuration and enable register.                               */

    struct {
      __IO uint32_t  ENABLETX   :  1;               /*!< Enable the transmit FIFO. This is automatically enabled when
                                                         PSELID.PERSEL is set to 1 to configure the USART functionality.       */
      __IO uint32_t  ENABLERX   :  1;               /*!< Enable the receive FIFO. This is automatically enabled when
                                                         PSELID.PERSEL is set to 1 to configure the USART functionality.       */
           uint32_t             :  2;
      __I  uint32_t  SIZE       :  2;               /*!< FIFO size configuration. This is a read-only field. 0x0 = FIFO
                                                         is configured as 4 entries of 8 bits. 0x1, 0x2, 0x3 = not applicable. */
           uint32_t             :  6;
      __IO uint32_t  DMATX      :  1;               /*!< DMA configuration for transmit.                                       */
      __IO uint32_t  DMARX      :  1;               /*!< DMA configuration for receive.                                        */
      __IO uint32_t  WAKETX     :  1;               /*!< Wakeup for transmit FIFO level. This allows the device to be
                                                         woken from reduced power modes (up to power-down, as long as
                                                          the peripheral function works in that power mode) without enabling
                                                          the TXLVL interrupt. Only DMA wakes up, processes data, and
                                                          goes back to sleep. The CPU will remain stopped until woken
                                                          by another cause, such as DMA completion.                            */
      __IO uint32_t  WAKERX     :  1;               /*!< Wakeup for receive FIFO level. This allows the device to be
                                                         woken from reduced power modes (up to power-down, as long as
                                                          the peripheral function works in that power mode) without enabling
                                                          the TXLVL interrupt. Only DMA wakes up, processes data, and
                                                          goes back to sleep. The CPU will remain stopped until woken
                                                          by another cause, such as DMA completion.                            */
      __IO uint32_t  EMPTYTX    :  1;               /*!< Empty command for the transmit FIFO. When a 1 is written to
                                                         this bit, the TX FIFO is emptied.                                     */
      __IO uint32_t  EMPTYRX    :  1;               /*!< Empty command for the receive FIFO. When a 1 is written to this
                                                         bit, the RX FIFO is emptied.                                          */
      __IO uint32_t  POPDBG     :  1;               /*!< Pop FIFO for debug reads.                                             */
    } FIFOCFG_b;                                    /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FIFOSTAT;                        /*!< FIFO status register.                                                 */

    struct {
      __I  uint32_t  TXERR      :  1;               /*!< TX FIFO error. Will be set if a transmit FIFO error occurs.
                                                         This could be an overflow caused by pushing data into a full
                                                          FIFO, or by an underflow if the FIFO is empty when data is needed.
                                                          Cleared by writing a 1 to this bit.                                  */
      __I  uint32_t  RXERR      :  1;               /*!< RX FIFO error. Will be set if a receive FIFO overflow occurs,
                                                         caused by software or DMA not emptying the FIFO fast enough.
                                                          Cleared by writing a 1 to this bit.                                  */
           uint32_t             :  1;
      __I  uint32_t  PERINT     :  1;               /*!< Peripheral interrupt. When 1, this indicates that the peripheral
                                                         function has asserted an interrupt. The details can be found
                                                          by reading the peripheral s STAT register.                           */
      __I  uint32_t  TXEMPTY    :  1;               /*!< Transmit FIFO empty. When 1, the transmit FIFO is empty. The
                                                         peripheral may still be processing the last piece of data.            */
      __I  uint32_t  TXNOTFULL  :  1;               /*!< Transmit FIFO not full. When 1, the transmit FIFO is not full,
                                                         so more data can be written. When 0, the transmit FIFO is full
                                                          and another write would cause it to overflow.                        */
      __I  uint32_t  RXNOTEMPTY :  1;               /*!< Receive FIFO not empty. When 1, the receive FIFO is not empty,
                                                         so data can be read. When 0, the receive FIFO is empty.               */
      __I  uint32_t  RXFULL     :  1;               /*!< Receive FIFO full. When 1, the receive FIFO is full. Data needs
                                                         to be read out to prevent the peripheral from causing an overflow.    */
      __I  uint32_t  TXLVL      :  5;               /*!< Transmit FIFO current level. A 0 means the TX FIFO is currently
                                                         empty, and the TXEMPTY and TXNOTFULL flags will be 1. Other
                                                          values tell how much data is actually in the TX FIFO at the
                                                          point where the read occurs. If the TX FIFO is full, the TXEMPTY
                                                          and TXNOTFULL flags will be 0.                                       */
           uint32_t             :  3;
      __I  uint32_t  RXLVL      :  5;               /*!< Receive FIFO current level. A 0 means the RX FIFO is currently
                                                         empty, and the RXFULL and RXNOTEMPTY flags will be 0. Other
                                                          values tell how much data is actually in the RX FIFO at the
                                                          point where the read occurs. If the RX FIFO is full, the RXFULL
                                                          and RXNOTEMPTY flags will be 1.                                      */
    } FIFOSTAT_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFOTRIG;                        /*!< FIFO trigger settings for interrupt and DMA request.                  */

    struct {
      __IO uint32_t  TXLVLENA   :  1;               /*!< Transmit FIFO level trigger enable. This trigger will become
                                                         an interrupt if enabled in FIFOINTENSET, or a DMA trigger if
                                                          DMATX in FIFOCFG is set.                                             */
      __IO uint32_t  RXLVLENA   :  1;               /*!< Receive FIFO level trigger enable. This trigger will become
                                                         an interrupt if enabled in FIFOINTENSET, or a DMA trigger if
                                                          DMARX in FIFOCFG is set.                                             */
           uint32_t             :  6;
      __IO uint32_t  TXLVL      :  4;               /*!< Transmit FIFO level trigger point. This field is used only when
                                                         TXLVLENA = 1. 0 = trigger when the TX FIFO becomes empty. 1
                                                          = trigger when the TX FIFO level decreases to one entry. ...
                                                          3 = trigger when the TX FIFO level decreases to 3 entries (is
                                                          no longer full).                                                     */
           uint32_t             :  4;
      __IO uint32_t  RXLVL      :  4;               /*!< Receive FIFO level trigger point. The RX FIFO level is checked
                                                         when a new piece of data is received. This field is used only
                                                          when RXLVLENA = 1. 0 = trigger when the RX FIFO has received
                                                          one entry (is no longer empty). 1 = trigger when the RX FIFO
                                                          has received two entries. ... 3 = trigger when the RX FIFO has
                                                          received 3 entries (has become full).                                */
    } FIFOTRIG_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2;

  union {
    __IO uint32_t  FIFOINTENSET;                    /*!< FIFO interrupt enable set (enable) and read register.                 */

    struct {
      __IO uint32_t  TXERR      :  1;               /*!< Determines whether an interrupt occurs when a transmit error
                                                         occurs, based on the TXERR flag in the FIFOSTAT register.             */
      __IO uint32_t  RXERR      :  1;               /*!< Determines whether an interrupt occurs when a receive error
                                                         occurs, based on the RXERR flag in the FIFOSTAT register.             */
      __IO uint32_t  TXLVL      :  1;               /*!< Determines whether an interrupt occurs when a the transmit FIFO
                                                         reaches the level specified by the TXLVL field in the FIFOTRIG
                                                          register.                                                            */
      __IO uint32_t  RXLVL      :  1;               /*!< Determines whether an interrupt occurs when a the receive FIFO
                                                         reaches the level specified by the TXLVL field in the FIFOTRIG
                                                          register.                                                            */
    } FIFOINTENSET_b;                               /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFOINTENCLR;                    /*!< FIFO interrupt enable clear (disable) and read register.              */

    struct {
      __IO uint32_t  TXERR      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  RXERR      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  TXLVL      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  RXLVL      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
    } FIFOINTENCLR_b;                               /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FIFOINTSTAT;                     /*!< FIFO interrupt status register.                                       */

    struct {
      __I  uint32_t  TXERR      :  1;               /*!< TX FIFO error.                                                        */
      __I  uint32_t  RXERR      :  1;               /*!< RX FIFO error.                                                        */
      __I  uint32_t  TXLVL      :  1;               /*!< Transmit FIFO level interrupt.                                        */
      __I  uint32_t  RXLVL      :  1;               /*!< Receive FIFO level interrupt.                                         */
      __I  uint32_t  PERINT     :  1;               /*!< Peripheral interrupt.                                                 */
    } FIFOINTSTAT_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3;

  union {
    __O  uint32_t  FIFOWR;                          /*!< FIFO write data.                                                      */

    struct {
      __O  uint32_t  TXDATA     :  8;               /*!< Transmit data to the FIFO.                                            */
    } FIFOWR_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[3];

  union {
    __I  uint32_t  FIFORD;                          /*!< FIFO read data.                                                       */

    struct {
      __I  uint32_t  RXDATA     :  9;               /*!< Received data from the FIFO. The number of bits used depends
                                                         on the DATALEN and PARITYSEL settings.                                */
           uint32_t             :  4;
      __I  uint32_t  FRAMERR    :  1;               /*!< Framing Error status flag. This bit reflects the status for
                                                         the data it is read along with from the FIFO, and indicates
                                                          that the character was received with a missing stop bit at the
                                                          expected location. This could be an indication of a baud rate
                                                          or configuration mismatch with the transmitting source.              */
      __I  uint32_t  PARITYERR  :  1;               /*!< Parity Error status flag. This bit reflects the status for the
                                                         data it is read along with from the FIFO. This bit will be set
                                                          when a parity error is detected in a received character.             */
      __I  uint32_t  RXNOISE    :  1;               /*!< Received Noise flag.                                                  */
    } FIFORD_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[3];

  union {
    __I  uint32_t  FIFORDNOPOP;                     /*!< FIFO data read with no FIFO pop.                                      */

    struct {
      __I  uint32_t  RXDATA     :  9;               /*!< Received data from the FIFO. The number of bits used depends
                                                         on the DATALEN and PARITYSEL settings.                                */
           uint32_t             :  4;
      __I  uint32_t  FRAMERR    :  1;               /*!< Framing Error status flag. This bit reflects the status for
                                                         the data it is read along with from the FIFO, and indicates
                                                          that the character was received with a missing stop bit at the
                                                          expected location. This could be an indication of a baud rate
                                                          or configuration mismatch with the transmitting source.              */
      __I  uint32_t  PARITYERR  :  1;               /*!< Parity Error status flag. This bit reflects the status for the
                                                         data it is read along with from the FIFO. This bit will be set
                                                          when a parity error is detected in a received character.             */
      __I  uint32_t  RXNOISE    :  1;               /*!< Received Noise flag.                                                  */
    } FIFORDNOPOP_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[109];

  union {
    __IO uint32_t  PSELID;                          /*!< Flexcomm ID and peripheral function select register                   */

    struct {
      __IO uint32_t  PERSEL     :  3;               /*!< Peripheral Select. This field is writable by software. 0x0 No
                                                         peripheral selected. 0x1 USART function selected 0x2 Reserved.
                                                          0x3 Reserved. 0x4 Reserved. 0x5 Reserved. 0x6 Reserved 0x7 Reserved  */
      __IO uint32_t  LOCK       :  1;               /*!< Lock the peripheral select. This field is writable by software.
                                                         0 Peripheral select can be changed by software. 1 Peripheral
                                                          select is locked and cannot be changed until this Flexcomm or
                                                          the entire device is reset.                                          */
      __I  uint32_t  USARTPRESENT:  1;              /*!< USART present indicator. This field is Read-only. 0 This Flexcomm
                                                         does not include the USART function. 1 This Flexcomm includes
                                                          the USART function.                                                  */
           uint32_t             :  7;
      __I  uint32_t  ID         : 20;               /*!< Flexcomm ID.                                                          */
    } PSELID_b;                                     /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  ID;                              /*!< USART Module Identifier                                               */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } ID_b;                                         /*!< BitSize                                                               */
  };
} u0_usart_Type;


/* ================================================================================ */
/* ================                    u1_usart                    ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component usart. It is an Universal Synchrnous/Asynchrnous Receiver/Transmitter with APB bus interface. More details will follow. (u1_usart)
  */

typedef struct {                                    /*!< u1_usart Structure                                                    */

  union {
    __IO uint32_t  CFG;                             /*!< USART Configuration register. Basic USART configuration settings
                                                         that typically are not changed during operation.                      */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< USART Enable.                                                         */
           uint32_t             :  1;
      __IO uint32_t  DATALEN    :  2;               /*!< Selects the data size for the USART.                                  */
      __IO uint32_t  PARITYSEL  :  2;               /*!< Selects what type of parity is used by the USART.                     */
      __IO uint32_t  STOPLEN    :  1;               /*!< Number of stop bits appended to transmitted data. Only a single
                                                         stop bit is required for received data.                               */
      __IO uint32_t  MODE32K    :  1;               /*!< Selects standard or 32 kHz clocking mode.                             */
      __IO uint32_t  LINMODE    :  1;               /*!< LIN bus break mode enable.                                            */
      __IO uint32_t  CTSEN      :  1;               /*!< CTS Enable. Determines whether CTS is used for flow control.
                                                         CTS can be from the input pin, or from the USART s own RTS if
                                                          loopback mode is enabled.                                            */
           uint32_t             :  1;
      __IO uint32_t  SYNCEN     :  1;               /*!< Selects synchronous or asynchronous operation.                        */
      __IO uint32_t  CLKPOL     :  1;               /*!< Selects the clock polarity and sampling edge of received data
                                                         in synchronous mode.                                                  */
           uint32_t             :  1;
      __IO uint32_t  SYNCMST    :  1;               /*!< Synchronous mode Master select.                                       */
      __IO uint32_t  LOOP       :  1;               /*!< Selects data loopback mode.                                           */
      __IO uint32_t  IOMODE     :  1;               /*!< I/O output mode.                                                      */
           uint32_t             :  1;
      __IO uint32_t  OETA       :  1;               /*!< Output Enable Turnaround time enable for RS-485 operation.            */
      __IO uint32_t  AUTOADDR   :  1;               /*!< Automatic Address matching enable.                                    */
      __IO uint32_t  OESEL      :  1;               /*!< Output Enable Select.                                                 */
      __IO uint32_t  OEPOL      :  1;               /*!< Output Enable Polarity.                                               */
      __IO uint32_t  RXPOL      :  1;               /*!< Receive data polarity.                                                */
      __IO uint32_t  TXPOL      :  1;               /*!< Transmit data polarity.                                               */
    } CFG_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CTL;                             /*!< USART Control register. USART control settings that are more
                                                         likely to change during operation.                                    */

    struct {
           uint32_t             :  1;
      __IO uint32_t  TXBRKEN    :  1;               /*!< Break Enable.                                                         */
      __IO uint32_t  ADDRDET    :  1;               /*!< Enable address detect mode.                                           */
           uint32_t             :  3;
      __IO uint32_t  TXDIS      :  1;               /*!< Transmit Disable.                                                     */
           uint32_t             :  1;
      __IO uint32_t  CC         :  1;               /*!< Continuous Clock generation. By default, SCLK is only output
                                                         while data is being transmitted in synchronous mode.                  */
      __IO uint32_t  CLRCCONRX  :  1;               /*!< Clear Continuous Clock.                                               */
           uint32_t             :  6;
      __IO uint32_t  AUTOBAUD   :  1;               /*!< Autobaud enable.                                                      */
    } CTL_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STAT;                            /*!< USART Status register. The complete status value can be read
                                                         here. Writing ones clears some bits in the register. Some bits
                                                          can be cleared by writing a 1 to them.                               */

    struct {
           uint32_t             :  1;
      __I  uint32_t  RXIDLE     :  1;               /*!< Receiver Idle. When 0, indicates that the receiver is currently
                                                         in the process of receiving data. When 1, indicates that the
                                                          receiver is not currently in the process of receiving data.          */
           uint32_t             :  1;
      __I  uint32_t  TXIDLE     :  1;               /*!< Transmitter Idle. When 0, indicates that the transmitter is
                                                         currently in the process of sending data.When 1, indicate that
                                                          the transmitter is not currently in the process of sending data.     */
      __I  uint32_t  CTS        :  1;               /*!< This bit reflects the current state of the CTS signal, regardless
                                                         of the setting of the CTSEN bit in the CFG register. This will
                                                          be the value of the CTS input pin unless loopback mode is enabled.   */
      __IO uint32_t  DELTACTS   :  1;               /*!< This bit is set when a change in the state is detected for the
                                                         CTS flag above. This bit is cleared by software.                      */
      __I  uint32_t  TXDISSTAT  :  1;               /*!< Transmitter Disabled Status flag. When 1, this bit indicates
                                                         that the USART transmitter is fully idle after being disabled
                                                          via the TXDIS bit in the CFG register (TXDIS = 1).                   */
           uint32_t             :  1;
      __IO uint32_t  OVERRUNINT :  1;               /*!< Overrun Error interrupt flag. This flag is set when a new character
                                                         is received while the receiver buffer is still in use. If this
                                                          occurs, the newly received character in the shift register is
                                                          lost.                                                                */
           uint32_t             :  1;
      __I  uint32_t  RXBRK      :  1;               /*!< Received Break. This bit reflects the current state of the receiver
                                                         break detection logic. It is set when the Un_RXD pin remains
                                                          low for 16 bit times. Note that FRAMERRINT will also be set
                                                          when this condition occurs because the stop bit(s) for the character
                                                          would be missing. RXBRK is cleared when the Un_RXD pin goes
                                                          high.                                                                */
      __IO uint32_t  DELTARXBRK :  1;               /*!< This bit is set when a change in the state of receiver break
                                                         detection occurs. Cleared by software.                                */
      __IO uint32_t  START      :  1;               /*!< This bit is set when a start is detected on the receiver input.
                                                         Its purpose is primarily to allow wake-up from Deep sleep or
                                                          Power-down mode immediately when a start is detected. Cleared
                                                          by software.                                                         */
      __IO uint32_t  FRAMERRINT :  1;               /*!< Framing Error interrupt flag. This flag is set when a character
                                                         is received with a missing stop bit at the expected location.
                                                          This could be an indication of a baud rate or configuration
                                                          mismatch with the transmitting source.                               */
      __IO uint32_t  PARITYERRINT:  1;              /*!< Parity Error interrupt flag. This flag is set when a parity
                                                         error is detected in a received character.                            */
      __IO uint32_t  RXNOISEINT :  1;               /*!< Received Noise interrupt flag. Three samples of received data
                                                         are taken in order to determine the value of each received data
                                                          bit, except in synchronous mode. This acts as a noise filter
                                                          if one sample disagrees. This flag is set when a received data
                                                          bit contains one disagreeing sample. This could indicate line
                                                          noise, a baud rate or character format mismatch, or loss of
                                                          synchronization during data reception.                               */
      __IO uint32_t  ABERR      :  1;               /*!< Auto baud Error. An auto baud error can occur if the BRG counts
                                                         to its limit before the end of the start bit that is being measured,
                                                          essentially an auto baud time-out.                                   */
    } STAT_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENSET;                        /*!< Interrupt Enable read and Set register for USART (not FIFO)
                                                         status. Contains individual interrupt enable bits for each potential
                                                          USART interrupt. A complete value may be read from this register.
                                                          Writing a 1 to any implemented bit position causes that bit
                                                          to be set.                                                           */

    struct {
      __IO uint32_t  RXRDYEN    :  1;               /*!< When 1, enables an interrupt when RX becomes ready                    */
           uint32_t             :  1;
      __IO uint32_t  TXRDTEN    :  1;               /*!< When 1, enables an interrupt when TX becomes ready                    */
      __IO uint32_t  TXIDLEEN   :  1;               /*!< When 1, enables an interrupt when the transmitter becomes idle
                                                         (TXIDLE = 1).                                                         */
           uint32_t             :  1;
      __IO uint32_t  DELTACTSEN :  1;               /*!< Transmitter Idle. When 0, indicates that the transmitter is
                                                         currently in the process of sending data.When 1, indicate that
                                                          the transmitter is not currently in the process of sending data.     */
      __IO uint32_t  TXDISEN    :  1;               /*!< When 1, enables an interrupt when the transmitter is fully disabled
                                                         as indicated by the TXDISINT flag in STAT. See description of
                                                          the TXDISINT bit for details.                                        */
           uint32_t             :  1;
      __IO uint32_t  OVERRUNEN  :  1;               /*!< When 1, enables an interrupt when an overrun error occurred.          */
           uint32_t             :  2;
      __IO uint32_t  DELTARXBRKEN:  1;              /*!< When 1, enables an interrupt when a change of state has occurred
                                                         in the detection of a received break condition (break condition
                                                          asserted or deasserted).                                             */
      __IO uint32_t  STARTEN    :  1;               /*!< When 1, enables an interrupt when a received start bit has been
                                                         detected.                                                             */
      __IO uint32_t  FRAMERREN  :  1;               /*!< When 1, enables an interrupt when a framing error has been detected.  */
      __IO uint32_t  PARITYERREN:  1;               /*!< When 1, enables an interrupt when a parity error has been detected.   */
      __IO uint32_t  RXNOISEEN  :  1;               /*!< When 1, enables an interrupt when noise is detected.                  */
      __IO uint32_t  ABERREN    :  1;               /*!< When 1, enables an interrupt when an auto baud error occurs.          */
    } INTENSET_b;                                   /*!< BitSize                                                               */
  };

  union {
    __O  uint32_t  INTENCLR;                        /*!< Interrupt Enable Clear register. Allows clearing any combination
                                                         of bits in the INTENSET register. Writing a 1 to any implemented
                                                          bit position causes the corresponding bit to be cleared.             */

    struct {
      __O  uint32_t  RXRDYCLR   :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
           uint32_t             :  1;
      __O  uint32_t  TXRDYCLR   :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  TXIDLECLR  :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
           uint32_t             :  1;
      __O  uint32_t  DELTACTSCLR:  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  TXDISCLR   :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
           uint32_t             :  1;
      __O  uint32_t  OVERRUNCLR :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
           uint32_t             :  2;
      __O  uint32_t  DELTARXBRKCLR:  1;             /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  STARTCLR   :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  FRAMERRCLR :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  PARITYERRCLR:  1;              /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  RXNOISECLR :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __O  uint32_t  ABERRCLR   :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
    } INTENCLR_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[3];

  union {
    __IO uint32_t  BRG;                             /*!< Baud Rate Generator register. 16-bit integer baud rate divisor
                                                         value.                                                                */

    struct {
      __IO uint32_t  BRGVAL     : 16;               /*!< This value is used to divide the USART input clock to determine
                                                         the baud rate, based on the input clock from the FRG. 0 = FCLK
                                                          is used directly by the USART function. 1 = FCLK is divided
                                                          by 2 before use by the USART function. 2 = FCLK is divided by
                                                          3 before use by the USART function. ... 0xFFFF = FCLK is divided
                                                          by 65,536 before use by the USART function.                          */
    } BRG_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  INTSTAT;                         /*!< Interrupt status register. Reflects interrupts that are currently
                                                         enabled.                                                              */

    struct {
      __I  uint32_t  RX_RDY     :  1;               /*!< Receiver Ready Status                                                 */
      __I  uint32_t  RXIDLE     :  1;               /*!< Receiver Idle Status                                                  */
      __I  uint32_t  TX_RDY     :  1;               /*!< Transmitter Ready Status                                              */
      __I  uint32_t  TXIDLE     :  1;               /*!< Transmitter Idle status.                                              */
           uint32_t             :  1;
      __I  uint32_t  DELTACTS   :  1;               /*!< This bit is set when a change in the state of the CTS input
                                                         is detected.                                                          */
      __I  uint32_t  TXDIS      :  1;               /*!< Transmitter Disabled Interrupt flag.                                  */
           uint32_t             :  1;
      __I  uint32_t  OVERRUN    :  1;               /*!< Overrun Error interrupt flag.                                         */
           uint32_t             :  2;
      __I  uint32_t  DELTARXBRK :  1;               /*!< This bit is set when a change in the state of receiver break
                                                         detection occurs.                                                     */
      __I  uint32_t  START      :  1;               /*!< This bit is set when a start is detected on the receiver input.       */
      __I  uint32_t  FRAMERR    :  1;               /*!< Framing Error interrupt flag.                                         */
      __I  uint32_t  PARITYERR  :  1;               /*!< Parity Error interrupt flag.                                          */
      __I  uint32_t  RXNOISE    :  1;               /*!< Received Noise interrupt flag.                                        */
      __I  uint32_t  ABERR      :  1;               /*!< Auto baud Error Interrupt flag.                                       */
    } INTSTAT_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  OSR;                             /*!< Oversample selection register for asynchronous communication.         */

    struct {
      __IO uint32_t  OSRVAL     :  4;               /*!< Oversample Selection Value. 0 to 3 = not supported 0x4 = 5 function
                                                         clocks are used to transmit and receive each data bit. 0x5 =
                                                          6 function clocks are used to transmit and receive each data
                                                          bit. ... 0xF= 16 function clocks are used to transmit and receive
                                                          each data bit.                                                       */
    } OSR_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  ADDR;                            /*!< Address register for automatic address matching.                      */

    struct {
      __IO uint32_t  ADDRESS    :  8;               /*!< 8-bit address used with automatic address matching. Used when
                                                         address detection is enabled (ADDRDET in CTL = 1) and automatic
                                                          address matching is enabled (AUTOADDR in CFG = 1).                   */
    } ADDR_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[884];

  union {
    __IO uint32_t  FIFOCFG;                         /*!< FIFO configuration and enable register.                               */

    struct {
      __IO uint32_t  ENABLETX   :  1;               /*!< Enable the transmit FIFO. This is automatically enabled when
                                                         PSELID.PERSEL is set to 1 to configure the USART functionality.       */
      __IO uint32_t  ENABLERX   :  1;               /*!< Enable the receive FIFO. This is automatically enabled when
                                                         PSELID.PERSEL is set to 1 to configure the USART functionality.       */
           uint32_t             :  2;
      __I  uint32_t  SIZE       :  2;               /*!< FIFO size configuration. This is a read-only field. 0x0 = FIFO
                                                         is configured as 4 entries of 8 bits. 0x1, 0x2, 0x3 = not applicable. */
           uint32_t             :  6;
      __IO uint32_t  DMATX      :  1;               /*!< DMA configuration for transmit.                                       */
      __IO uint32_t  DMARX      :  1;               /*!< DMA configuration for receive.                                        */
      __IO uint32_t  WAKETX     :  1;               /*!< Wakeup for transmit FIFO level. This allows the device to be
                                                         woken from reduced power modes (up to power-down, as long as
                                                          the peripheral function works in that power mode) without enabling
                                                          the TXLVL interrupt. Only DMA wakes up, processes data, and
                                                          goes back to sleep. The CPU will remain stopped until woken
                                                          by another cause, such as DMA completion.                            */
      __IO uint32_t  WAKERX     :  1;               /*!< Wakeup for receive FIFO level. This allows the device to be
                                                         woken from reduced power modes (up to power-down, as long as
                                                          the peripheral function works in that power mode) without enabling
                                                          the TXLVL interrupt. Only DMA wakes up, processes data, and
                                                          goes back to sleep. The CPU will remain stopped until woken
                                                          by another cause, such as DMA completion.                            */
      __IO uint32_t  EMPTYTX    :  1;               /*!< Empty command for the transmit FIFO. When a 1 is written to
                                                         this bit, the TX FIFO is emptied.                                     */
      __IO uint32_t  EMPTYRX    :  1;               /*!< Empty command for the receive FIFO. When a 1 is written to this
                                                         bit, the RX FIFO is emptied.                                          */
      __IO uint32_t  POPDBG     :  1;               /*!< Pop FIFO for debug reads.                                             */
    } FIFOCFG_b;                                    /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FIFOSTAT;                        /*!< FIFO status register.                                                 */

    struct {
      __I  uint32_t  TXERR      :  1;               /*!< TX FIFO error. Will be set if a transmit FIFO error occurs.
                                                         This could be an overflow caused by pushing data into a full
                                                          FIFO, or by an underflow if the FIFO is empty when data is needed.
                                                          Cleared by writing a 1 to this bit.                                  */
      __I  uint32_t  RXERR      :  1;               /*!< RX FIFO error. Will be set if a receive FIFO overflow occurs,
                                                         caused by software or DMA not emptying the FIFO fast enough.
                                                          Cleared by writing a 1 to this bit.                                  */
           uint32_t             :  1;
      __I  uint32_t  PERINT     :  1;               /*!< Peripheral interrupt. When 1, this indicates that the peripheral
                                                         function has asserted an interrupt. The details can be found
                                                          by reading the peripheral s STAT register.                           */
      __I  uint32_t  TXEMPTY    :  1;               /*!< Transmit FIFO empty. When 1, the transmit FIFO is empty. The
                                                         peripheral may still be processing the last piece of data.            */
      __I  uint32_t  TXNOTFULL  :  1;               /*!< Transmit FIFO not full. When 1, the transmit FIFO is not full,
                                                         so more data can be written. When 0, the transmit FIFO is full
                                                          and another write would cause it to overflow.                        */
      __I  uint32_t  RXNOTEMPTY :  1;               /*!< Receive FIFO not empty. When 1, the receive FIFO is not empty,
                                                         so data can be read. When 0, the receive FIFO is empty.               */
      __I  uint32_t  RXFULL     :  1;               /*!< Receive FIFO full. When 1, the receive FIFO is full. Data needs
                                                         to be read out to prevent the peripheral from causing an overflow.    */
      __I  uint32_t  TXLVL      :  5;               /*!< Transmit FIFO current level. A 0 means the TX FIFO is currently
                                                         empty, and the TXEMPTY and TXNOTFULL flags will be 1. Other
                                                          values tell how much data is actually in the TX FIFO at the
                                                          point where the read occurs. If the TX FIFO is full, the TXEMPTY
                                                          and TXNOTFULL flags will be 0.                                       */
           uint32_t             :  3;
      __I  uint32_t  RXLVL      :  5;               /*!< Receive FIFO current level. A 0 means the RX FIFO is currently
                                                         empty, and the RXFULL and RXNOTEMPTY flags will be 0. Other
                                                          values tell how much data is actually in the RX FIFO at the
                                                          point where the read occurs. If the RX FIFO is full, the RXFULL
                                                          and RXNOTEMPTY flags will be 1.                                      */
    } FIFOSTAT_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFOTRIG;                        /*!< FIFO trigger settings for interrupt and DMA request.                  */

    struct {
      __IO uint32_t  TXLVLENA   :  1;               /*!< Transmit FIFO level trigger enable. This trigger will become
                                                         an interrupt if enabled in FIFOINTENSET, or a DMA trigger if
                                                          DMATX in FIFOCFG is set.                                             */
      __IO uint32_t  RXLVLENA   :  1;               /*!< Receive FIFO level trigger enable. This trigger will become
                                                         an interrupt if enabled in FIFOINTENSET, or a DMA trigger if
                                                          DMARX in FIFOCFG is set.                                             */
           uint32_t             :  6;
      __IO uint32_t  TXLVL      :  4;               /*!< Transmit FIFO level trigger point. This field is used only when
                                                         TXLVLENA = 1. 0 = trigger when the TX FIFO becomes empty. 1
                                                          = trigger when the TX FIFO level decreases to one entry. ...
                                                          3 = trigger when the TX FIFO level decreases to 3 entries (is
                                                          no longer full).                                                     */
           uint32_t             :  4;
      __IO uint32_t  RXLVL      :  4;               /*!< Receive FIFO level trigger point. The RX FIFO level is checked
                                                         when a new piece of data is received. This field is used only
                                                          when RXLVLENA = 1. 0 = trigger when the RX FIFO has received
                                                          one entry (is no longer empty). 1 = trigger when the RX FIFO
                                                          has received two entries. ... 3 = trigger when the RX FIFO has
                                                          received 3 entries (has become full).                                */
    } FIFOTRIG_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2;

  union {
    __IO uint32_t  FIFOINTENSET;                    /*!< FIFO interrupt enable set (enable) and read register.                 */

    struct {
      __IO uint32_t  TXERR      :  1;               /*!< Determines whether an interrupt occurs when a transmit error
                                                         occurs, based on the TXERR flag in the FIFOSTAT register.             */
      __IO uint32_t  RXERR      :  1;               /*!< Determines whether an interrupt occurs when a receive error
                                                         occurs, based on the RXERR flag in the FIFOSTAT register.             */
      __IO uint32_t  TXLVL      :  1;               /*!< Determines whether an interrupt occurs when a the transmit FIFO
                                                         reaches the level specified by the TXLVL field in the FIFOTRIG
                                                          register.                                                            */
      __IO uint32_t  RXLVL      :  1;               /*!< Determines whether an interrupt occurs when a the receive FIFO
                                                         reaches the level specified by the TXLVL field in the FIFOTRIG
                                                          register.                                                            */
    } FIFOINTENSET_b;                               /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFOINTENCLR;                    /*!< FIFO interrupt enable clear (disable) and read register.              */

    struct {
      __IO uint32_t  TXERR      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  RXERR      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  TXLVL      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  RXLVL      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
    } FIFOINTENCLR_b;                               /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FIFOINTSTAT;                     /*!< FIFO interrupt status register.                                       */

    struct {
      __I  uint32_t  TXERR      :  1;               /*!< TX FIFO error.                                                        */
      __I  uint32_t  RXERR      :  1;               /*!< RX FIFO error.                                                        */
      __I  uint32_t  TXLVL      :  1;               /*!< Transmit FIFO level interrupt.                                        */
      __I  uint32_t  RXLVL      :  1;               /*!< Receive FIFO level interrupt.                                         */
      __I  uint32_t  PERINT     :  1;               /*!< Peripheral interrupt.                                                 */
    } FIFOINTSTAT_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3;

  union {
    __O  uint32_t  FIFOWR;                          /*!< FIFO write data.                                                      */

    struct {
      __O  uint32_t  TXDATA     :  8;               /*!< Transmit data to the FIFO.                                            */
    } FIFOWR_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[3];

  union {
    __I  uint32_t  FIFORD;                          /*!< FIFO read data.                                                       */

    struct {
      __I  uint32_t  RXDATA     :  9;               /*!< Received data from the FIFO. The number of bits used depends
                                                         on the DATALEN and PARITYSEL settings.                                */
           uint32_t             :  4;
      __I  uint32_t  FRAMERR    :  1;               /*!< Framing Error status flag. This bit reflects the status for
                                                         the data it is read along with from the FIFO, and indicates
                                                          that the character was received with a missing stop bit at the
                                                          expected location. This could be an indication of a baud rate
                                                          or configuration mismatch with the transmitting source.              */
      __I  uint32_t  PARITYERR  :  1;               /*!< Parity Error status flag. This bit reflects the status for the
                                                         data it is read along with from the FIFO. This bit will be set
                                                          when a parity error is detected in a received character.             */
      __I  uint32_t  RXNOISE    :  1;               /*!< Received Noise flag.                                                  */
    } FIFORD_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[3];

  union {
    __I  uint32_t  FIFORDNOPOP;                     /*!< FIFO data read with no FIFO pop.                                      */

    struct {
      __I  uint32_t  RXDATA     :  9;               /*!< Received data from the FIFO. The number of bits used depends
                                                         on the DATALEN and PARITYSEL settings.                                */
           uint32_t             :  4;
      __I  uint32_t  FRAMERR    :  1;               /*!< Framing Error status flag. This bit reflects the status for
                                                         the data it is read along with from the FIFO, and indicates
                                                          that the character was received with a missing stop bit at the
                                                          expected location. This could be an indication of a baud rate
                                                          or configuration mismatch with the transmitting source.              */
      __I  uint32_t  PARITYERR  :  1;               /*!< Parity Error status flag. This bit reflects the status for the
                                                         data it is read along with from the FIFO. This bit will be set
                                                          when a parity error is detected in a received character.             */
      __I  uint32_t  RXNOISE    :  1;               /*!< Received Noise flag.                                                  */
    } FIFORDNOPOP_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[109];

  union {
    __IO uint32_t  PSELID;                          /*!< Flexcomm ID and peripheral function select register                   */

    struct {
      __IO uint32_t  PERSEL     :  3;               /*!< Peripheral Select. This field is writable by software. 0x0 No
                                                         peripheral selected. 0x1 USART function selected 0x2 Reserved.
                                                          0x3 Reserved. 0x4 Reserved. 0x5 Reserved. 0x6 Reserved 0x7 Reserved  */
      __IO uint32_t  LOCK       :  1;               /*!< Lock the peripheral select. This field is writable by software.
                                                         0 Peripheral select can be changed by software. 1 Peripheral
                                                          select is locked and cannot be changed until this Flexcomm or
                                                          the entire device is reset.                                          */
      __I  uint32_t  USARTPRESENT:  1;              /*!< USART present indicator. This field is Read-only. 0 This Flexcomm
                                                         does not include the USART function. 1 This Flexcomm includes
                                                          the USART function.                                                  */
           uint32_t             :  7;
      __I  uint32_t  ID         : 20;               /*!< Flexcomm ID.                                                          */
    } PSELID_b;                                     /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  ID;                              /*!< USART Module Identifier                                               */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } ID_b;                                         /*!< BitSize                                                               */
  };
} u1_usart_Type;


/* ================================================================================ */
/* ================                     u0_spi                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component spi. It is a Serial Peripheral Interface with APB bus interface. More details will follow. (u0_spi)
  */

typedef struct {                                    /*!< u0_spi Structure                                                      */
  __I  uint32_t  RESERVED0[256];

  union {
    __IO uint32_t  CFG;                             /*!< SPI Configuration register                                            */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< SPI enable.                                                           */
           uint32_t             :  1;
      __IO uint32_t  MASTER     :  1;               /*!< Master mode select.                                                   */
      __IO uint32_t  LSBF       :  1;               /*!< LSB First mode enable.                                                */
      __IO uint32_t  CPHA       :  1;               /*!< Clock Phase select.                                                   */
      __IO uint32_t  CPOL       :  1;               /*!< Clock Polarity select.                                                */
           uint32_t             :  1;
      __IO uint32_t  LOOP       :  1;               /*!< Loopback mode enable. Loopback mode applies only to Master mode,
                                                         and connects transmit and receive data connected together to
                                                          allow simple software testing.                                       */
      __IO uint32_t  SPOL0      :  1;               /*!< SSEL0 Polarity select.                                                */
      __IO uint32_t  SPOL1      :  1;               /*!< SSEL1 Polarity select. Valid only for SPI-1                           */
      __IO uint32_t  SPOL2      :  1;               /*!< SSEL2 Polarity select. Valid only for SPI-1                           */
      __IO uint32_t  SPOL3      :  1;               /*!< [Reserved] SSEL3 Polarity select.                                     */
    } CFG_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DLY;                             /*!< SPI Delay register                                                    */

    struct {
      __IO uint32_t  PRE_DELAY  :  4;               /*!< Controls the amount of time between SSEL assertion and the beginning
                                                         of a data transfer. There is always one SPI clock time between
                                                          SSEL assertion and the first clock edge. This is not considered
                                                          part of the pre-delay. 0x0 = No additional time is inserted.
                                                          0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times
                                                          are inserted. ... 0xF = 15 SPI clock times are inserted.             */
      __IO uint32_t  POST_DELAY :  4;               /*!< Controls the amount of time between the end of a data transfer
                                                         and SSEL deassertion. 0x0 = No additional time is inserted.
                                                          0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times
                                                          are inserted. ... 0xF = 15 SPI clock times are inserted.             */
      __IO uint32_t  FRAME_DELAY:  4;               /*!< If the EOFR flag is set, controls the minimum amount of time
                                                         between the current frame and the next frame (or SSEL deassertion
                                                          if EOTR). 0x0 = No additional time is inserted. 0x1 = 1 SPI
                                                          clock time is inserted. 0x2 = 2 SPI clock times are inserted.
                                                          ... 0xF = 15 SPI clock times are inserted.                           */
      __IO uint32_t  TRANSFER_DELAY:  4;            /*!< Controls the minimum amount of time that the SSEL is deasserted
                                                         between transfers. 0x0 = The minimum time that SSEL is deasserted
                                                          is 1 SPI clock time. (Zero added time.) 0x1 = The minimum time
                                                          that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum
                                                          time that SSEL is deasserted is 3 SPI clock times. ... 0xF =
                                                          The minimum time that SSEL is deasserted is 16 SPI clock times.      */
    } DLY_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STAT;                            /*!< SPI Status. Some status flags can be cleared by writing a 1
                                                         to that bit position.                                                 */

    struct {
           uint32_t             :  2;
      __IO uint32_t  RXOV       :  1;               /*!< Receiver Overrun interrupt flag. This flag applies only to slave
                                                         mode (Master = 0). This flag is set when the beginning of a
                                                          received character is detected while the receiver buffer is
                                                          still in use. If this occurs, the receiver buffer contents are
                                                          preserved, and the incoming data is lost. Data received by the
                                                          SPI should be considered undefined if RxOv is set.                   */
      __IO uint32_t  TXUR       :  1;               /*!< Transmitter Underrun interrupt flag. This flag applies only
                                                         to slave mode (Master = 0). In this case, the transmitter must
                                                          begin sending new data on the next input clock if the transmitter
                                                          is idle. If that data is not available in the transmitter holding
                                                          register at that point, there is no data to transmit and the
                                                          TXUR flag is set. Data transmitted by the SPI should be considered
                                                          undefined if TXUR is set.                                            */
      __IO uint32_t  SSA        :  1;               /*!< Slave Select Assert. This flag is set whenever any slave select
                                                         transitions from deasserted to asserted, in both master and
                                                          slave modes. This allows determining when the SPI transmit/receive
                                                          functions become busy, and allows waking up the device from
                                                          reduced power modes when a slave mode access begins. This flag
                                                          is cleared by software.                                              */
      __IO uint32_t  SSD        :  1;               /*!< Slave Select Deassert. This flag is set whenever any asserted
                                                         slave selects transition to deasserted, in both master and slave
                                                          modes. This allows determining when the SPI transmit/receive
                                                          functions become idle. This flag is cleared by software.             */
      __I  uint32_t  STALLED    :  1;               /*!< Stalled status flag. This indicates whether the SPI is currently
                                                         in a stall condition.                                                 */
      __IO uint32_t  ENDTRANSFER:  1;               /*!< End Transfer control bit. Software can set this bit to force
                                                         an end to the current transfer when the transmitter finishes
                                                          any activity already in progress, as if the EOTR flag had been
                                                          set prior to the last transmission. This capability is included
                                                          to support cases where it is not known when transmit data is
                                                          written that it will be the end of a transfer. The bit is cleared
                                                          when the transmitter becomes idle as the transfer comes to an
                                                          end. Forcing an end of transfer in this manner causes any specified
                                                          FRAME                                                                */
      __I  uint32_t  MSTIDLE    :  1;               /*!< Master idle status flag. This bit is 1 whenever the SPI master
                                                         function is fully idle. This means that the transmit holding
                                                          register is empty and the transmitter is not in the process
                                                          of sending data.                                                     */
    } STAT_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENSET;                        /*!< SPI Interrupt Enable read and Set. A complete value may be read
                                                         from this register. Writing a 1 to any implemented bit position
                                                          causes that bit to be set.                                           */

    struct {
           uint32_t             :  2;
      __IO uint32_t  RXOVEN     :  1;               /*!< RX overrun interrupt enable. Determines whether an interrupt
                                                         occurs when a receiver overrun occurs. This happens in slave
                                                          mode when there is a need for the receiver to move newly received
                                                          data to the RXDAT register when it is already in use. The interface
                                                          prevents receiver overrun in Master mode by not allowing a new
                                                          transmission to begin when a receiver overrun would otherwise
                                                          occur.                                                               */
      __IO uint32_t  TXUREN     :  1;               /*!< TX underrun interrupt enable. Determines whether an interrupt
                                                         occurs when a transmitter underrun occurs. This happens in slave
                                                          mode when there is a need to transmit data when none is available.   */
      __IO uint32_t  SSAEN      :  1;               /*!< Slave select assert interrupt enable. Determines whether an
                                                         interrupt occurs when the Slave Select is asserted.                   */
      __IO uint32_t  SSDEN      :  1;               /*!< Slave select deassert interrupt enable. Determines whether an
                                                         interrupt occurs when the Slave Select is deasserted.                 */
           uint32_t             :  2;
      __IO uint32_t  MSTIDLEEN  :  1;               /*!< Master idle interrupt enable.                                         */
    } INTENSET_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENCLR;                        /*!< SPI Interrupt Enable Clear. Writing a 1 to any implemented bit
                                                         position causes the corresponding bit in INTENSET to be cleared.      */

    struct {
           uint32_t             :  2;
      __IO uint32_t  RXOVCLR    :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __IO uint32_t  TXURCLR    :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __IO uint32_t  SSACLR     :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __IO uint32_t  SSDCLR     :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
           uint32_t             :  2;
      __IO uint32_t  MSTIDLECLR :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
    } INTENCLR_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[3];

  union {
    __IO uint32_t  TXCTL;                           /*!< SPI Transmit Control. If Transmit FIFO is enabled, in FIFOCFG,
                                                         then values read in this register are affected values in FIFO.        */

    struct {
           uint32_t             : 16;
      __IO uint32_t  TXSSEL0_N  :  1;               /*!< Transmit Slave Select 0.                                              */
      __IO uint32_t  TXSSEL1_N  :  1;               /*!< Transmit Slave Select 1. Valid only for SPI-1                         */
      __IO uint32_t  TXSSEL2_N  :  1;               /*!< Transmit Slave Select 2. Valid only for SPI-1                         */
      __IO uint32_t  TXSSEL3_N  :  1;               /*!< [Reserved] Transmit Slave Select 3.                                   */
      __IO uint32_t  EOTR       :  1;               /*!< End of Transfer.                                                      */
      __IO uint32_t  EOFR       :  1;               /*!< End of Frame.                                                         */
      __IO uint32_t  RXIGNORE   :  1;               /*!< Receive Ignore.                                                       */
           uint32_t             :  1;
      __IO uint32_t  LEN        :  4;               /*!< Data transfer Length.                                                 */
    } TXCTL_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DIV;                             /*!< SPI clock Divider                                                     */

    struct {
      __IO uint32_t  DIVVAL     : 16;               /*!< Rate divider value. Specifies how the SPI Module clock is divided
                                                         to produce the SPI clock rate in master mode. DIVVAL is -1 encoded
                                                          such that the value 0 results in SPICLK/1, the value 1 results
                                                          in SPICLK/2, up to the maximum possible divide value of 0xFFFF,
                                                          which results in SPICLK/65536.                                       */
    } DIV_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  INTSTAT;                         /*!< SPI Interrupt Status                                                  */

    struct {
           uint32_t             :  2;
      __I  uint32_t  RXOV       :  1;               /*!< Receiver Overrun interrupt flag.                                      */
      __I  uint32_t  TXUR       :  1;               /*!< Transmitter Underrun interrupt flag.                                  */
      __I  uint32_t  SSA        :  1;               /*!< Slave Select Assert.                                                  */
      __I  uint32_t  SSD        :  1;               /*!< Slave Select Deassert.                                                */
           uint32_t             :  2;
      __I  uint32_t  MSTIDLE    :  1;               /*!< Master Idle status flag.                                              */
    } INTSTAT_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[629];

  union {
    __IO uint32_t  FIFOCFG;                         /*!< FIFO configuration and enable register.                               */

    struct {
      __IO uint32_t  ENABLETX   :  1;               /*!< Enable the transmit FIFO. This is automatically enabled when
                                                         PSELID.PERSEL is set to 2 to configure for SPI functionality          */
      __IO uint32_t  ENABLERX   :  1;               /*!< Enable the receive FIFO. This is automatically enabled when
                                                         PSELID.PERSEL is set to 2 to configure for SPI functionality          */
           uint32_t             :  2;
      __I  uint32_t  SIZE       :  2;               /*!< FIFO size configuration. This is a read-only field. 0x0 = Reset
                                                         value. 0x1 = FIFO is configured as 4 entries of 16bits. This
                                                          value is read after PSELID.PERSEL=2 for SPI functionlaity. 0x2,
                                                          0x3 = not applicable.                                                */
           uint32_t             :  6;
      __IO uint32_t  DMATX      :  1;               /*!< DMA configuration for transmit.                                       */
      __IO uint32_t  DMARX      :  1;               /*!< DMA configuration for receive.                                        */
      __IO uint32_t  WAKETX     :  1;               /*!< Wakeup for transmit FIFO level. This allows the device to be
                                                         woken from reduced power modes (up to power-down, as long as
                                                          the peripheral function works in that power mode) without enabling
                                                          the TXLVL interrupt. Only DMA wakes up, processes data, and
                                                          goes back to sleep. The CPU will remain stopped until woken
                                                          by another cause, such as DMA completion.                            */
      __IO uint32_t  WAKERX     :  1;               /*!< Wakeup for receive FIFO level. This allows the device to be
                                                         woken from reduced power modes (up to power-down, as long as
                                                          the peripheral function works in that power mode) without enabling
                                                          the TXLVL interrupt. Only DMA wakes up, processes data, and
                                                          goes back to sleep. The CPU will remain stopped until woken
                                                          by another cause, such as DMA completion.                            */
      __IO uint32_t  EMPTYTX    :  1;               /*!< Empty command for the transmit FIFO. When a 1 is written to
                                                         this bit, the TX FIFO is emptied.                                     */
      __IO uint32_t  EMPTYRX    :  1;               /*!< Empty command for the receive FIFO. When a 1 is written to this
                                                         bit, the RX FIFO is emptied.                                          */
      __IO uint32_t  POPDBG     :  1;               /*!< Pop FIFO for debug reads.                                             */
    } FIFOCFG_b;                                    /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FIFOSTAT;                        /*!< FIFO status register.                                                 */

    struct {
      __I  uint32_t  TXERR      :  1;               /*!< TX FIFO error. Will be set if a transmit FIFO error occurs.
                                                         This could be an overflow caused by pushing data into a full
                                                          FIFO, or by an underflow if the FIFO is empty when data is needed.
                                                          Cleared by writing a 1 to this bit.                                  */
      __I  uint32_t  RXERR      :  1;               /*!< RX FIFO error. Will be set if a receive FIFO overflow occurs,
                                                         caused by software or DMA not emptying the FIFO fast enough.
                                                          Cleared by writing a 1 to this bit.                                  */
           uint32_t             :  1;
      __I  uint32_t  PERINT     :  1;               /*!< Peripheral interrupt. When 1, this indicates that the peripheral
                                                         function has asserted an interrupt. The details can be found
                                                          by reading the peripheral s STAT register.                           */
      __I  uint32_t  TXEMPTY    :  1;               /*!< Transmit FIFO empty. When 1, the transmit FIFO is empty. The
                                                         peripheral may still be processing the last piece of data.            */
      __I  uint32_t  TXNOTFULL  :  1;               /*!< Transmit FIFO not full. When 1, the transmit FIFO is not full,
                                                         so more data can be written. When 0, the transmit FIFO is full
                                                          and another write would cause it to overflow.                        */
      __I  uint32_t  RXNOTEMPTY :  1;               /*!< Receive FIFO not empty. When 1, the receive FIFO is not empty,
                                                         so data can be read. When 0, the receive FIFO is empty.               */
      __I  uint32_t  RXFULL     :  1;               /*!< Receive FIFO full. When 1, the receive FIFO is full. Data needs
                                                         to be read out to prevent the peripheral from causing an overflow.    */
      __I  uint32_t  TXLVL      :  5;               /*!< Transmit FIFO current level. A 0 means the TX FIFO is currently
                                                         empty, and the TXEMPTY and TXNOTFULL flags will be 1. Other
                                                          values tell how much data is actually in the TX FIFO at the
                                                          point where the read occurs. If the TX FIFO is full, the TXEMPTY
                                                          and TXNOTFULL flags will be 0.                                       */
           uint32_t             :  3;
      __I  uint32_t  RXLVL      :  5;               /*!< Receive FIFO current level. A 0 means the RX FIFO is currently
                                                         empty, and the RXFULL and RXNOTEMPTY flags will be 0. Other
                                                          values tell how much data is actually in the RX FIFO at the
                                                          point where the read occurs. If the RX FIFO is full, the RXFULL
                                                          and RXNOTEMPTY flags will be 1.                                      */
    } FIFOSTAT_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFOTRIG;                        /*!< FIFO trigger settings for interrupt and DMA request.                  */

    struct {
      __IO uint32_t  TXLVLENA   :  1;               /*!< Transmit FIFO level trigger enable. This trigger will become
                                                         an interrupt if enabled in FIFOINTENSET, or a DMA trigger if
                                                          DMATX in FIFOCFG is set.                                             */
      __IO uint32_t  RXLVLENA   :  1;               /*!< Receive FIFO level trigger enable. This trigger will become
                                                         an interrupt if enabled in FIFOINTENSET, or a DMA trigger if
                                                          DMARX in FIFOCFG is set.                                             */
           uint32_t             :  6;
      __IO uint32_t  TXLVL      :  4;               /*!< Transmit FIFO level trigger point. This field is used only when
                                                         TXLVLENA = 1. 0 = trigger when the TX FIFO becomes empty. 1
                                                          = trigger when the TX FIFO level decreases to one entry. ...
                                                          7 = 1 = trigger when the TX FIFO level decreases to 7 entries
                                                          (is no longer full).                                                 */
           uint32_t             :  4;
      __IO uint32_t  RXLVL      :  4;               /*!< Receive FIFO level trigger point. The RX FIFO level is checked
                                                         when a new piece of data is received. This field is used only
                                                          when RXLVLENA = 1. 0 = trigger when the RX FIFO has received
                                                          one entry (is no longer empty). 1 = trigger when the RX FIFO
                                                          has received two entries. ... 7 = trigger when the RX FIFO has
                                                          received 8 entries (has become full).                                */
    } FIFOTRIG_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3;

  union {
    __IO uint32_t  FIFOINTENSET;                    /*!< FIFO interrupt enable set (enable) and read register.                 */

    struct {
      __IO uint32_t  TXERR      :  1;               /*!< Determines whether an interrupt occurs when a transmit error
                                                         occurs, based on the TXERR flag in the FIFOSTAT register.             */
      __IO uint32_t  RXERR      :  1;               /*!< Determines whether an interrupt occurs when a receive error
                                                         occurs, based on the RXERR flag in the FIFOSTAT register.             */
      __IO uint32_t  TXLVL      :  1;               /*!< Determines whether an interrupt occurs when a the transmit FIFO
                                                         reaches the level specified by the TXLVL field in the FIFOTRIG
                                                          register.                                                            */
      __IO uint32_t  RXLVL      :  1;               /*!< Determines whether an interrupt occurs when a the receive FIFO
                                                         reaches the level specified by the TXLVL field in the FIFOTRIG
                                                          register.                                                            */
    } FIFOINTENSET_b;                               /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFOINTENCLR;                    /*!< FIFO interrupt enable clear (disable) and read register.              */

    struct {
      __IO uint32_t  TXERR      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  RXERR      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  TXLVL      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  RXLVL      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
    } FIFOINTENCLR_b;                               /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FIFOINTSTAT;                     /*!< FIFO interrupt status register.                                       */

    struct {
      __I  uint32_t  TXERR      :  1;               /*!< TX FIFO error.                                                        */
      __I  uint32_t  RXERR      :  1;               /*!< RX FIFO error.                                                        */
      __I  uint32_t  TXLVL      :  1;               /*!< Transmit FIFO level interrupt.                                        */
      __I  uint32_t  RXLVL      :  1;               /*!< Receive FIFO level interrupt.                                         */
      __I  uint32_t  PERINT     :  1;               /*!< Peripheral interrupt.                                                 */
    } FIFOINTSTAT_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4;

  union {
    __O  uint32_t  FIFOWR;                          /*!< FIFO write data. FIFO data not reset by block reset                   */

    struct {
      __O  uint32_t  TXDATA     : 16;               /*!< Transmit data to the FIFO.                                            */
      __O  uint32_t  TXSSEL0_N  :  1;               /*!< Transmit Slave Select. This field asserts SSEL0 in master mode.
                                                         The output on the pin is active LOW by default. Remark: The
                                                          active state of the SSEL0 pin is configured by bits in the CFG
                                                          register.                                                            */
      __O  uint32_t  TXSSEL1_N  :  1;               /*!< Transmit Slave Select. This field asserts SSEL1 in master mode.
                                                         The output on the pin is active LOW by default. Remark: The
                                                          active state of the SSEL1 pin is configured by bits in the CFG
                                                          register.                                                            */
      __O  uint32_t  TXSSEL2_N  :  1;               /*!< Transmit Slave Select. This field asserts SSEL2 in master mode.
                                                         The output on the pin is active LOW by default. Remark: The
                                                          active state of the SSEL2 pin is configured by bits in the CFG
                                                          register.                                                            */
      __O  uint32_t  TXSSEL3_N  :  1;               /*!< Transmit Slave Select. This field asserts SSEL3 in master mode.
                                                         The output on the pin is active LOW by default. Remark: The
                                                          active state of the SSEL3 pin is configured by bits in the CFG
                                                          register.                                                            */
      __O  uint32_t  EOTR       :  1;               /*!< End of Transfer. The asserted SSEL will be deasserted at the
                                                         end of a transfer, and remain so for at least the time specified
                                                          by the Transfer_delay value in the DLY register.                     */
      __O  uint32_t  EOFR       :  1;               /*!< End of Frame. Between frames, a delay may be inserted, as defined
                                                         by the FRAME_DELAY value in the DLY register. The end of a frame
                                                          may not be particularly meaningful if the FRAME_DELAY value
                                                          = 0. This control can be used as part of the support for frame
                                                          lengths greater than 16 bits.                                        */
      __O  uint32_t  RXIGNORE   :  1;               /*!< Receive Ignore. This allows data to be transmitted using the
                                                         SPI without the need to read unneeded data from the receiver.Setting
                                                          this bit simplifies the transmit process and can be used with
                                                          the DMA.                                                             */
           uint32_t             :  1;
      __O  uint32_t  LEN        :  4;               /*!< Data Length. Specifies the data length from 1 to 16 bits. Note
                                                         that transfer lengths greater than 16 bits are supported by
                                                          implementing multiple sequential transmits. 0x0 = Data transfer
                                                          is 1 bit in length. Note: when LEN = 0, the underrun status
                                                          is not meaningful. 0x1 = Data transfer is 2 bits in length.
                                                          0x2 = Data transfer is 3 bits in length. ... 0xF = Data transfer
                                                          is 16 bits in length.                                                */
    } FIFOWR_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[3];

  union {
    __I  uint32_t  FIFORD;                          /*!< FIFO read data.                                                       */

    struct {
      __I  uint32_t  RXDATA     : 16;               /*!< Received data from the FIFO.                                          */
      __I  uint32_t  RXSSEL0_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL0 pin to be saved along with received data. The value will
                                                          reflect the SSEL0 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL1_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL1 pin to be saved along with received data. The value will
                                                          reflect the SSEL1 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL2_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL2 pin to be saved along with received data. The value will
                                                          reflect the SSEL2 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL3_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL3 pin to be saved along with received data. The value will
                                                          reflect the SSEL3 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  SOT        :  1;               /*!< Start of Transfer flag. This flag will be 1 if this is the first
                                                         data after the SSELs went from deasserted to asserted (i.e.,
                                                          any previous transfer has ended). This information can be used
                                                          to identify the first piece of data in cases where the transfer
                                                          length is greater than 16 bit.                                       */
    } FIFORD_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[3];

  union {
    __I  uint32_t  FIFORDNOPOP;                     /*!< FIFO data read with no FIFO pop.                                      */

    struct {
      __I  uint32_t  RXDATA     : 16;               /*!< Received data from the FIFO.                                          */
      __I  uint32_t  RXSSEL0_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL0 pin to be saved along with received data. The value will
                                                          reflect the SSEL0 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL1_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL1 pin to be saved along with received data. The value will
                                                          reflect the SSEL1 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL2_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL2 pin to be saved along with received data. The value will
                                                          reflect the SSEL2 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL3_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL3 pin to be saved along with received data. The value will
                                                          reflect the SSEL3 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  SOT        :  1;               /*!< Start of Transfer flag. This flag will be 1 if this is the first
                                                         data after the SSELs went from deasserted to asserted (i.e.,
                                                          any previous transfer has ended). This information can be used
                                                          to identify the first piece of data in cases where the transfer
                                                          length is greater than 16 bit.                                       */
    } FIFORDNOPOP_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7[109];

  union {
    __IO uint32_t  PSELID;                          /*!< Flexcomm ID and peripheral function select register                   */

    struct {
      __IO uint32_t  PERSEL     :  3;               /*!< Peripheral Select. This field is writable by software. 0x0 No
                                                         peripheral selected. 0x1 Reserved. 0x2 SPI function selected
                                                          0x3 Reserved. 0x4 Reserved. 0x5 Reserved. 0x6 Reserved 0x7 Reserved  */
      __IO uint32_t  LOCK       :  1;               /*!< Lock the peripheral select. This field is writable by software.
                                                         0 Peripheral select can be changed by software. 1 Peripheral
                                                          select is locked and cannot be changed until this Flexcomm or
                                                          the entire device is reset.                                          */
           uint32_t             :  1;
      __I  uint32_t  SPIPRESENT :  1;               /*!< SPI present indicator. This field is Read-only. 0 This peripheral
                                                         does not include the SPI function. 1 This peripheral includes
                                                          the SPI function.                                                    */
           uint32_t             :  6;
      __I  uint32_t  ID         : 20;               /*!< Flexcomm ID.                                                          */
    } PSELID_b;                                     /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  ID;                              /*!< SPI Module Identifier                                                 */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } ID_b;                                         /*!< BitSize                                                               */
  };
} u0_spi_Type;


/* ================================================================================ */
/* ================                     u1_spi                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component spi. It is a Serial Peripheral Interface with APB bus interface. More details will follow. (u1_spi)
  */

typedef struct {                                    /*!< u1_spi Structure                                                      */
  __I  uint32_t  RESERVED0[256];

  union {
    __IO uint32_t  CFG;                             /*!< SPI Configuration register                                            */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< SPI enable.                                                           */
           uint32_t             :  1;
      __IO uint32_t  MASTER     :  1;               /*!< Master mode select.                                                   */
      __IO uint32_t  LSBF       :  1;               /*!< LSB First mode enable.                                                */
      __IO uint32_t  CPHA       :  1;               /*!< Clock Phase select.                                                   */
      __IO uint32_t  CPOL       :  1;               /*!< Clock Polarity select.                                                */
           uint32_t             :  1;
      __IO uint32_t  LOOP       :  1;               /*!< Loopback mode enable. Loopback mode applies only to Master mode,
                                                         and connects transmit and receive data connected together to
                                                          allow simple software testing.                                       */
      __IO uint32_t  SPOL0      :  1;               /*!< SSEL0 Polarity select.                                                */
      __IO uint32_t  SPOL1      :  1;               /*!< SSEL1 Polarity select. Valid only for SPI-1                           */
      __IO uint32_t  SPOL2      :  1;               /*!< SSEL2 Polarity select. Valid only for SPI-1                           */
      __IO uint32_t  SPOL3      :  1;               /*!< [Reserved] SSEL3 Polarity select.                                     */
    } CFG_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DLY;                             /*!< SPI Delay register                                                    */

    struct {
      __IO uint32_t  PRE_DELAY  :  4;               /*!< Controls the amount of time between SSEL assertion and the beginning
                                                         of a data transfer. There is always one SPI clock time between
                                                          SSEL assertion and the first clock edge. This is not considered
                                                          part of the pre-delay. 0x0 = No additional time is inserted.
                                                          0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times
                                                          are inserted. ... 0xF = 15 SPI clock times are inserted.             */
      __IO uint32_t  POST_DELAY :  4;               /*!< Controls the amount of time between the end of a data transfer
                                                         and SSEL deassertion. 0x0 = No additional time is inserted.
                                                          0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times
                                                          are inserted. ... 0xF = 15 SPI clock times are inserted.             */
      __IO uint32_t  FRAME_DELAY:  4;               /*!< If the EOFR flag is set, controls the minimum amount of time
                                                         between the current frame and the next frame (or SSEL deassertion
                                                          if EOTR). 0x0 = No additional time is inserted. 0x1 = 1 SPI
                                                          clock time is inserted. 0x2 = 2 SPI clock times are inserted.
                                                          ... 0xF = 15 SPI clock times are inserted.                           */
      __IO uint32_t  TRANSFER_DELAY:  4;            /*!< Controls the minimum amount of time that the SSEL is deasserted
                                                         between transfers. 0x0 = The minimum time that SSEL is deasserted
                                                          is 1 SPI clock time. (Zero added time.) 0x1 = The minimum time
                                                          that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum
                                                          time that SSEL is deasserted is 3 SPI clock times. ... 0xF =
                                                          The minimum time that SSEL is deasserted is 16 SPI clock times.      */
    } DLY_b;                                        /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STAT;                            /*!< SPI Status. Some status flags can be cleared by writing a 1
                                                         to that bit position.                                                 */

    struct {
           uint32_t             :  2;
      __IO uint32_t  RXOV       :  1;               /*!< Receiver Overrun interrupt flag. This flag applies only to slave
                                                         mode (Master = 0). This flag is set when the beginning of a
                                                          received character is detected while the receiver buffer is
                                                          still in use. If this occurs, the receiver buffer contents are
                                                          preserved, and the incoming data is lost. Data received by the
                                                          SPI should be considered undefined if RxOv is set.                   */
      __IO uint32_t  TXUR       :  1;               /*!< Transmitter Underrun interrupt flag. This flag applies only
                                                         to slave mode (Master = 0). In this case, the transmitter must
                                                          begin sending new data on the next input clock if the transmitter
                                                          is idle. If that data is not available in the transmitter holding
                                                          register at that point, there is no data to transmit and the
                                                          TXUR flag is set. Data transmitted by the SPI should be considered
                                                          undefined if TXUR is set.                                            */
      __IO uint32_t  SSA        :  1;               /*!< Slave Select Assert. This flag is set whenever any slave select
                                                         transitions from deasserted to asserted, in both master and
                                                          slave modes. This allows determining when the SPI transmit/receive
                                                          functions become busy, and allows waking up the device from
                                                          reduced power modes when a slave mode access begins. This flag
                                                          is cleared by software.                                              */
      __IO uint32_t  SSD        :  1;               /*!< Slave Select Deassert. This flag is set whenever any asserted
                                                         slave selects transition to deasserted, in both master and slave
                                                          modes. This allows determining when the SPI transmit/receive
                                                          functions become idle. This flag is cleared by software.             */
      __I  uint32_t  STALLED    :  1;               /*!< Stalled status flag. This indicates whether the SPI is currently
                                                         in a stall condition.                                                 */
      __IO uint32_t  ENDTRANSFER:  1;               /*!< End Transfer control bit. Software can set this bit to force
                                                         an end to the current transfer when the transmitter finishes
                                                          any activity already in progress, as if the EOTR flag had been
                                                          set prior to the last transmission. This capability is included
                                                          to support cases where it is not known when transmit data is
                                                          written that it will be the end of a transfer. The bit is cleared
                                                          when the transmitter becomes idle as the transfer comes to an
                                                          end. Forcing an end of transfer in this manner causes any specified
                                                          FRAME                                                                */
      __I  uint32_t  MSTIDLE    :  1;               /*!< Master idle status flag. This bit is 1 whenever the SPI master
                                                         function is fully idle. This means that the transmit holding
                                                          register is empty and the transmitter is not in the process
                                                          of sending data.                                                     */
    } STAT_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENSET;                        /*!< SPI Interrupt Enable read and Set. A complete value may be read
                                                         from this register. Writing a 1 to any implemented bit position
                                                          causes that bit to be set.                                           */

    struct {
           uint32_t             :  2;
      __IO uint32_t  RXOVEN     :  1;               /*!< RX overrun interrupt enable. Determines whether an interrupt
                                                         occurs when a receiver overrun occurs. This happens in slave
                                                          mode when there is a need for the receiver to move newly received
                                                          data to the RXDAT register when it is already in use. The interface
                                                          prevents receiver overrun in Master mode by not allowing a new
                                                          transmission to begin when a receiver overrun would otherwise
                                                          occur.                                                               */
      __IO uint32_t  TXUREN     :  1;               /*!< TX underrun interrupt enable. Determines whether an interrupt
                                                         occurs when a transmitter underrun occurs. This happens in slave
                                                          mode when there is a need to transmit data when none is available.   */
      __IO uint32_t  SSAEN      :  1;               /*!< Slave select assert interrupt enable. Determines whether an
                                                         interrupt occurs when the Slave Select is asserted.                   */
      __IO uint32_t  SSDEN      :  1;               /*!< Slave select deassert interrupt enable. Determines whether an
                                                         interrupt occurs when the Slave Select is deasserted.                 */
           uint32_t             :  2;
      __IO uint32_t  MSTIDLEEN  :  1;               /*!< Master idle interrupt enable.                                         */
    } INTENSET_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTENCLR;                        /*!< SPI Interrupt Enable Clear. Writing a 1 to any implemented bit
                                                         position causes the corresponding bit in INTENSET to be cleared.      */

    struct {
           uint32_t             :  2;
      __IO uint32_t  RXOVCLR    :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __IO uint32_t  TXURCLR    :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __IO uint32_t  SSACLR     :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
      __IO uint32_t  SSDCLR     :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
           uint32_t             :  2;
      __IO uint32_t  MSTIDLECLR :  1;               /*!< Writing 1 clears the corresponding bit in the INTENSET register.      */
    } INTENCLR_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[3];

  union {
    __IO uint32_t  TXCTL;                           /*!< SPI Transmit Control. If Transmit FIFO is enabled, in FIFOCFG,
                                                         then values read in this register are affected values in FIFO.        */

    struct {
           uint32_t             : 16;
      __IO uint32_t  TXSSEL0_N  :  1;               /*!< Transmit Slave Select 0.                                              */
      __IO uint32_t  TXSSEL1_N  :  1;               /*!< Transmit Slave Select 1. Valid only for SPI-1                         */
      __IO uint32_t  TXSSEL2_N  :  1;               /*!< Transmit Slave Select 2. Valid only for SPI-1                         */
      __IO uint32_t  TXSSEL3_N  :  1;               /*!< [Reserved] Transmit Slave Select 3.                                   */
      __IO uint32_t  EOTR       :  1;               /*!< End of Transfer.                                                      */
      __IO uint32_t  EOFR       :  1;               /*!< End of Frame.                                                         */
      __IO uint32_t  RXIGNORE   :  1;               /*!< Receive Ignore.                                                       */
           uint32_t             :  1;
      __IO uint32_t  LEN        :  4;               /*!< Data transfer Length.                                                 */
    } TXCTL_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  DIV;                             /*!< SPI clock Divider                                                     */

    struct {
      __IO uint32_t  DIVVAL     : 16;               /*!< Rate divider value. Specifies how the SPI Module clock is divided
                                                         to produce the SPI clock rate in master mode. DIVVAL is -1 encoded
                                                          such that the value 0 results in SPICLK/1, the value 1 results
                                                          in SPICLK/2, up to the maximum possible divide value of 0xFFFF,
                                                          which results in SPICLK/65536.                                       */
    } DIV_b;                                        /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  INTSTAT;                         /*!< SPI Interrupt Status                                                  */

    struct {
           uint32_t             :  2;
      __I  uint32_t  RXOV       :  1;               /*!< Receiver Overrun interrupt flag.                                      */
      __I  uint32_t  TXUR       :  1;               /*!< Transmitter Underrun interrupt flag.                                  */
      __I  uint32_t  SSA        :  1;               /*!< Slave Select Assert.                                                  */
      __I  uint32_t  SSD        :  1;               /*!< Slave Select Deassert.                                                */
           uint32_t             :  2;
      __I  uint32_t  MSTIDLE    :  1;               /*!< Master Idle status flag.                                              */
    } INTSTAT_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[629];

  union {
    __IO uint32_t  FIFOCFG;                         /*!< FIFO configuration and enable register.                               */

    struct {
      __IO uint32_t  ENABLETX   :  1;               /*!< Enable the transmit FIFO. This is automatically enabled when
                                                         PSELID.PERSEL is set to 2 to configure for SPI functionality          */
      __IO uint32_t  ENABLERX   :  1;               /*!< Enable the receive FIFO. This is automatically enabled when
                                                         PSELID.PERSEL is set to 2 to configure for SPI functionality          */
           uint32_t             :  2;
      __I  uint32_t  SIZE       :  2;               /*!< FIFO size configuration. This is a read-only field. 0x0 = Reset
                                                         value. 0x1 = FIFO is configured as 4 entries of 16bits. This
                                                          value is read after PSELID.PERSEL=2 for SPI functionlaity. 0x2,
                                                          0x3 = not applicable.                                                */
           uint32_t             :  6;
      __IO uint32_t  DMATX      :  1;               /*!< DMA configuration for transmit.                                       */
      __IO uint32_t  DMARX      :  1;               /*!< DMA configuration for receive.                                        */
      __IO uint32_t  WAKETX     :  1;               /*!< Wakeup for transmit FIFO level. This allows the device to be
                                                         woken from reduced power modes (up to power-down, as long as
                                                          the peripheral function works in that power mode) without enabling
                                                          the TXLVL interrupt. Only DMA wakes up, processes data, and
                                                          goes back to sleep. The CPU will remain stopped until woken
                                                          by another cause, such as DMA completion.                            */
      __IO uint32_t  WAKERX     :  1;               /*!< Wakeup for receive FIFO level. This allows the device to be
                                                         woken from reduced power modes (up to power-down, as long as
                                                          the peripheral function works in that power mode) without enabling
                                                          the TXLVL interrupt. Only DMA wakes up, processes data, and
                                                          goes back to sleep. The CPU will remain stopped until woken
                                                          by another cause, such as DMA completion.                            */
      __IO uint32_t  EMPTYTX    :  1;               /*!< Empty command for the transmit FIFO. When a 1 is written to
                                                         this bit, the TX FIFO is emptied.                                     */
      __IO uint32_t  EMPTYRX    :  1;               /*!< Empty command for the receive FIFO. When a 1 is written to this
                                                         bit, the RX FIFO is emptied.                                          */
      __IO uint32_t  POPDBG     :  1;               /*!< Pop FIFO for debug reads.                                             */
    } FIFOCFG_b;                                    /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FIFOSTAT;                        /*!< FIFO status register.                                                 */

    struct {
      __I  uint32_t  TXERR      :  1;               /*!< TX FIFO error. Will be set if a transmit FIFO error occurs.
                                                         This could be an overflow caused by pushing data into a full
                                                          FIFO, or by an underflow if the FIFO is empty when data is needed.
                                                          Cleared by writing a 1 to this bit.                                  */
      __I  uint32_t  RXERR      :  1;               /*!< RX FIFO error. Will be set if a receive FIFO overflow occurs,
                                                         caused by software or DMA not emptying the FIFO fast enough.
                                                          Cleared by writing a 1 to this bit.                                  */
           uint32_t             :  1;
      __I  uint32_t  PERINT     :  1;               /*!< Peripheral interrupt. When 1, this indicates that the peripheral
                                                         function has asserted an interrupt. The details can be found
                                                          by reading the peripheral s STAT register.                           */
      __I  uint32_t  TXEMPTY    :  1;               /*!< Transmit FIFO empty. When 1, the transmit FIFO is empty. The
                                                         peripheral may still be processing the last piece of data.            */
      __I  uint32_t  TXNOTFULL  :  1;               /*!< Transmit FIFO not full. When 1, the transmit FIFO is not full,
                                                         so more data can be written. When 0, the transmit FIFO is full
                                                          and another write would cause it to overflow.                        */
      __I  uint32_t  RXNOTEMPTY :  1;               /*!< Receive FIFO not empty. When 1, the receive FIFO is not empty,
                                                         so data can be read. When 0, the receive FIFO is empty.               */
      __I  uint32_t  RXFULL     :  1;               /*!< Receive FIFO full. When 1, the receive FIFO is full. Data needs
                                                         to be read out to prevent the peripheral from causing an overflow.    */
      __I  uint32_t  TXLVL      :  5;               /*!< Transmit FIFO current level. A 0 means the TX FIFO is currently
                                                         empty, and the TXEMPTY and TXNOTFULL flags will be 1. Other
                                                          values tell how much data is actually in the TX FIFO at the
                                                          point where the read occurs. If the TX FIFO is full, the TXEMPTY
                                                          and TXNOTFULL flags will be 0.                                       */
           uint32_t             :  3;
      __I  uint32_t  RXLVL      :  5;               /*!< Receive FIFO current level. A 0 means the RX FIFO is currently
                                                         empty, and the RXFULL and RXNOTEMPTY flags will be 0. Other
                                                          values tell how much data is actually in the RX FIFO at the
                                                          point where the read occurs. If the RX FIFO is full, the RXFULL
                                                          and RXNOTEMPTY flags will be 1.                                      */
    } FIFOSTAT_b;                                   /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFOTRIG;                        /*!< FIFO trigger settings for interrupt and DMA request.                  */

    struct {
      __IO uint32_t  TXLVLENA   :  1;               /*!< Transmit FIFO level trigger enable. This trigger will become
                                                         an interrupt if enabled in FIFOINTENSET, or a DMA trigger if
                                                          DMATX in FIFOCFG is set.                                             */
      __IO uint32_t  RXLVLENA   :  1;               /*!< Receive FIFO level trigger enable. This trigger will become
                                                         an interrupt if enabled in FIFOINTENSET, or a DMA trigger if
                                                          DMARX in FIFOCFG is set.                                             */
           uint32_t             :  6;
      __IO uint32_t  TXLVL      :  4;               /*!< Transmit FIFO level trigger point. This field is used only when
                                                         TXLVLENA = 1. 0 = trigger when the TX FIFO becomes empty. 1
                                                          = trigger when the TX FIFO level decreases to one entry. ...
                                                          7 = 1 = trigger when the TX FIFO level decreases to 7 entries
                                                          (is no longer full).                                                 */
           uint32_t             :  4;
      __IO uint32_t  RXLVL      :  4;               /*!< Receive FIFO level trigger point. The RX FIFO level is checked
                                                         when a new piece of data is received. This field is used only
                                                          when RXLVLENA = 1. 0 = trigger when the RX FIFO has received
                                                          one entry (is no longer empty). 1 = trigger when the RX FIFO
                                                          has received two entries. ... 7 = trigger when the RX FIFO has
                                                          received 8 entries (has become full).                                */
    } FIFOTRIG_b;                                   /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3;

  union {
    __IO uint32_t  FIFOINTENSET;                    /*!< FIFO interrupt enable set (enable) and read register.                 */

    struct {
      __IO uint32_t  TXERR      :  1;               /*!< Determines whether an interrupt occurs when a transmit error
                                                         occurs, based on the TXERR flag in the FIFOSTAT register.             */
      __IO uint32_t  RXERR      :  1;               /*!< Determines whether an interrupt occurs when a receive error
                                                         occurs, based on the RXERR flag in the FIFOSTAT register.             */
      __IO uint32_t  TXLVL      :  1;               /*!< Determines whether an interrupt occurs when a the transmit FIFO
                                                         reaches the level specified by the TXLVL field in the FIFOTRIG
                                                          register.                                                            */
      __IO uint32_t  RXLVL      :  1;               /*!< Determines whether an interrupt occurs when a the receive FIFO
                                                         reaches the level specified by the TXLVL field in the FIFOTRIG
                                                          register.                                                            */
    } FIFOINTENSET_b;                               /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  FIFOINTENCLR;                    /*!< FIFO interrupt enable clear (disable) and read register.              */

    struct {
      __IO uint32_t  TXERR      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  RXERR      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  TXLVL      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
      __IO uint32_t  RXLVL      :  1;               /*!< Writing 1 clears the corresponding bit in the FIFOINTENSET register   */
    } FIFOINTENCLR_b;                               /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  FIFOINTSTAT;                     /*!< FIFO interrupt status register.                                       */

    struct {
      __I  uint32_t  TXERR      :  1;               /*!< TX FIFO error.                                                        */
      __I  uint32_t  RXERR      :  1;               /*!< RX FIFO error.                                                        */
      __I  uint32_t  TXLVL      :  1;               /*!< Transmit FIFO level interrupt.                                        */
      __I  uint32_t  RXLVL      :  1;               /*!< Receive FIFO level interrupt.                                         */
      __I  uint32_t  PERINT     :  1;               /*!< Peripheral interrupt.                                                 */
    } FIFOINTSTAT_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4;

  union {
    __O  uint32_t  FIFOWR;                          /*!< FIFO write data. FIFO data not reset by block reset                   */

    struct {
      __O  uint32_t  TXDATA     : 16;               /*!< Transmit data to the FIFO.                                            */
      __O  uint32_t  TXSSEL0_N  :  1;               /*!< Transmit Slave Select. This field asserts SSEL0 in master mode.
                                                         The output on the pin is active LOW by default. Remark: The
                                                          active state of the SSEL0 pin is configured by bits in the CFG
                                                          register.                                                            */
      __O  uint32_t  TXSSEL1_N  :  1;               /*!< Transmit Slave Select. This field asserts SSEL1 in master mode.
                                                         The output on the pin is active LOW by default. Remark: The
                                                          active state of the SSEL1 pin is configured by bits in the CFG
                                                          register.                                                            */
      __O  uint32_t  TXSSEL2_N  :  1;               /*!< Transmit Slave Select. This field asserts SSEL2 in master mode.
                                                         The output on the pin is active LOW by default. Remark: The
                                                          active state of the SSEL2 pin is configured by bits in the CFG
                                                          register.                                                            */
      __O  uint32_t  TXSSEL3_N  :  1;               /*!< Transmit Slave Select. This field asserts SSEL3 in master mode.
                                                         The output on the pin is active LOW by default. Remark: The
                                                          active state of the SSEL3 pin is configured by bits in the CFG
                                                          register.                                                            */
      __O  uint32_t  EOTR       :  1;               /*!< End of Transfer. The asserted SSEL will be deasserted at the
                                                         end of a transfer, and remain so for at least the time specified
                                                          by the Transfer_delay value in the DLY register.                     */
      __O  uint32_t  EOFR       :  1;               /*!< End of Frame. Between frames, a delay may be inserted, as defined
                                                         by the FRAME_DELAY value in the DLY register. The end of a frame
                                                          may not be particularly meaningful if the FRAME_DELAY value
                                                          = 0. This control can be used as part of the support for frame
                                                          lengths greater than 16 bits.                                        */
      __O  uint32_t  RXIGNORE   :  1;               /*!< Receive Ignore. This allows data to be transmitted using the
                                                         SPI without the need to read unneeded data from the receiver.Setting
                                                          this bit simplifies the transmit process and can be used with
                                                          the DMA.                                                             */
           uint32_t             :  1;
      __O  uint32_t  LEN        :  4;               /*!< Data Length. Specifies the data length from 1 to 16 bits. Note
                                                         that transfer lengths greater than 16 bits are supported by
                                                          implementing multiple sequential transmits. 0x0 = Data transfer
                                                          is 1 bit in length. Note: when LEN = 0, the underrun status
                                                          is not meaningful. 0x1 = Data transfer is 2 bits in length.
                                                          0x2 = Data transfer is 3 bits in length. ... 0xF = Data transfer
                                                          is 16 bits in length.                                                */
    } FIFOWR_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[3];

  union {
    __I  uint32_t  FIFORD;                          /*!< FIFO read data.                                                       */

    struct {
      __I  uint32_t  RXDATA     : 16;               /*!< Received data from the FIFO.                                          */
      __I  uint32_t  RXSSEL0_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL0 pin to be saved along with received data. The value will
                                                          reflect the SSEL0 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL1_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL1 pin to be saved along with received data. The value will
                                                          reflect the SSEL1 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL2_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL2 pin to be saved along with received data. The value will
                                                          reflect the SSEL2 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL3_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL3 pin to be saved along with received data. The value will
                                                          reflect the SSEL3 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  SOT        :  1;               /*!< Start of Transfer flag. This flag will be 1 if this is the first
                                                         data after the SSELs went from deasserted to asserted (i.e.,
                                                          any previous transfer has ended). This information can be used
                                                          to identify the first piece of data in cases where the transfer
                                                          length is greater than 16 bit.                                       */
    } FIFORD_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED6[3];

  union {
    __I  uint32_t  FIFORDNOPOP;                     /*!< FIFO data read with no FIFO pop.                                      */

    struct {
      __I  uint32_t  RXDATA     : 16;               /*!< Received data from the FIFO.                                          */
      __I  uint32_t  RXSSEL0_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL0 pin to be saved along with received data. The value will
                                                          reflect the SSEL0 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL1_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL1 pin to be saved along with received data. The value will
                                                          reflect the SSEL1 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL2_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL2 pin to be saved along with received data. The value will
                                                          reflect the SSEL2 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  RXSSEL3_N  :  1;               /*!< Slave Select for receive. This field allows the state of the
                                                         SSEL3 pin to be saved along with received data. The value will
                                                          reflect the SSEL3 pin for both master and slave operation. A
                                                          zero indicates that a slave select is active. The actual polarity
                                                          of each slave select pin is configured by the related SPOL bit
                                                          in CFG.                                                              */
      __I  uint32_t  SOT        :  1;               /*!< Start of Transfer flag. This flag will be 1 if this is the first
                                                         data after the SSELs went from deasserted to asserted (i.e.,
                                                          any previous transfer has ended). This information can be used
                                                          to identify the first piece of data in cases where the transfer
                                                          length is greater than 16 bit.                                       */
    } FIFORDNOPOP_b;                                /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED7[109];

  union {
    __IO uint32_t  PSELID;                          /*!< Flexcomm ID and peripheral function select register                   */

    struct {
      __IO uint32_t  PERSEL     :  3;               /*!< Peripheral Select. This field is writable by software. 0x0 No
                                                         peripheral selected. 0x1 Reserved. 0x2 SPI function selected
                                                          0x3 Reserved. 0x4 Reserved. 0x5 Reserved. 0x6 Reserved 0x7 Reserved  */
      __IO uint32_t  LOCK       :  1;               /*!< Lock the peripheral select. This field is writable by software.
                                                         0 Peripheral select can be changed by software. 1 Peripheral
                                                          select is locked and cannot be changed until this Flexcomm or
                                                          the entire device is reset.                                          */
           uint32_t             :  1;
      __I  uint32_t  SPIPRESENT :  1;               /*!< SPI present indicator. This field is Read-only. 0 This peripheral
                                                         does not include the SPI function. 1 This peripheral includes
                                                          the SPI function.                                                    */
           uint32_t             :  6;
      __I  uint32_t  ID         : 20;               /*!< Flexcomm ID.                                                          */
    } PSELID_b;                                     /*!< BitSize                                                               */
  };

  union {
    __I  uint32_t  ID;                              /*!< SPI Module Identifier                                                 */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } ID_b;                                         /*!< BitSize                                                               */
  };
} u1_spi_Type;


/* ================================================================================ */
/* ================                     u_hash                     ================ */
/* ================================================================================ */


/**
  * @brief This is the description of component hash It is AES 128-192-256 with GCM mode. More details will follow. (u_hash)
  */

typedef struct {                                    /*!< u_hash Structure                                                      */

  union {
    __IO uint32_t  CTRL;                            /*!< CTRL                                                                  */

    struct {
      __IO uint32_t  CTRL       : 32;               /*!< (null)                                                                */
    } CTRL_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  STAT;                            /*!< STAT                                                                  */

    struct {
      __IO uint32_t  STAT       : 32;               /*!< (null)                                                                */
    } STAT_b;                                       /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTEN;                           /*!< INTEN                                                                 */

    struct {
      __IO uint32_t  INTEN      : 32;               /*!< (null)                                                                */
    } INTEN_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  INTCLR;                          /*!< INTCLR                                                                */

    struct {
      __IO uint32_t  INTCLR     : 32;               /*!< (null)                                                                */
    } INTCLR_b;                                     /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MEMCTRL;                         /*!< MEMCTRL                                                               */

    struct {
      __IO uint32_t  MEMCTRL    : 32;               /*!< (null)                                                                */
    } MEMCTRL_b;                                    /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  MEMADDR;                         /*!< MEMADDR                                                               */

    struct {
      __IO uint32_t  MEMADDR    : 32;               /*!< (null)                                                                */
    } MEMADDR_b;                                    /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED0[2];

  union {
    __IO uint32_t  INDATA;                          /*!< INDATA                                                                */

    struct {
      __IO uint32_t  INDATA     : 32;               /*!< (null)                                                                */
    } INDATA_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED1[7];

  union {
    __IO uint32_t  DIGEST;                          /*!< DIGEST                                                                */

    struct {
      __IO uint32_t  DIGEST     : 32;               /*!< (null)                                                                */
    } DIGEST_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED2[7];

  union {
    __IO uint32_t  OUTD2;                           /*!< OUTD2                                                                 */

    struct {
      __IO uint32_t  OUTD2      : 32;               /*!< (null)                                                                */
    } OUTD2_b;                                      /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED3[7];

  union {
    __IO uint32_t  CRYPT;                           /*!< CRYPT                                                                 */

    struct {
      __IO uint32_t  CRYPT      : 32;               /*!< (null)                                                                */
    } CRYPT_b;                                      /*!< BitSize                                                               */
  };

  union {
    __IO uint32_t  CONFIG;                          /*!< CONFIG                                                                */

    struct {
      __IO uint32_t  CONFIG     : 32;               /*!< (null)                                                                */
    } CONFIG_b;                                     /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED4[2];

  union {
    __IO uint32_t  MASK;                            /*!< MASK                                                                  */

    struct {
      __IO uint32_t  MASK       : 32;               /*!< (null)                                                                */
    } MASK_b;                                       /*!< BitSize                                                               */
  };
  __I  uint32_t  RESERVED5[986];

  union {
    __I  uint32_t  ID;                              /*!< IP identifier                                                         */

    struct {
      __I  uint32_t  APERTURE   :  8;               /*!< Aperture i.e. number minus 1 of consecutive packets 4 Kbytes
                                                         reserved for this IP                                                  */
      __I  uint32_t  MIN_REV    :  4;               /*!< Minor revision i.e. with no software consequences                     */
      __I  uint32_t  MAJ_REV    :  4;               /*!< Major revision i.e. implies software modifications                    */
      __I  uint32_t  ID         : 16;               /*!< Identifier. This is the unique identifier of the module               */
    } ID_b;                                         /*!< BitSize                                                               */
  };
} u_hash_Type;


#include "jn518x_zb_modem.h"
#include "jn518x_zb_mac.h"
#include "jn518x_ble_link.h"
#define APB_ALLOW_BITFIELDS
#include "jn518x_rfp_modem.h"

/* --------------------  End of section using anonymous unions  ------------------- */
#if defined(__CC_ARM)
  #pragma pop
#elif defined(__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined(__TASKING__)
  #pragma warning restore
#else
  #warning Not supported compiler type
#endif



/* ================================================================================ */
/* ================        struct 'u_syscon' Position & Mask       ================ */
/* ================================================================================ */


/* ----------------------------  u_syscon_MEMORYREMAP  ---------------------------- */
#define SYSCON_MEMORYREMAP_MAP_Pos          0                                                       /*!< SYSCON MEMORYREMAP: MAP Position      */
#define SYSCON_MEMORYREMAP_MAP_Msk          (0x03UL << SYSCON_MEMORYREMAP_MAP_Pos)                /*!< SYSCON MEMORYREMAP: MAP Mask          */
#define SYSCON_MEMORYREMAP_FLASH_REMAP_APP_0_Pos 2                                                  /*!< SYSCON MEMORYREMAP: FLASH_REMAP_APP_0 Position */
#define SYSCON_MEMORYREMAP_FLASH_REMAP_APP_0_Msk (0x01UL << SYSCON_MEMORYREMAP_FLASH_REMAP_APP_0_Pos)/*!< SYSCON MEMORYREMAP: FLASH_REMAP_APP_0 Mask */
#define SYSCON_MEMORYREMAP_FLASH_REMAP_APP_1_Pos 3                                                  /*!< SYSCON MEMORYREMAP: FLASH_REMAP_APP_1 Position */
#define SYSCON_MEMORYREMAP_FLASH_REMAP_APP_1_Msk (0x01UL << SYSCON_MEMORYREMAP_FLASH_REMAP_APP_1_Pos)/*!< SYSCON MEMORYREMAP: FLASH_REMAP_APP_1 Mask */
#define SYSCON_MEMORYREMAP_FLASH_APP_0_SIZE_Pos 4                                                   /*!< SYSCON MEMORYREMAP: FLASH_APP_0_SIZE Position */
#define SYSCON_MEMORYREMAP_FLASH_APP_0_SIZE_Msk (0x7fUL << SYSCON_MEMORYREMAP_FLASH_APP_0_SIZE_Pos)/*!< SYSCON MEMORYREMAP: FLASH_APP_0_SIZE Mask */
#define SYSCON_MEMORYREMAP_FLASH_APP_1_SIZE_Pos 12                                                  /*!< SYSCON MEMORYREMAP: FLASH_APP_1_SIZE Position */
#define SYSCON_MEMORYREMAP_FLASH_APP_1_SIZE_Msk (0x7fUL << SYSCON_MEMORYREMAP_FLASH_APP_1_SIZE_Pos)/*!< SYSCON MEMORYREMAP: FLASH_APP_1_SIZE Mask */
#define SYSCON_MEMORYREMAP_QSPI_REMAP_APP_0_Pos 20                                                  /*!< SYSCON MEMORYREMAP: QSPI_REMAP_APP_0 Position */
#define SYSCON_MEMORYREMAP_QSPI_REMAP_APP_0_Msk (0x03UL << SYSCON_MEMORYREMAP_QSPI_REMAP_APP_0_Pos)/*!< SYSCON MEMORYREMAP: QSPI_REMAP_APP_0 Mask */
#define SYSCON_MEMORYREMAP_QSPI_REMAP_APP_1_Pos 22                                                  /*!< SYSCON MEMORYREMAP: QSPI_REMAP_APP_1 Position */
#define SYSCON_MEMORYREMAP_QSPI_REMAP_APP_1_Msk (0x03UL << SYSCON_MEMORYREMAP_QSPI_REMAP_APP_1_Pos)/*!< SYSCON MEMORYREMAP: QSPI_REMAP_APP_1 Mask */
#define SYSCON_MEMORYREMAP_QSPI_REMAP_APP_2_Pos 24                                                  /*!< SYSCON MEMORYREMAP: QSPI_REMAP_APP_2 Position */
#define SYSCON_MEMORYREMAP_QSPI_REMAP_APP_2_Msk (0x03UL << SYSCON_MEMORYREMAP_QSPI_REMAP_APP_2_Pos)/*!< SYSCON MEMORYREMAP: QSPI_REMAP_APP_2 Mask */
#define SYSCON_MEMORYREMAP_QSPI_REMAP_APP_3_Pos 26                                                  /*!< SYSCON MEMORYREMAP: QSPI_REMAP_APP_3 Position */
#define SYSCON_MEMORYREMAP_QSPI_REMAP_APP_3_Msk (0x03UL << SYSCON_MEMORYREMAP_QSPI_REMAP_APP_3_Pos)/*!< SYSCON MEMORYREMAP: QSPI_REMAP_APP_3 Mask */

/* -----------------------------  u_syscon_AHBMATPRIO  ---------------------------- */
#define SYSCON_AHBMATPRIO_PRI_CM40_ICODE_Pos 0                                                      /*!< SYSCON AHBMATPRIO: PRI_CM40_ICODE Position */
#define SYSCON_AHBMATPRIO_PRI_CM40_ICODE_Msk (0x03UL << SYSCON_AHBMATPRIO_PRI_CM40_ICODE_Pos)     /*!< SYSCON AHBMATPRIO: PRI_CM40_ICODE Mask */
#define SYSCON_AHBMATPRIO_PRI_CM40_DCODE_Pos 2                                                      /*!< SYSCON AHBMATPRIO: PRI_CM40_DCODE Position */
#define SYSCON_AHBMATPRIO_PRI_CM40_DCODE_Msk (0x03UL << SYSCON_AHBMATPRIO_PRI_CM40_DCODE_Pos)     /*!< SYSCON AHBMATPRIO: PRI_CM40_DCODE Mask */
#define SYSCON_AHBMATPRIO_PRI_CM40_SYS_Pos  4                                                       /*!< SYSCON AHBMATPRIO: PRI_CM40_SYS Position */
#define SYSCON_AHBMATPRIO_PRI_CM40_SYS_Msk  (0x03UL << SYSCON_AHBMATPRIO_PRI_CM40_SYS_Pos)        /*!< SYSCON AHBMATPRIO: PRI_CM40_SYS Mask  */
#define SYSCON_AHBMATPRIO_PRI_DMA_Pos       6                                                       /*!< SYSCON AHBMATPRIO: PRI_DMA Position   */
#define SYSCON_AHBMATPRIO_PRI_DMA_Msk       (0x03UL << SYSCON_AHBMATPRIO_PRI_DMA_Pos)             /*!< SYSCON AHBMATPRIO: PRI_DMA Mask       */
#define SYSCON_AHBMATPRIO_PRI_MODEM_Pos     8                                                       /*!< SYSCON AHBMATPRIO: PRI_MODEM Position */
#define SYSCON_AHBMATPRIO_PRI_MODEM_Msk     (0x03UL << SYSCON_AHBMATPRIO_PRI_MODEM_Pos)           /*!< SYSCON AHBMATPRIO: PRI_MODEM Mask     */
#define SYSCON_AHBMATPRIO_PRI_CM41_ICODE_Pos 10                                                     /*!< SYSCON AHBMATPRIO: PRI_CM41_ICODE Position */
#define SYSCON_AHBMATPRIO_PRI_CM41_ICODE_Msk (0x03UL << SYSCON_AHBMATPRIO_PRI_CM41_ICODE_Pos)     /*!< SYSCON AHBMATPRIO: PRI_CM41_ICODE Mask */
#define SYSCON_AHBMATPRIO_PRI_CM41_DCODE_Pos 12                                                     /*!< SYSCON AHBMATPRIO: PRI_CM41_DCODE Position */
#define SYSCON_AHBMATPRIO_PRI_CM41_DCODE_Msk (0x03UL << SYSCON_AHBMATPRIO_PRI_CM41_DCODE_Pos)     /*!< SYSCON AHBMATPRIO: PRI_CM41_DCODE Mask */
#define SYSCON_AHBMATPRIO_PRI_CM41_SYS_Pos  14                                                      /*!< SYSCON AHBMATPRIO: PRI_CM41_SYS Position */
#define SYSCON_AHBMATPRIO_PRI_CM41_SYS_Msk  (0x03UL << SYSCON_AHBMATPRIO_PRI_CM41_SYS_Pos)        /*!< SYSCON AHBMATPRIO: PRI_CM41_SYS Mask  */
#define SYSCON_AHBMATPRIO_PRI_TPR_Pos       16                                                      /*!< SYSCON AHBMATPRIO: PRI_TPR Position   */
#define SYSCON_AHBMATPRIO_PRI_TPR_Msk       (0x03UL << SYSCON_AHBMATPRIO_PRI_TPR_Pos)             /*!< SYSCON AHBMATPRIO: PRI_TPR Mask       */

/* -------------------------  u_syscon_BUFFERINGAHB2VPB0  ------------------------- */
#define SYSCON_BUFFERINGAHB2VPB0_SYSCON_Pos 0                                                       /*!< SYSCON BUFFERINGAHB2VPB0: SYSCON Position */
#define SYSCON_BUFFERINGAHB2VPB0_SYSCON_Msk (0x01UL << SYSCON_BUFFERINGAHB2VPB0_SYSCON_Pos)       /*!< SYSCON BUFFERINGAHB2VPB0: SYSCON Mask */
#define SYSCON_BUFFERINGAHB2VPB0_FIREWALL_Pos 1                                                     /*!< SYSCON BUFFERINGAHB2VPB0: FIREWALL Position */
#define SYSCON_BUFFERINGAHB2VPB0_FIREWALL_Msk (0x01UL << SYSCON_BUFFERINGAHB2VPB0_FIREWALL_Pos)   /*!< SYSCON BUFFERINGAHB2VPB0: FIREWALL Mask */
#define SYSCON_BUFFERINGAHB2VPB0_OTPC_Pos   2                                                       /*!< SYSCON BUFFERINGAHB2VPB0: OTPC Position */
#define SYSCON_BUFFERINGAHB2VPB0_OTPC_Msk   (0x01UL << SYSCON_BUFFERINGAHB2VPB0_OTPC_Pos)         /*!< SYSCON BUFFERINGAHB2VPB0: OTPC Mask   */
#define SYSCON_BUFFERINGAHB2VPB0_I2C0_Pos   3                                                       /*!< SYSCON BUFFERINGAHB2VPB0: I2C0 Position */
#define SYSCON_BUFFERINGAHB2VPB0_I2C0_Msk   (0x01UL << SYSCON_BUFFERINGAHB2VPB0_I2C0_Pos)         /*!< SYSCON BUFFERINGAHB2VPB0: I2C0 Mask   */
#define SYSCON_BUFFERINGAHB2VPB0_I2C1_Pos   4                                                       /*!< SYSCON BUFFERINGAHB2VPB0: I2C1 Position */
#define SYSCON_BUFFERINGAHB2VPB0_I2C1_Msk   (0x01UL << SYSCON_BUFFERINGAHB2VPB0_I2C1_Pos)         /*!< SYSCON BUFFERINGAHB2VPB0: I2C1 Mask   */
#define SYSCON_BUFFERINGAHB2VPB0_I2C2_Pos   5                                                       /*!< SYSCON BUFFERINGAHB2VPB0: I2C2 Position */
#define SYSCON_BUFFERINGAHB2VPB0_I2C2_Msk   (0x01UL << SYSCON_BUFFERINGAHB2VPB0_I2C2_Pos)         /*!< SYSCON BUFFERINGAHB2VPB0: I2C2 Mask   */
#define SYSCON_BUFFERINGAHB2VPB0_ISO7816_Pos 6                                                      /*!< SYSCON BUFFERINGAHB2VPB0: ISO7816 Position */
#define SYSCON_BUFFERINGAHB2VPB0_ISO7816_Msk (0x01UL << SYSCON_BUFFERINGAHB2VPB0_ISO7816_Pos)     /*!< SYSCON BUFFERINGAHB2VPB0: ISO7816 Mask */
#define SYSCON_BUFFERINGAHB2VPB0_IR_Pos     7                                                       /*!< SYSCON BUFFERINGAHB2VPB0: IR Position */
#define SYSCON_BUFFERINGAHB2VPB0_IR_Msk     (0x01UL << SYSCON_BUFFERINGAHB2VPB0_IR_Pos)           /*!< SYSCON BUFFERINGAHB2VPB0: IR Mask     */
#define SYSCON_BUFFERINGAHB2VPB0_CODEPATCH_Pos 8                                                    /*!< SYSCON BUFFERINGAHB2VPB0: CODEPATCH Position */
#define SYSCON_BUFFERINGAHB2VPB0_CODEPATCH_Msk (0x01UL << SYSCON_BUFFERINGAHB2VPB0_CODEPATCH_Pos) /*!< SYSCON BUFFERINGAHB2VPB0: CODEPATCH Mask */
#define SYSCON_BUFFERINGAHB2VPB0_FLASHCTRL_Pos 9                                                    /*!< SYSCON BUFFERINGAHB2VPB0: FLASHCTRL Position */
#define SYSCON_BUFFERINGAHB2VPB0_FLASHCTRL_Msk (0x01UL << SYSCON_BUFFERINGAHB2VPB0_FLASHCTRL_Pos) /*!< SYSCON BUFFERINGAHB2VPB0: FLASHCTRL Mask */
#define SYSCON_BUFFERINGAHB2VPB0_WDT_Pos    10                                                      /*!< SYSCON BUFFERINGAHB2VPB0: WDT Position */
#define SYSCON_BUFFERINGAHB2VPB0_WDT_Msk    (0x01UL << SYSCON_BUFFERINGAHB2VPB0_WDT_Pos)          /*!< SYSCON BUFFERINGAHB2VPB0: WDT Mask    */
#define SYSCON_BUFFERINGAHB2VPB0_RTC_Pos    11                                                      /*!< SYSCON BUFFERINGAHB2VPB0: RTC Position */
#define SYSCON_BUFFERINGAHB2VPB0_RTC_Msk    (0x01UL << SYSCON_BUFFERINGAHB2VPB0_RTC_Pos)          /*!< SYSCON BUFFERINGAHB2VPB0: RTC Mask    */
#define SYSCON_BUFFERINGAHB2VPB0_PWM_Pos    12                                                      /*!< SYSCON BUFFERINGAHB2VPB0: PWM Position */
#define SYSCON_BUFFERINGAHB2VPB0_PWM_Msk    (0x01UL << SYSCON_BUFFERINGAHB2VPB0_PWM_Pos)          /*!< SYSCON BUFFERINGAHB2VPB0: PWM Mask    */
#define SYSCON_BUFFERINGAHB2VPB0_RNG_Pos    13                                                      /*!< SYSCON BUFFERINGAHB2VPB0: RNG Position */
#define SYSCON_BUFFERINGAHB2VPB0_RNG_Msk    (0x01UL << SYSCON_BUFFERINGAHB2VPB0_RNG_Pos)          /*!< SYSCON BUFFERINGAHB2VPB0: RNG Mask    */
#define SYSCON_BUFFERINGAHB2VPB0_PMUX_Pos   14                                                      /*!< SYSCON BUFFERINGAHB2VPB0: PMUX Position */
#define SYSCON_BUFFERINGAHB2VPB0_PMUX_Msk   (0x01UL << SYSCON_BUFFERINGAHB2VPB0_PMUX_Pos)         /*!< SYSCON BUFFERINGAHB2VPB0: PMUX Mask   */
#define SYSCON_BUFFERINGAHB2VPB0_IOCON_Pos  15                                                      /*!< SYSCON BUFFERINGAHB2VPB0: IOCON Position */
#define SYSCON_BUFFERINGAHB2VPB0_IOCON_Msk  (0x01UL << SYSCON_BUFFERINGAHB2VPB0_IOCON_Pos)        /*!< SYSCON BUFFERINGAHB2VPB0: IOCON Mask  */
#define SYSCON_BUFFERINGAHB2VPB0_GPIOINT_Pos 16                                                     /*!< SYSCON BUFFERINGAHB2VPB0: GPIOINT Position */
#define SYSCON_BUFFERINGAHB2VPB0_GPIOINT_Msk (0x01UL << SYSCON_BUFFERINGAHB2VPB0_GPIOINT_Pos)     /*!< SYSCON BUFFERINGAHB2VPB0: GPIOINT Mask */
#define SYSCON_BUFFERINGAHB2VPB0_GPIOGLOBALINT_Pos 17                                               /*!< SYSCON BUFFERINGAHB2VPB0: GPIOGLOBALINT Position */
#define SYSCON_BUFFERINGAHB2VPB0_GPIOGLOBALINT_Msk (0x01UL << SYSCON_BUFFERINGAHB2VPB0_GPIOGLOBALINT_Pos)/*!< SYSCON BUFFERINGAHB2VPB0: GPIOGLOBALINT Mask */
#define SYSCON_BUFFERINGAHB2VPB0_PMC_Pos    18                                                      /*!< SYSCON BUFFERINGAHB2VPB0: PMC Position */
#define SYSCON_BUFFERINGAHB2VPB0_PMC_Msk    (0x01UL << SYSCON_BUFFERINGAHB2VPB0_PMC_Pos)          /*!< SYSCON BUFFERINGAHB2VPB0: PMC Mask    */
#define SYSCON_BUFFERINGAHB2VPB0_RFP_Pos    19                                                      /*!< SYSCON BUFFERINGAHB2VPB0: RFP Position */
#define SYSCON_BUFFERINGAHB2VPB0_RFP_Msk    (0x01UL << SYSCON_BUFFERINGAHB2VPB0_RFP_Pos)          /*!< SYSCON BUFFERINGAHB2VPB0: RFP Mask    */
#define SYSCON_BUFFERINGAHB2VPB0_BLE_Pos    20                                                      /*!< SYSCON BUFFERINGAHB2VPB0: BLE Position */
#define SYSCON_BUFFERINGAHB2VPB0_BLE_Msk    (0x01UL << SYSCON_BUFFERINGAHB2VPB0_BLE_Pos)          /*!< SYSCON BUFFERINGAHB2VPB0: BLE Mask    */

/* -------------------------  u_syscon_BUFFERINGAHB2VPB1  ------------------------- */
#define SYSCON_BUFFERINGAHB2VPB1_ASYNCSYSCON_Pos 0                                                  /*!< SYSCON BUFFERINGAHB2VPB1: ASYNCSYSCON Position */
#define SYSCON_BUFFERINGAHB2VPB1_ASYNCSYSCON_Msk (0x01UL << SYSCON_BUFFERINGAHB2VPB1_ASYNCSYSCON_Pos)/*!< SYSCON BUFFERINGAHB2VPB1: ASYNCSYSCON Mask */
#define SYSCON_BUFFERINGAHB2VPB1_CT32B0_Pos 1                                                       /*!< SYSCON BUFFERINGAHB2VPB1: CT32B0 Position */
#define SYSCON_BUFFERINGAHB2VPB1_CT32B0_Msk (0x01UL << SYSCON_BUFFERINGAHB2VPB1_CT32B0_Pos)       /*!< SYSCON BUFFERINGAHB2VPB1: CT32B0 Mask */
#define SYSCON_BUFFERINGAHB2VPB1_CT32B1_Pos 2                                                       /*!< SYSCON BUFFERINGAHB2VPB1: CT32B1 Position */
#define SYSCON_BUFFERINGAHB2VPB1_CT32B1_Msk (0x01UL << SYSCON_BUFFERINGAHB2VPB1_CT32B1_Pos)       /*!< SYSCON BUFFERINGAHB2VPB1: CT32B1 Mask */

/* -----------------------------  u_syscon_SYSTCKCAL  ----------------------------- */
#define SYSCON_SYSTCKCAL_CAL_Pos            0                                                       /*!< SYSCON SYSTCKCAL: CAL Position        */
#define SYSCON_SYSTCKCAL_CAL_Msk            (0x00ffffffUL << SYSCON_SYSTCKCAL_CAL_Pos)            /*!< SYSCON SYSTCKCAL: CAL Mask            */
#define SYSCON_SYSTCKCAL_SKEW_Pos           24                                                      /*!< SYSCON SYSTCKCAL: SKEW Position       */
#define SYSCON_SYSTCKCAL_SKEW_Msk           (0x01UL << SYSCON_SYSTCKCAL_SKEW_Pos)                 /*!< SYSCON SYSTCKCAL: SKEW Mask           */
#define SYSCON_SYSTCKCAL_NOREF_Pos          25                                                      /*!< SYSCON SYSTCKCAL: NOREF Position      */
#define SYSCON_SYSTCKCAL_NOREF_Msk          (0x01UL << SYSCON_SYSTCKCAL_NOREF_Pos)                /*!< SYSCON SYSTCKCAL: NOREF Mask          */

/* -------------------------------  u_syscon_NMISRC  ------------------------------ */
#define SYSCON_NMISRC_IRQM40_Pos            0                                                       /*!< SYSCON NMISRC: IRQM40 Position        */
#define SYSCON_NMISRC_IRQM40_Msk            (0x3fUL << SYSCON_NMISRC_IRQM40_Pos)                  /*!< SYSCON NMISRC: IRQM40 Mask            */
#define SYSCON_NMISRC_IRQM41_Pos            8                                                       /*!< SYSCON NMISRC: IRQM41 Position        */
#define SYSCON_NMISRC_IRQM41_Msk            (0x3fUL << SYSCON_NMISRC_IRQM41_Pos)                  /*!< SYSCON NMISRC: IRQM41 Mask            */
#define SYSCON_NMISRC_NMIENM41_Pos          30                                                      /*!< SYSCON NMISRC: NMIENM41 Position      */
#define SYSCON_NMISRC_NMIENM41_Msk          (0x01UL << SYSCON_NMISRC_NMIENM41_Pos)                /*!< SYSCON NMISRC: NMIENM41 Mask          */
#define SYSCON_NMISRC_NMIENM40_Pos          31                                                      /*!< SYSCON NMISRC: NMIENM40 Position      */
#define SYSCON_NMISRC_NMIENM40_Msk          (0x01UL << SYSCON_NMISRC_NMIENM40_Pos)                /*!< SYSCON NMISRC: NMIENM40 Mask          */

/* ----------------------------  u_syscon_ASYNCAPBCTRL  --------------------------- */
#define SYSCON_ASYNCAPBCTRL_ENABLE_Pos      0                                                       /*!< SYSCON ASYNCAPBCTRL: ENABLE Position  */
#define SYSCON_ASYNCAPBCTRL_ENABLE_Msk      (0x01UL << SYSCON_ASYNCAPBCTRL_ENABLE_Pos)            /*!< SYSCON ASYNCAPBCTRL: ENABLE Mask      */

/* ----------------------------  u_syscon_PRESETCTRL0  ---------------------------- */
#define SYSCON_PRESETCTRL0_FLASH_RST_Pos    8                                                       /*!< SYSCON PRESETCTRL0: FLASH_RST Position */
#define SYSCON_PRESETCTRL0_FLASH_RST_Msk    (0x01UL << SYSCON_PRESETCTRL0_FLASH_RST_Pos)          /*!< SYSCON PRESETCTRL0: FLASH_RST Mask    */
#define SYSCON_PRESETCTRL0_SPIFI_RST_Pos    10                                                      /*!< SYSCON PRESETCTRL0: SPIFI_RST Position */
#define SYSCON_PRESETCTRL0_SPIFI_RST_Msk    (0x01UL << SYSCON_PRESETCTRL0_SPIFI_RST_Pos)          /*!< SYSCON PRESETCTRL0: SPIFI_RST Mask    */
#define SYSCON_PRESETCTRL0_MUX_RST_Pos      11                                                      /*!< SYSCON PRESETCTRL0: MUX_RST Position  */
#define SYSCON_PRESETCTRL0_MUX_RST_Msk      (0x01UL << SYSCON_PRESETCTRL0_MUX_RST_Pos)            /*!< SYSCON PRESETCTRL0: MUX_RST Mask      */
#define SYSCON_PRESETCTRL0_BLE_TIMING_GEN_RST_Pos 12                                                /*!< SYSCON PRESETCTRL0: BLE_TIMING_GEN_RST Position */
#define SYSCON_PRESETCTRL0_BLE_TIMING_GEN_RST_Msk (0x01UL << SYSCON_PRESETCTRL0_BLE_TIMING_GEN_RST_Pos)/*!< SYSCON PRESETCTRL0: BLE_TIMING_GEN_RST Mask */
#define SYSCON_PRESETCTRL0_IOCON_RST_Pos    13                                                      /*!< SYSCON PRESETCTRL0: IOCON_RST Position */
#define SYSCON_PRESETCTRL0_IOCON_RST_Msk    (0x01UL << SYSCON_PRESETCTRL0_IOCON_RST_Pos)          /*!< SYSCON PRESETCTRL0: IOCON_RST Mask    */
#define SYSCON_PRESETCTRL0_GPIO_RST_Pos     14                                                      /*!< SYSCON PRESETCTRL0: GPIO_RST Position */
#define SYSCON_PRESETCTRL0_GPIO_RST_Msk     (0x01UL << SYSCON_PRESETCTRL0_GPIO_RST_Pos)           /*!< SYSCON PRESETCTRL0: GPIO_RST Mask     */
#define SYSCON_PRESETCTRL0_PINT_RST_Pos     18                                                      /*!< SYSCON PRESETCTRL0: PINT_RST Position */
#define SYSCON_PRESETCTRL0_PINT_RST_Msk     (0x01UL << SYSCON_PRESETCTRL0_PINT_RST_Pos)           /*!< SYSCON PRESETCTRL0: PINT_RST Mask     */
#define SYSCON_PRESETCTRL0_GINT_RST_Pos     19                                                      /*!< SYSCON PRESETCTRL0: GINT_RST Position */
#define SYSCON_PRESETCTRL0_GINT_RST_Msk     (0x01UL << SYSCON_PRESETCTRL0_GINT_RST_Pos)           /*!< SYSCON PRESETCTRL0: GINT_RST Mask     */
#define SYSCON_PRESETCTRL0_DMA_RST_Pos      20                                                      /*!< SYSCON PRESETCTRL0: DMA_RST Position  */
#define SYSCON_PRESETCTRL0_DMA_RST_Msk      (0x01UL << SYSCON_PRESETCTRL0_DMA_RST_Pos)            /*!< SYSCON PRESETCTRL0: DMA_RST Mask      */
#define SYSCON_PRESETCTRL0_ISO7816_RST_Pos  21                                                      /*!< SYSCON PRESETCTRL0: ISO7816_RST Position */
#define SYSCON_PRESETCTRL0_ISO7816_RST_Msk  (0x01UL << SYSCON_PRESETCTRL0_ISO7816_RST_Pos)        /*!< SYSCON PRESETCTRL0: ISO7816_RST Mask  */
#define SYSCON_PRESETCTRL0_WWDT_RST_Pos     22                                                      /*!< SYSCON PRESETCTRL0: WWDT_RST Position */
#define SYSCON_PRESETCTRL0_WWDT_RST_Msk     (0x01UL << SYSCON_PRESETCTRL0_WWDT_RST_Pos)           /*!< SYSCON PRESETCTRL0: WWDT_RST Mask     */
#define SYSCON_PRESETCTRL0_RTC_RST_Pos      23                                                      /*!< SYSCON PRESETCTRL0: RTC_RST Position  */
#define SYSCON_PRESETCTRL0_RTC_RST_Msk      (0x01UL << SYSCON_PRESETCTRL0_RTC_RST_Pos)            /*!< SYSCON PRESETCTRL0: RTC_RST Mask      */
#define SYSCON_PRESETCTRL0_ANA_INT_CTRL_RST_Pos 24                                                  /*!< SYSCON PRESETCTRL0: ANA_INT_CTRL_RST Position */
#define SYSCON_PRESETCTRL0_ANA_INT_CTRL_RST_Msk (0x01UL << SYSCON_PRESETCTRL0_ANA_INT_CTRL_RST_Pos)/*!< SYSCON PRESETCTRL0: ANA_INT_CTRL_RST Mask */
#define SYSCON_PRESETCTRL0_WAKE_UP_TIMERS_RST_Pos 25                                                /*!< SYSCON PRESETCTRL0: WAKE_UP_TIMERS_RST Position */
#define SYSCON_PRESETCTRL0_WAKE_UP_TIMERS_RST_Msk (0x01UL << SYSCON_PRESETCTRL0_WAKE_UP_TIMERS_RST_Pos)/*!< SYSCON PRESETCTRL0: WAKE_UP_TIMERS_RST Mask */
#define SYSCON_PRESETCTRL0_MAILBOX_RST_Pos  26                                                      /*!< SYSCON PRESETCTRL0: MAILBOX_RST Position */
#define SYSCON_PRESETCTRL0_MAILBOX_RST_Msk  (0x01UL << SYSCON_PRESETCTRL0_MAILBOX_RST_Pos)        /*!< SYSCON PRESETCTRL0: MAILBOX_RST Mask  */
#define SYSCON_PRESETCTRL0_ADC_RST_Pos      27                                                      /*!< SYSCON PRESETCTRL0: ADC_RST Position  */
#define SYSCON_PRESETCTRL0_ADC_RST_Msk      (0x01UL << SYSCON_PRESETCTRL0_ADC_RST_Pos)            /*!< SYSCON PRESETCTRL0: ADC_RST Mask      */
#define SYSCON_PRESETCTRL0_EFUSE_RST_Pos    28                                                      /*!< SYSCON PRESETCTRL0: EFUSE_RST Position */
#define SYSCON_PRESETCTRL0_EFUSE_RST_Msk    (0x01UL << SYSCON_PRESETCTRL0_EFUSE_RST_Pos)          /*!< SYSCON PRESETCTRL0: EFUSE_RST Mask    */
#define SYSCON_PRESETCTRL0_PVT_RST_Pos      29                                                      /*!< SYSCON PRESETCTRL0: PVT_RST Position  */
#define SYSCON_PRESETCTRL0_PVT_RST_Msk      (0x01UL << SYSCON_PRESETCTRL0_PVT_RST_Pos)            /*!< SYSCON PRESETCTRL0: PVT_RST Mask      */

/* ----------------------------  u_syscon_PRESETCTRL1  ---------------------------- */
#define SYSCON_PRESETCTRL1_USART0_RST_Pos   11                                                      /*!< SYSCON PRESETCTRL1: USART0_RST Position */
#define SYSCON_PRESETCTRL1_USART0_RST_Msk   (0x01UL << SYSCON_PRESETCTRL1_USART0_RST_Pos)         /*!< SYSCON PRESETCTRL1: USART0_RST Mask   */
#define SYSCON_PRESETCTRL1_USART1_RST_Pos   12                                                      /*!< SYSCON PRESETCTRL1: USART1_RST Position */
#define SYSCON_PRESETCTRL1_USART1_RST_Msk   (0x01UL << SYSCON_PRESETCTRL1_USART1_RST_Pos)         /*!< SYSCON PRESETCTRL1: USART1_RST Mask   */
#define SYSCON_PRESETCTRL1_I2C0_RST_Pos     13                                                      /*!< SYSCON PRESETCTRL1: I2C0_RST Position */
#define SYSCON_PRESETCTRL1_I2C0_RST_Msk     (0x01UL << SYSCON_PRESETCTRL1_I2C0_RST_Pos)           /*!< SYSCON PRESETCTRL1: I2C0_RST Mask     */
#define SYSCON_PRESETCTRL1_I2C1_RST_Pos     14                                                      /*!< SYSCON PRESETCTRL1: I2C1_RST Position */
#define SYSCON_PRESETCTRL1_I2C1_RST_Msk     (0x01UL << SYSCON_PRESETCTRL1_I2C1_RST_Pos)           /*!< SYSCON PRESETCTRL1: I2C1_RST Mask     */
#define SYSCON_PRESETCTRL1_SPI0_RST_Pos     15                                                      /*!< SYSCON PRESETCTRL1: SPI0_RST Position */
#define SYSCON_PRESETCTRL1_SPI0_RST_Msk     (0x01UL << SYSCON_PRESETCTRL1_SPI0_RST_Pos)           /*!< SYSCON PRESETCTRL1: SPI0_RST Mask     */
#define SYSCON_PRESETCTRL1_SPI1_RST_Pos     16                                                      /*!< SYSCON PRESETCTRL1: SPI1_RST Position */
#define SYSCON_PRESETCTRL1_SPI1_RST_Msk     (0x01UL << SYSCON_PRESETCTRL1_SPI1_RST_Pos)           /*!< SYSCON PRESETCTRL1: SPI1_RST Mask     */
#define SYSCON_PRESETCTRL1_IR_RST_Pos       17                                                      /*!< SYSCON PRESETCTRL1: IR_RST Position   */
#define SYSCON_PRESETCTRL1_IR_RST_Msk       (0x01UL << SYSCON_PRESETCTRL1_IR_RST_Pos)             /*!< SYSCON PRESETCTRL1: IR_RST Mask       */
#define SYSCON_PRESETCTRL1_PWM_RST_Pos      18                                                      /*!< SYSCON PRESETCTRL1: PWM_RST Position  */
#define SYSCON_PRESETCTRL1_PWM_RST_Msk      (0x01UL << SYSCON_PRESETCTRL1_PWM_RST_Pos)            /*!< SYSCON PRESETCTRL1: PWM_RST Mask      */
#define SYSCON_PRESETCTRL1_RNG_RST_Pos      19                                                      /*!< SYSCON PRESETCTRL1: RNG_RST Position  */
#define SYSCON_PRESETCTRL1_RNG_RST_Msk      (0x01UL << SYSCON_PRESETCTRL1_RNG_RST_Pos)            /*!< SYSCON PRESETCTRL1: RNG_RST Mask      */
#define SYSCON_PRESETCTRL1_I2C2_RST_Pos     20                                                      /*!< SYSCON PRESETCTRL1: I2C2_RST Position */
#define SYSCON_PRESETCTRL1_I2C2_RST_Msk     (0x01UL << SYSCON_PRESETCTRL1_I2C2_RST_Pos)           /*!< SYSCON PRESETCTRL1: I2C2_RST Mask     */
#define SYSCON_PRESETCTRL1_ZIGBEE_RST_Pos   21                                                      /*!< SYSCON PRESETCTRL1: ZIGBEE_RST Position */
#define SYSCON_PRESETCTRL1_ZIGBEE_RST_Msk   (0x01UL << SYSCON_PRESETCTRL1_ZIGBEE_RST_Pos)         /*!< SYSCON PRESETCTRL1: ZIGBEE_RST Mask   */
#define SYSCON_PRESETCTRL1_BLE_RST_Pos      22                                                      /*!< SYSCON PRESETCTRL1: BLE_RST Position  */
#define SYSCON_PRESETCTRL1_BLE_RST_Msk      (0x01UL << SYSCON_PRESETCTRL1_BLE_RST_Pos)            /*!< SYSCON PRESETCTRL1: BLE_RST Mask      */
#define SYSCON_PRESETCTRL1_MODEM_MASTER_RST_Pos 23                                                  /*!< SYSCON PRESETCTRL1: MODEM_MASTER_RST Position */
#define SYSCON_PRESETCTRL1_MODEM_MASTER_RST_Msk (0x01UL << SYSCON_PRESETCTRL1_MODEM_MASTER_RST_Pos)/*!< SYSCON PRESETCTRL1: MODEM_MASTER_RST Mask */
#define SYSCON_PRESETCTRL1_AES_RST_Pos      24                                                      /*!< SYSCON PRESETCTRL1: AES_RST Position  */
#define SYSCON_PRESETCTRL1_AES_RST_Msk      (0x01UL << SYSCON_PRESETCTRL1_AES_RST_Pos)            /*!< SYSCON PRESETCTRL1: AES_RST Mask      */
#define SYSCON_PRESETCTRL1_RFP_RST_Pos      25                                                      /*!< SYSCON PRESETCTRL1: RFP_RST Position  */
#define SYSCON_PRESETCTRL1_RFP_RST_Msk      (0x01UL << SYSCON_PRESETCTRL1_RFP_RST_Pos)            /*!< SYSCON PRESETCTRL1: RFP_RST Mask      */
#define SYSCON_PRESETCTRL1_DMIC_RST_Pos     26                                                      /*!< SYSCON PRESETCTRL1: DMIC_RST Position */
#define SYSCON_PRESETCTRL1_DMIC_RST_Msk     (0x01UL << SYSCON_PRESETCTRL1_DMIC_RST_Pos)           /*!< SYSCON PRESETCTRL1: DMIC_RST Mask     */
#define SYSCON_PRESETCTRL1_HASH_RST_Pos     27                                                      /*!< SYSCON PRESETCTRL1: HASH_RST Position */
#define SYSCON_PRESETCTRL1_HASH_RST_Msk     (0x01UL << SYSCON_PRESETCTRL1_HASH_RST_Pos)           /*!< SYSCON PRESETCTRL1: HASH_RST Mask     */
#define SYSCON_PRESETCTRL1_TPR_RST_Pos      28                                                      /*!< SYSCON PRESETCTRL1: TPR_RST Position  */
#define SYSCON_PRESETCTRL1_TPR_RST_Msk      (0x01UL << SYSCON_PRESETCTRL1_TPR_RST_Pos)            /*!< SYSCON PRESETCTRL1: TPR_RST Mask      */

/* ---------------------------  u_syscon_PRESETCTRLSET0  -------------------------- */
#define SYSCON_PRESETCTRLSET0_FLASH_RST_SET_Pos 8                                                   /*!< SYSCON PRESETCTRLSET0: FLASH_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_FLASH_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_FLASH_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET0: FLASH_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_SPIFI_RST_SET_Pos 10                                                  /*!< SYSCON PRESETCTRLSET0: SPIFI_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_SPIFI_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_SPIFI_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET0: SPIFI_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_MUX_RST_SET_Pos 11                                                    /*!< SYSCON PRESETCTRLSET0: MUX_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_MUX_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_MUX_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET0: MUX_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_BLE_TIMING_GEN_RST_SET_Pos 12                                         /*!< SYSCON PRESETCTRLSET0: BLE_TIMING_GEN_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_BLE_TIMING_GEN_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_BLE_TIMING_GEN_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET0: BLE_TIMING_GEN_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_IOCON_RST_SET_Pos 13                                                  /*!< SYSCON PRESETCTRLSET0: IOCON_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_IOCON_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_IOCON_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET0: IOCON_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_GPIO_RST_SET_Pos 14                                                   /*!< SYSCON PRESETCTRLSET0: GPIO_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_GPIO_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_GPIO_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET0: GPIO_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_PINT_RST_SET_Pos 18                                                   /*!< SYSCON PRESETCTRLSET0: PINT_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_PINT_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_PINT_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET0: PINT_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_GINT_RST_SET_Pos 19                                                   /*!< SYSCON PRESETCTRLSET0: GINT_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_GINT_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_GINT_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET0: GINT_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_DMA_RST_SET_Pos 20                                                    /*!< SYSCON PRESETCTRLSET0: DMA_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_DMA_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_DMA_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET0: DMA_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_ISO7816_RST_SET_Pos 21                                                /*!< SYSCON PRESETCTRLSET0: ISO7816_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_ISO7816_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_ISO7816_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET0: ISO7816_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_WWDT_RST_SET_Pos 22                                                   /*!< SYSCON PRESETCTRLSET0: WWDT_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_WWDT_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_WWDT_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET0: WWDT_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_RTC_RST_SET_Pos 23                                                    /*!< SYSCON PRESETCTRLSET0: RTC_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_RTC_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_RTC_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET0: RTC_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_ANA_INT_CTRL_RST_SET_Pos 24                                           /*!< SYSCON PRESETCTRLSET0: ANA_INT_CTRL_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_ANA_INT_CTRL_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_ANA_INT_CTRL_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET0: ANA_INT_CTRL_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_WAKE_UP_TIMERS_RST_SET_Pos 25                                         /*!< SYSCON PRESETCTRLSET0: WAKE_UP_TIMERS_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_WAKE_UP_TIMERS_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_WAKE_UP_TIMERS_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET0: WAKE_UP_TIMERS_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_MAILBOX_RST_SET_Pos 26                                                /*!< SYSCON PRESETCTRLSET0: MAILBOX_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_MAILBOX_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_MAILBOX_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET0: MAILBOX_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_ADC_RST_SET_Pos 27                                                    /*!< SYSCON PRESETCTRLSET0: ADC_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_ADC_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_ADC_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET0: ADC_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_EFUSE_RST_SET_Pos 28                                                  /*!< SYSCON PRESETCTRLSET0: EFUSE_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_EFUSE_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_EFUSE_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET0: EFUSE_RST_SET Mask */
#define SYSCON_PRESETCTRLSET0_PVT_RST_SET_Pos 29                                                    /*!< SYSCON PRESETCTRLSET0: PVT_RST_SET Position */
#define SYSCON_PRESETCTRLSET0_PVT_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET0_PVT_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET0: PVT_RST_SET Mask */

/* ---------------------------  u_syscon_PRESETCTRLSET1  -------------------------- */
#define SYSCON_PRESETCTRLSET1_USART0_RST_SET_Pos 11                                                 /*!< SYSCON PRESETCTRLSET1: USART0_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_USART0_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_USART0_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET1: USART0_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_USART1_RST_SET_Pos 12                                                 /*!< SYSCON PRESETCTRLSET1: USART1_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_USART1_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_USART1_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET1: USART1_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_I2C0_RST_SET_Pos 13                                                   /*!< SYSCON PRESETCTRLSET1: I2C0_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_I2C0_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_I2C0_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET1: I2C0_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_I2C1_RST_SET_Pos 14                                                   /*!< SYSCON PRESETCTRLSET1: I2C1_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_I2C1_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_I2C1_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET1: I2C1_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_SPI0_RST_SET_Pos 15                                                   /*!< SYSCON PRESETCTRLSET1: SPI0_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_SPI0_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_SPI0_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET1: SPI0_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_SPI1_RST_SET_Pos 16                                                   /*!< SYSCON PRESETCTRLSET1: SPI1_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_SPI1_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_SPI1_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET1: SPI1_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_IR_RST_SET_Pos 17                                                     /*!< SYSCON PRESETCTRLSET1: IR_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_IR_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_IR_RST_SET_Pos)     /*!< SYSCON PRESETCTRLSET1: IR_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_PWM_RST_SET_Pos 18                                                    /*!< SYSCON PRESETCTRLSET1: PWM_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_PWM_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_PWM_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET1: PWM_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_RNG_RST_SET_Pos 19                                                    /*!< SYSCON PRESETCTRLSET1: RNG_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_RNG_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_RNG_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET1: RNG_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_I2C2_RST_SET_Pos 20                                                   /*!< SYSCON PRESETCTRLSET1: I2C2_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_I2C2_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_I2C2_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET1: I2C2_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Pos 21                                                 /*!< SYSCON PRESETCTRLSET1: ZIGBEE_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET1: ZIGBEE_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_BLE_RST_SET_Pos 22                                                    /*!< SYSCON PRESETCTRLSET1: BLE_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_BLE_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_BLE_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET1: BLE_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_MODEM_MASTER_RST_SET_Pos 23                                           /*!< SYSCON PRESETCTRLSET1: MODEM_MASTER_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_MODEM_MASTER_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_MODEM_MASTER_RST_SET_Pos)/*!< SYSCON PRESETCTRLSET1: MODEM_MASTER_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_AES_RST_SET_Pos 24                                                    /*!< SYSCON PRESETCTRLSET1: AES_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_AES_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_AES_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET1: AES_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_RFP_RST_SET_Pos 25                                                    /*!< SYSCON PRESETCTRLSET1: RFP_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_RFP_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_RFP_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET1: RFP_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_DMIC_RST_SET_Pos 26                                                   /*!< SYSCON PRESETCTRLSET1: DMIC_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_DMIC_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_DMIC_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET1: DMIC_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_HASH_RST_SET_Pos 27                                                   /*!< SYSCON PRESETCTRLSET1: HASH_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_HASH_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_HASH_RST_SET_Pos) /*!< SYSCON PRESETCTRLSET1: HASH_RST_SET Mask */
#define SYSCON_PRESETCTRLSET1_TPR_RST_SET_Pos 28                                                    /*!< SYSCON PRESETCTRLSET1: TPR_RST_SET Position */
#define SYSCON_PRESETCTRLSET1_TPR_RST_SET_Msk (0x01UL << SYSCON_PRESETCTRLSET1_TPR_RST_SET_Pos)   /*!< SYSCON PRESETCTRLSET1: TPR_RST_SET Mask */

/* ---------------------------  u_syscon_PRESETCTRLCLR0  -------------------------- */
#define SYSCON_PRESETCTRLCLR0_FLASH_RST_CLR_Pos 8                                                   /*!< SYSCON PRESETCTRLCLR0: FLASH_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_FLASH_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_FLASH_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR0: FLASH_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_SPIFI_RST_CLR_Pos 10                                                  /*!< SYSCON PRESETCTRLCLR0: SPIFI_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_SPIFI_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_SPIFI_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR0: SPIFI_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_MUX_RST_CLR_Pos 11                                                    /*!< SYSCON PRESETCTRLCLR0: MUX_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_MUX_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_MUX_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR0: MUX_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_BLE_TIMING_GEN_RST_CLR_Pos 12                                         /*!< SYSCON PRESETCTRLCLR0: BLE_TIMING_GEN_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_BLE_TIMING_GEN_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_BLE_TIMING_GEN_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR0: BLE_TIMING_GEN_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_IOCON_RST_CLR_Pos 13                                                  /*!< SYSCON PRESETCTRLCLR0: IOCON_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_IOCON_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_IOCON_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR0: IOCON_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_GPIO_RST_CLR_Pos 14                                                   /*!< SYSCON PRESETCTRLCLR0: GPIO_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_GPIO_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_GPIO_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR0: GPIO_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_PINT_RST_CLR_Pos 18                                                   /*!< SYSCON PRESETCTRLCLR0: PINT_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_PINT_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_PINT_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR0: PINT_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_GINT_RST_CLR_Pos 19                                                   /*!< SYSCON PRESETCTRLCLR0: GINT_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_GINT_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_GINT_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR0: GINT_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_DMA_RST_CLR_Pos 20                                                    /*!< SYSCON PRESETCTRLCLR0: DMA_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_DMA_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_DMA_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR0: DMA_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_ISO7816_RST_CLR_Pos 21                                                /*!< SYSCON PRESETCTRLCLR0: ISO7816_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_ISO7816_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_ISO7816_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR0: ISO7816_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_WWDT_RST_CLR_Pos 22                                                   /*!< SYSCON PRESETCTRLCLR0: WWDT_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_WWDT_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_WWDT_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR0: WWDT_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_RTC_RST_CLR_Pos 23                                                    /*!< SYSCON PRESETCTRLCLR0: RTC_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_RTC_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_RTC_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR0: RTC_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_ANA_INT_CTRL_RST_CLR_Pos 24                                           /*!< SYSCON PRESETCTRLCLR0: ANA_INT_CTRL_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_ANA_INT_CTRL_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_ANA_INT_CTRL_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR0: ANA_INT_CTRL_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_WAKE_UP_TIMERS_RST_CLR_Pos 25                                         /*!< SYSCON PRESETCTRLCLR0: WAKE_UP_TIMERS_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_WAKE_UP_TIMERS_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_WAKE_UP_TIMERS_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR0: WAKE_UP_TIMERS_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_MAILBOX_RST_CLR_Pos 26                                                /*!< SYSCON PRESETCTRLCLR0: MAILBOX_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_MAILBOX_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_MAILBOX_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR0: MAILBOX_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_ADC_RST_CLR_Pos 27                                                    /*!< SYSCON PRESETCTRLCLR0: ADC_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_ADC_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_ADC_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR0: ADC_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_EFUSE_RST_CLR_Pos 28                                                  /*!< SYSCON PRESETCTRLCLR0: EFUSE_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_EFUSE_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_EFUSE_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR0: EFUSE_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR0_PVT_RST_CLR_Pos 29                                                    /*!< SYSCON PRESETCTRLCLR0: PVT_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR0_PVT_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR0_PVT_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR0: PVT_RST_CLR Mask */

/* ---------------------------  u_syscon_PRESETCTRLCLR1  -------------------------- */
#define SYSCON_PRESETCTRLCLR1_USART0_RST_CLR_Pos 11                                                 /*!< SYSCON PRESETCTRLCLR1: USART0_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_USART0_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_USART0_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR1: USART0_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_USART1_RST_CLR_Pos 12                                                 /*!< SYSCON PRESETCTRLCLR1: USART1_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_USART1_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_USART1_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR1: USART1_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_I2C0_RST_CLR_Pos 13                                                   /*!< SYSCON PRESETCTRLCLR1: I2C0_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_I2C0_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_I2C0_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR1: I2C0_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_I2C1_RST_CLR_Pos 14                                                   /*!< SYSCON PRESETCTRLCLR1: I2C1_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_I2C1_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_I2C1_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR1: I2C1_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_SPI0_RST_CLR_Pos 15                                                   /*!< SYSCON PRESETCTRLCLR1: SPI0_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_SPI0_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_SPI0_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR1: SPI0_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_SPI1_RST_CLR_Pos 16                                                   /*!< SYSCON PRESETCTRLCLR1: SPI1_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_SPI1_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_SPI1_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR1: SPI1_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_IR_RST_CLR_Pos 17                                                     /*!< SYSCON PRESETCTRLCLR1: IR_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_IR_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_IR_RST_CLR_Pos)     /*!< SYSCON PRESETCTRLCLR1: IR_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_PWM_RST_CLR_Pos 18                                                    /*!< SYSCON PRESETCTRLCLR1: PWM_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_PWM_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_PWM_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR1: PWM_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_RNG_RST_CLR_Pos 19                                                    /*!< SYSCON PRESETCTRLCLR1: RNG_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_RNG_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_RNG_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR1: RNG_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_I2C2_RST_CLR_Pos 20                                                   /*!< SYSCON PRESETCTRLCLR1: I2C2_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_I2C2_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_I2C2_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR1: I2C2_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_ZIGBEE_RST_CLR_Pos 21                                                 /*!< SYSCON PRESETCTRLCLR1: ZIGBEE_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_ZIGBEE_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_ZIGBEE_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR1: ZIGBEE_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_BLE_RST_CLR_Pos 22                                                    /*!< SYSCON PRESETCTRLCLR1: BLE_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_BLE_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_BLE_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR1: BLE_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_MODEM_MASTER_RST_CLR_Pos 23                                           /*!< SYSCON PRESETCTRLCLR1: MODEM_MASTER_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_MODEM_MASTER_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_MODEM_MASTER_RST_CLR_Pos)/*!< SYSCON PRESETCTRLCLR1: MODEM_MASTER_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_AES_RST_CLR_Pos 24                                                    /*!< SYSCON PRESETCTRLCLR1: AES_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_AES_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_AES_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR1: AES_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_RFP_RST_CLR_Pos 25                                                    /*!< SYSCON PRESETCTRLCLR1: RFP_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_RFP_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_RFP_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR1: RFP_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_DMIC_RST_CLR_Pos 26                                                   /*!< SYSCON PRESETCTRLCLR1: DMIC_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_DMIC_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_DMIC_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR1: DMIC_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_HASH_RST_CLR_Pos 27                                                   /*!< SYSCON PRESETCTRLCLR1: HASH_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_HASH_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_HASH_RST_CLR_Pos) /*!< SYSCON PRESETCTRLCLR1: HASH_RST_CLR Mask */
#define SYSCON_PRESETCTRLCLR1_TPR_RST_CLR_Pos 28                                                    /*!< SYSCON PRESETCTRLCLR1: TPR_RST_CLR Position */
#define SYSCON_PRESETCTRLCLR1_TPR_RST_CLR_Msk (0x01UL << SYSCON_PRESETCTRLCLR1_TPR_RST_CLR_Pos)   /*!< SYSCON PRESETCTRLCLR1: TPR_RST_CLR Mask */

/* ----------------------------  u_syscon_AHBCLKCTRL0  ---------------------------- */
#define SYSCON_AHBCLKCTRL0_ROM_Pos          1                                                       /*!< SYSCON AHBCLKCTRL0: ROM Position      */
#define SYSCON_AHBCLKCTRL0_ROM_Msk          (0x01UL << SYSCON_AHBCLKCTRL0_ROM_Pos)                /*!< SYSCON AHBCLKCTRL0: ROM Mask          */
#define SYSCON_AHBCLKCTRL0_SRAM_CTRL0_Pos   3                                                       /*!< SYSCON AHBCLKCTRL0: SRAM_CTRL0 Position */
#define SYSCON_AHBCLKCTRL0_SRAM_CTRL0_Msk   (0x01UL << SYSCON_AHBCLKCTRL0_SRAM_CTRL0_Pos)         /*!< SYSCON AHBCLKCTRL0: SRAM_CTRL0 Mask   */
#define SYSCON_AHBCLKCTRL0_SRAM_CTRL1_Pos   4                                                       /*!< SYSCON AHBCLKCTRL0: SRAM_CTRL1 Position */
#define SYSCON_AHBCLKCTRL0_SRAM_CTRL1_Msk   (0x01UL << SYSCON_AHBCLKCTRL0_SRAM_CTRL1_Pos)         /*!< SYSCON AHBCLKCTRL0: SRAM_CTRL1 Mask   */
#define SYSCON_AHBCLKCTRL0_FLASH_Pos        8                                                       /*!< SYSCON AHBCLKCTRL0: FLASH Position    */
#define SYSCON_AHBCLKCTRL0_FLASH_Msk        (0x01UL << SYSCON_AHBCLKCTRL0_FLASH_Pos)              /*!< SYSCON AHBCLKCTRL0: FLASH Mask        */
#define SYSCON_AHBCLKCTRL0_SPIFI_Pos        10                                                      /*!< SYSCON AHBCLKCTRL0: SPIFI Position    */
#define SYSCON_AHBCLKCTRL0_SPIFI_Msk        (0x01UL << SYSCON_AHBCLKCTRL0_SPIFI_Pos)              /*!< SYSCON AHBCLKCTRL0: SPIFI Mask        */
#define SYSCON_AHBCLKCTRL0_MUX_Pos          11                                                      /*!< SYSCON AHBCLKCTRL0: MUX Position      */
#define SYSCON_AHBCLKCTRL0_MUX_Msk          (0x01UL << SYSCON_AHBCLKCTRL0_MUX_Pos)                /*!< SYSCON AHBCLKCTRL0: MUX Mask          */
#define SYSCON_AHBCLKCTRL0_IOCON_Pos        13                                                      /*!< SYSCON AHBCLKCTRL0: IOCON Position    */
#define SYSCON_AHBCLKCTRL0_IOCON_Msk        (0x01UL << SYSCON_AHBCLKCTRL0_IOCON_Pos)              /*!< SYSCON AHBCLKCTRL0: IOCON Mask        */
#define SYSCON_AHBCLKCTRL0_GPIO_Pos         14                                                      /*!< SYSCON AHBCLKCTRL0: GPIO Position     */
#define SYSCON_AHBCLKCTRL0_GPIO_Msk         (0x01UL << SYSCON_AHBCLKCTRL0_GPIO_Pos)               /*!< SYSCON AHBCLKCTRL0: GPIO Mask         */
#define SYSCON_AHBCLKCTRL0_PINT_Pos         18                                                      /*!< SYSCON AHBCLKCTRL0: PINT Position     */
#define SYSCON_AHBCLKCTRL0_PINT_Msk         (0x01UL << SYSCON_AHBCLKCTRL0_PINT_Pos)               /*!< SYSCON AHBCLKCTRL0: PINT Mask         */
#define SYSCON_AHBCLKCTRL0_GINT_Pos         19                                                      /*!< SYSCON AHBCLKCTRL0: GINT Position     */
#define SYSCON_AHBCLKCTRL0_GINT_Msk         (0x01UL << SYSCON_AHBCLKCTRL0_GINT_Pos)               /*!< SYSCON AHBCLKCTRL0: GINT Mask         */
#define SYSCON_AHBCLKCTRL0_DMA_Pos          20                                                      /*!< SYSCON AHBCLKCTRL0: DMA Position      */
#define SYSCON_AHBCLKCTRL0_DMA_Msk          (0x01UL << SYSCON_AHBCLKCTRL0_DMA_Pos)                /*!< SYSCON AHBCLKCTRL0: DMA Mask          */
#define SYSCON_AHBCLKCTRL0_ISO7816_Pos      21                                                      /*!< SYSCON AHBCLKCTRL0: ISO7816 Position  */
#define SYSCON_AHBCLKCTRL0_ISO7816_Msk      (0x01UL << SYSCON_AHBCLKCTRL0_ISO7816_Pos)            /*!< SYSCON AHBCLKCTRL0: ISO7816 Mask      */
#define SYSCON_AHBCLKCTRL0_WWDT_Pos         22                                                      /*!< SYSCON AHBCLKCTRL0: WWDT Position     */
#define SYSCON_AHBCLKCTRL0_WWDT_Msk         (0x01UL << SYSCON_AHBCLKCTRL0_WWDT_Pos)               /*!< SYSCON AHBCLKCTRL0: WWDT Mask         */
#define SYSCON_AHBCLKCTRL0_RTC_Pos          23                                                      /*!< SYSCON AHBCLKCTRL0: RTC Position      */
#define SYSCON_AHBCLKCTRL0_RTC_Msk          (0x01UL << SYSCON_AHBCLKCTRL0_RTC_Pos)                /*!< SYSCON AHBCLKCTRL0: RTC Mask          */
#define SYSCON_AHBCLKCTRL0_ANA_INT_CTRL_Pos 24                                                      /*!< SYSCON AHBCLKCTRL0: ANA_INT_CTRL Position */
#define SYSCON_AHBCLKCTRL0_ANA_INT_CTRL_Msk (0x01UL << SYSCON_AHBCLKCTRL0_ANA_INT_CTRL_Pos)       /*!< SYSCON AHBCLKCTRL0: ANA_INT_CTRL Mask */
#define SYSCON_AHBCLKCTRL0_WAKE_UP_TIMERS_Pos 25                                                    /*!< SYSCON AHBCLKCTRL0: WAKE_UP_TIMERS Position */
#define SYSCON_AHBCLKCTRL0_WAKE_UP_TIMERS_Msk (0x01UL << SYSCON_AHBCLKCTRL0_WAKE_UP_TIMERS_Pos)   /*!< SYSCON AHBCLKCTRL0: WAKE_UP_TIMERS Mask */
#define SYSCON_AHBCLKCTRL0_MAILBOX_Pos      26                                                      /*!< SYSCON AHBCLKCTRL0: MAILBOX Position  */
#define SYSCON_AHBCLKCTRL0_MAILBOX_Msk      (0x01UL << SYSCON_AHBCLKCTRL0_MAILBOX_Pos)            /*!< SYSCON AHBCLKCTRL0: MAILBOX Mask      */
#define SYSCON_AHBCLKCTRL0_ADC_Pos          27                                                      /*!< SYSCON AHBCLKCTRL0: ADC Position      */
#define SYSCON_AHBCLKCTRL0_ADC_Msk          (0x01UL << SYSCON_AHBCLKCTRL0_ADC_Pos)                /*!< SYSCON AHBCLKCTRL0: ADC Mask          */
#define SYSCON_AHBCLKCTRL0_EFUSE_Pos        28                                                      /*!< SYSCON AHBCLKCTRL0: EFUSE Position    */
#define SYSCON_AHBCLKCTRL0_EFUSE_Msk        (0x01UL << SYSCON_AHBCLKCTRL0_EFUSE_Pos)              /*!< SYSCON AHBCLKCTRL0: EFUSE Mask        */
#define SYSCON_AHBCLKCTRL0_PVT_Pos          29                                                      /*!< SYSCON AHBCLKCTRL0: PVT Position      */
#define SYSCON_AHBCLKCTRL0_PVT_Msk          (0x01UL << SYSCON_AHBCLKCTRL0_PVT_Pos)                /*!< SYSCON AHBCLKCTRL0: PVT Mask          */

/* ----------------------------  u_syscon_AHBCLKCTRL1  ---------------------------- */
#define SYSCON_AHBCLKCTRL1_USART0_Pos       11                                                      /*!< SYSCON AHBCLKCTRL1: USART0 Position   */
#define SYSCON_AHBCLKCTRL1_USART0_Msk       (0x01UL << SYSCON_AHBCLKCTRL1_USART0_Pos)             /*!< SYSCON AHBCLKCTRL1: USART0 Mask       */
#define SYSCON_AHBCLKCTRL1_USART1_Pos       12                                                      /*!< SYSCON AHBCLKCTRL1: USART1 Position   */
#define SYSCON_AHBCLKCTRL1_USART1_Msk       (0x01UL << SYSCON_AHBCLKCTRL1_USART1_Pos)             /*!< SYSCON AHBCLKCTRL1: USART1 Mask       */
#define SYSCON_AHBCLKCTRL1_I2C0_Pos         13                                                      /*!< SYSCON AHBCLKCTRL1: I2C0 Position     */
#define SYSCON_AHBCLKCTRL1_I2C0_Msk         (0x01UL << SYSCON_AHBCLKCTRL1_I2C0_Pos)               /*!< SYSCON AHBCLKCTRL1: I2C0 Mask         */
#define SYSCON_AHBCLKCTRL1_I2C1_Pos         14                                                      /*!< SYSCON AHBCLKCTRL1: I2C1 Position     */
#define SYSCON_AHBCLKCTRL1_I2C1_Msk         (0x01UL << SYSCON_AHBCLKCTRL1_I2C1_Pos)               /*!< SYSCON AHBCLKCTRL1: I2C1 Mask         */
#define SYSCON_AHBCLKCTRL1_SPI0_Pos         15                                                      /*!< SYSCON AHBCLKCTRL1: SPI0 Position     */
#define SYSCON_AHBCLKCTRL1_SPI0_Msk         (0x01UL << SYSCON_AHBCLKCTRL1_SPI0_Pos)               /*!< SYSCON AHBCLKCTRL1: SPI0 Mask         */
#define SYSCON_AHBCLKCTRL1_SPI1_Pos         16                                                      /*!< SYSCON AHBCLKCTRL1: SPI1 Position     */
#define SYSCON_AHBCLKCTRL1_SPI1_Msk         (0x01UL << SYSCON_AHBCLKCTRL1_SPI1_Pos)               /*!< SYSCON AHBCLKCTRL1: SPI1 Mask         */
#define SYSCON_AHBCLKCTRL1_IR_Pos           17                                                      /*!< SYSCON AHBCLKCTRL1: IR Position       */
#define SYSCON_AHBCLKCTRL1_IR_Msk           (0x01UL << SYSCON_AHBCLKCTRL1_IR_Pos)                 /*!< SYSCON AHBCLKCTRL1: IR Mask           */
#define SYSCON_AHBCLKCTRL1_PWM_Pos          18                                                      /*!< SYSCON AHBCLKCTRL1: PWM Position      */
#define SYSCON_AHBCLKCTRL1_PWM_Msk          (0x01UL << SYSCON_AHBCLKCTRL1_PWM_Pos)                /*!< SYSCON AHBCLKCTRL1: PWM Mask          */
#define SYSCON_AHBCLKCTRL1_RNG_Pos          19                                                      /*!< SYSCON AHBCLKCTRL1: RNG Position      */
#define SYSCON_AHBCLKCTRL1_RNG_Msk          (0x01UL << SYSCON_AHBCLKCTRL1_RNG_Pos)                /*!< SYSCON AHBCLKCTRL1: RNG Mask          */
#define SYSCON_AHBCLKCTRL1_I2C2_Pos         20                                                      /*!< SYSCON AHBCLKCTRL1: I2C2 Position     */
#define SYSCON_AHBCLKCTRL1_I2C2_Msk         (0x01UL << SYSCON_AHBCLKCTRL1_I2C2_Pos)               /*!< SYSCON AHBCLKCTRL1: I2C2 Mask         */
#define SYSCON_AHBCLKCTRL1_ZIGBEE_Pos       21                                                      /*!< SYSCON AHBCLKCTRL1: ZIGBEE Position   */
#define SYSCON_AHBCLKCTRL1_ZIGBEE_Msk       (0x01UL << SYSCON_AHBCLKCTRL1_ZIGBEE_Pos)             /*!< SYSCON AHBCLKCTRL1: ZIGBEE Mask       */
#define SYSCON_AHBCLKCTRL1_BLE_Pos          22                                                      /*!< SYSCON AHBCLKCTRL1: BLE Position      */
#define SYSCON_AHBCLKCTRL1_BLE_Msk          (0x01UL << SYSCON_AHBCLKCTRL1_BLE_Pos)                /*!< SYSCON AHBCLKCTRL1: BLE Mask          */
#define SYSCON_AHBCLKCTRL1_MODEM_MASTER_Pos 23                                                      /*!< SYSCON AHBCLKCTRL1: MODEM_MASTER Position */
#define SYSCON_AHBCLKCTRL1_MODEM_MASTER_Msk (0x01UL << SYSCON_AHBCLKCTRL1_MODEM_MASTER_Pos)       /*!< SYSCON AHBCLKCTRL1: MODEM_MASTER Mask */
#define SYSCON_AHBCLKCTRL1_AES_Pos          24                                                      /*!< SYSCON AHBCLKCTRL1: AES Position      */
#define SYSCON_AHBCLKCTRL1_AES_Msk          (0x01UL << SYSCON_AHBCLKCTRL1_AES_Pos)                /*!< SYSCON AHBCLKCTRL1: AES Mask          */
#define SYSCON_AHBCLKCTRL1_RFP_Pos          25                                                      /*!< SYSCON AHBCLKCTRL1: RFP Position      */
#define SYSCON_AHBCLKCTRL1_RFP_Msk          (0x01UL << SYSCON_AHBCLKCTRL1_RFP_Pos)                /*!< SYSCON AHBCLKCTRL1: RFP Mask          */
#define SYSCON_AHBCLKCTRL1_DMIC_Pos         26                                                      /*!< SYSCON AHBCLKCTRL1: DMIC Position     */
#define SYSCON_AHBCLKCTRL1_DMIC_Msk         (0x01UL << SYSCON_AHBCLKCTRL1_DMIC_Pos)               /*!< SYSCON AHBCLKCTRL1: DMIC Mask         */
#define SYSCON_AHBCLKCTRL1_HASH_Pos         27                                                      /*!< SYSCON AHBCLKCTRL1: HASH Position     */
#define SYSCON_AHBCLKCTRL1_HASH_Msk         (0x01UL << SYSCON_AHBCLKCTRL1_HASH_Pos)               /*!< SYSCON AHBCLKCTRL1: HASH Mask         */
#define SYSCON_AHBCLKCTRL1_TPR_Pos          28                                                      /*!< SYSCON AHBCLKCTRL1: TPR Position      */
#define SYSCON_AHBCLKCTRL1_TPR_Msk          (0x01UL << SYSCON_AHBCLKCTRL1_TPR_Pos)                /*!< SYSCON AHBCLKCTRL1: TPR Mask          */

/* ---------------------------  u_syscon_AHBCLKCTRLSET0  -------------------------- */
#define SYSCON_AHBCLKCTRLSET0_ROM_CLK_SET_Pos 1                                                     /*!< SYSCON AHBCLKCTRLSET0: ROM_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_ROM_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_ROM_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET0: ROM_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_SRAM_CTRL0_CLK_SET_Pos 3                                              /*!< SYSCON AHBCLKCTRLSET0: SRAM_CTRL0_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_SRAM_CTRL0_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_SRAM_CTRL0_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET0: SRAM_CTRL0_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_SRAM_CTRL1_CLK_SET_Pos 4                                              /*!< SYSCON AHBCLKCTRLSET0: SRAM_CTRL1_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_SRAM_CTRL1_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_SRAM_CTRL1_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET0: SRAM_CTRL1_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_FLASH_CLK_SET_Pos 8                                                   /*!< SYSCON AHBCLKCTRLSET0: FLASH_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_FLASH_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_FLASH_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET0: FLASH_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_SPIFI_CLK_SET_Pos 10                                                  /*!< SYSCON AHBCLKCTRLSET0: SPIFI_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_SPIFI_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_SPIFI_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET0: SPIFI_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_MUX_CLK_SET_Pos 11                                                    /*!< SYSCON AHBCLKCTRLSET0: MUX_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_MUX_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_MUX_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET0: MUX_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_IOCON_CLK_SET_Pos 13                                                  /*!< SYSCON AHBCLKCTRLSET0: IOCON_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_IOCON_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_IOCON_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET0: IOCON_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_GPIO_CLK_SET_Pos 14                                                   /*!< SYSCON AHBCLKCTRLSET0: GPIO_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_GPIO_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_GPIO_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET0: GPIO_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_PINT_CLK_SET_Pos 18                                                   /*!< SYSCON AHBCLKCTRLSET0: PINT_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_PINT_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_PINT_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET0: PINT_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_GINT_CLK_SET_Pos 19                                                   /*!< SYSCON AHBCLKCTRLSET0: GINT_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_GINT_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_GINT_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET0: GINT_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_DMA_CLK_SET_Pos 20                                                    /*!< SYSCON AHBCLKCTRLSET0: DMA_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_DMA_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_DMA_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET0: DMA_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_ISO7816_CLK_SET_Pos 21                                                /*!< SYSCON AHBCLKCTRLSET0: ISO7816_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_ISO7816_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_ISO7816_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET0: ISO7816_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_WWDT_CLK_SET_Pos 22                                                   /*!< SYSCON AHBCLKCTRLSET0: WWDT_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_WWDT_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_WWDT_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET0: WWDT_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_RTC_CLK_SET_Pos 23                                                    /*!< SYSCON AHBCLKCTRLSET0: RTC_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_RTC_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_RTC_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET0: RTC_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_ANA_INT_CTRL_CLK_SET_Pos 24                                           /*!< SYSCON AHBCLKCTRLSET0: ANA_INT_CTRL_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_ANA_INT_CTRL_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_ANA_INT_CTRL_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET0: ANA_INT_CTRL_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_WAKE_UP_TIMERS_CLK_SET_Pos 25                                         /*!< SYSCON AHBCLKCTRLSET0: WAKE_UP_TIMERS_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_WAKE_UP_TIMERS_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_WAKE_UP_TIMERS_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET0: WAKE_UP_TIMERS_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_MAILBOX_CLK_SET_Pos 26                                                /*!< SYSCON AHBCLKCTRLSET0: MAILBOX_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_MAILBOX_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_MAILBOX_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET0: MAILBOX_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_ADC_CLK_SET_Pos 27                                                    /*!< SYSCON AHBCLKCTRLSET0: ADC_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_ADC_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_ADC_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET0: ADC_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_EFUSE_CLK_SET_Pos 28                                                  /*!< SYSCON AHBCLKCTRLSET0: EFUSE_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_EFUSE_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_EFUSE_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET0: EFUSE_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET0_PVT_CLK_SET_Pos 29                                                    /*!< SYSCON AHBCLKCTRLSET0: PVT_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET0_PVT_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET0_PVT_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET0: PVT_CLK_SET Mask */

/* ---------------------------  u_syscon_AHBCLKCTRLSET1  -------------------------- */
#define SYSCON_AHBCLKCTRLSET1_USART0_CLK_SET_Pos 11                                                 /*!< SYSCON AHBCLKCTRLSET1: USART0_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_USART0_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_USART0_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET1: USART0_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_USART1_CLK_SET_Pos 12                                                 /*!< SYSCON AHBCLKCTRLSET1: USART1_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_USART1_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_USART1_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET1: USART1_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_I2C0_CLK_SET_Pos 13                                                   /*!< SYSCON AHBCLKCTRLSET1: I2C0_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_I2C0_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_I2C0_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET1: I2C0_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_I2C1_CLK_SET_Pos 14                                                   /*!< SYSCON AHBCLKCTRLSET1: I2C1_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_I2C1_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_I2C1_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET1: I2C1_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_SPI0_CLK_SET_Pos 15                                                   /*!< SYSCON AHBCLKCTRLSET1: SPI0_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_SPI0_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_SPI0_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET1: SPI0_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_SPI1_CLK_SET_Pos 16                                                   /*!< SYSCON AHBCLKCTRLSET1: SPI1_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_SPI1_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_SPI1_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET1: SPI1_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_IR_CLK_SET_Pos 17                                                     /*!< SYSCON AHBCLKCTRLSET1: IR_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_IR_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_IR_CLK_SET_Pos)     /*!< SYSCON AHBCLKCTRLSET1: IR_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_PWM_CLK_SET_Pos 18                                                    /*!< SYSCON AHBCLKCTRLSET1: PWM_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_PWM_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_PWM_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET1: PWM_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_RNG_CLK_SET_Pos 19                                                    /*!< SYSCON AHBCLKCTRLSET1: RNG_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_RNG_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_RNG_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET1: RNG_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_I2C2_CLK_SET_Pos 20                                                   /*!< SYSCON AHBCLKCTRLSET1: I2C2_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_I2C2_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_I2C2_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET1: I2C2_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_ZIGBEE_CLK_SET_Pos 21                                                 /*!< SYSCON AHBCLKCTRLSET1: ZIGBEE_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_ZIGBEE_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_ZIGBEE_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET1: ZIGBEE_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_BLE_CLK_SET_Pos 22                                                    /*!< SYSCON AHBCLKCTRLSET1: BLE_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_BLE_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_BLE_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET1: BLE_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_MODEM_MASTER_CLK_SET_Pos 23                                           /*!< SYSCON AHBCLKCTRLSET1: MODEM_MASTER_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_MODEM_MASTER_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_MODEM_MASTER_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLSET1: MODEM_MASTER_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_AES_CLK_SET_Pos 24                                                    /*!< SYSCON AHBCLKCTRLSET1: AES_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_AES_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_AES_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET1: AES_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_RFP_CLK_SET_Pos 25                                                    /*!< SYSCON AHBCLKCTRLSET1: RFP_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_RFP_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_RFP_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET1: RFP_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_DMIC_CLK_SET_Pos 26                                                   /*!< SYSCON AHBCLKCTRLSET1: DMIC_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_DMIC_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_DMIC_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET1: DMIC_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_HASH_CLK_SET_Pos 27                                                   /*!< SYSCON AHBCLKCTRLSET1: HASH_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_HASH_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_HASH_CLK_SET_Pos) /*!< SYSCON AHBCLKCTRLSET1: HASH_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLSET1_TPR_CLK_SET_Pos 28                                                    /*!< SYSCON AHBCLKCTRLSET1: TPR_CLK_SET Position */
#define SYSCON_AHBCLKCTRLSET1_TPR_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLSET1_TPR_CLK_SET_Pos)   /*!< SYSCON AHBCLKCTRLSET1: TPR_CLK_SET Mask */

/* ---------------------------  u_syscon_AHBCLKCTRLCLR0  -------------------------- */
#define SYSCON_AHBCLKCTRLCLR0_ROM_CLK_CLR_Pos 1                                                     /*!< SYSCON AHBCLKCTRLCLR0: ROM_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_ROM_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_ROM_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR0: ROM_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_SRAM_CTRL0_CLK_CLR_Pos 3                                              /*!< SYSCON AHBCLKCTRLCLR0: SRAM_CTRL0_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_SRAM_CTRL0_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_SRAM_CTRL0_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR0: SRAM_CTRL0_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_SRAM_CTRL1_CLK_CLR_Pos 4                                              /*!< SYSCON AHBCLKCTRLCLR0: SRAM_CTRL1_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_SRAM_CTRL1_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_SRAM_CTRL1_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR0: SRAM_CTRL1_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_FLASH_CLK_CLR_Pos 8                                                   /*!< SYSCON AHBCLKCTRLCLR0: FLASH_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_FLASH_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_FLASH_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR0: FLASH_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_SPIFI_CLK_CLR_Pos 10                                                  /*!< SYSCON AHBCLKCTRLCLR0: SPIFI_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_SPIFI_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_SPIFI_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR0: SPIFI_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_MUX_CLK_CLR_Pos 11                                                    /*!< SYSCON AHBCLKCTRLCLR0: MUX_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_MUX_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_MUX_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR0: MUX_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_IOCON_CLK_CLR_Pos 13                                                  /*!< SYSCON AHBCLKCTRLCLR0: IOCON_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_IOCON_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_IOCON_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR0: IOCON_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_GPIO_CLK_CLR_Pos 14                                                   /*!< SYSCON AHBCLKCTRLCLR0: GPIO_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_GPIO_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_GPIO_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR0: GPIO_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_PINT_CLK_CLR_Pos 18                                                   /*!< SYSCON AHBCLKCTRLCLR0: PINT_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_PINT_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_PINT_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR0: PINT_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_GINT_CLK_CLR_Pos 19                                                   /*!< SYSCON AHBCLKCTRLCLR0: GINT_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_GINT_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_GINT_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR0: GINT_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_DMA_CLK_CLR_Pos 20                                                    /*!< SYSCON AHBCLKCTRLCLR0: DMA_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_DMA_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_DMA_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR0: DMA_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_ISO7816_CLK_CLR_Pos 21                                                /*!< SYSCON AHBCLKCTRLCLR0: ISO7816_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_ISO7816_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_ISO7816_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR0: ISO7816_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_WWDT_CLK_CLR_Pos 22                                                   /*!< SYSCON AHBCLKCTRLCLR0: WWDT_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_WWDT_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_WWDT_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR0: WWDT_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_RTC_CLK_CLR_Pos 23                                                    /*!< SYSCON AHBCLKCTRLCLR0: RTC_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_RTC_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_RTC_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR0: RTC_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_ANA_INT_CTRL_CLK_SET_Pos 24                                           /*!< SYSCON AHBCLKCTRLCLR0: ANA_INT_CTRL_CLK_SET Position */
#define SYSCON_AHBCLKCTRLCLR0_ANA_INT_CTRL_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_ANA_INT_CTRL_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLCLR0: ANA_INT_CTRL_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLCLR0_WAKE_UP_TIMERS_CLK_SET_Pos 25                                         /*!< SYSCON AHBCLKCTRLCLR0: WAKE_UP_TIMERS_CLK_SET Position */
#define SYSCON_AHBCLKCTRLCLR0_WAKE_UP_TIMERS_CLK_SET_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_WAKE_UP_TIMERS_CLK_SET_Pos)/*!< SYSCON AHBCLKCTRLCLR0: WAKE_UP_TIMERS_CLK_SET Mask */
#define SYSCON_AHBCLKCTRLCLR0_MAILBOX_CLK_CLR_Pos 26                                                /*!< SYSCON AHBCLKCTRLCLR0: MAILBOX_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_MAILBOX_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_MAILBOX_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR0: MAILBOX_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_ADC_CLK_CLR_Pos 27                                                    /*!< SYSCON AHBCLKCTRLCLR0: ADC_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_ADC_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_ADC_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR0: ADC_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_EFUSE_CLK_CLR_Pos 28                                                  /*!< SYSCON AHBCLKCTRLCLR0: EFUSE_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_EFUSE_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_EFUSE_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR0: EFUSE_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR0_PVT_CLK_CLR_Pos 29                                                    /*!< SYSCON AHBCLKCTRLCLR0: PVT_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR0_PVT_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR0_PVT_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR0: PVT_CLK_CLR Mask */

/* ---------------------------  u_syscon_AHBCLKCTRLCLR1  -------------------------- */
#define SYSCON_AHBCLKCTRLCLR1_USART0_CLK_CLR_Pos 11                                                 /*!< SYSCON AHBCLKCTRLCLR1: USART0_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_USART0_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_USART0_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR1: USART0_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_USART1_CLK_CLR_Pos 12                                                 /*!< SYSCON AHBCLKCTRLCLR1: USART1_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_USART1_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_USART1_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR1: USART1_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_I2C0_CLK_CLR_Pos 13                                                   /*!< SYSCON AHBCLKCTRLCLR1: I2C0_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_I2C0_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_I2C0_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR1: I2C0_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_I2C1_CLK_CLR_Pos 14                                                   /*!< SYSCON AHBCLKCTRLCLR1: I2C1_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_I2C1_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_I2C1_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR1: I2C1_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_SPI0_CLK_CLR_Pos 15                                                   /*!< SYSCON AHBCLKCTRLCLR1: SPI0_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_SPI0_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_SPI0_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR1: SPI0_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_SPI1_CLK_CLR_Pos 16                                                   /*!< SYSCON AHBCLKCTRLCLR1: SPI1_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_SPI1_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_SPI1_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR1: SPI1_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_IR_CLK_CLR_Pos 17                                                     /*!< SYSCON AHBCLKCTRLCLR1: IR_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_IR_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_IR_CLK_CLR_Pos)     /*!< SYSCON AHBCLKCTRLCLR1: IR_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_PWM_CLK_CLR_Pos 18                                                    /*!< SYSCON AHBCLKCTRLCLR1: PWM_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_PWM_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_PWM_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR1: PWM_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_RNG_CLK_CLR_Pos 19                                                    /*!< SYSCON AHBCLKCTRLCLR1: RNG_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_RNG_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_RNG_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR1: RNG_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_I2C2_CLK_CLR_Pos 20                                                   /*!< SYSCON AHBCLKCTRLCLR1: I2C2_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_I2C2_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_I2C2_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR1: I2C2_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_ZIGBEE_CLK_CLR_Pos 21                                                 /*!< SYSCON AHBCLKCTRLCLR1: ZIGBEE_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_ZIGBEE_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_ZIGBEE_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR1: ZIGBEE_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_BLE_CLK_CLR_Pos 22                                                    /*!< SYSCON AHBCLKCTRLCLR1: BLE_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_BLE_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_BLE_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR1: BLE_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_MODEM_MASTER_CLK_CLR_Pos 23                                           /*!< SYSCON AHBCLKCTRLCLR1: MODEM_MASTER_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_MODEM_MASTER_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_MODEM_MASTER_CLK_CLR_Pos)/*!< SYSCON AHBCLKCTRLCLR1: MODEM_MASTER_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_AES_CLK_CLR_Pos 24                                                    /*!< SYSCON AHBCLKCTRLCLR1: AES_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_AES_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_AES_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR1: AES_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_RFP_CLK_CLR_Pos 25                                                    /*!< SYSCON AHBCLKCTRLCLR1: RFP_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_RFP_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_RFP_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR1: RFP_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_DMIC_CLK_CLR_Pos 26                                                   /*!< SYSCON AHBCLKCTRLCLR1: DMIC_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_DMIC_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_DMIC_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR1: DMIC_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_HASH_CLK_CLR_Pos 27                                                   /*!< SYSCON AHBCLKCTRLCLR1: HASH_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_HASH_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_HASH_CLK_CLR_Pos) /*!< SYSCON AHBCLKCTRLCLR1: HASH_CLK_CLR Mask */
#define SYSCON_AHBCLKCTRLCLR1_TPR_CLK_CLR_Pos 28                                                    /*!< SYSCON AHBCLKCTRLCLR1: TPR_CLK_CLR Position */
#define SYSCON_AHBCLKCTRLCLR1_TPR_CLK_CLR_Msk (0x01UL << SYSCON_AHBCLKCTRLCLR1_TPR_CLK_CLR_Pos)   /*!< SYSCON AHBCLKCTRLCLR1: TPR_CLK_CLR Mask */

/* -----------------------------  u_syscon_MAINCLKSEL  ---------------------------- */
#define SYSCON_MAINCLKSEL_SEL_Pos           0                                                       /*!< SYSCON MAINCLKSEL: SEL Position       */
#define SYSCON_MAINCLKSEL_SEL_Msk           (0x07UL << SYSCON_MAINCLKSEL_SEL_Pos)                 /*!< SYSCON MAINCLKSEL: SEL Mask           */

/* ----------------------------  u_syscon_OSC32CLKSEL  ---------------------------- */
#define SYSCON_OSC32CLKSEL_SEL32MHZ_Pos     0                                                       /*!< SYSCON OSC32CLKSEL: SEL32MHZ Position */
#define SYSCON_OSC32CLKSEL_SEL32MHZ_Msk     (0x01UL << SYSCON_OSC32CLKSEL_SEL32MHZ_Pos)           /*!< SYSCON OSC32CLKSEL: SEL32MHZ Mask     */
#define SYSCON_OSC32CLKSEL_SEL32KHZ_Pos     1                                                       /*!< SYSCON OSC32CLKSEL: SEL32KHZ Position */
#define SYSCON_OSC32CLKSEL_SEL32KHZ_Msk     (0x01UL << SYSCON_OSC32CLKSEL_SEL32KHZ_Pos)           /*!< SYSCON OSC32CLKSEL: SEL32KHZ Mask     */

/* -----------------------------  u_syscon_CLKOUTSEL  ----------------------------- */
#define SYSCON_CLKOUTSEL_SEL_Pos            0                                                       /*!< SYSCON CLKOUTSEL: SEL Position        */
#define SYSCON_CLKOUTSEL_SEL_Msk            (0x07UL << SYSCON_CLKOUTSEL_SEL_Pos)                  /*!< SYSCON CLKOUTSEL: SEL Mask            */

/* ----------------------------  u_syscon_SPIFICLKSEL  ---------------------------- */
#define SYSCON_SPIFICLKSEL_SEL_Pos          0                                                       /*!< SYSCON SPIFICLKSEL: SEL Position      */
#define SYSCON_SPIFICLKSEL_SEL_Msk          (0x07UL << SYSCON_SPIFICLKSEL_SEL_Pos)                /*!< SYSCON SPIFICLKSEL: SEL Mask          */

/* -----------------------------  u_syscon_ADCCLKSEL  ----------------------------- */
#define SYSCON_ADCCLKSEL_SEL_Pos            0                                                       /*!< SYSCON ADCCLKSEL: SEL Position        */
#define SYSCON_ADCCLKSEL_SEL_Msk            (0x03UL << SYSCON_ADCCLKSEL_SEL_Pos)                  /*!< SYSCON ADCCLKSEL: SEL Mask            */

/* ----------------------------  u_syscon_USARTCLKSEL  ---------------------------- */
#define SYSCON_USARTCLKSEL_SEL_Pos          0                                                       /*!< SYSCON USARTCLKSEL: SEL Position      */
#define SYSCON_USARTCLKSEL_SEL_Msk          (0x03UL << SYSCON_USARTCLKSEL_SEL_Pos)                /*!< SYSCON USARTCLKSEL: SEL Mask          */

/* -----------------------------  u_syscon_I2CCLKSEL  ----------------------------- */
#define u_syscon_I2CCLKSEL_SEL_Pos            0                                                       /*!< u_syscon I2CCLKSEL: SEL Position        */
#define u_syscon_I2CCLKSEL_SEL_Msk            (0x03UL << u_syscon_I2CCLKSEL_SEL_Pos)                  /*!< u_syscon I2CCLKSEL: SEL Mask            */

/* -----------------------------  u_syscon_SPICLKSEL  ----------------------------- */
#define SYSCON_SPICLKSEL_SEL_Pos            0                                                       /*!< SYSCON SPICLKSEL: SEL Position        */
#define SYSCON_SPICLKSEL_SEL_Msk            (0x03UL << SYSCON_SPICLKSEL_SEL_Pos)                  /*!< SYSCON SPICLKSEL: SEL Mask            */

/* ------------------------------  u_syscon_IRCLKSEL  ----------------------------- */
#define SYSCON_IRCLKSEL_SEL_Pos             0                                                       /*!< SYSCON IRCLKSEL: SEL Position         */
#define SYSCON_IRCLKSEL_SEL_Msk             (0x03UL << SYSCON_IRCLKSEL_SEL_Pos)                   /*!< SYSCON IRCLKSEL: SEL Mask             */

/* -----------------------------  u_syscon_PWMCLKSEL  ----------------------------- */
#define SYSCON_PWMCLKSEL_SEL_Pos            0                                                       /*!< SYSCON PWMCLKSEL: SEL Position        */
#define SYSCON_PWMCLKSEL_SEL_Msk            (0x03UL << SYSCON_PWMCLKSEL_SEL_Pos)                  /*!< SYSCON PWMCLKSEL: SEL Mask            */

/* -----------------------------  u_syscon_WDTCLKSEL  ----------------------------- */
#define SYSCON_WDTCLKSEL_SEL_Pos            0                                                       /*!< SYSCON WDTCLKSEL: SEL Position        */
#define SYSCON_WDTCLKSEL_SEL_Msk            (0x03UL << SYSCON_WDTCLKSEL_SEL_Pos)                  /*!< SYSCON WDTCLKSEL: SEL Mask            */

/* ----------------------------  u_syscon_MODEMCLKSEL  ---------------------------- */
#define SYSCON_MODEMCLKSEL_SEL_ZIGBEE_Pos   0                                                       /*!< SYSCON MODEMCLKSEL: SEL_ZIGBEE Position */
#define SYSCON_MODEMCLKSEL_SEL_ZIGBEE_Msk   (0x01UL << SYSCON_MODEMCLKSEL_SEL_ZIGBEE_Pos)         /*!< SYSCON MODEMCLKSEL: SEL_ZIGBEE Mask   */
#define SYSCON_MODEMCLKSEL_SEL_BLE_Pos      1                                                       /*!< SYSCON MODEMCLKSEL: SEL_BLE Position  */
#define SYSCON_MODEMCLKSEL_SEL_BLE_Msk      (0x01UL << SYSCON_MODEMCLKSEL_SEL_BLE_Pos)            /*!< SYSCON MODEMCLKSEL: SEL_BLE Mask      */

/* -----------------------------  u_syscon_FRGCLKSEL  ----------------------------- */
#define SYSCON_FRGCLKSEL_SEL_Pos            0                                                       /*!< SYSCON FRGCLKSEL: SEL Position        */
#define SYSCON_FRGCLKSEL_SEL_Msk            (0x03UL << SYSCON_FRGCLKSEL_SEL_Pos)                  /*!< SYSCON FRGCLKSEL: SEL Mask            */

/* -----------------------------  u_syscon_DMICCLKSEL  ---------------------------- */
#define SYSCON_DMICCLKSEL_SEL_Pos           0                                                       /*!< SYSCON DMICCLKSEL: SEL Position       */
#define SYSCON_DMICCLKSEL_SEL_Msk           (0x07UL << SYSCON_DMICCLKSEL_SEL_Pos)                 /*!< SYSCON DMICCLKSEL: SEL Mask           */

/* -----------------------------  u_syscon_WKTCLKSEL  ----------------------------- */
#define SYSCON_WKTCLKSEL_SEL_Pos            0                                                       /*!< SYSCON WKTCLKSEL: SEL Position        */
#define SYSCON_WKTCLKSEL_SEL_Msk            (0x03UL << SYSCON_WKTCLKSEL_SEL_Pos)                  /*!< SYSCON WKTCLKSEL: SEL Mask            */

/* ---------------------------  u_syscon_ISO7816CLKSEL  --------------------------- */
#define SYSCON_ISO7816CLKSEL_ISO7816CLKSEL_Pos 0                                                    /*!< SYSCON ISO7816CLKSEL: ISO7816CLKSEL Position */
#define SYSCON_ISO7816CLKSEL_ISO7816CLKSEL_Msk (0xffffffffUL << SYSCON_ISO7816CLKSEL_ISO7816CLKSEL_Pos)/*!< SYSCON ISO7816CLKSEL: ISO7816CLKSEL Mask */

/* ---------------------------  u_syscon_SYSTICKCLKDIV  --------------------------- */
#define SYSCON_SYSTICKCLKDIV_DIV_Pos        0                                                       /*!< SYSCON SYSTICKCLKDIV: DIV Position    */
#define SYSCON_SYSTICKCLKDIV_DIV_Msk        (0x000000ffUL << SYSCON_SYSTICKCLKDIV_DIV_Pos)        /*!< SYSCON SYSTICKCLKDIV: DIV Mask        */
#define SYSCON_SYSTICKCLKDIV_RESET_Pos      29                                                      /*!< SYSCON SYSTICKCLKDIV: RESET Position  */
#define SYSCON_SYSTICKCLKDIV_RESET_Msk      (0x01UL << SYSCON_SYSTICKCLKDIV_RESET_Pos)            /*!< SYSCON SYSTICKCLKDIV: RESET Mask      */
#define SYSCON_SYSTICKCLKDIV_HALT_Pos       30                                                      /*!< SYSCON SYSTICKCLKDIV: HALT Position   */
#define SYSCON_SYSTICKCLKDIV_HALT_Msk       (0x01UL << SYSCON_SYSTICKCLKDIV_HALT_Pos)             /*!< SYSCON SYSTICKCLKDIV: HALT Mask       */
#define SYSCON_SYSTICKCLKDIV_REQFLAG_Pos    31                                                      /*!< SYSCON SYSTICKCLKDIV: REQFLAG Position */
#define SYSCON_SYSTICKCLKDIV_REQFLAG_Msk    (0x01UL << SYSCON_SYSTICKCLKDIV_REQFLAG_Pos)          /*!< SYSCON SYSTICKCLKDIV: REQFLAG Mask    */

/* ----------------------------  u_syscon_TRACECLKDIV  ---------------------------- */
#define SYSCON_TRACECLKDIV_DIV_Pos          0                                                       /*!< SYSCON TRACECLKDIV: DIV Position      */
#define SYSCON_TRACECLKDIV_DIV_Msk          (0x000000ffUL << SYSCON_TRACECLKDIV_DIV_Pos)          /*!< SYSCON TRACECLKDIV: DIV Mask          */
#define SYSCON_TRACECLKDIV_RESET_Pos        29                                                      /*!< SYSCON TRACECLKDIV: RESET Position    */
#define SYSCON_TRACECLKDIV_RESET_Msk        (0x01UL << SYSCON_TRACECLKDIV_RESET_Pos)              /*!< SYSCON TRACECLKDIV: RESET Mask        */
#define SYSCON_TRACECLKDIV_HALT_Pos         30                                                      /*!< SYSCON TRACECLKDIV: HALT Position     */
#define SYSCON_TRACECLKDIV_HALT_Msk         (0x01UL << SYSCON_TRACECLKDIV_HALT_Pos)               /*!< SYSCON TRACECLKDIV: HALT Mask         */
#define SYSCON_TRACECLKDIV_REQFLAG_Pos      31                                                      /*!< SYSCON TRACECLKDIV: REQFLAG Position  */
#define SYSCON_TRACECLKDIV_REQFLAG_Msk      (0x01UL << SYSCON_TRACECLKDIV_REQFLAG_Pos)            /*!< SYSCON TRACECLKDIV: REQFLAG Mask      */

/* -----------------------------  u_syscon_WDTCLKDIV  ----------------------------- */
#define SYSCON_WDTCLKDIV_DIV_Pos            0                                                       /*!< SYSCON WDTCLKDIV: DIV Position        */
#define SYSCON_WDTCLKDIV_DIV_Msk            (0x000000ffUL << SYSCON_WDTCLKDIV_DIV_Pos)            /*!< SYSCON WDTCLKDIV: DIV Mask            */
#define SYSCON_WDTCLKDIV_RESET_Pos          29                                                      /*!< SYSCON WDTCLKDIV: RESET Position      */
#define SYSCON_WDTCLKDIV_RESET_Msk          (0x01UL << SYSCON_WDTCLKDIV_RESET_Pos)                /*!< SYSCON WDTCLKDIV: RESET Mask          */
#define SYSCON_WDTCLKDIV_HALT_Pos           30                                                      /*!< SYSCON WDTCLKDIV: HALT Position       */
#define SYSCON_WDTCLKDIV_HALT_Msk           (0x01UL << SYSCON_WDTCLKDIV_HALT_Pos)                 /*!< SYSCON WDTCLKDIV: HALT Mask           */
#define SYSCON_WDTCLKDIV_REQFLAG_Pos        31                                                      /*!< SYSCON WDTCLKDIV: REQFLAG Position    */
#define SYSCON_WDTCLKDIV_REQFLAG_Msk        (0x01UL << SYSCON_WDTCLKDIV_REQFLAG_Pos)              /*!< SYSCON WDTCLKDIV: REQFLAG Mask        */

/* ------------------------------  u_syscon_IRCLKDIV  ----------------------------- */
#define SYSCON_IRCLKDIV_DIV_Pos             0                                                       /*!< SYSCON IRCLKDIV: DIV Position         */
#define SYSCON_IRCLKDIV_DIV_Msk             (0x0fUL << SYSCON_IRCLKDIV_DIV_Pos)                   /*!< SYSCON IRCLKDIV: DIV Mask             */
#define SYSCON_IRCLKDIV_RESET_Pos           29                                                      /*!< SYSCON IRCLKDIV: RESET Position       */
#define SYSCON_IRCLKDIV_RESET_Msk           (0x01UL << SYSCON_IRCLKDIV_RESET_Pos)                 /*!< SYSCON IRCLKDIV: RESET Mask           */
#define SYSCON_IRCLKDIV_HALT_Pos            30                                                      /*!< SYSCON IRCLKDIV: HALT Position        */
#define SYSCON_IRCLKDIV_HALT_Msk            (0x01UL << SYSCON_IRCLKDIV_HALT_Pos)                  /*!< SYSCON IRCLKDIV: HALT Mask            */
#define SYSCON_IRCLKDIV_REQFLAG_Pos         31                                                      /*!< SYSCON IRCLKDIV: REQFLAG Position     */
#define SYSCON_IRCLKDIV_REQFLAG_Msk         (0x01UL << SYSCON_IRCLKDIV_REQFLAG_Pos)               /*!< SYSCON IRCLKDIV: REQFLAG Mask         */

/* -----------------------------  u_syscon_AHBCLKDIV  ----------------------------- */
#define SYSCON_AHBCLKDIV_DIV_Pos            0                                                       /*!< SYSCON AHBCLKDIV: DIV Position        */
#define SYSCON_AHBCLKDIV_DIV_Msk            (0x000000ffUL << SYSCON_AHBCLKDIV_DIV_Pos)            /*!< SYSCON AHBCLKDIV: DIV Mask            */
#define SYSCON_AHBCLKDIV_REQFLAG_Pos        31                                                      /*!< SYSCON AHBCLKDIV: REQFLAG Position    */
#define SYSCON_AHBCLKDIV_REQFLAG_Msk        (0x01UL << SYSCON_AHBCLKDIV_REQFLAG_Pos)              /*!< SYSCON AHBCLKDIV: REQFLAG Mask        */

/* -----------------------------  u_syscon_CLKOUTDIV  ----------------------------- */
#define SYSCON_CLKOUTDIV_DIV_Pos            0                                                       /*!< SYSCON CLKOUTDIV: DIV Position        */
#define SYSCON_CLKOUTDIV_DIV_Msk            (0x0fUL << SYSCON_CLKOUTDIV_DIV_Pos)                  /*!< SYSCON CLKOUTDIV: DIV Mask            */
#define SYSCON_CLKOUTDIV_RESET_Pos          29                                                      /*!< SYSCON CLKOUTDIV: RESET Position      */
#define SYSCON_CLKOUTDIV_RESET_Msk          (0x01UL << SYSCON_CLKOUTDIV_RESET_Pos)                /*!< SYSCON CLKOUTDIV: RESET Mask          */
#define SYSCON_CLKOUTDIV_HALT_Pos           30                                                      /*!< SYSCON CLKOUTDIV: HALT Position       */
#define SYSCON_CLKOUTDIV_HALT_Msk           (0x01UL << SYSCON_CLKOUTDIV_HALT_Pos)                 /*!< SYSCON CLKOUTDIV: HALT Mask           */
#define SYSCON_CLKOUTDIV_REQFLAG_Pos        31                                                      /*!< SYSCON CLKOUTDIV: REQFLAG Position    */
#define SYSCON_CLKOUTDIV_REQFLAG_Msk        (0x01UL << SYSCON_CLKOUTDIV_REQFLAG_Pos)              /*!< SYSCON CLKOUTDIV: REQFLAG Mask        */

/* ----------------------------  u_syscon_SPIFICLKDIV  ---------------------------- */
#define SYSCON_SPIFICLKDIV_DIV_Pos          0                                                       /*!< SYSCON SPIFICLKDIV: DIV Position      */
#define SYSCON_SPIFICLKDIV_DIV_Msk          (0x03UL << SYSCON_SPIFICLKDIV_DIV_Pos)                /*!< SYSCON SPIFICLKDIV: DIV Mask          */
#define SYSCON_SPIFICLKDIV_RESET_Pos        29                                                      /*!< SYSCON SPIFICLKDIV: RESET Position    */
#define SYSCON_SPIFICLKDIV_RESET_Msk        (0x01UL << SYSCON_SPIFICLKDIV_RESET_Pos)              /*!< SYSCON SPIFICLKDIV: RESET Mask        */
#define SYSCON_SPIFICLKDIV_HALT_Pos         30                                                      /*!< SYSCON SPIFICLKDIV: HALT Position     */
#define SYSCON_SPIFICLKDIV_HALT_Msk         (0x01UL << SYSCON_SPIFICLKDIV_HALT_Pos)               /*!< SYSCON SPIFICLKDIV: HALT Mask         */
#define SYSCON_SPIFICLKDIV_REQFLAG_Pos      31                                                      /*!< SYSCON SPIFICLKDIV: REQFLAG Position  */
#define SYSCON_SPIFICLKDIV_REQFLAG_Msk      (0x01UL << SYSCON_SPIFICLKDIV_REQFLAG_Pos)            /*!< SYSCON SPIFICLKDIV: REQFLAG Mask      */

/* -----------------------------  u_syscon_ADCCLKDIV  ----------------------------- */
#define SYSCON_ADCCLKDIV_DIV_Pos            0                                                       /*!< SYSCON ADCCLKDIV: DIV Position        */
#define SYSCON_ADCCLKDIV_DIV_Msk            (0x07UL << SYSCON_ADCCLKDIV_DIV_Pos)                  /*!< SYSCON ADCCLKDIV: DIV Mask            */
#define SYSCON_ADCCLKDIV_RESET_Pos          29                                                      /*!< SYSCON ADCCLKDIV: RESET Position      */
#define SYSCON_ADCCLKDIV_RESET_Msk          (0x01UL << SYSCON_ADCCLKDIV_RESET_Pos)                /*!< SYSCON ADCCLKDIV: RESET Mask          */
#define SYSCON_ADCCLKDIV_HALT_Pos           30                                                      /*!< SYSCON ADCCLKDIV: HALT Position       */
#define SYSCON_ADCCLKDIV_HALT_Msk           (0x01UL << SYSCON_ADCCLKDIV_HALT_Pos)                 /*!< SYSCON ADCCLKDIV: HALT Mask           */
#define SYSCON_ADCCLKDIV_REQFLAG_Pos        31                                                      /*!< SYSCON ADCCLKDIV: REQFLAG Position    */
#define SYSCON_ADCCLKDIV_REQFLAG_Msk        (0x01UL << SYSCON_ADCCLKDIV_REQFLAG_Pos)              /*!< SYSCON ADCCLKDIV: REQFLAG Mask        */

/* -----------------------------  u_syscon_RTCCLKDIV  ----------------------------- */
#define SYSCON_RTCCLKDIV_DIV_Pos            0                                                       /*!< SYSCON RTCCLKDIV: DIV Position        */
#define SYSCON_RTCCLKDIV_DIV_Msk            (0x1fUL << SYSCON_RTCCLKDIV_DIV_Pos)                  /*!< SYSCON RTCCLKDIV: DIV Mask            */
#define SYSCON_RTCCLKDIV_RESET_Pos          29                                                      /*!< SYSCON RTCCLKDIV: RESET Position      */
#define SYSCON_RTCCLKDIV_RESET_Msk          (0x01UL << SYSCON_RTCCLKDIV_RESET_Pos)                /*!< SYSCON RTCCLKDIV: RESET Mask          */
#define SYSCON_RTCCLKDIV_HALT_Pos           30                                                      /*!< SYSCON RTCCLKDIV: HALT Position       */
#define SYSCON_RTCCLKDIV_HALT_Msk           (0x01UL << SYSCON_RTCCLKDIV_HALT_Pos)                 /*!< SYSCON RTCCLKDIV: HALT Mask           */
#define SYSCON_RTCCLKDIV_REQFLAG_Pos        31                                                      /*!< SYSCON RTCCLKDIV: REQFLAG Position    */
#define SYSCON_RTCCLKDIV_REQFLAG_Msk        (0x01UL << SYSCON_RTCCLKDIV_REQFLAG_Pos)              /*!< SYSCON RTCCLKDIV: REQFLAG Mask        */

/* ------------------------------  u_syscon_FRGCTRL  ------------------------------ */
#define SYSCON_FRGCTRL_DIV_Pos              0                                                       /*!< SYSCON FRGCTRL: DIV Position          */
#define SYSCON_FRGCTRL_DIV_Msk              (0x000000ffUL << SYSCON_FRGCTRL_DIV_Pos)              /*!< SYSCON FRGCTRL: DIV Mask              */
#define SYSCON_FRGCTRL_MULT_Pos             8                                                       /*!< SYSCON FRGCTRL: MULT Position         */
#define SYSCON_FRGCTRL_MULT_Msk             (0x000000ffUL << SYSCON_FRGCTRL_MULT_Pos)             /*!< SYSCON FRGCTRL: MULT Mask             */

/* -----------------------------  u_syscon_DMICCLKDIV  ---------------------------- */
#define SYSCON_DMICCLKDIV_DIV_Pos           0                                                       /*!< SYSCON DMICCLKDIV: DIV Position       */
#define SYSCON_DMICCLKDIV_DIV_Msk           (0x000000ffUL << SYSCON_DMICCLKDIV_DIV_Pos)           /*!< SYSCON DMICCLKDIV: DIV Mask           */
#define SYSCON_DMICCLKDIV_RESET_Pos         29                                                      /*!< SYSCON DMICCLKDIV: RESET Position     */
#define SYSCON_DMICCLKDIV_RESET_Msk         (0x01UL << SYSCON_DMICCLKDIV_RESET_Pos)               /*!< SYSCON DMICCLKDIV: RESET Mask         */
#define SYSCON_DMICCLKDIV_HALT_Pos          30                                                      /*!< SYSCON DMICCLKDIV: HALT Position      */
#define SYSCON_DMICCLKDIV_HALT_Msk          (0x01UL << SYSCON_DMICCLKDIV_HALT_Pos)                /*!< SYSCON DMICCLKDIV: HALT Mask          */
#define SYSCON_DMICCLKDIV_REQFLAG_Pos       31                                                      /*!< SYSCON DMICCLKDIV: REQFLAG Position   */
#define SYSCON_DMICCLKDIV_REQFLAG_Msk       (0x01UL << SYSCON_DMICCLKDIV_REQFLAG_Pos)             /*!< SYSCON DMICCLKDIV: REQFLAG Mask       */

/* ----------------------------  u_syscon_RTC1HZCLKDIV  --------------------------- */
#define SYSCON_RTC1HZCLKDIV_RESET_Pos       29                                                      /*!< SYSCON RTC1HZCLKDIV: RESET Position   */
#define SYSCON_RTC1HZCLKDIV_RESET_Msk       (0x01UL << SYSCON_RTC1HZCLKDIV_RESET_Pos)             /*!< SYSCON RTC1HZCLKDIV: RESET Mask       */
#define SYSCON_RTC1HZCLKDIV_HALT_Pos        30                                                      /*!< SYSCON RTC1HZCLKDIV: HALT Position    */
#define SYSCON_RTC1HZCLKDIV_HALT_Msk        (0x01UL << SYSCON_RTC1HZCLKDIV_HALT_Pos)              /*!< SYSCON RTC1HZCLKDIV: HALT Mask        */
#define SYSCON_RTC1HZCLKDIV_REQFLAG_Pos     31                                                      /*!< SYSCON RTC1HZCLKDIV: REQFLAG Position */
#define SYSCON_RTC1HZCLKDIV_REQFLAG_Msk     (0x01UL << SYSCON_RTC1HZCLKDIV_REQFLAG_Pos)           /*!< SYSCON RTC1HZCLKDIV: REQFLAG Mask     */

/* -----------------------  u_syscon_CLOCKGENUPDATELOCKOUT  ----------------------- */
#define SYSCON_CLOCKGENUPDATELOCKOUT_LOCK_Pos 0                                                     /*!< SYSCON CLOCKGENUPDATELOCKOUT: LOCK Position */
#define SYSCON_CLOCKGENUPDATELOCKOUT_LOCK_Msk (0x01UL << SYSCON_CLOCKGENUPDATELOCKOUT_LOCK_Pos)   /*!< SYSCON CLOCKGENUPDATELOCKOUT: LOCK Mask */

/* ----------------------------  u_syscon_EFUSECLKCTRL  --------------------------- */
#define SYSCON_EFUSECLKCTRL_ENABLE_Pos      0                                                       /*!< SYSCON EFUSECLKCTRL: ENABLE Position  */
#define SYSCON_EFUSECLKCTRL_ENABLE_Msk      (0x01UL << SYSCON_EFUSECLKCTRL_ENABLE_Pos)            /*!< SYSCON EFUSECLKCTRL: ENABLE Mask      */

/* ------------------------------  u_syscon_RNGCTRL  ------------------------------ */
#define SYSCON_RNGCTRL_START_Pos            0                                                       /*!< SYSCON RNGCTRL: START Position        */
#define SYSCON_RNGCTRL_START_Msk            (0x01UL << SYSCON_RNGCTRL_START_Pos)                  /*!< SYSCON RNGCTRL: START Mask            */

/* -----------------------------  u_syscon_RNGCLKCTRL  ---------------------------- */
#define SYSCON_RNGCLKCTRL_ENABLE_Pos        0                                                       /*!< SYSCON RNGCLKCTRL: ENABLE Position    */
#define SYSCON_RNGCLKCTRL_ENABLE_Msk        (0x01UL << SYSCON_RNGCLKCTRL_ENABLE_Pos)              /*!< SYSCON RNGCLKCTRL: ENABLE Mask        */

/* ------------------------------  u_syscon_SRAMCTRL  ----------------------------- */
#define SYSCON_SRAMCTRL_SMB_Pos             0                                                       /*!< SYSCON SRAMCTRL: SMB Position         */
#define SYSCON_SRAMCTRL_SMB_Msk             (0x03UL << SYSCON_SRAMCTRL_SMB_Pos)                   /*!< SYSCON SRAMCTRL: SMB Mask             */
#define SYSCON_SRAMCTRL_RM_Pos              2                                                       /*!< SYSCON SRAMCTRL: RM Position          */
#define SYSCON_SRAMCTRL_RM_Msk              (0x07UL << SYSCON_SRAMCTRL_RM_Pos)                    /*!< SYSCON SRAMCTRL: RM Mask              */
#define SYSCON_SRAMCTRL_WM_Pos              5                                                       /*!< SYSCON SRAMCTRL: WM Position          */
#define SYSCON_SRAMCTRL_WM_Msk              (0x07UL << SYSCON_SRAMCTRL_WM_Pos)                    /*!< SYSCON SRAMCTRL: WM Mask              */
#define SYSCON_SRAMCTRL_WRME_Pos            8                                                       /*!< SYSCON SRAMCTRL: WRME Position        */
#define SYSCON_SRAMCTRL_WRME_Msk            (0x01UL << SYSCON_SRAMCTRL_WRME_Pos)                  /*!< SYSCON SRAMCTRL: WRME Mask            */
#define SYSCON_SRAMCTRL_RAM_Pos             9                                                       /*!< SYSCON SRAMCTRL: RAM Position         */
#define SYSCON_SRAMCTRL_RAM_Msk             (0x0fUL << SYSCON_SRAMCTRL_RAM_Pos)                   /*!< SYSCON SRAMCTRL: RAM Mask             */
#define SYSCON_SRAMCTRL_WAM_Pos             13                                                      /*!< SYSCON SRAMCTRL: WAM Position         */
#define SYSCON_SRAMCTRL_WAM_Msk             (0x03UL << SYSCON_SRAMCTRL_WAM_Pos)                   /*!< SYSCON SRAMCTRL: WAM Mask             */
#define SYSCON_SRAMCTRL_RAEN_Pos            15                                                      /*!< SYSCON SRAMCTRL: RAEN Position        */
#define SYSCON_SRAMCTRL_RAEN_Msk            (0x01UL << SYSCON_SRAMCTRL_RAEN_Pos)                  /*!< SYSCON SRAMCTRL: RAEN Mask            */
#define SYSCON_SRAMCTRL_WAEN_Pos            16                                                      /*!< SYSCON SRAMCTRL: WAEN Position        */
#define SYSCON_SRAMCTRL_WAEN_Msk            (0x01UL << SYSCON_SRAMCTRL_WAEN_Pos)                  /*!< SYSCON SRAMCTRL: WAEN Mask            */
#define SYSCON_SRAMCTRL_STBP_Pos            17                                                      /*!< SYSCON SRAMCTRL: STBP Position        */
#define SYSCON_SRAMCTRL_STBP_Msk            (0x01UL << SYSCON_SRAMCTRL_STBP_Pos)                  /*!< SYSCON SRAMCTRL: STBP Mask            */
#define SYSCON_SRAMCTRL_VSBTEST_Pos         18                                                      /*!< SYSCON SRAMCTRL: VSBTEST Position     */
#define SYSCON_SRAMCTRL_VSBTEST_Msk         (0x01UL << SYSCON_SRAMCTRL_VSBTEST_Pos)               /*!< SYSCON SRAMCTRL: VSBTEST Mask         */

/* -----------------------------  u_syscon_SRAMCTRL0  ----------------------------- */
#define SYSCON_SRAMCTRL0_SRAM0_LS_Pos       0                                                       /*!< SYSCON SRAMCTRL0: SRAM0_LS Position   */
#define SYSCON_SRAMCTRL0_SRAM0_LS_Msk       (0x01UL << SYSCON_SRAMCTRL0_SRAM0_LS_Pos)             /*!< SYSCON SRAMCTRL0: SRAM0_LS Mask       */
#define SYSCON_SRAMCTRL0_SRAM0_DSB_Pos      1                                                       /*!< SYSCON SRAMCTRL0: SRAM0_DSB Position  */
#define SYSCON_SRAMCTRL0_SRAM0_DSB_Msk      (0x01UL << SYSCON_SRAMCTRL0_SRAM0_DSB_Pos)            /*!< SYSCON SRAMCTRL0: SRAM0_DSB Mask      */
#define SYSCON_SRAMCTRL0_SRAM0_DSBDEL_Pos   2                                                       /*!< SYSCON SRAMCTRL0: SRAM0_DSBDEL Position */
#define SYSCON_SRAMCTRL0_SRAM0_DSBDEL_Msk   (0x01UL << SYSCON_SRAMCTRL0_SRAM0_DSBDEL_Pos)         /*!< SYSCON SRAMCTRL0: SRAM0_DSBDEL Mask   */
#define SYSCON_SRAMCTRL0_SRAM0_LSDEL_Pos    3                                                       /*!< SYSCON SRAMCTRL0: SRAM0_LSDEL Position */
#define SYSCON_SRAMCTRL0_SRAM0_LSDEL_Msk    (0x01UL << SYSCON_SRAMCTRL0_SRAM0_LSDEL_Pos)          /*!< SYSCON SRAMCTRL0: SRAM0_LSDEL Mask    */
#define SYSCON_SRAMCTRL0_SRAM1_LS_Pos       4                                                       /*!< SYSCON SRAMCTRL0: SRAM1_LS Position   */
#define SYSCON_SRAMCTRL0_SRAM1_LS_Msk       (0x01UL << SYSCON_SRAMCTRL0_SRAM1_LS_Pos)             /*!< SYSCON SRAMCTRL0: SRAM1_LS Mask       */
#define SYSCON_SRAMCTRL0_SRAM1_DSB_Pos      5                                                       /*!< SYSCON SRAMCTRL0: SRAM1_DSB Position  */
#define SYSCON_SRAMCTRL0_SRAM1_DSB_Msk      (0x01UL << SYSCON_SRAMCTRL0_SRAM1_DSB_Pos)            /*!< SYSCON SRAMCTRL0: SRAM1_DSB Mask      */
#define SYSCON_SRAMCTRL0_SRAM1_DSBDEL_Pos   6                                                       /*!< SYSCON SRAMCTRL0: SRAM1_DSBDEL Position */
#define SYSCON_SRAMCTRL0_SRAM1_DSBDEL_Msk   (0x01UL << SYSCON_SRAMCTRL0_SRAM1_DSBDEL_Pos)         /*!< SYSCON SRAMCTRL0: SRAM1_DSBDEL Mask   */
#define SYSCON_SRAMCTRL0_SRAM1_LSDEL_Pos    7                                                       /*!< SYSCON SRAMCTRL0: SRAM1_LSDEL Position */
#define SYSCON_SRAMCTRL0_SRAM1_LSDEL_Msk    (0x01UL << SYSCON_SRAMCTRL0_SRAM1_LSDEL_Pos)          /*!< SYSCON SRAMCTRL0: SRAM1_LSDEL Mask    */
#define SYSCON_SRAMCTRL0_SRAM2_LS_Pos       8                                                       /*!< SYSCON SRAMCTRL0: SRAM2_LS Position   */
#define SYSCON_SRAMCTRL0_SRAM2_LS_Msk       (0x01UL << SYSCON_SRAMCTRL0_SRAM2_LS_Pos)             /*!< SYSCON SRAMCTRL0: SRAM2_LS Mask       */
#define SYSCON_SRAMCTRL0_SRAM2_DSB_Pos      9                                                       /*!< SYSCON SRAMCTRL0: SRAM2_DSB Position  */
#define SYSCON_SRAMCTRL0_SRAM2_DSB_Msk      (0x01UL << SYSCON_SRAMCTRL0_SRAM2_DSB_Pos)            /*!< SYSCON SRAMCTRL0: SRAM2_DSB Mask      */
#define SYSCON_SRAMCTRL0_SRAM2_DSBDEL_Pos   10                                                      /*!< SYSCON SRAMCTRL0: SRAM2_DSBDEL Position */
#define SYSCON_SRAMCTRL0_SRAM2_DSBDEL_Msk   (0x01UL << SYSCON_SRAMCTRL0_SRAM2_DSBDEL_Pos)         /*!< SYSCON SRAMCTRL0: SRAM2_DSBDEL Mask   */
#define SYSCON_SRAMCTRL0_SRAM2_LSDEL_Pos    11                                                      /*!< SYSCON SRAMCTRL0: SRAM2_LSDEL Position */
#define SYSCON_SRAMCTRL0_SRAM2_LSDEL_Msk    (0x01UL << SYSCON_SRAMCTRL0_SRAM2_LSDEL_Pos)          /*!< SYSCON SRAMCTRL0: SRAM2_LSDEL Mask    */
#define SYSCON_SRAMCTRL0_SRAM3_LS_Pos       12                                                      /*!< SYSCON SRAMCTRL0: SRAM3_LS Position   */
#define SYSCON_SRAMCTRL0_SRAM3_LS_Msk       (0x01UL << SYSCON_SRAMCTRL0_SRAM3_LS_Pos)             /*!< SYSCON SRAMCTRL0: SRAM3_LS Mask       */
#define SYSCON_SRAMCTRL0_SRAM3_DSB_Pos      13                                                      /*!< SYSCON SRAMCTRL0: SRAM3_DSB Position  */
#define SYSCON_SRAMCTRL0_SRAM3_DSB_Msk      (0x01UL << SYSCON_SRAMCTRL0_SRAM3_DSB_Pos)            /*!< SYSCON SRAMCTRL0: SRAM3_DSB Mask      */
#define SYSCON_SRAMCTRL0_SRAM3_DSBDEL_Pos   14                                                      /*!< SYSCON SRAMCTRL0: SRAM3_DSBDEL Position */
#define SYSCON_SRAMCTRL0_SRAM3_DSBDEL_Msk   (0x01UL << SYSCON_SRAMCTRL0_SRAM3_DSBDEL_Pos)         /*!< SYSCON SRAMCTRL0: SRAM3_DSBDEL Mask   */
#define SYSCON_SRAMCTRL0_SRAM3_LSDEL_Pos    15                                                      /*!< SYSCON SRAMCTRL0: SRAM3_LSDEL Position */
#define SYSCON_SRAMCTRL0_SRAM3_LSDEL_Msk    (0x01UL << SYSCON_SRAMCTRL0_SRAM3_LSDEL_Pos)          /*!< SYSCON SRAMCTRL0: SRAM3_LSDEL Mask    */
#define SYSCON_SRAMCTRL0_SRAM4_LS_Pos       16                                                      /*!< SYSCON SRAMCTRL0: SRAM4_LS Position   */
#define SYSCON_SRAMCTRL0_SRAM4_LS_Msk       (0x01UL << SYSCON_SRAMCTRL0_SRAM4_LS_Pos)             /*!< SYSCON SRAMCTRL0: SRAM4_LS Mask       */
#define SYSCON_SRAMCTRL0_SRAM4_DSB_Pos      17                                                      /*!< SYSCON SRAMCTRL0: SRAM4_DSB Position  */
#define SYSCON_SRAMCTRL0_SRAM4_DSB_Msk      (0x01UL << SYSCON_SRAMCTRL0_SRAM4_DSB_Pos)            /*!< SYSCON SRAMCTRL0: SRAM4_DSB Mask      */
#define SYSCON_SRAMCTRL0_SRAM4_DSBDEL_Pos   18                                                      /*!< SYSCON SRAMCTRL0: SRAM4_DSBDEL Position */
#define SYSCON_SRAMCTRL0_SRAM4_DSBDEL_Msk   (0x01UL << SYSCON_SRAMCTRL0_SRAM4_DSBDEL_Pos)         /*!< SYSCON SRAMCTRL0: SRAM4_DSBDEL Mask   */
#define SYSCON_SRAMCTRL0_SRAM4_LSDEL_Pos    19                                                      /*!< SYSCON SRAMCTRL0: SRAM4_LSDEL Position */
#define SYSCON_SRAMCTRL0_SRAM4_LSDEL_Msk    (0x01UL << SYSCON_SRAMCTRL0_SRAM4_LSDEL_Pos)          /*!< SYSCON SRAMCTRL0: SRAM4_LSDEL Mask    */
#define SYSCON_SRAMCTRL0_SRAM5_LS_Pos       20                                                      /*!< SYSCON SRAMCTRL0: SRAM5_LS Position   */
#define SYSCON_SRAMCTRL0_SRAM5_LS_Msk       (0x01UL << SYSCON_SRAMCTRL0_SRAM5_LS_Pos)             /*!< SYSCON SRAMCTRL0: SRAM5_LS Mask       */
#define SYSCON_SRAMCTRL0_SRAM5_DSB_Pos      21                                                      /*!< SYSCON SRAMCTRL0: SRAM5_DSB Position  */
#define SYSCON_SRAMCTRL0_SRAM5_DSB_Msk      (0x01UL << SYSCON_SRAMCTRL0_SRAM5_DSB_Pos)            /*!< SYSCON SRAMCTRL0: SRAM5_DSB Mask      */
#define SYSCON_SRAMCTRL0_SRAM5_DSBDEL_Pos   22                                                      /*!< SYSCON SRAMCTRL0: SRAM5_DSBDEL Position */
#define SYSCON_SRAMCTRL0_SRAM5_DSBDEL_Msk   (0x01UL << SYSCON_SRAMCTRL0_SRAM5_DSBDEL_Pos)         /*!< SYSCON SRAMCTRL0: SRAM5_DSBDEL Mask   */
#define SYSCON_SRAMCTRL0_SRAM5_LSDEL_Pos    23                                                      /*!< SYSCON SRAMCTRL0: SRAM5_LSDEL Position */
#define SYSCON_SRAMCTRL0_SRAM5_LSDEL_Msk    (0x01UL << SYSCON_SRAMCTRL0_SRAM5_LSDEL_Pos)          /*!< SYSCON SRAMCTRL0: SRAM5_LSDEL Mask    */
#define SYSCON_SRAMCTRL0_SRAM6_LS_Pos       24                                                      /*!< SYSCON SRAMCTRL0: SRAM6_LS Position   */
#define SYSCON_SRAMCTRL0_SRAM6_LS_Msk       (0x01UL << SYSCON_SRAMCTRL0_SRAM6_LS_Pos)             /*!< SYSCON SRAMCTRL0: SRAM6_LS Mask       */
#define SYSCON_SRAMCTRL0_SRAM6_DSB_Pos      25                                                      /*!< SYSCON SRAMCTRL0: SRAM6_DSB Position  */
#define SYSCON_SRAMCTRL0_SRAM6_DSB_Msk      (0x01UL << SYSCON_SRAMCTRL0_SRAM6_DSB_Pos)            /*!< SYSCON SRAMCTRL0: SRAM6_DSB Mask      */
#define SYSCON_SRAMCTRL0_SRAM6_DSBDEL_Pos   26                                                      /*!< SYSCON SRAMCTRL0: SRAM6_DSBDEL Position */
#define SYSCON_SRAMCTRL0_SRAM6_DSBDEL_Msk   (0x01UL << SYSCON_SRAMCTRL0_SRAM6_DSBDEL_Pos)         /*!< SYSCON SRAMCTRL0: SRAM6_DSBDEL Mask   */
#define SYSCON_SRAMCTRL0_SRAM6_LSDEL_Pos    27                                                      /*!< SYSCON SRAMCTRL0: SRAM6_LSDEL Position */
#define SYSCON_SRAMCTRL0_SRAM6_LSDEL_Msk    (0x01UL << SYSCON_SRAMCTRL0_SRAM6_LSDEL_Pos)          /*!< SYSCON SRAMCTRL0: SRAM6_LSDEL Mask    */
#define SYSCON_SRAMCTRL0_SRAM7_LS_Pos       28                                                      /*!< SYSCON SRAMCTRL0: SRAM7_LS Position   */
#define SYSCON_SRAMCTRL0_SRAM7_LS_Msk       (0x01UL << SYSCON_SRAMCTRL0_SRAM7_LS_Pos)             /*!< SYSCON SRAMCTRL0: SRAM7_LS Mask       */
#define SYSCON_SRAMCTRL0_SRAM7_DSB_Pos      29                                                      /*!< SYSCON SRAMCTRL0: SRAM7_DSB Position  */
#define SYSCON_SRAMCTRL0_SRAM7_DSB_Msk      (0x01UL << SYSCON_SRAMCTRL0_SRAM7_DSB_Pos)            /*!< SYSCON SRAMCTRL0: SRAM7_DSB Mask      */
#define SYSCON_SRAMCTRL0_SRAM7_DSBDEL_Pos   30                                                      /*!< SYSCON SRAMCTRL0: SRAM7_DSBDEL Position */
#define SYSCON_SRAMCTRL0_SRAM7_DSBDEL_Msk   (0x01UL << SYSCON_SRAMCTRL0_SRAM7_DSBDEL_Pos)         /*!< SYSCON SRAMCTRL0: SRAM7_DSBDEL Mask   */
#define SYSCON_SRAMCTRL0_SRAM7_LSDEL_Pos    31                                                      /*!< SYSCON SRAMCTRL0: SRAM7_LSDEL Position */
#define SYSCON_SRAMCTRL0_SRAM7_LSDEL_Msk    (0x01UL << SYSCON_SRAMCTRL0_SRAM7_LSDEL_Pos)          /*!< SYSCON SRAMCTRL0: SRAM7_LSDEL Mask    */

/* -----------------------------  u_syscon_SRAMCTRL1  ----------------------------- */
#define SYSCON_SRAMCTRL1_SRAM8_LS_Pos       0                                                       /*!< SYSCON SRAMCTRL1: SRAM8_LS Position   */
#define SYSCON_SRAMCTRL1_SRAM8_LS_Msk       (0x01UL << SYSCON_SRAMCTRL1_SRAM8_LS_Pos)             /*!< SYSCON SRAMCTRL1: SRAM8_LS Mask       */
#define SYSCON_SRAMCTRL1_SRAM8_DSB_Pos      1                                                       /*!< SYSCON SRAMCTRL1: SRAM8_DSB Position  */
#define SYSCON_SRAMCTRL1_SRAM8_DSB_Msk      (0x01UL << SYSCON_SRAMCTRL1_SRAM8_DSB_Pos)            /*!< SYSCON SRAMCTRL1: SRAM8_DSB Mask      */
#define SYSCON_SRAMCTRL1_SRAM8_DSBDEL_Pos   2                                                       /*!< SYSCON SRAMCTRL1: SRAM8_DSBDEL Position */
#define SYSCON_SRAMCTRL1_SRAM8_DSBDEL_Msk   (0x01UL << SYSCON_SRAMCTRL1_SRAM8_DSBDEL_Pos)         /*!< SYSCON SRAMCTRL1: SRAM8_DSBDEL Mask   */
#define SYSCON_SRAMCTRL1_SRAM8_LSDEL_Pos    3                                                       /*!< SYSCON SRAMCTRL1: SRAM8_LSDEL Position */
#define SYSCON_SRAMCTRL1_SRAM8_LSDEL_Msk    (0x01UL << SYSCON_SRAMCTRL1_SRAM8_LSDEL_Pos)          /*!< SYSCON SRAMCTRL1: SRAM8_LSDEL Mask    */
#define SYSCON_SRAMCTRL1_SRAM9_LS_Pos       4                                                       /*!< SYSCON SRAMCTRL1: SRAM9_LS Position   */
#define SYSCON_SRAMCTRL1_SRAM9_LS_Msk       (0x01UL << SYSCON_SRAMCTRL1_SRAM9_LS_Pos)             /*!< SYSCON SRAMCTRL1: SRAM9_LS Mask       */
#define SYSCON_SRAMCTRL1_SRAM9_DSB_Pos      5                                                       /*!< SYSCON SRAMCTRL1: SRAM9_DSB Position  */
#define SYSCON_SRAMCTRL1_SRAM9_DSB_Msk      (0x01UL << SYSCON_SRAMCTRL1_SRAM9_DSB_Pos)            /*!< SYSCON SRAMCTRL1: SRAM9_DSB Mask      */
#define SYSCON_SRAMCTRL1_SRAM9_DSBDEL_Pos   6                                                       /*!< SYSCON SRAMCTRL1: SRAM9_DSBDEL Position */
#define SYSCON_SRAMCTRL1_SRAM9_DSBDEL_Msk   (0x01UL << SYSCON_SRAMCTRL1_SRAM9_DSBDEL_Pos)         /*!< SYSCON SRAMCTRL1: SRAM9_DSBDEL Mask   */
#define SYSCON_SRAMCTRL1_SRAM9_LSDEL_Pos    7                                                       /*!< SYSCON SRAMCTRL1: SRAM9_LSDEL Position */
#define SYSCON_SRAMCTRL1_SRAM9_LSDEL_Msk    (0x01UL << SYSCON_SRAMCTRL1_SRAM9_LSDEL_Pos)          /*!< SYSCON SRAMCTRL1: SRAM9_LSDEL Mask    */
#define SYSCON_SRAMCTRL1_SRAM10_LS_Pos      8                                                       /*!< SYSCON SRAMCTRL1: SRAM10_LS Position  */
#define SYSCON_SRAMCTRL1_SRAM10_LS_Msk      (0x01UL << SYSCON_SRAMCTRL1_SRAM10_LS_Pos)            /*!< SYSCON SRAMCTRL1: SRAM10_LS Mask      */
#define SYSCON_SRAMCTRL1_SRAM10_DSB_Pos     9                                                       /*!< SYSCON SRAMCTRL1: SRAM10_DSB Position */
#define SYSCON_SRAMCTRL1_SRAM10_DSB_Msk     (0x01UL << SYSCON_SRAMCTRL1_SRAM10_DSB_Pos)           /*!< SYSCON SRAMCTRL1: SRAM10_DSB Mask     */
#define SYSCON_SRAMCTRL1_SRAM10_DSBDEL_Pos  10                                                      /*!< SYSCON SRAMCTRL1: SRAM10_DSBDEL Position */
#define SYSCON_SRAMCTRL1_SRAM10_DSBDEL_Msk  (0x01UL << SYSCON_SRAMCTRL1_SRAM10_DSBDEL_Pos)        /*!< SYSCON SRAMCTRL1: SRAM10_DSBDEL Mask  */
#define SYSCON_SRAMCTRL1_SRAM10_LSDEL_Pos   11                                                      /*!< SYSCON SRAMCTRL1: SRAM10_LSDEL Position */
#define SYSCON_SRAMCTRL1_SRAM10_LSDEL_Msk   (0x01UL << SYSCON_SRAMCTRL1_SRAM10_LSDEL_Pos)         /*!< SYSCON SRAMCTRL1: SRAM10_LSDEL Mask   */
#define SYSCON_SRAMCTRL1_SRAM11_LS_Pos      12                                                      /*!< SYSCON SRAMCTRL1: SRAM11_LS Position  */
#define SYSCON_SRAMCTRL1_SRAM11_LS_Msk      (0x01UL << SYSCON_SRAMCTRL1_SRAM11_LS_Pos)            /*!< SYSCON SRAMCTRL1: SRAM11_LS Mask      */
#define SYSCON_SRAMCTRL1_SRAM11_DSB_Pos     13                                                      /*!< SYSCON SRAMCTRL1: SRAM11_DSB Position */
#define SYSCON_SRAMCTRL1_SRAM11_DSB_Msk     (0x01UL << SYSCON_SRAMCTRL1_SRAM11_DSB_Pos)           /*!< SYSCON SRAMCTRL1: SRAM11_DSB Mask     */
#define SYSCON_SRAMCTRL1_SRAM11_DSBDEL_Pos  14                                                      /*!< SYSCON SRAMCTRL1: SRAM11_DSBDEL Position */
#define SYSCON_SRAMCTRL1_SRAM11_DSBDEL_Msk  (0x01UL << SYSCON_SRAMCTRL1_SRAM11_DSBDEL_Pos)        /*!< SYSCON SRAMCTRL1: SRAM11_DSBDEL Mask  */
#define SYSCON_SRAMCTRL1_SRAM11_LSDEL_Pos   15                                                      /*!< SYSCON SRAMCTRL1: SRAM11_LSDEL Position */
#define SYSCON_SRAMCTRL1_SRAM11_LSDEL_Msk   (0x01UL << SYSCON_SRAMCTRL1_SRAM11_LSDEL_Pos)         /*!< SYSCON SRAMCTRL1: SRAM11_LSDEL Mask   */

/* ------------------------------  u_syscon_ROMCTRL  ------------------------------ */
#define SYSCON_ROMCTRL_SDB_Pos              0                                                       /*!< SYSCON ROMCTRL: SDB Position          */
#define SYSCON_ROMCTRL_SDB_Msk              (0x01UL << SYSCON_ROMCTRL_SDB_Pos)                    /*!< SYSCON ROMCTRL: SDB Mask              */
#define SYSCON_ROMCTRL_SDBDEL_Pos           1                                                       /*!< SYSCON ROMCTRL: SDBDEL Position       */
#define SYSCON_ROMCTRL_SDBDEL_Msk           (0x01UL << SYSCON_ROMCTRL_SDBDEL_Pos)                 /*!< SYSCON ROMCTRL: SDBDEL Mask           */
#define SYSCON_ROMCTRL_RME_Pos              2                                                       /*!< SYSCON ROMCTRL: RME Position          */
#define SYSCON_ROMCTRL_RME_Msk              (0x01UL << SYSCON_ROMCTRL_RME_Pos)                    /*!< SYSCON ROMCTRL: RME Mask              */
#define SYSCON_ROMCTRL_RM_Pos               3                                                       /*!< SYSCON ROMCTRL: RM Position           */
#define SYSCON_ROMCTRL_RM_Msk               (0x0fUL << SYSCON_ROMCTRL_RM_Pos)                     /*!< SYSCON ROMCTRL: RM Mask               */
#define SYSCON_ROMCTRL_PM_Pos               7                                                       /*!< SYSCON ROMCTRL: PM Position           */
#define SYSCON_ROMCTRL_PM_Msk               (0x03UL << SYSCON_ROMCTRL_PM_Pos)                     /*!< SYSCON ROMCTRL: PM Mask               */
#define SYSCON_ROMCTRL_VDDMIN_Pos           9                                                       /*!< SYSCON ROMCTRL: VDDMIN Position       */
#define SYSCON_ROMCTRL_VDDMIN_Msk           (0x01UL << SYSCON_ROMCTRL_VDDMIN_Pos)                 /*!< SYSCON ROMCTRL: VDDMIN Mask           */

/* -----------------------------  u_syscon_MODEMCTRL  ----------------------------- */
#define SYSCON_MODEMCTRL_BLE_LP_SLEEP_TRIG_Pos 0                                                    /*!< SYSCON MODEMCTRL: BLE_LP_SLEEP_TRIG Position */
#define SYSCON_MODEMCTRL_BLE_LP_SLEEP_TRIG_Msk (0x01UL << SYSCON_MODEMCTRL_BLE_LP_SLEEP_TRIG_Pos) /*!< SYSCON MODEMCTRL: BLE_LP_SLEEP_TRIG Mask */
#define SYSCON_MODEMCTRL_BLE_FREQ_SEL_Pos   1                                                       /*!< SYSCON MODEMCTRL: BLE_FREQ_SEL Position */
#define SYSCON_MODEMCTRL_BLE_FREQ_SEL_Msk   (0x01UL << SYSCON_MODEMCTRL_BLE_FREQ_SEL_Pos)         /*!< SYSCON MODEMCTRL: BLE_FREQ_SEL Mask   */
#define SYSCON_MODEMCTRL_BLE_DP_DIV_EN_Pos  2                                                       /*!< SYSCON MODEMCTRL: BLE_DP_DIV_EN Position */
#define SYSCON_MODEMCTRL_BLE_DP_DIV_EN_Msk  (0x01UL << SYSCON_MODEMCTRL_BLE_DP_DIV_EN_Pos)        /*!< SYSCON MODEMCTRL: BLE_DP_DIV_EN Mask  */
#define SYSCON_MODEMCTRL_BLE_CLK32M_SEL_Pos 3                                                       /*!< SYSCON MODEMCTRL: BLE_CLK32M_SEL Position */
#define SYSCON_MODEMCTRL_BLE_CLK32M_SEL_Msk (0x01UL << SYSCON_MODEMCTRL_BLE_CLK32M_SEL_Pos)       /*!< SYSCON MODEMCTRL: BLE_CLK32M_SEL Mask */
#define SYSCON_MODEMCTRL_BLE_AHB_DIV0_Pos   4                                                       /*!< SYSCON MODEMCTRL: BLE_AHB_DIV0 Position */
#define SYSCON_MODEMCTRL_BLE_AHB_DIV0_Msk   (0x01UL << SYSCON_MODEMCTRL_BLE_AHB_DIV0_Pos)         /*!< SYSCON MODEMCTRL: BLE_AHB_DIV0 Mask   */
#define SYSCON_MODEMCTRL_BLE_AHB_DIV1_Pos   5                                                       /*!< SYSCON MODEMCTRL: BLE_AHB_DIV1 Position */
#define SYSCON_MODEMCTRL_BLE_AHB_DIV1_Msk   (0x01UL << SYSCON_MODEMCTRL_BLE_AHB_DIV1_Pos)         /*!< SYSCON MODEMCTRL: BLE_AHB_DIV1 Mask   */
#define SYSCON_MODEMCTRL_BLE_HCLK_BLE_EN_Pos 6                                                      /*!< SYSCON MODEMCTRL: BLE_HCLK_BLE_EN Position */
#define SYSCON_MODEMCTRL_BLE_HCLK_BLE_EN_Msk (0x01UL << SYSCON_MODEMCTRL_BLE_HCLK_BLE_EN_Pos)     /*!< SYSCON MODEMCTRL: BLE_HCLK_BLE_EN Mask */
#define SYSCON_MODEMCTRL_BLE_PHASE_MATCH_1_Pos 7                                                    /*!< SYSCON MODEMCTRL: BLE_PHASE_MATCH_1 Position */
#define SYSCON_MODEMCTRL_BLE_PHASE_MATCH_1_Msk (0x01UL << SYSCON_MODEMCTRL_BLE_PHASE_MATCH_1_Pos) /*!< SYSCON MODEMCTRL: BLE_PHASE_MATCH_1 Mask */
#define SYSCON_MODEMCTRL_BLE_ISO_ENABLE_Pos 8                                                       /*!< SYSCON MODEMCTRL: BLE_ISO_ENABLE Position */
#define SYSCON_MODEMCTRL_BLE_ISO_ENABLE_Msk (0x01UL << SYSCON_MODEMCTRL_BLE_ISO_ENABLE_Pos)       /*!< SYSCON MODEMCTRL: BLE_ISO_ENABLE Mask */
#define SYSCON_MODEMCTRL_BLE_LP_OSC32K_EN_Pos 9                                                     /*!< SYSCON MODEMCTRL: BLE_LP_OSC32K_EN Position */
#define SYSCON_MODEMCTRL_BLE_LP_OSC32K_EN_Msk (0x01UL << SYSCON_MODEMCTRL_BLE_LP_OSC32K_EN_Pos)   /*!< SYSCON MODEMCTRL: BLE_LP_OSC32K_EN Mask */

/* ----------------------------  u_syscon_MODEMSTATUS  ---------------------------- */
#define SYSCON_MODEMSTATUS_BLE_LL_CLK_STATUS_Pos 0                                                  /*!< SYSCON MODEMSTATUS: BLE_LL_CLK_STATUS Position */
#define SYSCON_MODEMSTATUS_BLE_LL_CLK_STATUS_Msk (0x01UL << SYSCON_MODEMSTATUS_BLE_LL_CLK_STATUS_Pos)/*!< SYSCON MODEMSTATUS: BLE_LL_CLK_STATUS Mask */
#define SYSCON_MODEMSTATUS_BLE_LP_OSC_EN_Pos 1                                                      /*!< SYSCON MODEMSTATUS: BLE_LP_OSC_EN Position */
#define SYSCON_MODEMSTATUS_BLE_LP_OSC_EN_Msk (0x01UL << SYSCON_MODEMSTATUS_BLE_LP_OSC_EN_Pos)     /*!< SYSCON MODEMSTATUS: BLE_LP_OSC_EN Mask */
#define SYSCON_MODEMSTATUS_BLE_LP_RADIO_EN_Pos 2                                                    /*!< SYSCON MODEMSTATUS: BLE_LP_RADIO_EN Position */
#define SYSCON_MODEMSTATUS_BLE_LP_RADIO_EN_Msk (0x01UL << SYSCON_MODEMSTATUS_BLE_LP_RADIO_EN_Pos) /*!< SYSCON MODEMSTATUS: BLE_LP_RADIO_EN Mask */

/* -----------------------------  u_syscon_XTAL32KCAP  ---------------------------- */
#define SYSCON_XTAL32KCAP_XO_OSC_CAP_IN_Pos 0                                                       /*!< SYSCON XTAL32KCAP: XO_OSC_CAP_IN Position */
#define SYSCON_XTAL32KCAP_XO_OSC_CAP_IN_Msk (0x7fUL << SYSCON_XTAL32KCAP_XO_OSC_CAP_IN_Pos)       /*!< SYSCON XTAL32KCAP: XO_OSC_CAP_IN Mask */
#define SYSCON_XTAL32KCAP_XO_OSC_CAP_OUT_Pos 7                                                      /*!< SYSCON XTAL32KCAP: XO_OSC_CAP_OUT Position */
#define SYSCON_XTAL32KCAP_XO_OSC_CAP_OUT_Msk (0x7fUL << SYSCON_XTAL32KCAP_XO_OSC_CAP_OUT_Pos)     /*!< SYSCON XTAL32KCAP: XO_OSC_CAP_OUT Mask */

/* ----------------------------  u_syscon_XTAL32MCTRL  ---------------------------- */
#define SYSCON_XTAL32MCTRL_DEACTIVATE_PMC_CTRL_Pos 0                                                /*!< SYSCON XTAL32MCTRL: DEACTIVATE_PMC_CTRL Position */
#define SYSCON_XTAL32MCTRL_DEACTIVATE_PMC_CTRL_Msk (0x01UL << SYSCON_XTAL32MCTRL_DEACTIVATE_PMC_CTRL_Pos)/*!< SYSCON XTAL32MCTRL: DEACTIVATE_PMC_CTRL Mask */
#define SYSCON_XTAL32MCTRL_DEACTIVATE_BLE_CTRL_Pos 1                                                /*!< SYSCON XTAL32MCTRL: DEACTIVATE_BLE_CTRL Position */
#define SYSCON_XTAL32MCTRL_DEACTIVATE_BLE_CTRL_Msk (0x01UL << SYSCON_XTAL32MCTRL_DEACTIVATE_BLE_CTRL_Pos)/*!< SYSCON XTAL32MCTRL: DEACTIVATE_BLE_CTRL Mask */

/* ------------------------------  u_syscon_STARTER0  ----------------------------- */
#define SYSCON_STARTER0_WDT_BOD_Pos         0                                                       /*!< SYSCON STARTER0: WDT_BOD Position     */
#define SYSCON_STARTER0_WDT_BOD_Msk         (0x01UL << SYSCON_STARTER0_WDT_BOD_Pos)               /*!< SYSCON STARTER0: WDT_BOD Mask         */
#define SYSCON_STARTER0_DMA_Pos             1                                                       /*!< SYSCON STARTER0: DMA Position         */
#define SYSCON_STARTER0_DMA_Msk             (0x01UL << SYSCON_STARTER0_DMA_Pos)                   /*!< SYSCON STARTER0: DMA Mask             */
#define SYSCON_STARTER0_GINT_Pos            2                                                       /*!< SYSCON STARTER0: GINT Position        */
#define SYSCON_STARTER0_GINT_Msk            (0x01UL << SYSCON_STARTER0_GINT_Pos)                  /*!< SYSCON STARTER0: GINT Mask            */
#define SYSCON_STARTER0_IRBLASTER_Pos       3                                                       /*!< SYSCON STARTER0: IRBLASTER Position   */
#define SYSCON_STARTER0_IRBLASTER_Msk       (0x01UL << SYSCON_STARTER0_IRBLASTER_Pos)             /*!< SYSCON STARTER0: IRBLASTER Mask       */
#define SYSCON_STARTER0_PINT0_Pos           4                                                       /*!< SYSCON STARTER0: PINT0 Position       */
#define SYSCON_STARTER0_PINT0_Msk           (0x01UL << SYSCON_STARTER0_PINT0_Pos)                 /*!< SYSCON STARTER0: PINT0 Mask           */
#define SYSCON_STARTER0_PINT1_Pos           5                                                       /*!< SYSCON STARTER0: PINT1 Position       */
#define SYSCON_STARTER0_PINT1_Msk           (0x01UL << SYSCON_STARTER0_PINT1_Pos)                 /*!< SYSCON STARTER0: PINT1 Mask           */
#define SYSCON_STARTER0_PINT2_Pos           6                                                       /*!< SYSCON STARTER0: PINT2 Position       */
#define SYSCON_STARTER0_PINT2_Msk           (0x01UL << SYSCON_STARTER0_PINT2_Pos)                 /*!< SYSCON STARTER0: PINT2 Mask           */
#define SYSCON_STARTER0_PINT3_Pos           7                                                       /*!< SYSCON STARTER0: PINT3 Position       */
#define SYSCON_STARTER0_PINT3_Msk           (0x01UL << SYSCON_STARTER0_PINT3_Pos)                 /*!< SYSCON STARTER0: PINT3 Mask           */
#define SYSCON_STARTER0_SPIFI_Pos           8                                                       /*!< SYSCON STARTER0: SPIFI Position       */
#define SYSCON_STARTER0_SPIFI_Msk           (0x01UL << SYSCON_STARTER0_SPIFI_Pos)                 /*!< SYSCON STARTER0: SPIFI Mask           */
#define SYSCON_STARTER0_TIMER0_Pos          9                                                       /*!< SYSCON STARTER0: TIMER0 Position      */
#define SYSCON_STARTER0_TIMER0_Msk          (0x01UL << SYSCON_STARTER0_TIMER0_Pos)                /*!< SYSCON STARTER0: TIMER0 Mask          */
#define SYSCON_STARTER0_TIMER1_Pos          10                                                      /*!< SYSCON STARTER0: TIMER1 Position      */
#define SYSCON_STARTER0_TIMER1_Msk          (0x01UL << SYSCON_STARTER0_TIMER1_Pos)                /*!< SYSCON STARTER0: TIMER1 Mask          */
#define SYSCON_STARTER0_USART0_Pos          11                                                      /*!< SYSCON STARTER0: USART0 Position      */
#define SYSCON_STARTER0_USART0_Msk          (0x01UL << SYSCON_STARTER0_USART0_Pos)                /*!< SYSCON STARTER0: USART0 Mask          */
#define SYSCON_STARTER0_USART1_Pos          12                                                      /*!< SYSCON STARTER0: USART1 Position      */
#define SYSCON_STARTER0_USART1_Msk          (0x01UL << SYSCON_STARTER0_USART1_Pos)                /*!< SYSCON STARTER0: USART1 Mask          */
#define SYSCON_STARTER0_I2C0_Pos            13                                                      /*!< SYSCON STARTER0: I2C0 Position        */
#define SYSCON_STARTER0_I2C0_Msk            (0x01UL << SYSCON_STARTER0_I2C0_Pos)                  /*!< SYSCON STARTER0: I2C0 Mask            */
#define SYSCON_STARTER0_I2C1_Pos            14                                                      /*!< SYSCON STARTER0: I2C1 Position        */
#define SYSCON_STARTER0_I2C1_Msk            (0x01UL << SYSCON_STARTER0_I2C1_Pos)                  /*!< SYSCON STARTER0: I2C1 Mask            */
#define SYSCON_STARTER0_SPI0_Pos            15                                                      /*!< SYSCON STARTER0: SPI0 Position        */
#define SYSCON_STARTER0_SPI0_Msk            (0x01UL << SYSCON_STARTER0_SPI0_Pos)                  /*!< SYSCON STARTER0: SPI0 Mask            */
#define SYSCON_STARTER0_SPI1_Pos            16                                                      /*!< SYSCON STARTER0: SPI1 Position        */
#define SYSCON_STARTER0_SPI1_Msk            (0x01UL << SYSCON_STARTER0_SPI1_Pos)                  /*!< SYSCON STARTER0: SPI1 Mask            */
#define SYSCON_STARTER0_PWM0_Pos            17                                                      /*!< SYSCON STARTER0: PWM0 Position        */
#define SYSCON_STARTER0_PWM0_Msk            (0x01UL << SYSCON_STARTER0_PWM0_Pos)                  /*!< SYSCON STARTER0: PWM0 Mask            */
#define SYSCON_STARTER0_PWM1_Pos            18                                                      /*!< SYSCON STARTER0: PWM1 Position        */
#define SYSCON_STARTER0_PWM1_Msk            (0x01UL << SYSCON_STARTER0_PWM1_Pos)                  /*!< SYSCON STARTER0: PWM1 Mask            */
#define SYSCON_STARTER0_PWM2_Pos            19                                                      /*!< SYSCON STARTER0: PWM2 Position        */
#define SYSCON_STARTER0_PWM2_Msk            (0x01UL << SYSCON_STARTER0_PWM2_Pos)                  /*!< SYSCON STARTER0: PWM2 Mask            */
#define SYSCON_STARTER0_PWM3_Pos            20                                                      /*!< SYSCON STARTER0: PWM3 Position        */
#define SYSCON_STARTER0_PWM3_Msk            (0x01UL << SYSCON_STARTER0_PWM3_Pos)                  /*!< SYSCON STARTER0: PWM3 Mask            */
#define SYSCON_STARTER0_PWM4_Pos            21                                                      /*!< SYSCON STARTER0: PWM4 Position        */
#define SYSCON_STARTER0_PWM4_Msk            (0x01UL << SYSCON_STARTER0_PWM4_Pos)                  /*!< SYSCON STARTER0: PWM4 Mask            */
#define SYSCON_STARTER0_PWM5_Pos            22                                                      /*!< SYSCON STARTER0: PWM5 Position        */
#define SYSCON_STARTER0_PWM5_Msk            (0x01UL << SYSCON_STARTER0_PWM5_Pos)                  /*!< SYSCON STARTER0: PWM5 Mask            */
#define SYSCON_STARTER0_PWM6_Pos            23                                                      /*!< SYSCON STARTER0: PWM6 Position        */
#define SYSCON_STARTER0_PWM6_Msk            (0x01UL << SYSCON_STARTER0_PWM6_Pos)                  /*!< SYSCON STARTER0: PWM6 Mask            */
#define SYSCON_STARTER0_PWM7_Pos            24                                                      /*!< SYSCON STARTER0: PWM7 Position        */
#define SYSCON_STARTER0_PWM7_Msk            (0x01UL << SYSCON_STARTER0_PWM7_Pos)                  /*!< SYSCON STARTER0: PWM7 Mask            */
#define SYSCON_STARTER0_PWM8_Pos            25                                                      /*!< SYSCON STARTER0: PWM8 Position        */
#define SYSCON_STARTER0_PWM8_Msk            (0x01UL << SYSCON_STARTER0_PWM8_Pos)                  /*!< SYSCON STARTER0: PWM8 Mask            */
#define SYSCON_STARTER0_PWM9_Pos            26                                                      /*!< SYSCON STARTER0: PWM9 Position        */
#define SYSCON_STARTER0_PWM9_Msk            (0x01UL << SYSCON_STARTER0_PWM9_Pos)                  /*!< SYSCON STARTER0: PWM9 Mask            */
#define SYSCON_STARTER0_PWM10_Pos           27                                                      /*!< SYSCON STARTER0: PWM10 Position       */
#define SYSCON_STARTER0_PWM10_Msk           (0x01UL << SYSCON_STARTER0_PWM10_Pos)                 /*!< SYSCON STARTER0: PWM10 Mask           */
#define SYSCON_STARTER0_I2C2_Pos            28                                                      /*!< SYSCON STARTER0: I2C2 Position        */
#define SYSCON_STARTER0_I2C2_Msk            (0x01UL << SYSCON_STARTER0_I2C2_Pos)                  /*!< SYSCON STARTER0: I2C2 Mask            */
#define SYSCON_STARTER0_RTC_Pos             29                                                      /*!< SYSCON STARTER0: RTC Position         */
#define SYSCON_STARTER0_RTC_Msk             (0x01UL << SYSCON_STARTER0_RTC_Pos)                   /*!< SYSCON STARTER0: RTC Mask             */
#define SYSCON_STARTER0_NFCTAG_Pos          30                                                      /*!< SYSCON STARTER0: NFCTAG Position      */
#define SYSCON_STARTER0_NFCTAG_Msk          (0x01UL << SYSCON_STARTER0_NFCTAG_Pos)                /*!< SYSCON STARTER0: NFCTAG Mask          */
#define SYSCON_STARTER0_MAILBOX_Pos         31                                                      /*!< SYSCON STARTER0: MAILBOX Position     */
#define SYSCON_STARTER0_MAILBOX_Msk         (0x01UL << SYSCON_STARTER0_MAILBOX_Pos)               /*!< SYSCON STARTER0: MAILBOX Mask         */

/* ------------------------------  u_syscon_STARTER1  ----------------------------- */
#define SYSCON_STARTER1_ADC_SEQA_Pos        0                                                       /*!< SYSCON STARTER1: ADC_SEQA Position    */
#define SYSCON_STARTER1_ADC_SEQA_Msk        (0x01UL << SYSCON_STARTER1_ADC_SEQA_Pos)              /*!< SYSCON STARTER1: ADC_SEQA Mask        */
#define SYSCON_STARTER1_ADC_SEQB_Pos        1                                                       /*!< SYSCON STARTER1: ADC_SEQB Position    */
#define SYSCON_STARTER1_ADC_SEQB_Msk        (0x01UL << SYSCON_STARTER1_ADC_SEQB_Pos)              /*!< SYSCON STARTER1: ADC_SEQB Mask        */
#define SYSCON_STARTER1_ADC_THCMP_OVR_Pos   2                                                       /*!< SYSCON STARTER1: ADC_THCMP_OVR Position */
#define SYSCON_STARTER1_ADC_THCMP_OVR_Msk   (0x01UL << SYSCON_STARTER1_ADC_THCMP_OVR_Pos)         /*!< SYSCON STARTER1: ADC_THCMP_OVR Mask   */
#define SYSCON_STARTER1_DMIC_Pos            3                                                       /*!< SYSCON STARTER1: DMIC Position        */
#define SYSCON_STARTER1_DMIC_Msk            (0x01UL << SYSCON_STARTER1_DMIC_Pos)                  /*!< SYSCON STARTER1: DMIC Mask            */
#define SYSCON_STARTER1_HWVAD_Pos           4                                                       /*!< SYSCON STARTER1: HWVAD Position       */
#define SYSCON_STARTER1_HWVAD_Msk           (0x01UL << SYSCON_STARTER1_HWVAD_Pos)                 /*!< SYSCON STARTER1: HWVAD Mask           */
#define SYSCON_STARTER1_BLE_DP_Pos          5                                                       /*!< SYSCON STARTER1: BLE_DP Position      */
#define SYSCON_STARTER1_BLE_DP_Msk          (0x01UL << SYSCON_STARTER1_BLE_DP_Pos)                /*!< SYSCON STARTER1: BLE_DP Mask          */
#define SYSCON_STARTER1_BLE_DP0_Pos         6                                                       /*!< SYSCON STARTER1: BLE_DP0 Position     */
#define SYSCON_STARTER1_BLE_DP0_Msk         (0x01UL << SYSCON_STARTER1_BLE_DP0_Pos)               /*!< SYSCON STARTER1: BLE_DP0 Mask         */
#define SYSCON_STARTER1_BLE_DP1_Pos         7                                                       /*!< SYSCON STARTER1: BLE_DP1 Position     */
#define SYSCON_STARTER1_BLE_DP1_Msk         (0x01UL << SYSCON_STARTER1_BLE_DP1_Pos)               /*!< SYSCON STARTER1: BLE_DP1 Mask         */
#define SYSCON_STARTER1_BLE_DP2_Pos         8                                                       /*!< SYSCON STARTER1: BLE_DP2 Position     */
#define SYSCON_STARTER1_BLE_DP2_Msk         (0x01UL << SYSCON_STARTER1_BLE_DP2_Pos)               /*!< SYSCON STARTER1: BLE_DP2 Mask         */
#define SYSCON_STARTER1_BLE_LL_ALL_Pos      9                                                       /*!< SYSCON STARTER1: BLE_LL_ALL Position  */
#define SYSCON_STARTER1_BLE_LL_ALL_Msk      (0x01UL << SYSCON_STARTER1_BLE_LL_ALL_Pos)            /*!< SYSCON STARTER1: BLE_LL_ALL Mask      */
#define SYSCON_STARTER1_ZIGBEE_MAC_Pos      10                                                      /*!< SYSCON STARTER1: ZIGBEE_MAC Position  */
#define SYSCON_STARTER1_ZIGBEE_MAC_Msk      (0x01UL << SYSCON_STARTER1_ZIGBEE_MAC_Pos)            /*!< SYSCON STARTER1: ZIGBEE_MAC Mask      */
#define SYSCON_STARTER1_ZIGBEE_MODEM_Pos    11                                                      /*!< SYSCON STARTER1: ZIGBEE_MODEM Position */
#define SYSCON_STARTER1_ZIGBEE_MODEM_Msk    (0x01UL << SYSCON_STARTER1_ZIGBEE_MODEM_Pos)          /*!< SYSCON STARTER1: ZIGBEE_MODEM Mask    */
#define SYSCON_STARTER1_RFP_TMU_Pos         12                                                      /*!< SYSCON STARTER1: RFP_TMU Position     */
#define SYSCON_STARTER1_RFP_TMU_Msk         (0x01UL << SYSCON_STARTER1_RFP_TMU_Pos)               /*!< SYSCON STARTER1: RFP_TMU Mask         */
#define SYSCON_STARTER1_RFP_AGC_Pos         13                                                      /*!< SYSCON STARTER1: RFP_AGC Position     */
#define SYSCON_STARTER1_RFP_AGC_Msk         (0x01UL << SYSCON_STARTER1_RFP_AGC_Pos)               /*!< SYSCON STARTER1: RFP_AGC Mask         */
#define SYSCON_STARTER1_ISO7816_Pos         14                                                      /*!< SYSCON STARTER1: ISO7816 Position     */
#define SYSCON_STARTER1_ISO7816_Msk         (0x01UL << SYSCON_STARTER1_ISO7816_Pos)               /*!< SYSCON STARTER1: ISO7816 Mask         */
#define SYSCON_STARTER1_ANA_COMP_Pos        15                                                      /*!< SYSCON STARTER1: ANA_COMP Position    */
#define SYSCON_STARTER1_ANA_COMP_Msk        (0x01UL << SYSCON_STARTER1_ANA_COMP_Pos)              /*!< SYSCON STARTER1: ANA_COMP Mask        */
#define SYSCON_STARTER1_WAKE_UP_TIMER0_Pos  16                                                      /*!< SYSCON STARTER1: WAKE_UP_TIMER0 Position */
#define SYSCON_STARTER1_WAKE_UP_TIMER0_Msk  (0x01UL << SYSCON_STARTER1_WAKE_UP_TIMER0_Pos)        /*!< SYSCON STARTER1: WAKE_UP_TIMER0 Mask  */
#define SYSCON_STARTER1_WAKE_UP_TIMER1_Pos  17                                                      /*!< SYSCON STARTER1: WAKE_UP_TIMER1 Position */
#define SYSCON_STARTER1_WAKE_UP_TIMER1_Msk  (0x01UL << SYSCON_STARTER1_WAKE_UP_TIMER1_Pos)        /*!< SYSCON STARTER1: WAKE_UP_TIMER1 Mask  */
#define SYSCON_STARTER1_BLE_WAKE_UP_TIMER_Pos 22                                                    /*!< SYSCON STARTER1: BLE_WAKE_UP_TIMER Position */
#define SYSCON_STARTER1_BLE_WAKE_UP_TIMER_Msk (0x01UL << SYSCON_STARTER1_BLE_WAKE_UP_TIMER_Pos)   /*!< SYSCON STARTER1: BLE_WAKE_UP_TIMER Mask */
#define SYSCON_STARTER1_BLE_OSC_EN_Pos      23                                                      /*!< SYSCON STARTER1: BLE_OSC_EN Position  */
#define SYSCON_STARTER1_BLE_OSC_EN_Msk      (0x01UL << SYSCON_STARTER1_BLE_OSC_EN_Pos)            /*!< SYSCON STARTER1: BLE_OSC_EN Mask      */
#define SYSCON_STARTER1_GPIO_Pos            31                                                      /*!< SYSCON STARTER1: GPIO Position        */
#define SYSCON_STARTER1_GPIO_Msk            (0x01UL << SYSCON_STARTER1_GPIO_Pos)                  /*!< SYSCON STARTER1: GPIO Mask            */

/* ----------------------------  u_syscon_STARTERSET0  ---------------------------- */
#define SYSCON_STARTERSET0_WDT_BOD_SET_Pos  0                                                       /*!< SYSCON STARTERSET0: WDT_BOD_SET Position */
#define SYSCON_STARTERSET0_WDT_BOD_SET_Msk  (0x01UL << SYSCON_STARTERSET0_WDT_BOD_SET_Pos)        /*!< SYSCON STARTERSET0: WDT_BOD_SET Mask  */
#define SYSCON_STARTERSET0_DMA_SET_Pos      1                                                       /*!< SYSCON STARTERSET0: DMA_SET Position  */
#define SYSCON_STARTERSET0_DMA_SET_Msk      (0x01UL << SYSCON_STARTERSET0_DMA_SET_Pos)            /*!< SYSCON STARTERSET0: DMA_SET Mask      */
#define SYSCON_STARTERSET0_GINT_SET_Pos     2                                                       /*!< SYSCON STARTERSET0: GINT_SET Position */
#define SYSCON_STARTERSET0_GINT_SET_Msk     (0x01UL << SYSCON_STARTERSET0_GINT_SET_Pos)           /*!< SYSCON STARTERSET0: GINT_SET Mask     */
#define SYSCON_STARTERSET0_IRBLASTER_SET_Pos 3                                                      /*!< SYSCON STARTERSET0: IRBLASTER_SET Position */
#define SYSCON_STARTERSET0_IRBLASTER_SET_Msk (0x01UL << SYSCON_STARTERSET0_IRBLASTER_SET_Pos)     /*!< SYSCON STARTERSET0: IRBLASTER_SET Mask */
#define SYSCON_STARTERSET0_PINT0_SET_Pos    4                                                       /*!< SYSCON STARTERSET0: PINT0_SET Position */
#define SYSCON_STARTERSET0_PINT0_SET_Msk    (0x01UL << SYSCON_STARTERSET0_PINT0_SET_Pos)          /*!< SYSCON STARTERSET0: PINT0_SET Mask    */
#define SYSCON_STARTERSET0_PINT1_SET_Pos    5                                                       /*!< SYSCON STARTERSET0: PINT1_SET Position */
#define SYSCON_STARTERSET0_PINT1_SET_Msk    (0x01UL << SYSCON_STARTERSET0_PINT1_SET_Pos)          /*!< SYSCON STARTERSET0: PINT1_SET Mask    */
#define SYSCON_STARTERSET0_PINT2_SET_Pos    6                                                       /*!< SYSCON STARTERSET0: PINT2_SET Position */
#define SYSCON_STARTERSET0_PINT2_SET_Msk    (0x01UL << SYSCON_STARTERSET0_PINT2_SET_Pos)          /*!< SYSCON STARTERSET0: PINT2_SET Mask    */
#define SYSCON_STARTERSET0_PINT3_SET_Pos    7                                                       /*!< SYSCON STARTERSET0: PINT3_SET Position */
#define SYSCON_STARTERSET0_PINT3_SET_Msk    (0x01UL << SYSCON_STARTERSET0_PINT3_SET_Pos)          /*!< SYSCON STARTERSET0: PINT3_SET Mask    */
#define SYSCON_STARTERSET0_SPIFI_SET_Pos    8                                                       /*!< SYSCON STARTERSET0: SPIFI_SET Position */
#define SYSCON_STARTERSET0_SPIFI_SET_Msk    (0x01UL << SYSCON_STARTERSET0_SPIFI_SET_Pos)          /*!< SYSCON STARTERSET0: SPIFI_SET Mask    */
#define SYSCON_STARTERSET0_TIMER0_SET_Pos   9                                                       /*!< SYSCON STARTERSET0: TIMER0_SET Position */
#define SYSCON_STARTERSET0_TIMER0_SET_Msk   (0x01UL << SYSCON_STARTERSET0_TIMER0_SET_Pos)         /*!< SYSCON STARTERSET0: TIMER0_SET Mask   */
#define SYSCON_STARTERSET0_TIMER1_SET_Pos   10                                                      /*!< SYSCON STARTERSET0: TIMER1_SET Position */
#define SYSCON_STARTERSET0_TIMER1_SET_Msk   (0x01UL << SYSCON_STARTERSET0_TIMER1_SET_Pos)         /*!< SYSCON STARTERSET0: TIMER1_SET Mask   */
#define SYSCON_STARTERSET0_USART0_SET_Pos   11                                                      /*!< SYSCON STARTERSET0: USART0_SET Position */
#define SYSCON_STARTERSET0_USART0_SET_Msk   (0x01UL << SYSCON_STARTERSET0_USART0_SET_Pos)         /*!< SYSCON STARTERSET0: USART0_SET Mask   */
#define SYSCON_STARTERSET0_USART1_SET_Pos   12                                                      /*!< SYSCON STARTERSET0: USART1_SET Position */
#define SYSCON_STARTERSET0_USART1_SET_Msk   (0x01UL << SYSCON_STARTERSET0_USART1_SET_Pos)         /*!< SYSCON STARTERSET0: USART1_SET Mask   */
#define SYSCON_STARTERSET0_I2C0_SET_Pos     13                                                      /*!< SYSCON STARTERSET0: I2C0_SET Position */
#define SYSCON_STARTERSET0_I2C0_SET_Msk     (0x01UL << SYSCON_STARTERSET0_I2C0_SET_Pos)           /*!< SYSCON STARTERSET0: I2C0_SET Mask     */
#define SYSCON_STARTERSET0_I2C1_SET_Pos     14                                                      /*!< SYSCON STARTERSET0: I2C1_SET Position */
#define SYSCON_STARTERSET0_I2C1_SET_Msk     (0x01UL << SYSCON_STARTERSET0_I2C1_SET_Pos)           /*!< SYSCON STARTERSET0: I2C1_SET Mask     */
#define SYSCON_STARTERSET0_SPI0_SET_Pos     15                                                      /*!< SYSCON STARTERSET0: SPI0_SET Position */
#define SYSCON_STARTERSET0_SPI0_SET_Msk     (0x01UL << SYSCON_STARTERSET0_SPI0_SET_Pos)           /*!< SYSCON STARTERSET0: SPI0_SET Mask     */
#define SYSCON_STARTERSET0_SPI1_SET_Pos     16                                                      /*!< SYSCON STARTERSET0: SPI1_SET Position */
#define SYSCON_STARTERSET0_SPI1_SET_Msk     (0x01UL << SYSCON_STARTERSET0_SPI1_SET_Pos)           /*!< SYSCON STARTERSET0: SPI1_SET Mask     */
#define SYSCON_STARTERSET0_PWM0_SET_Pos     17                                                      /*!< SYSCON STARTERSET0: PWM0_SET Position */
#define SYSCON_STARTERSET0_PWM0_SET_Msk     (0x01UL << SYSCON_STARTERSET0_PWM0_SET_Pos)           /*!< SYSCON STARTERSET0: PWM0_SET Mask     */
#define SYSCON_STARTERSET0_PWM1_SET_Pos     18                                                      /*!< SYSCON STARTERSET0: PWM1_SET Position */
#define SYSCON_STARTERSET0_PWM1_SET_Msk     (0x01UL << SYSCON_STARTERSET0_PWM1_SET_Pos)           /*!< SYSCON STARTERSET0: PWM1_SET Mask     */
#define SYSCON_STARTERSET0_PWM2_SET_Pos     19                                                      /*!< SYSCON STARTERSET0: PWM2_SET Position */
#define SYSCON_STARTERSET0_PWM2_SET_Msk     (0x01UL << SYSCON_STARTERSET0_PWM2_SET_Pos)           /*!< SYSCON STARTERSET0: PWM2_SET Mask     */
#define SYSCON_STARTERSET0_PWM3_SET_Pos     20                                                      /*!< SYSCON STARTERSET0: PWM3_SET Position */
#define SYSCON_STARTERSET0_PWM3_SET_Msk     (0x01UL << SYSCON_STARTERSET0_PWM3_SET_Pos)           /*!< SYSCON STARTERSET0: PWM3_SET Mask     */
#define SYSCON_STARTERSET0_PWM4_SET_Pos     21                                                      /*!< SYSCON STARTERSET0: PWM4_SET Position */
#define SYSCON_STARTERSET0_PWM4_SET_Msk     (0x01UL << SYSCON_STARTERSET0_PWM4_SET_Pos)           /*!< SYSCON STARTERSET0: PWM4_SET Mask     */
#define SYSCON_STARTERSET0_PWM5_SET_Pos     22                                                      /*!< SYSCON STARTERSET0: PWM5_SET Position */
#define SYSCON_STARTERSET0_PWM5_SET_Msk     (0x01UL << SYSCON_STARTERSET0_PWM5_SET_Pos)           /*!< SYSCON STARTERSET0: PWM5_SET Mask     */
#define SYSCON_STARTERSET0_PWM6_SET_Pos     23                                                      /*!< SYSCON STARTERSET0: PWM6_SET Position */
#define SYSCON_STARTERSET0_PWM6_SET_Msk     (0x01UL << SYSCON_STARTERSET0_PWM6_SET_Pos)           /*!< SYSCON STARTERSET0: PWM6_SET Mask     */
#define SYSCON_STARTERSET0_PWM7_SET_Pos     24                                                      /*!< SYSCON STARTERSET0: PWM7_SET Position */
#define SYSCON_STARTERSET0_PWM7_SET_Msk     (0x01UL << SYSCON_STARTERSET0_PWM7_SET_Pos)           /*!< SYSCON STARTERSET0: PWM7_SET Mask     */
#define SYSCON_STARTERSET0_PWM8_SET_Pos     25                                                      /*!< SYSCON STARTERSET0: PWM8_SET Position */
#define SYSCON_STARTERSET0_PWM8_SET_Msk     (0x01UL << SYSCON_STARTERSET0_PWM8_SET_Pos)           /*!< SYSCON STARTERSET0: PWM8_SET Mask     */
#define SYSCON_STARTERSET0_PWM9_SET_Pos     26                                                      /*!< SYSCON STARTERSET0: PWM9_SET Position */
#define SYSCON_STARTERSET0_PWM9_SET_Msk     (0x01UL << SYSCON_STARTERSET0_PWM9_SET_Pos)           /*!< SYSCON STARTERSET0: PWM9_SET Mask     */
#define SYSCON_STARTERSET0_PWM10_SET_Pos    27                                                      /*!< SYSCON STARTERSET0: PWM10_SET Position */
#define SYSCON_STARTERSET0_PWM10_SET_Msk    (0x01UL << SYSCON_STARTERSET0_PWM10_SET_Pos)          /*!< SYSCON STARTERSET0: PWM10_SET Mask    */
#define SYSCON_STARTERSET0_I2C2_SET_Pos     28                                                      /*!< SYSCON STARTERSET0: I2C2_SET Position */
#define SYSCON_STARTERSET0_I2C2_SET_Msk     (0x01UL << SYSCON_STARTERSET0_I2C2_SET_Pos)           /*!< SYSCON STARTERSET0: I2C2_SET Mask     */
#define SYSCON_STARTERSET0_RTC_SET_Pos      29                                                      /*!< SYSCON STARTERSET0: RTC_SET Position  */
#define SYSCON_STARTERSET0_RTC_SET_Msk      (0x01UL << SYSCON_STARTERSET0_RTC_SET_Pos)            /*!< SYSCON STARTERSET0: RTC_SET Mask      */
#define SYSCON_STARTERSET0_NFCTAG_SET_Pos   30                                                      /*!< SYSCON STARTERSET0: NFCTAG_SET Position */
#define SYSCON_STARTERSET0_NFCTAG_SET_Msk   (0x01UL << SYSCON_STARTERSET0_NFCTAG_SET_Pos)         /*!< SYSCON STARTERSET0: NFCTAG_SET Mask   */
#define SYSCON_STARTERSET0_MAILBOX_SET_Pos  31                                                      /*!< SYSCON STARTERSET0: MAILBOX_SET Position */
#define SYSCON_STARTERSET0_MAILBOX_SET_Msk  (0x01UL << SYSCON_STARTERSET0_MAILBOX_SET_Pos)        /*!< SYSCON STARTERSET0: MAILBOX_SET Mask  */

/* ----------------------------  u_syscon_STARTERSET1  ---------------------------- */
#define SYSCON_STARTERSET1_ADC_SEQA_SET_Pos 0                                                       /*!< SYSCON STARTERSET1: ADC_SEQA_SET Position */
#define SYSCON_STARTERSET1_ADC_SEQA_SET_Msk (0x01UL << SYSCON_STARTERSET1_ADC_SEQA_SET_Pos)       /*!< SYSCON STARTERSET1: ADC_SEQA_SET Mask */
#define SYSCON_STARTERSET1_ADC_SEQB_SET_Pos 1                                                       /*!< SYSCON STARTERSET1: ADC_SEQB_SET Position */
#define SYSCON_STARTERSET1_ADC_SEQB_SET_Msk (0x01UL << SYSCON_STARTERSET1_ADC_SEQB_SET_Pos)       /*!< SYSCON STARTERSET1: ADC_SEQB_SET Mask */
#define SYSCON_STARTERSET1_ADC_THCMP_OVR_SET_Pos 2                                                  /*!< SYSCON STARTERSET1: ADC_THCMP_OVR_SET Position */
#define SYSCON_STARTERSET1_ADC_THCMP_OVR_SET_Msk (0x01UL << SYSCON_STARTERSET1_ADC_THCMP_OVR_SET_Pos)/*!< SYSCON STARTERSET1: ADC_THCMP_OVR_SET Mask */
#define SYSCON_STARTERSET1_DMIC_SET_Pos     3                                                       /*!< SYSCON STARTERSET1: DMIC_SET Position */
#define SYSCON_STARTERSET1_DMIC_SET_Msk     (0x01UL << SYSCON_STARTERSET1_DMIC_SET_Pos)           /*!< SYSCON STARTERSET1: DMIC_SET Mask     */
#define SYSCON_STARTERSET1_HWVAD_SET_Pos    4                                                       /*!< SYSCON STARTERSET1: HWVAD_SET Position */
#define SYSCON_STARTERSET1_HWVAD_SET_Msk    (0x01UL << SYSCON_STARTERSET1_HWVAD_SET_Pos)          /*!< SYSCON STARTERSET1: HWVAD_SET Mask    */
#define SYSCON_STARTERSET1_BLE_DP_SET_Pos   5                                                       /*!< SYSCON STARTERSET1: BLE_DP_SET Position */
#define SYSCON_STARTERSET1_BLE_DP_SET_Msk   (0x01UL << SYSCON_STARTERSET1_BLE_DP_SET_Pos)         /*!< SYSCON STARTERSET1: BLE_DP_SET Mask   */
#define SYSCON_STARTERSET1_BLE_DP0_SET_Pos  6                                                       /*!< SYSCON STARTERSET1: BLE_DP0_SET Position */
#define SYSCON_STARTERSET1_BLE_DP0_SET_Msk  (0x01UL << SYSCON_STARTERSET1_BLE_DP0_SET_Pos)        /*!< SYSCON STARTERSET1: BLE_DP0_SET Mask  */
#define SYSCON_STARTERSET1_BLE_DP1_SET_Pos  7                                                       /*!< SYSCON STARTERSET1: BLE_DP1_SET Position */
#define SYSCON_STARTERSET1_BLE_DP1_SET_Msk  (0x01UL << SYSCON_STARTERSET1_BLE_DP1_SET_Pos)        /*!< SYSCON STARTERSET1: BLE_DP1_SET Mask  */
#define SYSCON_STARTERSET1_BLE_DP2_SET_Pos  8                                                       /*!< SYSCON STARTERSET1: BLE_DP2_SET Position */
#define SYSCON_STARTERSET1_BLE_DP2_SET_Msk  (0x01UL << SYSCON_STARTERSET1_BLE_DP2_SET_Pos)        /*!< SYSCON STARTERSET1: BLE_DP2_SET Mask  */
#define SYSCON_STARTERSET1_BLE_LL_ALL_SET_Pos 9                                                     /*!< SYSCON STARTERSET1: BLE_LL_ALL_SET Position */
#define SYSCON_STARTERSET1_BLE_LL_ALL_SET_Msk (0x01UL << SYSCON_STARTERSET1_BLE_LL_ALL_SET_Pos)   /*!< SYSCON STARTERSET1: BLE_LL_ALL_SET Mask */
#define SYSCON_STARTERSET1_ZIGBEE_MAC_SET_Pos 10                                                    /*!< SYSCON STARTERSET1: ZIGBEE_MAC_SET Position */
#define SYSCON_STARTERSET1_ZIGBEE_MAC_SET_Msk (0x01UL << SYSCON_STARTERSET1_ZIGBEE_MAC_SET_Pos)   /*!< SYSCON STARTERSET1: ZIGBEE_MAC_SET Mask */
#define SYSCON_STARTERSET1_ZIGBEE_MODEM_SET_Pos 11                                                  /*!< SYSCON STARTERSET1: ZIGBEE_MODEM_SET Position */
#define SYSCON_STARTERSET1_ZIGBEE_MODEM_SET_Msk (0x01UL << SYSCON_STARTERSET1_ZIGBEE_MODEM_SET_Pos)/*!< SYSCON STARTERSET1: ZIGBEE_MODEM_SET Mask */
#define SYSCON_STARTERSET1_RFP_TMU_SET_Pos  12                                                      /*!< SYSCON STARTERSET1: RFP_TMU_SET Position */
#define SYSCON_STARTERSET1_RFP_TMU_SET_Msk  (0x01UL << SYSCON_STARTERSET1_RFP_TMU_SET_Pos)        /*!< SYSCON STARTERSET1: RFP_TMU_SET Mask  */
#define SYSCON_STARTERSET1_RFP_AGC_SET_Pos  13                                                      /*!< SYSCON STARTERSET1: RFP_AGC_SET Position */
#define SYSCON_STARTERSET1_RFP_AGC_SET_Msk  (0x01UL << SYSCON_STARTERSET1_RFP_AGC_SET_Pos)        /*!< SYSCON STARTERSET1: RFP_AGC_SET Mask  */
#define SYSCON_STARTERSET1_ISO7816_SET_Pos  14                                                      /*!< SYSCON STARTERSET1: ISO7816_SET Position */
#define SYSCON_STARTERSET1_ISO7816_SET_Msk  (0x01UL << SYSCON_STARTERSET1_ISO7816_SET_Pos)        /*!< SYSCON STARTERSET1: ISO7816_SET Mask  */
#define SYSCON_STARTERSET1_ANA_COMP_SET_Pos 15                                                      /*!< SYSCON STARTERSET1: ANA_COMP_SET Position */
#define SYSCON_STARTERSET1_ANA_COMP_SET_Msk (0x01UL << SYSCON_STARTERSET1_ANA_COMP_SET_Pos)       /*!< SYSCON STARTERSET1: ANA_COMP_SET Mask */
#define SYSCON_STARTERSET1_WAKE_UP_TIMER0_SET_Pos 16                                                /*!< SYSCON STARTERSET1: WAKE_UP_TIMER0_SET Position */
#define SYSCON_STARTERSET1_WAKE_UP_TIMER0_SET_Msk (0x01UL << SYSCON_STARTERSET1_WAKE_UP_TIMER0_SET_Pos)/*!< SYSCON STARTERSET1: WAKE_UP_TIMER0_SET Mask */
#define SYSCON_STARTERSET1_WAKE_UP_TIMER1_SET_Pos 17                                                /*!< SYSCON STARTERSET1: WAKE_UP_TIMER1_SET Position */
#define SYSCON_STARTERSET1_WAKE_UP_TIMER1_SET_Msk (0x01UL << SYSCON_STARTERSET1_WAKE_UP_TIMER1_SET_Pos)/*!< SYSCON STARTERSET1: WAKE_UP_TIMER1_SET Mask */
#define SYSCON_STARTERSET1_BLE_WAKE_UP_TIMER_SET_Pos 22                                             /*!< SYSCON STARTERSET1: BLE_WAKE_UP_TIMER_SET Position */
#define SYSCON_STARTERSET1_BLE_WAKE_UP_TIMER_SET_Msk (0x01UL << SYSCON_STARTERSET1_BLE_WAKE_UP_TIMER_SET_Pos)/*!< SYSCON STARTERSET1: BLE_WAKE_UP_TIMER_SET Mask */

/* ----------------------------  u_syscon_STARTERCLR0  ---------------------------- */
#define SYSCON_STARTERCLR0_WDT_BOD_CLR_Pos  0                                                       /*!< SYSCON STARTERCLR0: WDT_BOD_CLR Position */
#define SYSCON_STARTERCLR0_WDT_BOD_CLR_Msk  (0x01UL << SYSCON_STARTERCLR0_WDT_BOD_CLR_Pos)        /*!< SYSCON STARTERCLR0: WDT_BOD_CLR Mask  */
#define SYSCON_STARTERCLR0_DMA_CLR_Pos      1                                                       /*!< SYSCON STARTERCLR0: DMA_CLR Position  */
#define SYSCON_STARTERCLR0_DMA_CLR_Msk      (0x01UL << SYSCON_STARTERCLR0_DMA_CLR_Pos)            /*!< SYSCON STARTERCLR0: DMA_CLR Mask      */
#define SYSCON_STARTERCLR0_GINT_CLR_Pos     2                                                       /*!< SYSCON STARTERCLR0: GINT_CLR Position */
#define SYSCON_STARTERCLR0_GINT_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_GINT_CLR_Pos)           /*!< SYSCON STARTERCLR0: GINT_CLR Mask     */
#define SYSCON_STARTERCLR0_IRBLASTER_CLR_Pos 3                                                      /*!< SYSCON STARTERCLR0: IRBLASTER_CLR Position */
#define SYSCON_STARTERCLR0_IRBLASTER_CLR_Msk (0x01UL << SYSCON_STARTERCLR0_IRBLASTER_CLR_Pos)     /*!< SYSCON STARTERCLR0: IRBLASTER_CLR Mask */
#define SYSCON_STARTERCLR0_PINT0_CLR_Pos    4                                                       /*!< SYSCON STARTERCLR0: PINT0_CLR Position */
#define SYSCON_STARTERCLR0_PINT0_CLR_Msk    (0x01UL << SYSCON_STARTERCLR0_PINT0_CLR_Pos)          /*!< SYSCON STARTERCLR0: PINT0_CLR Mask    */
#define SYSCON_STARTERCLR0_PINT1_CLR_Pos    5                                                       /*!< SYSCON STARTERCLR0: PINT1_CLR Position */
#define SYSCON_STARTERCLR0_PINT1_CLR_Msk    (0x01UL << SYSCON_STARTERCLR0_PINT1_CLR_Pos)          /*!< SYSCON STARTERCLR0: PINT1_CLR Mask    */
#define SYSCON_STARTERCLR0_PINT2_CLR_Pos    6                                                       /*!< SYSCON STARTERCLR0: PINT2_CLR Position */
#define SYSCON_STARTERCLR0_PINT2_CLR_Msk    (0x01UL << SYSCON_STARTERCLR0_PINT2_CLR_Pos)          /*!< SYSCON STARTERCLR0: PINT2_CLR Mask    */
#define SYSCON_STARTERCLR0_PINT3_CLR_Pos    7                                                       /*!< SYSCON STARTERCLR0: PINT3_CLR Position */
#define SYSCON_STARTERCLR0_PINT3_CLR_Msk    (0x01UL << SYSCON_STARTERCLR0_PINT3_CLR_Pos)          /*!< SYSCON STARTERCLR0: PINT3_CLR Mask    */
#define SYSCON_STARTERCLR0_SPIFI_CLR_Pos    8                                                       /*!< SYSCON STARTERCLR0: SPIFI_CLR Position */
#define SYSCON_STARTERCLR0_SPIFI_CLR_Msk    (0x01UL << SYSCON_STARTERCLR0_SPIFI_CLR_Pos)          /*!< SYSCON STARTERCLR0: SPIFI_CLR Mask    */
#define SYSCON_STARTERCLR0_TIMER0_CLR_Pos   9                                                       /*!< SYSCON STARTERCLR0: TIMER0_CLR Position */
#define SYSCON_STARTERCLR0_TIMER0_CLR_Msk   (0x01UL << SYSCON_STARTERCLR0_TIMER0_CLR_Pos)         /*!< SYSCON STARTERCLR0: TIMER0_CLR Mask   */
#define SYSCON_STARTERCLR0_TIMER1_CLR_Pos   10                                                      /*!< SYSCON STARTERCLR0: TIMER1_CLR Position */
#define SYSCON_STARTERCLR0_TIMER1_CLR_Msk   (0x01UL << SYSCON_STARTERCLR0_TIMER1_CLR_Pos)         /*!< SYSCON STARTERCLR0: TIMER1_CLR Mask   */
#define SYSCON_STARTERCLR0_USART0_CLR_Pos   11                                                      /*!< SYSCON STARTERCLR0: USART0_CLR Position */
#define SYSCON_STARTERCLR0_USART0_CLR_Msk   (0x01UL << SYSCON_STARTERCLR0_USART0_CLR_Pos)         /*!< SYSCON STARTERCLR0: USART0_CLR Mask   */
#define SYSCON_STARTERCLR0_USART1_CLR_Pos   12                                                      /*!< SYSCON STARTERCLR0: USART1_CLR Position */
#define SYSCON_STARTERCLR0_USART1_CLR_Msk   (0x01UL << SYSCON_STARTERCLR0_USART1_CLR_Pos)         /*!< SYSCON STARTERCLR0: USART1_CLR Mask   */
#define SYSCON_STARTERCLR0_I2C0_CLR_Pos     13                                                      /*!< SYSCON STARTERCLR0: I2C0_CLR Position */
#define SYSCON_STARTERCLR0_I2C0_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_I2C0_CLR_Pos)           /*!< SYSCON STARTERCLR0: I2C0_CLR Mask     */
#define SYSCON_STARTERCLR0_I2C1_CLR_Pos     14                                                      /*!< SYSCON STARTERCLR0: I2C1_CLR Position */
#define SYSCON_STARTERCLR0_I2C1_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_I2C1_CLR_Pos)           /*!< SYSCON STARTERCLR0: I2C1_CLR Mask     */
#define SYSCON_STARTERCLR0_SPI0_CLR_Pos     15                                                      /*!< SYSCON STARTERCLR0: SPI0_CLR Position */
#define SYSCON_STARTERCLR0_SPI0_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_SPI0_CLR_Pos)           /*!< SYSCON STARTERCLR0: SPI0_CLR Mask     */
#define SYSCON_STARTERCLR0_SPI1_CLR_Pos     16                                                      /*!< SYSCON STARTERCLR0: SPI1_CLR Position */
#define SYSCON_STARTERCLR0_SPI1_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_SPI1_CLR_Pos)           /*!< SYSCON STARTERCLR0: SPI1_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM0_CLR_Pos     17                                                      /*!< SYSCON STARTERCLR0: PWM0_CLR Position */
#define SYSCON_STARTERCLR0_PWM0_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_PWM0_CLR_Pos)           /*!< SYSCON STARTERCLR0: PWM0_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM1_CLR_Pos     18                                                      /*!< SYSCON STARTERCLR0: PWM1_CLR Position */
#define SYSCON_STARTERCLR0_PWM1_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_PWM1_CLR_Pos)           /*!< SYSCON STARTERCLR0: PWM1_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM2_CLR_Pos     19                                                      /*!< SYSCON STARTERCLR0: PWM2_CLR Position */
#define SYSCON_STARTERCLR0_PWM2_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_PWM2_CLR_Pos)           /*!< SYSCON STARTERCLR0: PWM2_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM3_CLR_Pos     20                                                      /*!< SYSCON STARTERCLR0: PWM3_CLR Position */
#define SYSCON_STARTERCLR0_PWM3_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_PWM3_CLR_Pos)           /*!< SYSCON STARTERCLR0: PWM3_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM4_CLR_Pos     21                                                      /*!< SYSCON STARTERCLR0: PWM4_CLR Position */
#define SYSCON_STARTERCLR0_PWM4_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_PWM4_CLR_Pos)           /*!< SYSCON STARTERCLR0: PWM4_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM5_CLR_Pos     22                                                      /*!< SYSCON STARTERCLR0: PWM5_CLR Position */
#define SYSCON_STARTERCLR0_PWM5_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_PWM5_CLR_Pos)           /*!< SYSCON STARTERCLR0: PWM5_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM6_CLR_Pos     23                                                      /*!< SYSCON STARTERCLR0: PWM6_CLR Position */
#define SYSCON_STARTERCLR0_PWM6_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_PWM6_CLR_Pos)           /*!< SYSCON STARTERCLR0: PWM6_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM7_CLR_Pos     24                                                      /*!< SYSCON STARTERCLR0: PWM7_CLR Position */
#define SYSCON_STARTERCLR0_PWM7_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_PWM7_CLR_Pos)           /*!< SYSCON STARTERCLR0: PWM7_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM8_CLR_Pos     25                                                      /*!< SYSCON STARTERCLR0: PWM8_CLR Position */
#define SYSCON_STARTERCLR0_PWM8_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_PWM8_CLR_Pos)           /*!< SYSCON STARTERCLR0: PWM8_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM9_CLR_Pos     26                                                      /*!< SYSCON STARTERCLR0: PWM9_CLR Position */
#define SYSCON_STARTERCLR0_PWM9_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_PWM9_CLR_Pos)           /*!< SYSCON STARTERCLR0: PWM9_CLR Mask     */
#define SYSCON_STARTERCLR0_PWM10_CLR_Pos    27                                                      /*!< SYSCON STARTERCLR0: PWM10_CLR Position */
#define SYSCON_STARTERCLR0_PWM10_CLR_Msk    (0x01UL << SYSCON_STARTERCLR0_PWM10_CLR_Pos)          /*!< SYSCON STARTERCLR0: PWM10_CLR Mask    */
#define SYSCON_STARTERCLR0_I2C2_CLR_Pos     28                                                      /*!< SYSCON STARTERCLR0: I2C2_CLR Position */
#define SYSCON_STARTERCLR0_I2C2_CLR_Msk     (0x01UL << SYSCON_STARTERCLR0_I2C2_CLR_Pos)           /*!< SYSCON STARTERCLR0: I2C2_CLR Mask     */
#define SYSCON_STARTERCLR0_RTC_CLR_Pos      29                                                      /*!< SYSCON STARTERCLR0: RTC_CLR Position  */
#define SYSCON_STARTERCLR0_RTC_CLR_Msk      (0x01UL << SYSCON_STARTERCLR0_RTC_CLR_Pos)            /*!< SYSCON STARTERCLR0: RTC_CLR Mask      */
#define SYSCON_STARTERCLR0_NFCTAG_CLR_Pos   30                                                      /*!< SYSCON STARTERCLR0: NFCTAG_CLR Position */
#define SYSCON_STARTERCLR0_NFCTAG_CLR_Msk   (0x01UL << SYSCON_STARTERCLR0_NFCTAG_CLR_Pos)         /*!< SYSCON STARTERCLR0: NFCTAG_CLR Mask   */
#define SYSCON_STARTERCLR0_MAILBOX_CLR_Pos  31                                                      /*!< SYSCON STARTERCLR0: MAILBOX_CLR Position */
#define SYSCON_STARTERCLR0_MAILBOX_CLR_Msk  (0x01UL << SYSCON_STARTERCLR0_MAILBOX_CLR_Pos)        /*!< SYSCON STARTERCLR0: MAILBOX_CLR Mask  */

/* ----------------------------  u_syscon_STARTERCLR1  ---------------------------- */
#define SYSCON_STARTERCLR1_ADC_SEQA_CLR_Pos 0                                                       /*!< SYSCON STARTERCLR1: ADC_SEQA_CLR Position */
#define SYSCON_STARTERCLR1_ADC_SEQA_CLR_Msk (0x01UL << SYSCON_STARTERCLR1_ADC_SEQA_CLR_Pos)       /*!< SYSCON STARTERCLR1: ADC_SEQA_CLR Mask */
#define SYSCON_STARTERCLR1_ADC_SEQB_CLR_Pos 1                                                       /*!< SYSCON STARTERCLR1: ADC_SEQB_CLR Position */
#define SYSCON_STARTERCLR1_ADC_SEQB_CLR_Msk (0x01UL << SYSCON_STARTERCLR1_ADC_SEQB_CLR_Pos)       /*!< SYSCON STARTERCLR1: ADC_SEQB_CLR Mask */
#define SYSCON_STARTERCLR1_ADC_THCMP_OVR_CLR_Pos 2                                                  /*!< SYSCON STARTERCLR1: ADC_THCMP_OVR_CLR Position */
#define SYSCON_STARTERCLR1_ADC_THCMP_OVR_CLR_Msk (0x01UL << SYSCON_STARTERCLR1_ADC_THCMP_OVR_CLR_Pos)/*!< SYSCON STARTERCLR1: ADC_THCMP_OVR_CLR Mask */
#define SYSCON_STARTERCLR1_DMIC_CLR_Pos     3                                                       /*!< SYSCON STARTERCLR1: DMIC_CLR Position */
#define SYSCON_STARTERCLR1_DMIC_CLR_Msk     (0x01UL << SYSCON_STARTERCLR1_DMIC_CLR_Pos)           /*!< SYSCON STARTERCLR1: DMIC_CLR Mask     */
#define SYSCON_STARTERCLR1_HWVAD_CLR_Pos    4                                                       /*!< SYSCON STARTERCLR1: HWVAD_CLR Position */
#define SYSCON_STARTERCLR1_HWVAD_CLR_Msk    (0x01UL << SYSCON_STARTERCLR1_HWVAD_CLR_Pos)          /*!< SYSCON STARTERCLR1: HWVAD_CLR Mask    */
#define SYSCON_STARTERCLR1_BLE_DP_CLR_Pos   5                                                       /*!< SYSCON STARTERCLR1: BLE_DP_CLR Position */
#define SYSCON_STARTERCLR1_BLE_DP_CLR_Msk   (0x01UL << SYSCON_STARTERCLR1_BLE_DP_CLR_Pos)         /*!< SYSCON STARTERCLR1: BLE_DP_CLR Mask   */
#define SYSCON_STARTERCLR1_BLE_DP0_CLR_Pos  6                                                       /*!< SYSCON STARTERCLR1: BLE_DP0_CLR Position */
#define SYSCON_STARTERCLR1_BLE_DP0_CLR_Msk  (0x01UL << SYSCON_STARTERCLR1_BLE_DP0_CLR_Pos)        /*!< SYSCON STARTERCLR1: BLE_DP0_CLR Mask  */
#define SYSCON_STARTERCLR1_BLE_DP1_CLR_Pos  7                                                       /*!< SYSCON STARTERCLR1: BLE_DP1_CLR Position */
#define SYSCON_STARTERCLR1_BLE_DP1_CLR_Msk  (0x01UL << SYSCON_STARTERCLR1_BLE_DP1_CLR_Pos)        /*!< SYSCON STARTERCLR1: BLE_DP1_CLR Mask  */
#define SYSCON_STARTERCLR1_BLE_DP2_CLR_Pos  8                                                       /*!< SYSCON STARTERCLR1: BLE_DP2_CLR Position */
#define SYSCON_STARTERCLR1_BLE_DP2_CLR_Msk  (0x01UL << SYSCON_STARTERCLR1_BLE_DP2_CLR_Pos)        /*!< SYSCON STARTERCLR1: BLE_DP2_CLR Mask  */
#define SYSCON_STARTERCLR1_BLE_LL_ALL_CLR_Pos 9                                                     /*!< SYSCON STARTERCLR1: BLE_LL_ALL_CLR Position */
#define SYSCON_STARTERCLR1_BLE_LL_ALL_CLR_Msk (0x01UL << SYSCON_STARTERCLR1_BLE_LL_ALL_CLR_Pos)   /*!< SYSCON STARTERCLR1: BLE_LL_ALL_CLR Mask */
#define SYSCON_STARTERCLR1_ZIGBEE_MAC_CLR_Pos 10                                                    /*!< SYSCON STARTERCLR1: ZIGBEE_MAC_CLR Position */
#define SYSCON_STARTERCLR1_ZIGBEE_MAC_CLR_Msk (0x01UL << SYSCON_STARTERCLR1_ZIGBEE_MAC_CLR_Pos)   /*!< SYSCON STARTERCLR1: ZIGBEE_MAC_CLR Mask */
#define SYSCON_STARTERCLR1_ZIGBEE_MODEM_CLR_Pos 11                                                  /*!< SYSCON STARTERCLR1: ZIGBEE_MODEM_CLR Position */
#define SYSCON_STARTERCLR1_ZIGBEE_MODEM_CLR_Msk (0x01UL << SYSCON_STARTERCLR1_ZIGBEE_MODEM_CLR_Pos)/*!< SYSCON STARTERCLR1: ZIGBEE_MODEM_CLR Mask */
#define SYSCON_STARTERCLR1_RFP_TMU_CLR_Pos  12                                                      /*!< SYSCON STARTERCLR1: RFP_TMU_CLR Position */
#define SYSCON_STARTERCLR1_RFP_TMU_CLR_Msk  (0x01UL << SYSCON_STARTERCLR1_RFP_TMU_CLR_Pos)        /*!< SYSCON STARTERCLR1: RFP_TMU_CLR Mask  */
#define SYSCON_STARTERCLR1_RFP_AGC_CLR_Pos  13                                                      /*!< SYSCON STARTERCLR1: RFP_AGC_CLR Position */
#define SYSCON_STARTERCLR1_RFP_AGC_CLR_Msk  (0x01UL << SYSCON_STARTERCLR1_RFP_AGC_CLR_Pos)        /*!< SYSCON STARTERCLR1: RFP_AGC_CLR Mask  */
#define SYSCON_STARTERCLR1_ISO7816_CLR_Pos  14                                                      /*!< SYSCON STARTERCLR1: ISO7816_CLR Position */
#define SYSCON_STARTERCLR1_ISO7816_CLR_Msk  (0x01UL << SYSCON_STARTERCLR1_ISO7816_CLR_Pos)        /*!< SYSCON STARTERCLR1: ISO7816_CLR Mask  */
#define SYSCON_STARTERCLR1_ANA_COMP_CLR_Pos 15                                                      /*!< SYSCON STARTERCLR1: ANA_COMP_CLR Position */
#define SYSCON_STARTERCLR1_ANA_COMP_CLR_Msk (0x01UL << SYSCON_STARTERCLR1_ANA_COMP_CLR_Pos)       /*!< SYSCON STARTERCLR1: ANA_COMP_CLR Mask */
#define SYSCON_STARTERCLR1_WAKE_UP_TIMER0_CLR_Pos 16                                                /*!< SYSCON STARTERCLR1: WAKE_UP_TIMER0_CLR Position */
#define SYSCON_STARTERCLR1_WAKE_UP_TIMER0_CLR_Msk (0x01UL << SYSCON_STARTERCLR1_WAKE_UP_TIMER0_CLR_Pos)/*!< SYSCON STARTERCLR1: WAKE_UP_TIMER0_CLR Mask */
#define SYSCON_STARTERCLR1_WAKE_UP_TIMER1_CLR_Pos 17                                                /*!< SYSCON STARTERCLR1: WAKE_UP_TIMER1_CLR Position */
#define SYSCON_STARTERCLR1_WAKE_UP_TIMER1_CLR_Msk (0x01UL << SYSCON_STARTERCLR1_WAKE_UP_TIMER1_CLR_Pos)/*!< SYSCON STARTERCLR1: WAKE_UP_TIMER1_CLR Mask */
#define SYSCON_STARTERCLR1_BLE_WAKE_UP_TIMER_CLR_Pos 22                                             /*!< SYSCON STARTERCLR1: BLE_WAKE_UP_TIMER_CLR Position */
#define SYSCON_STARTERCLR1_BLE_WAKE_UP_TIMER_CLR_Msk (0x01UL << SYSCON_STARTERCLR1_BLE_WAKE_UP_TIMER_CLR_Pos)/*!< SYSCON STARTERCLR1: BLE_WAKE_UP_TIMER_CLR Mask */

/* ---------------------------  u_syscon_RETENTIONCTRL  --------------------------- */
#define SYSCON_RETENTIONCTRL_IOCLAMP_Pos    0                                                       /*!< SYSCON RETENTIONCTRL: IOCLAMP Position */
#define SYSCON_RETENTIONCTRL_IOCLAMP_Msk    (0x01UL << SYSCON_RETENTIONCTRL_IOCLAMP_Pos)          /*!< SYSCON RETENTIONCTRL: IOCLAMP Mask    */

/* --------------------------  u_syscon_POWERDOWNSAFETY  -------------------------- */
#define SYSCON_POWERDOWNSAFETY_OVERRIDEFRO_Pos 0                                                    /*!< SYSCON POWERDOWNSAFETY: OVERRIDEFRO Position */
#define SYSCON_POWERDOWNSAFETY_OVERRIDEFRO_Msk (0x01UL << SYSCON_POWERDOWNSAFETY_OVERRIDEFRO_Pos) /*!< SYSCON POWERDOWNSAFETY: OVERRIDEFRO Mask */

/* ---------------------------  u_syscon_MAINCLKSAFETY  --------------------------- */
#define SYSCON_MAINCLKSAFETY_MAIN_CLK_SAFETY_DEL_Pos 0                                              /*!< SYSCON MAINCLKSAFETY: MAIN_CLK_SAFETY_DEL Position */
#define SYSCON_MAINCLKSAFETY_MAIN_CLK_SAFETY_DEL_Msk (0x0000ffffUL << SYSCON_MAINCLKSAFETY_MAIN_CLK_SAFETY_DEL_Pos)/*!< SYSCON MAINCLKSAFETY: MAIN_CLK_SAFETY_DEL Mask */

/* ---------------------------  u_syscon_HARDWARESLEEP  --------------------------- */
#define SYSCON_HARDWARESLEEP_FORCED_Pos     0                                                       /*!< SYSCON HARDWARESLEEP: FORCED Position */
#define SYSCON_HARDWARESLEEP_FORCED_Msk     (0x01UL << SYSCON_HARDWARESLEEP_FORCED_Pos)           /*!< SYSCON HARDWARESLEEP: FORCED Mask     */
#define SYSCON_HARDWARESLEEP_PERIPHERALS_Pos 1                                                      /*!< SYSCON HARDWARESLEEP: PERIPHERALS Position */
#define SYSCON_HARDWARESLEEP_PERIPHERALS_Msk (0x01UL << SYSCON_HARDWARESLEEP_PERIPHERALS_Pos)     /*!< SYSCON HARDWARESLEEP: PERIPHERALS Mask */
#define SYSCON_HARDWARESLEEP_DMIC_Pos       2                                                       /*!< SYSCON HARDWARESLEEP: DMIC Position   */
#define SYSCON_HARDWARESLEEP_DMIC_Msk       (0x01UL << SYSCON_HARDWARESLEEP_DMIC_Pos)             /*!< SYSCON HARDWARESLEEP: DMIC Mask       */
#define SYSCON_HARDWARESLEEP_SDMA_Pos       3                                                       /*!< SYSCON HARDWARESLEEP: SDMA Position   */
#define SYSCON_HARDWARESLEEP_SDMA_Msk       (0x01UL << SYSCON_HARDWARESLEEP_SDMA_Pos)             /*!< SYSCON HARDWARESLEEP: SDMA Mask       */
#define SYSCON_HARDWARESLEEP_NFCTAG_Pos     4                                                       /*!< SYSCON HARDWARESLEEP: NFCTAG Position */
#define SYSCON_HARDWARESLEEP_NFCTAG_Msk     (0x01UL << SYSCON_HARDWARESLEEP_NFCTAG_Pos)           /*!< SYSCON HARDWARESLEEP: NFCTAG Mask     */
#define SYSCON_HARDWARESLEEP_BLEOSC_Pos     5                                                       /*!< SYSCON HARDWARESLEEP: BLEOSC Position */
#define SYSCON_HARDWARESLEEP_BLEOSC_Msk     (0x01UL << SYSCON_HARDWARESLEEP_BLEOSC_Pos)           /*!< SYSCON HARDWARESLEEP: BLEOSC Mask     */

/* ------------------------------  u_syscon_CPUCTRL  ------------------------------ */
#define SYSCON_CPUCTRL_MASTERCPU_Pos        0                                                       /*!< SYSCON CPUCTRL: MASTERCPU Position    */
#define SYSCON_CPUCTRL_MASTERCPU_Msk        (0x01UL << SYSCON_CPUCTRL_MASTERCPU_Pos)              /*!< SYSCON CPUCTRL: MASTERCPU Mask        */
#define SYSCON_CPUCTRL_CM40CLKEN_Pos        2                                                       /*!< SYSCON CPUCTRL: CM40CLKEN Position    */
#define SYSCON_CPUCTRL_CM40CLKEN_Msk        (0x01UL << SYSCON_CPUCTRL_CM40CLKEN_Pos)              /*!< SYSCON CPUCTRL: CM40CLKEN Mask        */
#define SYSCON_CPUCTRL_CM41CLKEN_Pos        3                                                       /*!< SYSCON CPUCTRL: CM41CLKEN Position    */
#define SYSCON_CPUCTRL_CM41CLKEN_Msk        (0x01UL << SYSCON_CPUCTRL_CM41CLKEN_Pos)              /*!< SYSCON CPUCTRL: CM41CLKEN Mask        */
#define SYSCON_CPUCTRL_CM40RSTEN_Pos        4                                                       /*!< SYSCON CPUCTRL: CM40RSTEN Position    */
#define SYSCON_CPUCTRL_CM40RSTEN_Msk        (0x01UL << SYSCON_CPUCTRL_CM40RSTEN_Pos)              /*!< SYSCON CPUCTRL: CM40RSTEN Mask        */
#define SYSCON_CPUCTRL_CM41RSTEN_Pos        5                                                       /*!< SYSCON CPUCTRL: CM41RSTEN Position    */
#define SYSCON_CPUCTRL_CM41RSTEN_Msk        (0x01UL << SYSCON_CPUCTRL_CM41RSTEN_Pos)              /*!< SYSCON CPUCTRL: CM41RSTEN Mask        */
#define SYSCON_CPUCTRL_POWERCPU_Pos         6                                                       /*!< SYSCON CPUCTRL: POWERCPU Position     */
#define SYSCON_CPUCTRL_POWERCPU_Msk         (0x01UL << SYSCON_CPUCTRL_POWERCPU_Pos)               /*!< SYSCON CPUCTRL: POWERCPU Mask         */
#define SYSCON_CPUCTRL_WAKEUPEVENT_Pos      7                                                       /*!< SYSCON CPUCTRL: WAKEUPEVENT Position  */
#define SYSCON_CPUCTRL_WAKEUPEVENT_Msk      (0x01UL << SYSCON_CPUCTRL_WAKEUPEVENT_Pos)            /*!< SYSCON CPUCTRL: WAKEUPEVENT Mask      */
#define SYSCON_CPUCTRL_CM40SYSRESETEN_Pos   8                                                       /*!< SYSCON CPUCTRL: CM40SYSRESETEN Position */
#define SYSCON_CPUCTRL_CM40SYSRESETEN_Msk   (0x01UL << SYSCON_CPUCTRL_CM40SYSRESETEN_Pos)         /*!< SYSCON CPUCTRL: CM40SYSRESETEN Mask   */
#define SYSCON_CPUCTRL_CM41SYSRESETEN_Pos   9                                                       /*!< SYSCON CPUCTRL: CM41SYSRESETEN Position */
#define SYSCON_CPUCTRL_CM41SYSRESETEN_Msk   (0x01UL << SYSCON_CPUCTRL_CM41SYSRESETEN_Pos)         /*!< SYSCON CPUCTRL: CM41SYSRESETEN Mask   */
#define SYSCON_CPUCTRL_RESERVED1_Pos        15                                                      /*!< SYSCON CPUCTRL: RESERVED1 Position    */
#define SYSCON_CPUCTRL_RESERVED1_Msk        (0x01UL << SYSCON_CPUCTRL_RESERVED1_Pos)              /*!< SYSCON CPUCTRL: RESERVED1 Mask        */
#define SYSCON_CPUCTRL_RESERVEDC0C4_Pos     16                                                      /*!< SYSCON CPUCTRL: RESERVEDC0C4 Position */
#define SYSCON_CPUCTRL_RESERVEDC0C4_Msk     (0x0000ffffUL << SYSCON_CPUCTRL_RESERVEDC0C4_Pos)     /*!< SYSCON CPUCTRL: RESERVEDC0C4 Mask     */

/* -------------------------------  u_syscon_CPBOOT  ------------------------------ */
#define SYSCON_CPBOOT_CPBOOT_Pos            0                                                       /*!< SYSCON CPBOOT: CPBOOT Position        */
#define SYSCON_CPBOOT_CPBOOT_Msk            (0xffffffffUL << SYSCON_CPBOOT_CPBOOT_Pos)            /*!< SYSCON CPBOOT: CPBOOT Mask            */

/* ------------------------------  u_syscon_CPSTACK  ------------------------------ */
#define SYSCON_CPSTACK_CPSTACK_Pos          0                                                       /*!< SYSCON CPSTACK: CPSTACK Position      */
#define SYSCON_CPSTACK_CPSTACK_Msk          (0xffffffffUL << SYSCON_CPSTACK_CPSTACK_Pos)          /*!< SYSCON CPSTACK: CPSTACK Mask          */

/* -------------------------------  u_syscon_CPSTAT  ------------------------------ */
#define SYSCON_CPSTAT_CM40SLEEPING_Pos      0                                                       /*!< SYSCON CPSTAT: CM40SLEEPING Position  */
#define SYSCON_CPSTAT_CM40SLEEPING_Msk      (0x01UL << SYSCON_CPSTAT_CM40SLEEPING_Pos)            /*!< SYSCON CPSTAT: CM40SLEEPING Mask      */
#define SYSCON_CPSTAT_CM41SLEEPING_Pos      1                                                       /*!< SYSCON CPSTAT: CM41SLEEPING Position  */
#define SYSCON_CPSTAT_CM41SLEEPING_Msk      (0x01UL << SYSCON_CPSTAT_CM41SLEEPING_Pos)            /*!< SYSCON CPSTAT: CM41SLEEPING Mask      */
#define SYSCON_CPSTAT_CM40LOCKUP_Pos        2                                                       /*!< SYSCON CPSTAT: CM40LOCKUP Position    */
#define SYSCON_CPSTAT_CM40LOCKUP_Msk        (0x01UL << SYSCON_CPSTAT_CM40LOCKUP_Pos)              /*!< SYSCON CPSTAT: CM40LOCKUP Mask        */
#define SYSCON_CPSTAT_CM41LOCKUP_Pos        3                                                       /*!< SYSCON CPSTAT: CM41LOCKUP Position    */
#define SYSCON_CPSTAT_CM41LOCKUP_Msk        (0x01UL << SYSCON_CPSTAT_CM41LOCKUP_Pos)              /*!< SYSCON CPSTAT: CM41LOCKUP Mask        */

/* -----------------------------  u_syscon_GPIOSECIN  ----------------------------- */
#define SYSCON_GPIOSECIN_GPIOSECIN_Pos      0                                                       /*!< SYSCON GPIOSECIN: GPIOSECIN Position  */
#define SYSCON_GPIOSECIN_GPIOSECIN_Msk      (0xffffffffUL << SYSCON_GPIOSECIN_GPIOSECIN_Pos)      /*!< SYSCON GPIOSECIN: GPIOSECIN Mask      */

/* -----------------------------  u_syscon_GPIOSECOUT  ---------------------------- */
#define SYSCON_GPIOSECOUT_GPIOSECOUT_Pos    0                                                       /*!< SYSCON GPIOSECOUT: GPIOSECOUT Position */
#define SYSCON_GPIOSECOUT_GPIOSECOUT_Msk    (0xffffffffUL << SYSCON_GPIOSECOUT_GPIOSECOUT_Pos)    /*!< SYSCON GPIOSECOUT: GPIOSECOUT Mask    */

/* -----------------------------  u_syscon_GPIOSECDIR  ---------------------------- */
#define SYSCON_GPIOSECDIR_GPIOSECDIR_Pos    0                                                       /*!< SYSCON GPIOSECDIR: GPIOSECDIR Position */
#define SYSCON_GPIOSECDIR_GPIOSECDIR_Msk    (0xffffffffUL << SYSCON_GPIOSECDIR_GPIOSECDIR_Pos)    /*!< SYSCON GPIOSECDIR: GPIOSECDIR Mask    */

/* ----------------------------  u_syscon_ANACTRL_CTRL  --------------------------- */
#define SYSCON_ANACTRL_CTRL_COMPINTRLVL_Pos 0                                                       /*!< SYSCON ANACTRL_CTRL: COMPINTRLVL Position */
#define SYSCON_ANACTRL_CTRL_COMPINTRLVL_Msk (0x01UL << SYSCON_ANACTRL_CTRL_COMPINTRLVL_Pos)       /*!< SYSCON ANACTRL_CTRL: COMPINTRLVL Mask */
#define SYSCON_ANACTRL_CTRL_COMPINTRPOL_Pos 1                                                       /*!< SYSCON ANACTRL_CTRL: COMPINTRPOL Position */
#define SYSCON_ANACTRL_CTRL_COMPINTRPOL_Msk (0x03UL << SYSCON_ANACTRL_CTRL_COMPINTRPOL_Pos)       /*!< SYSCON ANACTRL_CTRL: COMPINTRPOL Mask */

/* ----------------------------  u_syscon_ANACTRL_VAL  ---------------------------- */
#define SYSCON_ANACTRL_VAL_BODVBAT_Pos      0                                                       /*!< SYSCON ANACTRL_VAL: BODVBAT Position  */
#define SYSCON_ANACTRL_VAL_BODVBAT_Msk      (0x01UL << SYSCON_ANACTRL_VAL_BODVBAT_Pos)            /*!< SYSCON ANACTRL_VAL: BODVBAT Mask      */
#define SYSCON_ANACTRL_VAL_BODMEM_Pos       1                                                       /*!< SYSCON ANACTRL_VAL: BODMEM Position   */
#define SYSCON_ANACTRL_VAL_BODMEM_Msk       (0x01UL << SYSCON_ANACTRL_VAL_BODMEM_Pos)             /*!< SYSCON ANACTRL_VAL: BODMEM Mask       */
#define SYSCON_ANACTRL_VAL_BODCORE_Pos      2                                                       /*!< SYSCON ANACTRL_VAL: BODCORE Position  */
#define SYSCON_ANACTRL_VAL_BODCORE_Msk      (0x01UL << SYSCON_ANACTRL_VAL_BODCORE_Pos)            /*!< SYSCON ANACTRL_VAL: BODCORE Mask      */
#define SYSCON_ANACTRL_VAL_ANACOMP_Pos      3                                                       /*!< SYSCON ANACTRL_VAL: ANACOMP Position  */
#define SYSCON_ANACTRL_VAL_ANACOMP_Msk      (0x01UL << SYSCON_ANACTRL_VAL_ANACOMP_Pos)            /*!< SYSCON ANACTRL_VAL: ANACOMP Mask      */
#define SYSCON_ANACTRL_VAL_BODVBATHIGH_Pos  4                                                       /*!< SYSCON ANACTRL_VAL: BODVBATHIGH Position */
#define SYSCON_ANACTRL_VAL_BODVBATHIGH_Msk  (0x01UL << SYSCON_ANACTRL_VAL_BODVBATHIGH_Pos)        /*!< SYSCON ANACTRL_VAL: BODVBATHIGH Mask  */

/* ----------------------------  u_syscon_ANACTRL_STAT  --------------------------- */
#define SYSCON_ANACTRL_STAT_BODVBAT_Pos     0                                                       /*!< SYSCON ANACTRL_STAT: BODVBAT Position */
#define SYSCON_ANACTRL_STAT_BODVBAT_Msk     (0x01UL << SYSCON_ANACTRL_STAT_BODVBAT_Pos)           /*!< SYSCON ANACTRL_STAT: BODVBAT Mask     */
#define SYSCON_ANACTRL_STAT_BODMEM_Pos      1                                                       /*!< SYSCON ANACTRL_STAT: BODMEM Position  */
#define SYSCON_ANACTRL_STAT_BODMEM_Msk      (0x01UL << SYSCON_ANACTRL_STAT_BODMEM_Pos)            /*!< SYSCON ANACTRL_STAT: BODMEM Mask      */
#define SYSCON_ANACTRL_STAT_BODCORE_Pos     2                                                       /*!< SYSCON ANACTRL_STAT: BODCORE Position */
#define SYSCON_ANACTRL_STAT_BODCORE_Msk     (0x01UL << SYSCON_ANACTRL_STAT_BODCORE_Pos)           /*!< SYSCON ANACTRL_STAT: BODCORE Mask     */
#define SYSCON_ANACTRL_STAT_ANACOMP_Pos     3                                                       /*!< SYSCON ANACTRL_STAT: ANACOMP Position */
#define SYSCON_ANACTRL_STAT_ANACOMP_Msk     (0x01UL << SYSCON_ANACTRL_STAT_ANACOMP_Pos)           /*!< SYSCON ANACTRL_STAT: ANACOMP Mask     */
#define SYSCON_ANACTRL_STAT_BODVBATHIGH_Pos 4                                                       /*!< SYSCON ANACTRL_STAT: BODVBATHIGH Position */
#define SYSCON_ANACTRL_STAT_BODVBATHIGH_Msk (0x01UL << SYSCON_ANACTRL_STAT_BODVBATHIGH_Pos)       /*!< SYSCON ANACTRL_STAT: BODVBATHIGH Mask */

/* --------------------------  u_syscon_ANACTRL_INTENSET  ------------------------- */
#define SYSCON_ANACTRL_INTENSET_BODVBAT_Pos 0                                                       /*!< SYSCON ANACTRL_INTENSET: BODVBAT Position */
#define SYSCON_ANACTRL_INTENSET_BODVBAT_Msk (0x01UL << SYSCON_ANACTRL_INTENSET_BODVBAT_Pos)       /*!< SYSCON ANACTRL_INTENSET: BODVBAT Mask */
#define SYSCON_ANACTRL_INTENSET_BODMEM_Pos  1                                                       /*!< SYSCON ANACTRL_INTENSET: BODMEM Position */
#define SYSCON_ANACTRL_INTENSET_BODMEM_Msk  (0x01UL << SYSCON_ANACTRL_INTENSET_BODMEM_Pos)        /*!< SYSCON ANACTRL_INTENSET: BODMEM Mask  */
#define SYSCON_ANACTRL_INTENSET_BODCORE_Pos 2                                                       /*!< SYSCON ANACTRL_INTENSET: BODCORE Position */
#define SYSCON_ANACTRL_INTENSET_BODCORE_Msk (0x01UL << SYSCON_ANACTRL_INTENSET_BODCORE_Pos)       /*!< SYSCON ANACTRL_INTENSET: BODCORE Mask */
#define SYSCON_ANACTRL_INTENSET_ANACOMP_Pos 3                                                       /*!< SYSCON ANACTRL_INTENSET: ANACOMP Position */
#define SYSCON_ANACTRL_INTENSET_ANACOMP_Msk (0x01UL << SYSCON_ANACTRL_INTENSET_ANACOMP_Pos)       /*!< SYSCON ANACTRL_INTENSET: ANACOMP Mask */
#define SYSCON_ANACTRL_INTENSET_BODVBATHIGH_Pos 4                                                   /*!< SYSCON ANACTRL_INTENSET: BODVBATHIGH Position */
#define SYSCON_ANACTRL_INTENSET_BODVBATHIGH_Msk (0x01UL << SYSCON_ANACTRL_INTENSET_BODVBATHIGH_Pos)/*!< SYSCON ANACTRL_INTENSET: BODVBATHIGH Mask */

/* --------------------------  u_syscon_ANACTRL_INTENCLR  ------------------------- */
#define SYSCON_ANACTRL_INTENCLR_BODVBAT_Pos 0                                                       /*!< SYSCON ANACTRL_INTENCLR: BODVBAT Position */
#define SYSCON_ANACTRL_INTENCLR_BODVBAT_Msk (0x01UL << SYSCON_ANACTRL_INTENCLR_BODVBAT_Pos)       /*!< SYSCON ANACTRL_INTENCLR: BODVBAT Mask */
#define SYSCON_ANACTRL_INTENCLR_BODMEM_Pos  1                                                       /*!< SYSCON ANACTRL_INTENCLR: BODMEM Position */
#define SYSCON_ANACTRL_INTENCLR_BODMEM_Msk  (0x01UL << SYSCON_ANACTRL_INTENCLR_BODMEM_Pos)        /*!< SYSCON ANACTRL_INTENCLR: BODMEM Mask  */
#define SYSCON_ANACTRL_INTENCLR_BODCORE_Pos 2                                                       /*!< SYSCON ANACTRL_INTENCLR: BODCORE Position */
#define SYSCON_ANACTRL_INTENCLR_BODCORE_Msk (0x01UL << SYSCON_ANACTRL_INTENCLR_BODCORE_Pos)       /*!< SYSCON ANACTRL_INTENCLR: BODCORE Mask */
#define SYSCON_ANACTRL_INTENCLR_ANACOMP_Pos 3                                                       /*!< SYSCON ANACTRL_INTENCLR: ANACOMP Position */
#define SYSCON_ANACTRL_INTENCLR_ANACOMP_Msk (0x01UL << SYSCON_ANACTRL_INTENCLR_ANACOMP_Pos)       /*!< SYSCON ANACTRL_INTENCLR: ANACOMP Mask */
#define SYSCON_ANACTRL_INTENCLR_BODVBATHIGH_Pos 4                                                   /*!< SYSCON ANACTRL_INTENCLR: BODVBATHIGH Position */
#define SYSCON_ANACTRL_INTENCLR_BODVBATHIGH_Msk (0x01UL << SYSCON_ANACTRL_INTENCLR_BODVBATHIGH_Pos)/*!< SYSCON ANACTRL_INTENCLR: BODVBATHIGH Mask */

/* --------------------------  u_syscon_ANACTRL_INTSTAT  -------------------------- */
#define SYSCON_ANACTRL_INTSTAT_BODVBAT_Pos  0                                                       /*!< SYSCON ANACTRL_INTSTAT: BODVBAT Position */
#define SYSCON_ANACTRL_INTSTAT_BODVBAT_Msk  (0x01UL << SYSCON_ANACTRL_INTSTAT_BODVBAT_Pos)        /*!< SYSCON ANACTRL_INTSTAT: BODVBAT Mask  */
#define SYSCON_ANACTRL_INTSTAT_BODMEM_Pos   1                                                       /*!< SYSCON ANACTRL_INTSTAT: BODMEM Position */
#define SYSCON_ANACTRL_INTSTAT_BODMEM_Msk   (0x01UL << SYSCON_ANACTRL_INTSTAT_BODMEM_Pos)         /*!< SYSCON ANACTRL_INTSTAT: BODMEM Mask   */
#define SYSCON_ANACTRL_INTSTAT_BODCORE_Pos  2                                                       /*!< SYSCON ANACTRL_INTSTAT: BODCORE Position */
#define SYSCON_ANACTRL_INTSTAT_BODCORE_Msk  (0x01UL << SYSCON_ANACTRL_INTSTAT_BODCORE_Pos)        /*!< SYSCON ANACTRL_INTSTAT: BODCORE Mask  */
#define SYSCON_ANACTRL_INTSTAT_ANACOMP_Pos  3                                                       /*!< SYSCON ANACTRL_INTSTAT: ANACOMP Position */
#define SYSCON_ANACTRL_INTSTAT_ANACOMP_Msk  (0x01UL << SYSCON_ANACTRL_INTSTAT_ANACOMP_Pos)        /*!< SYSCON ANACTRL_INTSTAT: ANACOMP Mask  */
#define SYSCON_ANACTRL_INTSTAT_BODVBATHIGH_Pos 4                                                    /*!< SYSCON ANACTRL_INTSTAT: BODVBATHIGH Position */
#define SYSCON_ANACTRL_INTSTAT_BODVBATHIGH_Msk (0x01UL << SYSCON_ANACTRL_INTSTAT_BODVBATHIGH_Pos) /*!< SYSCON ANACTRL_INTSTAT: BODVBATHIGH Mask */

/* -----------------------------  u_syscon_CLOCK_CTRL  ---------------------------- */
#define SYSCON_CLOCK_CTRL_FLASH48MHZ_ENA_Pos 0                                                      /*!< SYSCON CLOCK_CTRL: FLASH48MHZ_ENA Position */
#define SYSCON_CLOCK_CTRL_FLASH48MHZ_ENA_Msk (0x01UL << SYSCON_CLOCK_CTRL_FLASH48MHZ_ENA_Pos)     /*!< SYSCON CLOCK_CTRL: FLASH48MHZ_ENA Mask */
#define SYSCON_CLOCK_CTRL_XTAL32MHZ_FREQM_ENA_Pos 1                                                 /*!< SYSCON CLOCK_CTRL: XTAL32MHZ_FREQM_ENA Position */
#define SYSCON_CLOCK_CTRL_XTAL32MHZ_FREQM_ENA_Msk (0x01UL << SYSCON_CLOCK_CTRL_XTAL32MHZ_FREQM_ENA_Pos)/*!< SYSCON CLOCK_CTRL: XTAL32MHZ_FREQM_ENA Mask */
#define SYSCON_CLOCK_CTRL_FRO1MHZ_FREQM_ENA_Pos 2                                                   /*!< SYSCON CLOCK_CTRL: FRO1MHZ_FREQM_ENA Position */
#define SYSCON_CLOCK_CTRL_FRO1MHZ_FREQM_ENA_Msk (0x01UL << SYSCON_CLOCK_CTRL_FRO1MHZ_FREQM_ENA_Pos)/*!< SYSCON CLOCK_CTRL: FRO1MHZ_FREQM_ENA Mask */

/* ------------------------------  u_syscon_WKT_CTRL  ----------------------------- */
#define SYSCON_WKT_CTRL_WKT0_ENA_Pos        0                                                       /*!< SYSCON WKT_CTRL: WKT0_ENA Position    */
#define SYSCON_WKT_CTRL_WKT0_ENA_Msk        (0x01UL << SYSCON_WKT_CTRL_WKT0_ENA_Pos)              /*!< SYSCON WKT_CTRL: WKT0_ENA Mask        */
#define SYSCON_WKT_CTRL_WKT1_ENA_Pos        1                                                       /*!< SYSCON WKT_CTRL: WKT1_ENA Position    */
#define SYSCON_WKT_CTRL_WKT1_ENA_Msk        (0x01UL << SYSCON_WKT_CTRL_WKT1_ENA_Pos)              /*!< SYSCON WKT_CTRL: WKT1_ENA Mask        */
#define SYSCON_WKT_CTRL_WKT0_CLK_ENA_Pos    2                                                       /*!< SYSCON WKT_CTRL: WKT0_CLK_ENA Position */
#define SYSCON_WKT_CTRL_WKT0_CLK_ENA_Msk    (0x01UL << SYSCON_WKT_CTRL_WKT0_CLK_ENA_Pos)          /*!< SYSCON WKT_CTRL: WKT0_CLK_ENA Mask    */
#define SYSCON_WKT_CTRL_WKT1_CLK_ENA_Pos    3                                                       /*!< SYSCON WKT_CTRL: WKT1_CLK_ENA Position */
#define SYSCON_WKT_CTRL_WKT1_CLK_ENA_Msk    (0x01UL << SYSCON_WKT_CTRL_WKT1_CLK_ENA_Pos)          /*!< SYSCON WKT_CTRL: WKT1_CLK_ENA Mask    */

/* -------------------------  u_syscon_WKT_LOAD_WKT0_LSB  ------------------------- */
#define SYSCON_WKT_LOAD_WKT0_LSB_WKT0_LOAD_LSB_Pos 0                                                /*!< SYSCON WKT_LOAD_WKT0_LSB: WKT0_LOAD_LSB Position */
#define SYSCON_WKT_LOAD_WKT0_LSB_WKT0_LOAD_LSB_Msk (0xffffffffUL << SYSCON_WKT_LOAD_WKT0_LSB_WKT0_LOAD_LSB_Pos)/*!< SYSCON WKT_LOAD_WKT0_LSB: WKT0_LOAD_LSB Mask */

/* -------------------------  u_syscon_WKT_LOAD_WKT0_MSB  ------------------------- */
#define SYSCON_WKT_LOAD_WKT0_MSB_WKT0_LOAD_MSB_Pos 0                                                /*!< SYSCON WKT_LOAD_WKT0_MSB: WKT0_LOAD_MSB Position */
#define SYSCON_WKT_LOAD_WKT0_MSB_WKT0_LOAD_MSB_Msk (0x000001ffUL << SYSCON_WKT_LOAD_WKT0_MSB_WKT0_LOAD_MSB_Pos)/*!< SYSCON WKT_LOAD_WKT0_MSB: WKT0_LOAD_MSB Mask */

/* ---------------------------  u_syscon_WKT_LOAD_WKT1  --------------------------- */
#define SYSCON_WKT_LOAD_WKT1_WKT1_LOAD_Pos  0                                                       /*!< SYSCON WKT_LOAD_WKT1: WKT1_LOAD Position */
#define SYSCON_WKT_LOAD_WKT1_WKT1_LOAD_Msk  (0x0fffffffUL << SYSCON_WKT_LOAD_WKT1_WKT1_LOAD_Pos)  /*!< SYSCON WKT_LOAD_WKT1: WKT1_LOAD Mask  */

/* --------------------------  u_syscon_WKT_VAL_WKT0_LSB  ------------------------- */
#define SYSCON_WKT_VAL_WKT0_LSB_WKT0_VAL_LSB_Pos 0                                                  /*!< SYSCON WKT_VAL_WKT0_LSB: WKT0_VAL_LSB Position */
#define SYSCON_WKT_VAL_WKT0_LSB_WKT0_VAL_LSB_Msk (0xffffffffUL << SYSCON_WKT_VAL_WKT0_LSB_WKT0_VAL_LSB_Pos)/*!< SYSCON WKT_VAL_WKT0_LSB: WKT0_VAL_LSB Mask */

/* --------------------------  u_syscon_WKT_VAL_WKT0_MSB  ------------------------- */
#define SYSCON_WKT_VAL_WKT0_MSB_WKT0_VAL_MSB_Pos 0                                                  /*!< SYSCON WKT_VAL_WKT0_MSB: WKT0_VAL_MSB Position */
#define SYSCON_WKT_VAL_WKT0_MSB_WKT0_VAL_MSB_Msk (0x000001ffUL << SYSCON_WKT_VAL_WKT0_MSB_WKT0_VAL_MSB_Pos)/*!< SYSCON WKT_VAL_WKT0_MSB: WKT0_VAL_MSB Mask */

/* ----------------------------  u_syscon_WKT_VAL_WKT1  --------------------------- */
#define SYSCON_WKT_VAL_WKT1_WKT1_VAL_Pos    0                                                       /*!< SYSCON WKT_VAL_WKT1: WKT1_VAL Position */
#define SYSCON_WKT_VAL_WKT1_WKT1_VAL_Msk    (0x0fffffffUL << SYSCON_WKT_VAL_WKT1_WKT1_VAL_Pos)    /*!< SYSCON WKT_VAL_WKT1: WKT1_VAL Mask    */

/* ------------------------------  u_syscon_WKT_STAT  ----------------------------- */
#define SYSCON_WKT_STAT_WKT0_TIMEOUT_Pos    0                                                       /*!< SYSCON WKT_STAT: WKT0_TIMEOUT Position */
#define SYSCON_WKT_STAT_WKT0_TIMEOUT_Msk    (0x01UL << SYSCON_WKT_STAT_WKT0_TIMEOUT_Pos)          /*!< SYSCON WKT_STAT: WKT0_TIMEOUT Mask    */
#define SYSCON_WKT_STAT_WKT1_TIMEOUT_Pos    1                                                       /*!< SYSCON WKT_STAT: WKT1_TIMEOUT Position */
#define SYSCON_WKT_STAT_WKT1_TIMEOUT_Msk    (0x01UL << SYSCON_WKT_STAT_WKT1_TIMEOUT_Pos)          /*!< SYSCON WKT_STAT: WKT1_TIMEOUT Mask    */
#define SYSCON_WKT_STAT_WKT0_RUNNING_Pos    2                                                       /*!< SYSCON WKT_STAT: WKT0_RUNNING Position */
#define SYSCON_WKT_STAT_WKT0_RUNNING_Msk    (0x01UL << SYSCON_WKT_STAT_WKT0_RUNNING_Pos)          /*!< SYSCON WKT_STAT: WKT0_RUNNING Mask    */
#define SYSCON_WKT_STAT_WKT1_RUNNING_Pos    3                                                       /*!< SYSCON WKT_STAT: WKT1_RUNNING Position */
#define SYSCON_WKT_STAT_WKT1_RUNNING_Msk    (0x01UL << SYSCON_WKT_STAT_WKT1_RUNNING_Pos)          /*!< SYSCON WKT_STAT: WKT1_RUNNING Mask    */

/* ----------------------------  u_syscon_WKT_INTENSET  --------------------------- */
#define SYSCON_WKT_INTENSET_WKT0_TIMEOUT_Pos 0                                                      /*!< SYSCON WKT_INTENSET: WKT0_TIMEOUT Position */
#define SYSCON_WKT_INTENSET_WKT0_TIMEOUT_Msk (0x01UL << SYSCON_WKT_INTENSET_WKT0_TIMEOUT_Pos)     /*!< SYSCON WKT_INTENSET: WKT0_TIMEOUT Mask */
#define SYSCON_WKT_INTENSET_WKT1_TIMEOUT_Pos 1                                                      /*!< SYSCON WKT_INTENSET: WKT1_TIMEOUT Position */
#define SYSCON_WKT_INTENSET_WKT1_TIMEOUT_Msk (0x01UL << SYSCON_WKT_INTENSET_WKT1_TIMEOUT_Pos)     /*!< SYSCON WKT_INTENSET: WKT1_TIMEOUT Mask */

/* ----------------------------  u_syscon_WKT_INTENCLR  --------------------------- */
#define SYSCON_WKT_INTENCLR_WKT0_TIMEOUT_Pos 0                                                      /*!< SYSCON WKT_INTENCLR: WKT0_TIMEOUT Position */
#define SYSCON_WKT_INTENCLR_WKT0_TIMEOUT_Msk (0x01UL << SYSCON_WKT_INTENCLR_WKT0_TIMEOUT_Pos)     /*!< SYSCON WKT_INTENCLR: WKT0_TIMEOUT Mask */
#define SYSCON_WKT_INTENCLR_WKT1_TIMEOUT_Pos 1                                                      /*!< SYSCON WKT_INTENCLR: WKT1_TIMEOUT Position */
#define SYSCON_WKT_INTENCLR_WKT1_TIMEOUT_Msk (0x01UL << SYSCON_WKT_INTENCLR_WKT1_TIMEOUT_Pos)     /*!< SYSCON WKT_INTENCLR: WKT1_TIMEOUT Mask */

/* ----------------------------  u_syscon_WKT_INTSTAT  ---------------------------- */
#define SYSCON_WKT_INTSTAT_WKT0_TIMEOUT_Pos 0                                                       /*!< SYSCON WKT_INTSTAT: WKT0_TIMEOUT Position */
#define SYSCON_WKT_INTSTAT_WKT0_TIMEOUT_Msk (0x01UL << SYSCON_WKT_INTSTAT_WKT0_TIMEOUT_Pos)       /*!< SYSCON WKT_INTSTAT: WKT0_TIMEOUT Mask */
#define SYSCON_WKT_INTSTAT_WKT1_TIMEOUT_Pos 1                                                       /*!< SYSCON WKT_INTSTAT: WKT1_TIMEOUT Position */
#define SYSCON_WKT_INTSTAT_WKT1_TIMEOUT_Msk (0x01UL << SYSCON_WKT_INTSTAT_WKT1_TIMEOUT_Pos)       /*!< SYSCON WKT_INTSTAT: WKT1_TIMEOUT Mask */

/* ------------------------  u_syscon_AUTOCLKGATEOVERRIDE  ------------------------ */
#define SYSCON_AUTOCLKGATEOVERRIDE_ROM_Pos  0                                                       /*!< SYSCON AUTOCLKGATEOVERRIDE: ROM Position */
#define SYSCON_AUTOCLKGATEOVERRIDE_ROM_Msk  (0x01UL << SYSCON_AUTOCLKGATEOVERRIDE_ROM_Pos)        /*!< SYSCON AUTOCLKGATEOVERRIDE: ROM Mask  */
#define SYSCON_AUTOCLKGATEOVERRIDE_SRAM_CTRL0_Pos 1                                                 /*!< SYSCON AUTOCLKGATEOVERRIDE: SRAM_CTRL0 Position */
#define SYSCON_AUTOCLKGATEOVERRIDE_SRAM_CTRL0_Msk (0x01UL << SYSCON_AUTOCLKGATEOVERRIDE_SRAM_CTRL0_Pos)/*!< SYSCON AUTOCLKGATEOVERRIDE: SRAM_CTRL0 Mask */
#define SYSCON_AUTOCLKGATEOVERRIDE_SRAM_CTRL1_Pos 2                                                 /*!< SYSCON AUTOCLKGATEOVERRIDE: SRAM_CTRL1 Position */
#define SYSCON_AUTOCLKGATEOVERRIDE_SRAM_CTRL1_Msk (0x01UL << SYSCON_AUTOCLKGATEOVERRIDE_SRAM_CTRL1_Pos)/*!< SYSCON AUTOCLKGATEOVERRIDE: SRAM_CTRL1 Mask */
#define SYSCON_AUTOCLKGATEOVERRIDE_SYNC_APB_Pos 5                                                   /*!< SYSCON AUTOCLKGATEOVERRIDE: SYNC_APB Position */
#define SYSCON_AUTOCLKGATEOVERRIDE_SYNC_APB_Msk (0x01UL << SYSCON_AUTOCLKGATEOVERRIDE_SYNC_APB_Pos)/*!< SYSCON AUTOCLKGATEOVERRIDE: SYNC_APB Mask */
#define SYSCON_AUTOCLKGATEOVERRIDE_ASYNC_APB_Pos 6                                                  /*!< SYSCON AUTOCLKGATEOVERRIDE: ASYNC_APB Position */
#define SYSCON_AUTOCLKGATEOVERRIDE_ASYNC_APB_Msk (0x01UL << SYSCON_AUTOCLKGATEOVERRIDE_ASYNC_APB_Pos)/*!< SYSCON AUTOCLKGATEOVERRIDE: ASYNC_APB Mask */
#define SYSCON_AUTOCLKGATEOVERRIDE_SDMA_Pos 13                                                      /*!< SYSCON AUTOCLKGATEOVERRIDE: SDMA Position */
#define SYSCON_AUTOCLKGATEOVERRIDE_SDMA_Msk (0x01UL << SYSCON_AUTOCLKGATEOVERRIDE_SDMA_Pos)       /*!< SYSCON AUTOCLKGATEOVERRIDE: SDMA Mask */
#define SYSCON_AUTOCLKGATEOVERRIDE_SYSCON_Pos 15                                                    /*!< SYSCON AUTOCLKGATEOVERRIDE: SYSCON Position */
#define SYSCON_AUTOCLKGATEOVERRIDE_SYSCON_Msk (0x01UL << SYSCON_AUTOCLKGATEOVERRIDE_SYSCON_Pos)   /*!< SYSCON AUTOCLKGATEOVERRIDE: SYSCON Mask */
#define SYSCON_AUTOCLKGATEOVERRIDE_ENABLEUPDATE_Pos 16                                              /*!< SYSCON AUTOCLKGATEOVERRIDE: ENABLEUPDATE Position */
#define SYSCON_AUTOCLKGATEOVERRIDE_ENABLEUPDATE_Msk (0x0000ffffUL << SYSCON_AUTOCLKGATEOVERRIDE_ENABLEUPDATE_Pos)/*!< SYSCON AUTOCLKGATEOVERRIDE: ENABLEUPDATE Mask */

/* -----------------------------  u_syscon_GPIOPSYNC  ----------------------------- */
#define SYSCON_GPIOPSYNC_PSYNC_Pos          0                                                       /*!< SYSCON GPIOPSYNC: PSYNC Position      */
#define SYSCON_GPIOPSYNC_PSYNC_Msk          (0x01UL << SYSCON_GPIOPSYNC_PSYNC_Pos)                /*!< SYSCON GPIOPSYNC: PSYNC Mask          */

/* ---------------------------  u_syscon_INVERTMAINCLK  --------------------------- */
#define SYSCON_INVERTMAINCLK_INVERT_Pos     0                                                       /*!< SYSCON INVERTMAINCLK: INVERT Position */
#define SYSCON_INVERTMAINCLK_INVERT_Msk     (0x01UL << SYSCON_INVERTMAINCLK_INVERT_Pos)           /*!< SYSCON INVERTMAINCLK: INVERT Mask     */

/* -------------------------------  u_syscon_DIEID  ------------------------------- */
#define SYSCON_DIEID_REV_ID_Pos             0                                                       /*!< SYSCON DIEID: REV_ID Position         */
#define SYSCON_DIEID_REV_ID_Msk             (0x0fUL << SYSCON_DIEID_REV_ID_Pos)                   /*!< SYSCON DIEID: REV_ID Mask             */
#define SYSCON_DIEID_MCO_NUM_IN_DIE_ID_Pos  4                                                       /*!< SYSCON DIEID: MCO_NUM_IN_DIE_ID Position */
#define SYSCON_DIEID_MCO_NUM_IN_DIE_ID_Msk  (0x000fffffUL << SYSCON_DIEID_MCO_NUM_IN_DIE_ID_Pos)  /*!< SYSCON DIEID: MCO_NUM_IN_DIE_ID Mask  */

/* -------------------------------  u_syscon_CPUCFG  ------------------------------ */
#define SYSCON_CPUCFG_DEFAULT_Pos           0                                                       /*!< SYSCON CPUCFG: DEFAULT Position       */
#define SYSCON_CPUCFG_DEFAULT_Msk           (0x01UL << SYSCON_CPUCFG_DEFAULT_Pos)                 /*!< SYSCON CPUCFG: DEFAULT Mask           */
#define SYSCON_CPUCFG_CM40ENABLE_Pos        1                                                       /*!< SYSCON CPUCFG: CM40ENABLE Position    */
#define SYSCON_CPUCFG_CM40ENABLE_Msk        (0x01UL << SYSCON_CPUCFG_CM40ENABLE_Pos)              /*!< SYSCON CPUCFG: CM40ENABLE Mask        */
#define SYSCON_CPUCFG_CM41ENABLE_Pos        2                                                       /*!< SYSCON CPUCFG: CM41ENABLE Position    */
#define SYSCON_CPUCFG_CM41ENABLE_Msk        (0x01UL << SYSCON_CPUCFG_CM41ENABLE_Pos)              /*!< SYSCON CPUCFG: CM41ENABLE Mask        */

/* ---------------------------  u_syscon_CONFIGLOCKOUT  --------------------------- */
#define SYSCON_CONFIGLOCKOUT_LOCK_Pos       0                                                       /*!< SYSCON CONFIGLOCKOUT: LOCK Position   */
#define SYSCON_CONFIGLOCKOUT_LOCK_Msk       (0x01UL << SYSCON_CONFIGLOCKOUT_LOCK_Pos)             /*!< SYSCON CONFIGLOCKOUT: LOCK Mask       */

/* --------------------------  u_syscon_CODESECURITYPROT  ------------------------- */
#define SYSCON_CODESECURITYPROT_SEC_CODE_Pos 0                                                      /*!< SYSCON CODESECURITYPROT: SEC_CODE Position */
#define SYSCON_CODESECURITYPROT_SEC_CODE_Msk (0xffffffffUL << SYSCON_CODESECURITYPROT_SEC_CODE_Pos)/*!< SYSCON CODESECURITYPROT: SEC_CODE Mask */


/* ================================================================================ */
/* ================         struct 'u_otpc' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u_otpc_ADDR  -------------------------------- */
#define OTPC_ADDR_ADDR_Pos                  0                                                       /*!< OTPC ADDR: ADDR Position              */
#define OTPC_ADDR_ADDR_Msk                  (0x00000fffUL << OTPC_ADDR_ADDR_Pos)                  /*!< OTPC ADDR: ADDR Mask                  */

/* ---------------------------------  u_otpc_READ  -------------------------------- */
#define OTPC_READ_READ_Pos                  0                                                       /*!< OTPC READ: READ Position              */
#define OTPC_READ_READ_Msk                  (0x01UL << OTPC_READ_READ_Pos)                        /*!< OTPC READ: READ Mask                  */
#define OTPC_READ_SEQ_Pos                   16                                                      /*!< OTPC READ: SEQ Position               */
#define OTPC_READ_SEQ_Msk                   (0x0000ffffUL << OTPC_READ_SEQ_Pos)                   /*!< OTPC READ: SEQ Mask                   */

/* --------------------------------  u_otpc_RWIDTH  ------------------------------- */
#define OTPC_RWIDTH_OPCFG_Pos               0                                                       /*!< OTPC RWIDTH: OPCFG Position           */
#define OTPC_RWIDTH_OPCFG_Msk               (0x03UL << OTPC_RWIDTH_OPCFG_Pos)                     /*!< OTPC RWIDTH: OPCFG Mask               */

/* --------------------------------  u_otpc_HV_REQ  ------------------------------- */
#define OTPC_HV_REQ_PMC_REQ_Pos             0                                                       /*!< OTPC HV_REQ: PMC_REQ Position         */
#define OTPC_HV_REQ_PMC_REQ_Msk             (0x01UL << OTPC_HV_REQ_PMC_REQ_Pos)                   /*!< OTPC HV_REQ: PMC_REQ Mask             */
#define OTPC_HV_REQ_PAD_REQ_Pos             1                                                       /*!< OTPC HV_REQ: PAD_REQ Position         */
#define OTPC_HV_REQ_PAD_REQ_Msk             (0x01UL << OTPC_HV_REQ_PAD_REQ_Pos)                   /*!< OTPC HV_REQ: PAD_REQ Mask             */
#define OTPC_HV_REQ_SEQ_Pos                 16                                                      /*!< OTPC HV_REQ: SEQ Position             */
#define OTPC_HV_REQ_SEQ_Msk                 (0x0000ffffUL << OTPC_HV_REQ_SEQ_Pos)                 /*!< OTPC HV_REQ: SEQ Mask                 */

/* --------------------------------  u_otpc_RDATA  -------------------------------- */
#define OTPC_RDATA_DATA_Pos                 0                                                       /*!< OTPC RDATA: DATA Position             */
#define OTPC_RDATA_DATA_Msk                 (0x0000ffffUL << OTPC_RDATA_DATA_Pos)                 /*!< OTPC RDATA: DATA Mask                 */
#define OTPC_RDATA_VALID_Pos                31                                                      /*!< OTPC RDATA: VALID Position            */
#define OTPC_RDATA_VALID_Msk                (0x01UL << OTPC_RDATA_VALID_Pos)                      /*!< OTPC RDATA: VALID Mask                */

/* ---------------------------------  u_otpc_AES  --------------------------------- */
#define OTPC_AES_KEY_Pos                    0                                                       /*!< OTPC AES: KEY Position                */
#define OTPC_AES_KEY_Msk                    (0x01UL << OTPC_AES_KEY_Pos)                          /*!< OTPC AES: KEY Mask                    */
#define OTPC_AES_SEQ_Pos                    16                                                      /*!< OTPC AES: SEQ Position                */
#define OTPC_AES_SEQ_Msk                    (0x0000ffffUL << OTPC_AES_SEQ_Pos)                    /*!< OTPC AES: SEQ Mask                    */

/* -------------------------------  u_otpc_SECURITY  ------------------------------ */
#define OTPC_SECURITY_VALID_Pos             0                                                       /*!< OTPC SECURITY: VALID Position         */
#define OTPC_SECURITY_VALID_Msk             (0x01UL << OTPC_SECURITY_VALID_Pos)                   /*!< OTPC SECURITY: VALID Mask             */
#define OTPC_SECURITY_MODE_Pos              1                                                       /*!< OTPC SECURITY: MODE Position          */
#define OTPC_SECURITY_MODE_Msk              (0x01UL << OTPC_SECURITY_MODE_Pos)                    /*!< OTPC SECURITY: MODE Mask              */


/* ================================================================================ */
/* ================         struct 'u0_i2c' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u0_i2c_CFG  --------------------------------- */
#define I2C0_CFG_MSTEN_Pos                  0                                                       /*!< I2C0 CFG: MSTEN Position              */
#define I2C0_CFG_MSTEN_Msk                  (0x01UL << I2C0_CFG_MSTEN_Pos)                        /*!< I2C0 CFG: MSTEN Mask                  */
#define I2C0_CFG_SLVEN_Pos                  1                                                       /*!< I2C0 CFG: SLVEN Position              */
#define I2C0_CFG_SLVEN_Msk                  (0x01UL << I2C0_CFG_SLVEN_Pos)                        /*!< I2C0 CFG: SLVEN Mask                  */
#define I2C0_CFG_MONEN_Pos                  2                                                       /*!< I2C0 CFG: MONEN Position              */
#define I2C0_CFG_MONEN_Msk                  (0x01UL << I2C0_CFG_MONEN_Pos)                        /*!< I2C0 CFG: MONEN Mask                  */
#define I2C0_CFG_TIMEOUT_Pos                3                                                       /*!< I2C0 CFG: TIMEOUT Position            */
#define I2C0_CFG_TIMEOUT_Msk                (0x01UL << I2C0_CFG_TIMEOUT_Pos)                      /*!< I2C0 CFG: TIMEOUT Mask                */
#define I2C0_CFG_MONCLKSTR_Pos              4                                                       /*!< I2C0 CFG: MONCLKSTR Position          */
#define I2C0_CFG_MONCLKSTR_Msk              (0x01UL << I2C0_CFG_MONCLKSTR_Pos)                    /*!< I2C0 CFG: MONCLKSTR Mask              */
#define I2C0_CFG_HSCAPABLE_Pos              5                                                       /*!< I2C0 CFG: HSCAPABLE Position          */
#define I2C0_CFG_HSCAPABLE_Msk              (0x01UL << I2C0_CFG_HSCAPABLE_Pos)                    /*!< I2C0 CFG: HSCAPABLE Mask              */

/* ---------------------------------  u0_i2c_STAT  -------------------------------- */
#define I2C0_STAT_MSTPENDING_Pos            0                                                       /*!< I2C0 STAT: MSTPENDING Position        */
#define I2C0_STAT_MSTPENDING_Msk            (0x01UL << I2C0_STAT_MSTPENDING_Pos)                  /*!< I2C0 STAT: MSTPENDING Mask            */
#define I2C0_STAT_MSTSTATE_Pos              1                                                       /*!< I2C0 STAT: MSTSTATE Position          */
#define I2C0_STAT_MSTSTATE_Msk              (0x07UL << I2C0_STAT_MSTSTATE_Pos)                    /*!< I2C0 STAT: MSTSTATE Mask              */
#define I2C0_STAT_MSTARBLOSS_Pos            4                                                       /*!< I2C0 STAT: MSTARBLOSS Position        */
#define I2C0_STAT_MSTARBLOSS_Msk            (0x01UL << I2C0_STAT_MSTARBLOSS_Pos)                  /*!< I2C0 STAT: MSTARBLOSS Mask            */
#define I2C0_STAT_MSTSTSTPERR_Pos           6                                                       /*!< I2C0 STAT: MSTSTSTPERR Position       */
#define I2C0_STAT_MSTSTSTPERR_Msk           (0x01UL << I2C0_STAT_MSTSTSTPERR_Pos)                 /*!< I2C0 STAT: MSTSTSTPERR Mask           */
#define I2C0_STAT_SLVPENDING_Pos            8                                                       /*!< I2C0 STAT: SLVPENDING Position        */
#define I2C0_STAT_SLVPENDING_Msk            (0x01UL << I2C0_STAT_SLVPENDING_Pos)                  /*!< I2C0 STAT: SLVPENDING Mask            */
#define I2C0_STAT_SLVSTATE_Pos              9                                                       /*!< I2C0 STAT: SLVSTATE Position          */
#define I2C0_STAT_SLVSTATE_Msk              (0x03UL << I2C0_STAT_SLVSTATE_Pos)                    /*!< I2C0 STAT: SLVSTATE Mask              */
#define I2C0_STAT_SLVNOTSTR_Pos             11                                                      /*!< I2C0 STAT: SLVNOTSTR Position         */
#define I2C0_STAT_SLVNOTSTR_Msk             (0x01UL << I2C0_STAT_SLVNOTSTR_Pos)                   /*!< I2C0 STAT: SLVNOTSTR Mask             */
#define I2C0_STAT_SLVIDX_Pos                12                                                      /*!< I2C0 STAT: SLVIDX Position            */
#define I2C0_STAT_SLVIDX_Msk                (0x03UL << I2C0_STAT_SLVIDX_Pos)                      /*!< I2C0 STAT: SLVIDX Mask                */
#define I2C0_STAT_SLVSEL_Pos                14                                                      /*!< I2C0 STAT: SLVSEL Position            */
#define I2C0_STAT_SLVSEL_Msk                (0x01UL << I2C0_STAT_SLVSEL_Pos)                      /*!< I2C0 STAT: SLVSEL Mask                */
#define I2C0_STAT_SLVDESEL_Pos              15                                                      /*!< I2C0 STAT: SLVDESEL Position          */
#define I2C0_STAT_SLVDESEL_Msk              (0x01UL << I2C0_STAT_SLVDESEL_Pos)                    /*!< I2C0 STAT: SLVDESEL Mask              */
#define I2C0_STAT_MONRDY_Pos                16                                                      /*!< I2C0 STAT: MONRDY Position            */
#define I2C0_STAT_MONRDY_Msk                (0x01UL << I2C0_STAT_MONRDY_Pos)                      /*!< I2C0 STAT: MONRDY Mask                */
#define I2C0_STAT_MONOV_Pos                 17                                                      /*!< I2C0 STAT: MONOV Position             */
#define I2C0_STAT_MONOV_Msk                 (0x01UL << I2C0_STAT_MONOV_Pos)                       /*!< I2C0 STAT: MONOV Mask                 */
#define I2C0_STAT_MONACTIVE_Pos             18                                                      /*!< I2C0 STAT: MONACTIVE Position         */
#define I2C0_STAT_MONACTIVE_Msk             (0x01UL << I2C0_STAT_MONACTIVE_Pos)                   /*!< I2C0 STAT: MONACTIVE Mask             */
#define I2C0_STAT_MONIDLE_Pos               19                                                      /*!< I2C0 STAT: MONIDLE Position           */
#define I2C0_STAT_MONIDLE_Msk               (0x01UL << I2C0_STAT_MONIDLE_Pos)                     /*!< I2C0 STAT: MONIDLE Mask               */
#define I2C0_STAT_EVENTTIMEOUT_Pos          24                                                      /*!< I2C0 STAT: EVENTTIMEOUT Position      */
#define I2C0_STAT_EVENTTIMEOUT_Msk          (0x01UL << I2C0_STAT_EVENTTIMEOUT_Pos)                /*!< I2C0 STAT: EVENTTIMEOUT Mask          */
#define I2C0_STAT_SCLTIMEOUT_Pos            25                                                      /*!< I2C0 STAT: SCLTIMEOUT Position        */
#define I2C0_STAT_SCLTIMEOUT_Msk            (0x01UL << I2C0_STAT_SCLTIMEOUT_Pos)                  /*!< I2C0 STAT: SCLTIMEOUT Mask            */

/* -------------------------------  u0_i2c_INTENSET  ------------------------------ */
#define I2C0_INTENSET_MSTPENDINGEN_Pos      0                                                       /*!< I2C0 INTENSET: MSTPENDINGEN Position  */
#define I2C0_INTENSET_MSTPENDINGEN_Msk      (0x01UL << I2C0_INTENSET_MSTPENDINGEN_Pos)            /*!< I2C0 INTENSET: MSTPENDINGEN Mask      */
#define I2C0_INTENSET_MSTARBLOSSEN_Pos      4                                                       /*!< I2C0 INTENSET: MSTARBLOSSEN Position  */
#define I2C0_INTENSET_MSTARBLOSSEN_Msk      (0x01UL << I2C0_INTENSET_MSTARBLOSSEN_Pos)            /*!< I2C0 INTENSET: MSTARBLOSSEN Mask      */
#define I2C0_INTENSET_MSTSTSTPERREN_Pos     6                                                       /*!< I2C0 INTENSET: MSTSTSTPERREN Position */
#define I2C0_INTENSET_MSTSTSTPERREN_Msk     (0x01UL << I2C0_INTENSET_MSTSTSTPERREN_Pos)           /*!< I2C0 INTENSET: MSTSTSTPERREN Mask     */
#define I2C0_INTENSET_SLVPENDINGEN_Pos      8                                                       /*!< I2C0 INTENSET: SLVPENDINGEN Position  */
#define I2C0_INTENSET_SLVPENDINGEN_Msk      (0x01UL << I2C0_INTENSET_SLVPENDINGEN_Pos)            /*!< I2C0 INTENSET: SLVPENDINGEN Mask      */
#define I2C0_INTENSET_SLVNOTSTREN_Pos       11                                                      /*!< I2C0 INTENSET: SLVNOTSTREN Position   */
#define I2C0_INTENSET_SLVNOTSTREN_Msk       (0x01UL << I2C0_INTENSET_SLVNOTSTREN_Pos)             /*!< I2C0 INTENSET: SLVNOTSTREN Mask       */
#define I2C0_INTENSET_SLVDESELEN_Pos        15                                                      /*!< I2C0 INTENSET: SLVDESELEN Position    */
#define I2C0_INTENSET_SLVDESELEN_Msk        (0x01UL << I2C0_INTENSET_SLVDESELEN_Pos)              /*!< I2C0 INTENSET: SLVDESELEN Mask        */
#define I2C0_INTENSET_MONRDYEN_Pos          16                                                      /*!< I2C0 INTENSET: MONRDYEN Position      */
#define I2C0_INTENSET_MONRDYEN_Msk          (0x01UL << I2C0_INTENSET_MONRDYEN_Pos)                /*!< I2C0 INTENSET: MONRDYEN Mask          */
#define I2C0_INTENSET_MONOVEN_Pos           17                                                      /*!< I2C0 INTENSET: MONOVEN Position       */
#define I2C0_INTENSET_MONOVEN_Msk           (0x01UL << I2C0_INTENSET_MONOVEN_Pos)                 /*!< I2C0 INTENSET: MONOVEN Mask           */
#define I2C0_INTENSET_MONIDLEEN_Pos         19                                                      /*!< I2C0 INTENSET: MONIDLEEN Position     */
#define I2C0_INTENSET_MONIDLEEN_Msk         (0x01UL << I2C0_INTENSET_MONIDLEEN_Pos)               /*!< I2C0 INTENSET: MONIDLEEN Mask         */
#define I2C0_INTENSET_EVENTTIMEOUTEN_Pos    24                                                      /*!< I2C0 INTENSET: EVENTTIMEOUTEN Position */
#define I2C0_INTENSET_EVENTTIMEOUTEN_Msk    (0x01UL << I2C0_INTENSET_EVENTTIMEOUTEN_Pos)          /*!< I2C0 INTENSET: EVENTTIMEOUTEN Mask    */
#define I2C0_INTENSET_SCLTIMEOUTEN_Pos      25                                                      /*!< I2C0 INTENSET: SCLTIMEOUTEN Position  */
#define I2C0_INTENSET_SCLTIMEOUTEN_Msk      (0x01UL << I2C0_INTENSET_SCLTIMEOUTEN_Pos)            /*!< I2C0 INTENSET: SCLTIMEOUTEN Mask      */

/* -------------------------------  u0_i2c_INTENCLR  ------------------------------ */
#define I2C0_INTENCLR_MSTPCLRDINGCLR_Pos    0                                                       /*!< I2C0 INTENCLR: MSTPCLRDINGCLR Position */
#define I2C0_INTENCLR_MSTPCLRDINGCLR_Msk    (0x01UL << I2C0_INTENCLR_MSTPCLRDINGCLR_Pos)          /*!< I2C0 INTENCLR: MSTPCLRDINGCLR Mask    */
#define I2C0_INTENCLR_MSTARBLOSSCLR_Pos     4                                                       /*!< I2C0 INTENCLR: MSTARBLOSSCLR Position */
#define I2C0_INTENCLR_MSTARBLOSSCLR_Msk     (0x01UL << I2C0_INTENCLR_MSTARBLOSSCLR_Pos)           /*!< I2C0 INTENCLR: MSTARBLOSSCLR Mask     */
#define I2C0_INTENCLR_MSTSTSTPERRCLR_Pos    6                                                       /*!< I2C0 INTENCLR: MSTSTSTPERRCLR Position */
#define I2C0_INTENCLR_MSTSTSTPERRCLR_Msk    (0x01UL << I2C0_INTENCLR_MSTSTSTPERRCLR_Pos)          /*!< I2C0 INTENCLR: MSTSTSTPERRCLR Mask    */
#define I2C0_INTENCLR_SLVPENDINGCLR_Pos     8                                                       /*!< I2C0 INTENCLR: SLVPENDINGCLR Position */
#define I2C0_INTENCLR_SLVPENDINGCLR_Msk     (0x01UL << I2C0_INTENCLR_SLVPENDINGCLR_Pos)           /*!< I2C0 INTENCLR: SLVPENDINGCLR Mask     */
#define I2C0_INTENCLR_SLVNOTSTRCLR_Pos      11                                                      /*!< I2C0 INTENCLR: SLVNOTSTRCLR Position  */
#define I2C0_INTENCLR_SLVNOTSTRCLR_Msk      (0x01UL << I2C0_INTENCLR_SLVNOTSTRCLR_Pos)            /*!< I2C0 INTENCLR: SLVNOTSTRCLR Mask      */
#define I2C0_INTENCLR_SLVDESELCLR_Pos       15                                                      /*!< I2C0 INTENCLR: SLVDESELCLR Position   */
#define I2C0_INTENCLR_SLVDESELCLR_Msk       (0x01UL << I2C0_INTENCLR_SLVDESELCLR_Pos)             /*!< I2C0 INTENCLR: SLVDESELCLR Mask       */
#define I2C0_INTENCLR_MONRDYCLR_Pos         16                                                      /*!< I2C0 INTENCLR: MONRDYCLR Position     */
#define I2C0_INTENCLR_MONRDYCLR_Msk         (0x01UL << I2C0_INTENCLR_MONRDYCLR_Pos)               /*!< I2C0 INTENCLR: MONRDYCLR Mask         */
#define I2C0_INTENCLR_MONOVCLR_Pos          17                                                      /*!< I2C0 INTENCLR: MONOVCLR Position      */
#define I2C0_INTENCLR_MONOVCLR_Msk          (0x01UL << I2C0_INTENCLR_MONOVCLR_Pos)                /*!< I2C0 INTENCLR: MONOVCLR Mask          */
#define I2C0_INTENCLR_MONIDLECLR_Pos        19                                                      /*!< I2C0 INTENCLR: MONIDLECLR Position    */
#define I2C0_INTENCLR_MONIDLECLR_Msk        (0x01UL << I2C0_INTENCLR_MONIDLECLR_Pos)              /*!< I2C0 INTENCLR: MONIDLECLR Mask        */
#define I2C0_INTENCLR_EVCLRTTIMEOUTCLR_Pos  24                                                      /*!< I2C0 INTENCLR: EVCLRTTIMEOUTCLR Position */
#define I2C0_INTENCLR_EVCLRTTIMEOUTCLR_Msk  (0x01UL << I2C0_INTENCLR_EVCLRTTIMEOUTCLR_Pos)        /*!< I2C0 INTENCLR: EVCLRTTIMEOUTCLR Mask  */
#define I2C0_INTENCLR_SCLTIMEOUTCLR_Pos     25                                                      /*!< I2C0 INTENCLR: SCLTIMEOUTCLR Position */
#define I2C0_INTENCLR_SCLTIMEOUTCLR_Msk     (0x01UL << I2C0_INTENCLR_SCLTIMEOUTCLR_Pos)           /*!< I2C0 INTENCLR: SCLTIMEOUTCLR Mask     */

/* -------------------------------  u0_i2c_TIMEOUT  ------------------------------- */
#define I2C0_TIMEOUT_TOMIN_Pos              0                                                       /*!< I2C0 TIMEOUT: TOMIN Position          */
#define I2C0_TIMEOUT_TOMIN_Msk              (0x0fUL << I2C0_TIMEOUT_TOMIN_Pos)                    /*!< I2C0 TIMEOUT: TOMIN Mask              */
#define I2C0_TIMEOUT_TO_Pos                 4                                                       /*!< I2C0 TIMEOUT: TO Position             */
#define I2C0_TIMEOUT_TO_Msk                 (0x00000fffUL << I2C0_TIMEOUT_TO_Pos)                 /*!< I2C0 TIMEOUT: TO Mask                 */

/* --------------------------------  u0_i2c_CLKDIV  ------------------------------- */
#define I2C0_CLKDIV_DIVVAL_Pos              0                                                       /*!< I2C0 CLKDIV: DIVVAL Position          */
#define I2C0_CLKDIV_DIVVAL_Msk              (0x0000ffffUL << I2C0_CLKDIV_DIVVAL_Pos)              /*!< I2C0 CLKDIV: DIVVAL Mask              */

/* -------------------------------  u0_i2c_INTSTAT  ------------------------------- */
#define I2C0_INTSTAT_MSTPDING_Pos           0                                                       /*!< I2C0 INTSTAT: MSTPDING Position       */
#define I2C0_INTSTAT_MSTPDING_Msk           (0x01UL << I2C0_INTSTAT_MSTPDING_Pos)                 /*!< I2C0 INTSTAT: MSTPDING Mask           */
#define I2C0_INTSTAT_MSTARBLOSS_Pos         4                                                       /*!< I2C0 INTSTAT: MSTARBLOSS Position     */
#define I2C0_INTSTAT_MSTARBLOSS_Msk         (0x01UL << I2C0_INTSTAT_MSTARBLOSS_Pos)               /*!< I2C0 INTSTAT: MSTARBLOSS Mask         */
#define I2C0_INTSTAT_MSTSTSTPERR_Pos        6                                                       /*!< I2C0 INTSTAT: MSTSTSTPERR Position    */
#define I2C0_INTSTAT_MSTSTSTPERR_Msk        (0x01UL << I2C0_INTSTAT_MSTSTSTPERR_Pos)              /*!< I2C0 INTSTAT: MSTSTSTPERR Mask        */
#define I2C0_INTSTAT_SLVPENDING_Pos         8                                                       /*!< I2C0 INTSTAT: SLVPENDING Position     */
#define I2C0_INTSTAT_SLVPENDING_Msk         (0x01UL << I2C0_INTSTAT_SLVPENDING_Pos)               /*!< I2C0 INTSTAT: SLVPENDING Mask         */
#define I2C0_INTSTAT_SLVNOTSTR_Pos          11                                                      /*!< I2C0 INTSTAT: SLVNOTSTR Position      */
#define I2C0_INTSTAT_SLVNOTSTR_Msk          (0x01UL << I2C0_INTSTAT_SLVNOTSTR_Pos)                /*!< I2C0 INTSTAT: SLVNOTSTR Mask          */
#define I2C0_INTSTAT_SLVDESEL_Pos           15                                                      /*!< I2C0 INTSTAT: SLVDESEL Position       */
#define I2C0_INTSTAT_SLVDESEL_Msk           (0x01UL << I2C0_INTSTAT_SLVDESEL_Pos)                 /*!< I2C0 INTSTAT: SLVDESEL Mask           */
#define I2C0_INTSTAT_MONRDY_Pos             16                                                      /*!< I2C0 INTSTAT: MONRDY Position         */
#define I2C0_INTSTAT_MONRDY_Msk             (0x01UL << I2C0_INTSTAT_MONRDY_Pos)                   /*!< I2C0 INTSTAT: MONRDY Mask             */
#define I2C0_INTSTAT_MONOV_Pos              17                                                      /*!< I2C0 INTSTAT: MONOV Position          */
#define I2C0_INTSTAT_MONOV_Msk              (0x01UL << I2C0_INTSTAT_MONOV_Pos)                    /*!< I2C0 INTSTAT: MONOV Mask              */
#define I2C0_INTSTAT_MONIDLE_Pos            19                                                      /*!< I2C0 INTSTAT: MONIDLE Position        */
#define I2C0_INTSTAT_MONIDLE_Msk            (0x01UL << I2C0_INTSTAT_MONIDLE_Pos)                  /*!< I2C0 INTSTAT: MONIDLE Mask            */
#define I2C0_INTSTAT_EVTTIMEOUT_Pos         24                                                      /*!< I2C0 INTSTAT: EVTTIMEOUT Position     */
#define I2C0_INTSTAT_EVTTIMEOUT_Msk         (0x01UL << I2C0_INTSTAT_EVTTIMEOUT_Pos)               /*!< I2C0 INTSTAT: EVTTIMEOUT Mask         */
#define I2C0_INTSTAT_SCLTIMEOUT_Pos         25                                                      /*!< I2C0 INTSTAT: SCLTIMEOUT Position     */
#define I2C0_INTSTAT_SCLTIMEOUT_Msk         (0x01UL << I2C0_INTSTAT_SCLTIMEOUT_Pos)               /*!< I2C0 INTSTAT: SCLTIMEOUT Mask         */

/* --------------------------------  u0_i2c_MSTCTL  ------------------------------- */
#define I2C0_MSTCTL_MSTCONTINUE_Pos         0                                                       /*!< I2C0 MSTCTL: MSTCONTINUE Position     */
#define I2C0_MSTCTL_MSTCONTINUE_Msk         (0x01UL << I2C0_MSTCTL_MSTCONTINUE_Pos)               /*!< I2C0 MSTCTL: MSTCONTINUE Mask         */
#define I2C0_MSTCTL_MSTSTART_Pos            1                                                       /*!< I2C0 MSTCTL: MSTSTART Position        */
#define I2C0_MSTCTL_MSTSTART_Msk            (0x01UL << I2C0_MSTCTL_MSTSTART_Pos)                  /*!< I2C0 MSTCTL: MSTSTART Mask            */
#define I2C0_MSTCTL_MSTSTOP_Pos             2                                                       /*!< I2C0 MSTCTL: MSTSTOP Position         */
#define I2C0_MSTCTL_MSTSTOP_Msk             (0x01UL << I2C0_MSTCTL_MSTSTOP_Pos)                   /*!< I2C0 MSTCTL: MSTSTOP Mask             */
#define I2C0_MSTCTL_MSTDMA_Pos              3                                                       /*!< I2C0 MSTCTL: MSTDMA Position          */
#define I2C0_MSTCTL_MSTDMA_Msk              (0x01UL << I2C0_MSTCTL_MSTDMA_Pos)                    /*!< I2C0 MSTCTL: MSTDMA Mask              */

/* -------------------------------  u0_i2c_MSTTIME  ------------------------------- */
#define I2C0_MSTTIME_MSTSCLLOW_Pos          0                                                       /*!< I2C0 MSTTIME: MSTSCLLOW Position      */
#define I2C0_MSTTIME_MSTSCLLOW_Msk          (0x07UL << I2C0_MSTTIME_MSTSCLLOW_Pos)                /*!< I2C0 MSTTIME: MSTSCLLOW Mask          */
#define I2C0_MSTTIME_MSTSCLHIGH_Pos         4                                                       /*!< I2C0 MSTTIME: MSTSCLHIGH Position     */
#define I2C0_MSTTIME_MSTSCLHIGH_Msk         (0x07UL << I2C0_MSTTIME_MSTSCLHIGH_Pos)               /*!< I2C0 MSTTIME: MSTSCLHIGH Mask         */

/* --------------------------------  u0_i2c_MSTDAT  ------------------------------- */
#define I2C0_MSTDAT_DATA_Pos                0                                                       /*!< I2C0 MSTDAT: DATA Position            */
#define I2C0_MSTDAT_DATA_Msk                (0x000000ffUL << I2C0_MSTDAT_DATA_Pos)                /*!< I2C0 MSTDAT: DATA Mask                */

/* --------------------------------  u0_i2c_SLVCTL  ------------------------------- */
#define I2C0_SLVCTL_SLVCONTINUE_Pos         0                                                       /*!< I2C0 SLVCTL: SLVCONTINUE Position     */
#define I2C0_SLVCTL_SLVCONTINUE_Msk         (0x01UL << I2C0_SLVCTL_SLVCONTINUE_Pos)               /*!< I2C0 SLVCTL: SLVCONTINUE Mask         */
#define I2C0_SLVCTL_SLVNACK_Pos             1                                                       /*!< I2C0 SLVCTL: SLVNACK Position         */
#define I2C0_SLVCTL_SLVNACK_Msk             (0x01UL << I2C0_SLVCTL_SLVNACK_Pos)                   /*!< I2C0 SLVCTL: SLVNACK Mask             */
#define I2C0_SLVCTL_SLVDMA_Pos              3                                                       /*!< I2C0 SLVCTL: SLVDMA Position          */
#define I2C0_SLVCTL_SLVDMA_Msk              (0x01UL << I2C0_SLVCTL_SLVDMA_Pos)                    /*!< I2C0 SLVCTL: SLVDMA Mask              */
#define I2C0_SLVCTL_AUTOACK_Pos             8                                                       /*!< I2C0 SLVCTL: AUTOACK Position         */
#define I2C0_SLVCTL_AUTOACK_Msk             (0x01UL << I2C0_SLVCTL_AUTOACK_Pos)                   /*!< I2C0 SLVCTL: AUTOACK Mask             */
#define I2C0_SLVCTL_AUTOMATCHREAD_Pos       9                                                       /*!< I2C0 SLVCTL: AUTOMATCHREAD Position   */
#define I2C0_SLVCTL_AUTOMATCHREAD_Msk       (0x01UL << I2C0_SLVCTL_AUTOMATCHREAD_Pos)             /*!< I2C0 SLVCTL: AUTOMATCHREAD Mask       */

/* --------------------------------  u0_i2c_SLVDAT  ------------------------------- */
#define I2C0_SLVDAT_DATA_Pos                0                                                       /*!< I2C0 SLVDAT: DATA Position            */
#define I2C0_SLVDAT_DATA_Msk                (0x000000ffUL << I2C0_SLVDAT_DATA_Pos)                /*!< I2C0 SLVDAT: DATA Mask                */

/* -------------------------------  u0_i2c_SLVADR0  ------------------------------- */
#define I2C0_SLVADR0_SADISABLE0_Pos         0                                                       /*!< I2C0 SLVADR0: SADISABLE0 Position     */
#define I2C0_SLVADR0_SADISABLE0_Msk         (0x01UL << I2C0_SLVADR0_SADISABLE0_Pos)               /*!< I2C0 SLVADR0: SADISABLE0 Mask         */
#define I2C0_SLVADR0_SLVADR0_Pos            1                                                       /*!< I2C0 SLVADR0: SLVADR0 Position        */
#define I2C0_SLVADR0_SLVADR0_Msk            (0x7fUL << I2C0_SLVADR0_SLVADR0_Pos)                  /*!< I2C0 SLVADR0: SLVADR0 Mask            */
#define I2C0_SLVADR0_AUTONACK_Pos           15                                                      /*!< I2C0 SLVADR0: AUTONACK Position       */
#define I2C0_SLVADR0_AUTONACK_Msk           (0x01UL << I2C0_SLVADR0_AUTONACK_Pos)                 /*!< I2C0 SLVADR0: AUTONACK Mask           */

/* -------------------------------  u0_i2c_SLVADR1  ------------------------------- */
#define I2C0_SLVADR1_SADISABLE_Pos          0                                                       /*!< I2C0 SLVADR1: SADISABLE Position      */
#define I2C0_SLVADR1_SADISABLE_Msk          (0x01UL << I2C0_SLVADR1_SADISABLE_Pos)                /*!< I2C0 SLVADR1: SADISABLE Mask          */
#define I2C0_SLVADR1_SLVADR_Pos             1                                                       /*!< I2C0 SLVADR1: SLVADR Position         */
#define I2C0_SLVADR1_SLVADR_Msk             (0x7fUL << I2C0_SLVADR1_SLVADR_Pos)                   /*!< I2C0 SLVADR1: SLVADR Mask             */

/* -------------------------------  u0_i2c_SLVADR2  ------------------------------- */
#define I2C0_SLVADR2_SADISABLE_Pos          0                                                       /*!< I2C0 SLVADR2: SADISABLE Position      */
#define I2C0_SLVADR2_SADISABLE_Msk          (0x01UL << I2C0_SLVADR2_SADISABLE_Pos)                /*!< I2C0 SLVADR2: SADISABLE Mask          */
#define I2C0_SLVADR2_SLVADR_Pos             1                                                       /*!< I2C0 SLVADR2: SLVADR Position         */
#define I2C0_SLVADR2_SLVADR_Msk             (0x7fUL << I2C0_SLVADR2_SLVADR_Pos)                   /*!< I2C0 SLVADR2: SLVADR Mask             */

/* -------------------------------  u0_i2c_SLVADR3  ------------------------------- */
#define I2C0_SLVADR3_SADISABLE_Pos          0                                                       /*!< I2C0 SLVADR3: SADISABLE Position      */
#define I2C0_SLVADR3_SADISABLE_Msk          (0x01UL << I2C0_SLVADR3_SADISABLE_Pos)                /*!< I2C0 SLVADR3: SADISABLE Mask          */
#define I2C0_SLVADR3_SLVADR_Pos             1                                                       /*!< I2C0 SLVADR3: SLVADR Position         */
#define I2C0_SLVADR3_SLVADR_Msk             (0x7fUL << I2C0_SLVADR3_SLVADR_Pos)                   /*!< I2C0 SLVADR3: SLVADR Mask             */

/* -------------------------------  u0_i2c_SLVQUAL0  ------------------------------ */
#define I2C0_SLVQUAL0_QUALMODE0_Pos         0                                                       /*!< I2C0 SLVQUAL0: QUALMODE0 Position     */
#define I2C0_SLVQUAL0_QUALMODE0_Msk         (0x01UL << I2C0_SLVQUAL0_QUALMODE0_Pos)               /*!< I2C0 SLVQUAL0: QUALMODE0 Mask         */
#define I2C0_SLVQUAL0_SLVQUAL0_Pos          1                                                       /*!< I2C0 SLVQUAL0: SLVQUAL0 Position      */
#define I2C0_SLVQUAL0_SLVQUAL0_Msk          (0x7fUL << I2C0_SLVQUAL0_SLVQUAL0_Pos)                /*!< I2C0 SLVQUAL0: SLVQUAL0 Mask          */

/* -------------------------------  u0_i2c_MONRXDAT  ------------------------------ */
#define I2C0_MONRXDAT_MONRXDAT_Pos          0                                                       /*!< I2C0 MONRXDAT: MONRXDAT Position      */
#define I2C0_MONRXDAT_MONRXDAT_Msk          (0x000000ffUL << I2C0_MONRXDAT_MONRXDAT_Pos)          /*!< I2C0 MONRXDAT: MONRXDAT Mask          */
#define I2C0_MONRXDAT_MONSTART_Pos          8                                                       /*!< I2C0 MONRXDAT: MONSTART Position      */
#define I2C0_MONRXDAT_MONSTART_Msk          (0x01UL << I2C0_MONRXDAT_MONSTART_Pos)                /*!< I2C0 MONRXDAT: MONSTART Mask          */
#define I2C0_MONRXDAT_MONRESTART_Pos        9                                                       /*!< I2C0 MONRXDAT: MONRESTART Position    */
#define I2C0_MONRXDAT_MONRESTART_Msk        (0x01UL << I2C0_MONRXDAT_MONRESTART_Pos)              /*!< I2C0 MONRXDAT: MONRESTART Mask        */
#define I2C0_MONRXDAT_MONNACK_Pos           10                                                      /*!< I2C0 MONRXDAT: MONNACK Position       */
#define I2C0_MONRXDAT_MONNACK_Msk           (0x01UL << I2C0_MONRXDAT_MONNACK_Pos)                 /*!< I2C0 MONRXDAT: MONNACK Mask           */

/* ----------------------------------  u0_i2c_ID  --------------------------------- */
#define I2C0_ID_APERTURE_Pos                0                                                       /*!< I2C0 ID: APERTURE Position            */
#define I2C0_ID_APERTURE_Msk                (0x000000ffUL << I2C0_ID_APERTURE_Pos)                /*!< I2C0 ID: APERTURE Mask                */
#define I2C0_ID_MIN_REV_Pos                 8                                                       /*!< I2C0 ID: MIN_REV Position             */
#define I2C0_ID_MIN_REV_Msk                 (0x0fUL << I2C0_ID_MIN_REV_Pos)                       /*!< I2C0 ID: MIN_REV Mask                 */
#define I2C0_ID_MAJ_REV_Pos                 12                                                      /*!< I2C0 ID: MAJ_REV Position             */
#define I2C0_ID_MAJ_REV_Msk                 (0x0fUL << I2C0_ID_MAJ_REV_Pos)                       /*!< I2C0 ID: MAJ_REV Mask                 */
#define I2C0_ID_ID_Pos                      16                                                      /*!< I2C0 ID: ID Position                  */
#define I2C0_ID_ID_Msk                      (0x0000ffffUL << I2C0_ID_ID_Pos)                      /*!< I2C0 ID: ID Mask                      */


/* ================================================================================ */
/* ================         struct 'u1_i2c' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u1_i2c_CFG  --------------------------------- */
#define I2C1_CFG_MSTEN_Pos                  0                                                       /*!< I2C1 CFG: MSTEN Position              */
#define I2C1_CFG_MSTEN_Msk                  (0x01UL << I2C1_CFG_MSTEN_Pos)                        /*!< I2C1 CFG: MSTEN Mask                  */
#define I2C1_CFG_SLVEN_Pos                  1                                                       /*!< I2C1 CFG: SLVEN Position              */
#define I2C1_CFG_SLVEN_Msk                  (0x01UL << I2C1_CFG_SLVEN_Pos)                        /*!< I2C1 CFG: SLVEN Mask                  */
#define I2C1_CFG_MONEN_Pos                  2                                                       /*!< I2C1 CFG: MONEN Position              */
#define I2C1_CFG_MONEN_Msk                  (0x01UL << I2C1_CFG_MONEN_Pos)                        /*!< I2C1 CFG: MONEN Mask                  */
#define I2C1_CFG_TIMEOUT_Pos                3                                                       /*!< I2C1 CFG: TIMEOUT Position            */
#define I2C1_CFG_TIMEOUT_Msk                (0x01UL << I2C1_CFG_TIMEOUT_Pos)                      /*!< I2C1 CFG: TIMEOUT Mask                */
#define I2C1_CFG_MONCLKSTR_Pos              4                                                       /*!< I2C1 CFG: MONCLKSTR Position          */
#define I2C1_CFG_MONCLKSTR_Msk              (0x01UL << I2C1_CFG_MONCLKSTR_Pos)                    /*!< I2C1 CFG: MONCLKSTR Mask              */
#define I2C1_CFG_HSCAPABLE_Pos              5                                                       /*!< I2C1 CFG: HSCAPABLE Position          */
#define I2C1_CFG_HSCAPABLE_Msk              (0x01UL << I2C1_CFG_HSCAPABLE_Pos)                    /*!< I2C1 CFG: HSCAPABLE Mask              */

/* ---------------------------------  u1_i2c_STAT  -------------------------------- */
#define I2C1_STAT_MSTPENDING_Pos            0                                                       /*!< I2C1 STAT: MSTPENDING Position        */
#define I2C1_STAT_MSTPENDING_Msk            (0x01UL << I2C1_STAT_MSTPENDING_Pos)                  /*!< I2C1 STAT: MSTPENDING Mask            */
#define I2C1_STAT_MSTSTATE_Pos              1                                                       /*!< I2C1 STAT: MSTSTATE Position          */
#define I2C1_STAT_MSTSTATE_Msk              (0x07UL << I2C1_STAT_MSTSTATE_Pos)                    /*!< I2C1 STAT: MSTSTATE Mask              */
#define I2C1_STAT_MSTARBLOSS_Pos            4                                                       /*!< I2C1 STAT: MSTARBLOSS Position        */
#define I2C1_STAT_MSTARBLOSS_Msk            (0x01UL << I2C1_STAT_MSTARBLOSS_Pos)                  /*!< I2C1 STAT: MSTARBLOSS Mask            */
#define I2C1_STAT_MSTSTSTPERR_Pos           6                                                       /*!< I2C1 STAT: MSTSTSTPERR Position       */
#define I2C1_STAT_MSTSTSTPERR_Msk           (0x01UL << I2C1_STAT_MSTSTSTPERR_Pos)                 /*!< I2C1 STAT: MSTSTSTPERR Mask           */
#define I2C1_STAT_SLVPENDING_Pos            8                                                       /*!< I2C1 STAT: SLVPENDING Position        */
#define I2C1_STAT_SLVPENDING_Msk            (0x01UL << I2C1_STAT_SLVPENDING_Pos)                  /*!< I2C1 STAT: SLVPENDING Mask            */
#define I2C1_STAT_SLVSTATE_Pos              9                                                       /*!< I2C1 STAT: SLVSTATE Position          */
#define I2C1_STAT_SLVSTATE_Msk              (0x03UL << I2C1_STAT_SLVSTATE_Pos)                    /*!< I2C1 STAT: SLVSTATE Mask              */
#define I2C1_STAT_SLVNOTSTR_Pos             11                                                      /*!< I2C1 STAT: SLVNOTSTR Position         */
#define I2C1_STAT_SLVNOTSTR_Msk             (0x01UL << I2C1_STAT_SLVNOTSTR_Pos)                   /*!< I2C1 STAT: SLVNOTSTR Mask             */
#define I2C1_STAT_SLVIDX_Pos                12                                                      /*!< I2C1 STAT: SLVIDX Position            */
#define I2C1_STAT_SLVIDX_Msk                (0x03UL << I2C1_STAT_SLVIDX_Pos)                      /*!< I2C1 STAT: SLVIDX Mask                */
#define I2C1_STAT_SLVSEL_Pos                14                                                      /*!< I2C1 STAT: SLVSEL Position            */
#define I2C1_STAT_SLVSEL_Msk                (0x01UL << I2C1_STAT_SLVSEL_Pos)                      /*!< I2C1 STAT: SLVSEL Mask                */
#define I2C1_STAT_SLVDESEL_Pos              15                                                      /*!< I2C1 STAT: SLVDESEL Position          */
#define I2C1_STAT_SLVDESEL_Msk              (0x01UL << I2C1_STAT_SLVDESEL_Pos)                    /*!< I2C1 STAT: SLVDESEL Mask              */
#define I2C1_STAT_MONRDY_Pos                16                                                      /*!< I2C1 STAT: MONRDY Position            */
#define I2C1_STAT_MONRDY_Msk                (0x01UL << I2C1_STAT_MONRDY_Pos)                      /*!< I2C1 STAT: MONRDY Mask                */
#define I2C1_STAT_MONOV_Pos                 17                                                      /*!< I2C1 STAT: MONOV Position             */
#define I2C1_STAT_MONOV_Msk                 (0x01UL << I2C1_STAT_MONOV_Pos)                       /*!< I2C1 STAT: MONOV Mask                 */
#define I2C1_STAT_MONACTIVE_Pos             18                                                      /*!< I2C1 STAT: MONACTIVE Position         */
#define I2C1_STAT_MONACTIVE_Msk             (0x01UL << I2C1_STAT_MONACTIVE_Pos)                   /*!< I2C1 STAT: MONACTIVE Mask             */
#define I2C1_STAT_MONIDLE_Pos               19                                                      /*!< I2C1 STAT: MONIDLE Position           */
#define I2C1_STAT_MONIDLE_Msk               (0x01UL << I2C1_STAT_MONIDLE_Pos)                     /*!< I2C1 STAT: MONIDLE Mask               */
#define I2C1_STAT_EVENTTIMEOUT_Pos          24                                                      /*!< I2C1 STAT: EVENTTIMEOUT Position      */
#define I2C1_STAT_EVENTTIMEOUT_Msk          (0x01UL << I2C1_STAT_EVENTTIMEOUT_Pos)                /*!< I2C1 STAT: EVENTTIMEOUT Mask          */
#define I2C1_STAT_SCLTIMEOUT_Pos            25                                                      /*!< I2C1 STAT: SCLTIMEOUT Position        */
#define I2C1_STAT_SCLTIMEOUT_Msk            (0x01UL << I2C1_STAT_SCLTIMEOUT_Pos)                  /*!< I2C1 STAT: SCLTIMEOUT Mask            */

/* -------------------------------  u1_i2c_INTENSET  ------------------------------ */
#define I2C1_INTENSET_MSTPENDINGEN_Pos      0                                                       /*!< I2C1 INTENSET: MSTPENDINGEN Position  */
#define I2C1_INTENSET_MSTPENDINGEN_Msk      (0x01UL << I2C1_INTENSET_MSTPENDINGEN_Pos)            /*!< I2C1 INTENSET: MSTPENDINGEN Mask      */
#define I2C1_INTENSET_MSTARBLOSSEN_Pos      4                                                       /*!< I2C1 INTENSET: MSTARBLOSSEN Position  */
#define I2C1_INTENSET_MSTARBLOSSEN_Msk      (0x01UL << I2C1_INTENSET_MSTARBLOSSEN_Pos)            /*!< I2C1 INTENSET: MSTARBLOSSEN Mask      */
#define I2C1_INTENSET_MSTSTSTPERREN_Pos     6                                                       /*!< I2C1 INTENSET: MSTSTSTPERREN Position */
#define I2C1_INTENSET_MSTSTSTPERREN_Msk     (0x01UL << I2C1_INTENSET_MSTSTSTPERREN_Pos)           /*!< I2C1 INTENSET: MSTSTSTPERREN Mask     */
#define I2C1_INTENSET_SLVPENDINGEN_Pos      8                                                       /*!< I2C1 INTENSET: SLVPENDINGEN Position  */
#define I2C1_INTENSET_SLVPENDINGEN_Msk      (0x01UL << I2C1_INTENSET_SLVPENDINGEN_Pos)            /*!< I2C1 INTENSET: SLVPENDINGEN Mask      */
#define I2C1_INTENSET_SLVNOTSTREN_Pos       11                                                      /*!< I2C1 INTENSET: SLVNOTSTREN Position   */
#define I2C1_INTENSET_SLVNOTSTREN_Msk       (0x01UL << I2C1_INTENSET_SLVNOTSTREN_Pos)             /*!< I2C1 INTENSET: SLVNOTSTREN Mask       */
#define I2C1_INTENSET_SLVDESELEN_Pos        15                                                      /*!< I2C1 INTENSET: SLVDESELEN Position    */
#define I2C1_INTENSET_SLVDESELEN_Msk        (0x01UL << I2C1_INTENSET_SLVDESELEN_Pos)              /*!< I2C1 INTENSET: SLVDESELEN Mask        */
#define I2C1_INTENSET_MONRDYEN_Pos          16                                                      /*!< I2C1 INTENSET: MONRDYEN Position      */
#define I2C1_INTENSET_MONRDYEN_Msk          (0x01UL << I2C1_INTENSET_MONRDYEN_Pos)                /*!< I2C1 INTENSET: MONRDYEN Mask          */
#define I2C1_INTENSET_MONOVEN_Pos           17                                                      /*!< I2C1 INTENSET: MONOVEN Position       */
#define I2C1_INTENSET_MONOVEN_Msk           (0x01UL << I2C1_INTENSET_MONOVEN_Pos)                 /*!< I2C1 INTENSET: MONOVEN Mask           */
#define I2C1_INTENSET_MONIDLEEN_Pos         19                                                      /*!< I2C1 INTENSET: MONIDLEEN Position     */
#define I2C1_INTENSET_MONIDLEEN_Msk         (0x01UL << I2C1_INTENSET_MONIDLEEN_Pos)               /*!< I2C1 INTENSET: MONIDLEEN Mask         */
#define I2C1_INTENSET_EVENTTIMEOUTEN_Pos    24                                                      /*!< I2C1 INTENSET: EVENTTIMEOUTEN Position */
#define I2C1_INTENSET_EVENTTIMEOUTEN_Msk    (0x01UL << I2C1_INTENSET_EVENTTIMEOUTEN_Pos)          /*!< I2C1 INTENSET: EVENTTIMEOUTEN Mask    */
#define I2C1_INTENSET_SCLTIMEOUTEN_Pos      25                                                      /*!< I2C1 INTENSET: SCLTIMEOUTEN Position  */
#define I2C1_INTENSET_SCLTIMEOUTEN_Msk      (0x01UL << I2C1_INTENSET_SCLTIMEOUTEN_Pos)            /*!< I2C1 INTENSET: SCLTIMEOUTEN Mask      */

/* -------------------------------  u1_i2c_INTENCLR  ------------------------------ */
#define I2C1_INTENCLR_MSTPCLRDINGCLR_Pos    0                                                       /*!< I2C1 INTENCLR: MSTPCLRDINGCLR Position */
#define I2C1_INTENCLR_MSTPCLRDINGCLR_Msk    (0x01UL << I2C1_INTENCLR_MSTPCLRDINGCLR_Pos)          /*!< I2C1 INTENCLR: MSTPCLRDINGCLR Mask    */
#define I2C1_INTENCLR_MSTARBLOSSCLR_Pos     4                                                       /*!< I2C1 INTENCLR: MSTARBLOSSCLR Position */
#define I2C1_INTENCLR_MSTARBLOSSCLR_Msk     (0x01UL << I2C1_INTENCLR_MSTARBLOSSCLR_Pos)           /*!< I2C1 INTENCLR: MSTARBLOSSCLR Mask     */
#define I2C1_INTENCLR_MSTSTSTPERRCLR_Pos    6                                                       /*!< I2C1 INTENCLR: MSTSTSTPERRCLR Position */
#define I2C1_INTENCLR_MSTSTSTPERRCLR_Msk    (0x01UL << I2C1_INTENCLR_MSTSTSTPERRCLR_Pos)          /*!< I2C1 INTENCLR: MSTSTSTPERRCLR Mask    */
#define I2C1_INTENCLR_SLVPENDINGCLR_Pos     8                                                       /*!< I2C1 INTENCLR: SLVPENDINGCLR Position */
#define I2C1_INTENCLR_SLVPENDINGCLR_Msk     (0x01UL << I2C1_INTENCLR_SLVPENDINGCLR_Pos)           /*!< I2C1 INTENCLR: SLVPENDINGCLR Mask     */
#define I2C1_INTENCLR_SLVNOTSTRCLR_Pos      11                                                      /*!< I2C1 INTENCLR: SLVNOTSTRCLR Position  */
#define I2C1_INTENCLR_SLVNOTSTRCLR_Msk      (0x01UL << I2C1_INTENCLR_SLVNOTSTRCLR_Pos)            /*!< I2C1 INTENCLR: SLVNOTSTRCLR Mask      */
#define I2C1_INTENCLR_SLVDESELCLR_Pos       15                                                      /*!< I2C1 INTENCLR: SLVDESELCLR Position   */
#define I2C1_INTENCLR_SLVDESELCLR_Msk       (0x01UL << I2C1_INTENCLR_SLVDESELCLR_Pos)             /*!< I2C1 INTENCLR: SLVDESELCLR Mask       */
#define I2C1_INTENCLR_MONRDYCLR_Pos         16                                                      /*!< I2C1 INTENCLR: MONRDYCLR Position     */
#define I2C1_INTENCLR_MONRDYCLR_Msk         (0x01UL << I2C1_INTENCLR_MONRDYCLR_Pos)               /*!< I2C1 INTENCLR: MONRDYCLR Mask         */
#define I2C1_INTENCLR_MONOVCLR_Pos          17                                                      /*!< I2C1 INTENCLR: MONOVCLR Position      */
#define I2C1_INTENCLR_MONOVCLR_Msk          (0x01UL << I2C1_INTENCLR_MONOVCLR_Pos)                /*!< I2C1 INTENCLR: MONOVCLR Mask          */
#define I2C1_INTENCLR_MONIDLECLR_Pos        19                                                      /*!< I2C1 INTENCLR: MONIDLECLR Position    */
#define I2C1_INTENCLR_MONIDLECLR_Msk        (0x01UL << I2C1_INTENCLR_MONIDLECLR_Pos)              /*!< I2C1 INTENCLR: MONIDLECLR Mask        */
#define I2C1_INTENCLR_EVCLRTTIMEOUTCLR_Pos  24                                                      /*!< I2C1 INTENCLR: EVCLRTTIMEOUTCLR Position */
#define I2C1_INTENCLR_EVCLRTTIMEOUTCLR_Msk  (0x01UL << I2C1_INTENCLR_EVCLRTTIMEOUTCLR_Pos)        /*!< I2C1 INTENCLR: EVCLRTTIMEOUTCLR Mask  */
#define I2C1_INTENCLR_SCLTIMEOUTCLR_Pos     25                                                      /*!< I2C1 INTENCLR: SCLTIMEOUTCLR Position */
#define I2C1_INTENCLR_SCLTIMEOUTCLR_Msk     (0x01UL << I2C1_INTENCLR_SCLTIMEOUTCLR_Pos)           /*!< I2C1 INTENCLR: SCLTIMEOUTCLR Mask     */

/* -------------------------------  u1_i2c_TIMEOUT  ------------------------------- */
#define I2C1_TIMEOUT_TOMIN_Pos              0                                                       /*!< I2C1 TIMEOUT: TOMIN Position          */
#define I2C1_TIMEOUT_TOMIN_Msk              (0x0fUL << I2C1_TIMEOUT_TOMIN_Pos)                    /*!< I2C1 TIMEOUT: TOMIN Mask              */
#define I2C1_TIMEOUT_TO_Pos                 4                                                       /*!< I2C1 TIMEOUT: TO Position             */
#define I2C1_TIMEOUT_TO_Msk                 (0x00000fffUL << I2C1_TIMEOUT_TO_Pos)                 /*!< I2C1 TIMEOUT: TO Mask                 */

/* --------------------------------  u1_i2c_CLKDIV  ------------------------------- */
#define I2C1_CLKDIV_DIVVAL_Pos              0                                                       /*!< I2C1 CLKDIV: DIVVAL Position          */
#define I2C1_CLKDIV_DIVVAL_Msk              (0x0000ffffUL << I2C1_CLKDIV_DIVVAL_Pos)              /*!< I2C1 CLKDIV: DIVVAL Mask              */

/* -------------------------------  u1_i2c_INTSTAT  ------------------------------- */
#define I2C1_INTSTAT_MSTPDING_Pos           0                                                       /*!< I2C1 INTSTAT: MSTPDING Position       */
#define I2C1_INTSTAT_MSTPDING_Msk           (0x01UL << I2C1_INTSTAT_MSTPDING_Pos)                 /*!< I2C1 INTSTAT: MSTPDING Mask           */
#define I2C1_INTSTAT_MSTARBLOSS_Pos         4                                                       /*!< I2C1 INTSTAT: MSTARBLOSS Position     */
#define I2C1_INTSTAT_MSTARBLOSS_Msk         (0x01UL << I2C1_INTSTAT_MSTARBLOSS_Pos)               /*!< I2C1 INTSTAT: MSTARBLOSS Mask         */
#define I2C1_INTSTAT_MSTSTSTPERR_Pos        6                                                       /*!< I2C1 INTSTAT: MSTSTSTPERR Position    */
#define I2C1_INTSTAT_MSTSTSTPERR_Msk        (0x01UL << I2C1_INTSTAT_MSTSTSTPERR_Pos)              /*!< I2C1 INTSTAT: MSTSTSTPERR Mask        */
#define I2C1_INTSTAT_SLVPENDING_Pos         8                                                       /*!< I2C1 INTSTAT: SLVPENDING Position     */
#define I2C1_INTSTAT_SLVPENDING_Msk         (0x01UL << I2C1_INTSTAT_SLVPENDING_Pos)               /*!< I2C1 INTSTAT: SLVPENDING Mask         */
#define I2C1_INTSTAT_SLVNOTSTR_Pos          11                                                      /*!< I2C1 INTSTAT: SLVNOTSTR Position      */
#define I2C1_INTSTAT_SLVNOTSTR_Msk          (0x01UL << I2C1_INTSTAT_SLVNOTSTR_Pos)                /*!< I2C1 INTSTAT: SLVNOTSTR Mask          */
#define I2C1_INTSTAT_SLVDESEL_Pos           15                                                      /*!< I2C1 INTSTAT: SLVDESEL Position       */
#define I2C1_INTSTAT_SLVDESEL_Msk           (0x01UL << I2C1_INTSTAT_SLVDESEL_Pos)                 /*!< I2C1 INTSTAT: SLVDESEL Mask           */
#define I2C1_INTSTAT_MONRDY_Pos             16                                                      /*!< I2C1 INTSTAT: MONRDY Position         */
#define I2C1_INTSTAT_MONRDY_Msk             (0x01UL << I2C1_INTSTAT_MONRDY_Pos)                   /*!< I2C1 INTSTAT: MONRDY Mask             */
#define I2C1_INTSTAT_MONOV_Pos              17                                                      /*!< I2C1 INTSTAT: MONOV Position          */
#define I2C1_INTSTAT_MONOV_Msk              (0x01UL << I2C1_INTSTAT_MONOV_Pos)                    /*!< I2C1 INTSTAT: MONOV Mask              */
#define I2C1_INTSTAT_MONIDLE_Pos            19                                                      /*!< I2C1 INTSTAT: MONIDLE Position        */
#define I2C1_INTSTAT_MONIDLE_Msk            (0x01UL << I2C1_INTSTAT_MONIDLE_Pos)                  /*!< I2C1 INTSTAT: MONIDLE Mask            */
#define I2C1_INTSTAT_EVTTIMEOUT_Pos         24                                                      /*!< I2C1 INTSTAT: EVTTIMEOUT Position     */
#define I2C1_INTSTAT_EVTTIMEOUT_Msk         (0x01UL << I2C1_INTSTAT_EVTTIMEOUT_Pos)               /*!< I2C1 INTSTAT: EVTTIMEOUT Mask         */
#define I2C1_INTSTAT_SCLTIMEOUT_Pos         25                                                      /*!< I2C1 INTSTAT: SCLTIMEOUT Position     */
#define I2C1_INTSTAT_SCLTIMEOUT_Msk         (0x01UL << I2C1_INTSTAT_SCLTIMEOUT_Pos)               /*!< I2C1 INTSTAT: SCLTIMEOUT Mask         */

/* --------------------------------  u1_i2c_MSTCTL  ------------------------------- */
#define I2C1_MSTCTL_MSTCONTINUE_Pos         0                                                       /*!< I2C1 MSTCTL: MSTCONTINUE Position     */
#define I2C1_MSTCTL_MSTCONTINUE_Msk         (0x01UL << I2C1_MSTCTL_MSTCONTINUE_Pos)               /*!< I2C1 MSTCTL: MSTCONTINUE Mask         */
#define I2C1_MSTCTL_MSTSTART_Pos            1                                                       /*!< I2C1 MSTCTL: MSTSTART Position        */
#define I2C1_MSTCTL_MSTSTART_Msk            (0x01UL << I2C1_MSTCTL_MSTSTART_Pos)                  /*!< I2C1 MSTCTL: MSTSTART Mask            */
#define I2C1_MSTCTL_MSTSTOP_Pos             2                                                       /*!< I2C1 MSTCTL: MSTSTOP Position         */
#define I2C1_MSTCTL_MSTSTOP_Msk             (0x01UL << I2C1_MSTCTL_MSTSTOP_Pos)                   /*!< I2C1 MSTCTL: MSTSTOP Mask             */
#define I2C1_MSTCTL_MSTDMA_Pos              3                                                       /*!< I2C1 MSTCTL: MSTDMA Position          */
#define I2C1_MSTCTL_MSTDMA_Msk              (0x01UL << I2C1_MSTCTL_MSTDMA_Pos)                    /*!< I2C1 MSTCTL: MSTDMA Mask              */

/* -------------------------------  u1_i2c_MSTTIME  ------------------------------- */
#define I2C1_MSTTIME_MSTSCLLOW_Pos          0                                                       /*!< I2C1 MSTTIME: MSTSCLLOW Position      */
#define I2C1_MSTTIME_MSTSCLLOW_Msk          (0x07UL << I2C1_MSTTIME_MSTSCLLOW_Pos)                /*!< I2C1 MSTTIME: MSTSCLLOW Mask          */
#define I2C1_MSTTIME_MSTSCLHIGH_Pos         4                                                       /*!< I2C1 MSTTIME: MSTSCLHIGH Position     */
#define I2C1_MSTTIME_MSTSCLHIGH_Msk         (0x07UL << I2C1_MSTTIME_MSTSCLHIGH_Pos)               /*!< I2C1 MSTTIME: MSTSCLHIGH Mask         */

/* --------------------------------  u1_i2c_MSTDAT  ------------------------------- */
#define I2C1_MSTDAT_DATA_Pos                0                                                       /*!< I2C1 MSTDAT: DATA Position            */
#define I2C1_MSTDAT_DATA_Msk                (0x000000ffUL << I2C1_MSTDAT_DATA_Pos)                /*!< I2C1 MSTDAT: DATA Mask                */

/* --------------------------------  u1_i2c_SLVCTL  ------------------------------- */
#define I2C1_SLVCTL_SLVCONTINUE_Pos         0                                                       /*!< I2C1 SLVCTL: SLVCONTINUE Position     */
#define I2C1_SLVCTL_SLVCONTINUE_Msk         (0x01UL << I2C1_SLVCTL_SLVCONTINUE_Pos)               /*!< I2C1 SLVCTL: SLVCONTINUE Mask         */
#define I2C1_SLVCTL_SLVNACK_Pos             1                                                       /*!< I2C1 SLVCTL: SLVNACK Position         */
#define I2C1_SLVCTL_SLVNACK_Msk             (0x01UL << I2C1_SLVCTL_SLVNACK_Pos)                   /*!< I2C1 SLVCTL: SLVNACK Mask             */
#define I2C1_SLVCTL_SLVDMA_Pos              3                                                       /*!< I2C1 SLVCTL: SLVDMA Position          */
#define I2C1_SLVCTL_SLVDMA_Msk              (0x01UL << I2C1_SLVCTL_SLVDMA_Pos)                    /*!< I2C1 SLVCTL: SLVDMA Mask              */
#define I2C1_SLVCTL_AUTOACK_Pos             8                                                       /*!< I2C1 SLVCTL: AUTOACK Position         */
#define I2C1_SLVCTL_AUTOACK_Msk             (0x01UL << I2C1_SLVCTL_AUTOACK_Pos)                   /*!< I2C1 SLVCTL: AUTOACK Mask             */
#define I2C1_SLVCTL_AUTOMATCHREAD_Pos       9                                                       /*!< I2C1 SLVCTL: AUTOMATCHREAD Position   */
#define I2C1_SLVCTL_AUTOMATCHREAD_Msk       (0x01UL << I2C1_SLVCTL_AUTOMATCHREAD_Pos)             /*!< I2C1 SLVCTL: AUTOMATCHREAD Mask       */

/* --------------------------------  u1_i2c_SLVDAT  ------------------------------- */
#define I2C1_SLVDAT_DATA_Pos                0                                                       /*!< I2C1 SLVDAT: DATA Position            */
#define I2C1_SLVDAT_DATA_Msk                (0x000000ffUL << I2C1_SLVDAT_DATA_Pos)                /*!< I2C1 SLVDAT: DATA Mask                */

/* -------------------------------  u1_i2c_SLVADR0  ------------------------------- */
#define I2C1_SLVADR0_SADISABLE0_Pos         0                                                       /*!< I2C1 SLVADR0: SADISABLE0 Position     */
#define I2C1_SLVADR0_SADISABLE0_Msk         (0x01UL << I2C1_SLVADR0_SADISABLE0_Pos)               /*!< I2C1 SLVADR0: SADISABLE0 Mask         */
#define I2C1_SLVADR0_SLVADR0_Pos            1                                                       /*!< I2C1 SLVADR0: SLVADR0 Position        */
#define I2C1_SLVADR0_SLVADR0_Msk            (0x7fUL << I2C1_SLVADR0_SLVADR0_Pos)                  /*!< I2C1 SLVADR0: SLVADR0 Mask            */
#define I2C1_SLVADR0_AUTONACK_Pos           15                                                      /*!< I2C1 SLVADR0: AUTONACK Position       */
#define I2C1_SLVADR0_AUTONACK_Msk           (0x01UL << I2C1_SLVADR0_AUTONACK_Pos)                 /*!< I2C1 SLVADR0: AUTONACK Mask           */

/* -------------------------------  u1_i2c_SLVADR1  ------------------------------- */
#define I2C1_SLVADR1_SADISABLE_Pos          0                                                       /*!< I2C1 SLVADR1: SADISABLE Position      */
#define I2C1_SLVADR1_SADISABLE_Msk          (0x01UL << I2C1_SLVADR1_SADISABLE_Pos)                /*!< I2C1 SLVADR1: SADISABLE Mask          */
#define I2C1_SLVADR1_SLVADR_Pos             1                                                       /*!< I2C1 SLVADR1: SLVADR Position         */
#define I2C1_SLVADR1_SLVADR_Msk             (0x7fUL << I2C1_SLVADR1_SLVADR_Pos)                   /*!< I2C1 SLVADR1: SLVADR Mask             */

/* -------------------------------  u1_i2c_SLVADR2  ------------------------------- */
#define I2C1_SLVADR2_SADISABLE_Pos          0                                                       /*!< I2C1 SLVADR2: SADISABLE Position      */
#define I2C1_SLVADR2_SADISABLE_Msk          (0x01UL << I2C1_SLVADR2_SADISABLE_Pos)                /*!< I2C1 SLVADR2: SADISABLE Mask          */
#define I2C1_SLVADR2_SLVADR_Pos             1                                                       /*!< I2C1 SLVADR2: SLVADR Position         */
#define I2C1_SLVADR2_SLVADR_Msk             (0x7fUL << I2C1_SLVADR2_SLVADR_Pos)                   /*!< I2C1 SLVADR2: SLVADR Mask             */

/* -------------------------------  u1_i2c_SLVADR3  ------------------------------- */
#define I2C1_SLVADR3_SADISABLE_Pos          0                                                       /*!< I2C1 SLVADR3: SADISABLE Position      */
#define I2C1_SLVADR3_SADISABLE_Msk          (0x01UL << I2C1_SLVADR3_SADISABLE_Pos)                /*!< I2C1 SLVADR3: SADISABLE Mask          */
#define I2C1_SLVADR3_SLVADR_Pos             1                                                       /*!< I2C1 SLVADR3: SLVADR Position         */
#define I2C1_SLVADR3_SLVADR_Msk             (0x7fUL << I2C1_SLVADR3_SLVADR_Pos)                   /*!< I2C1 SLVADR3: SLVADR Mask             */

/* -------------------------------  u1_i2c_SLVQUAL0  ------------------------------ */
#define I2C1_SLVQUAL0_QUALMODE0_Pos         0                                                       /*!< I2C1 SLVQUAL0: QUALMODE0 Position     */
#define I2C1_SLVQUAL0_QUALMODE0_Msk         (0x01UL << I2C1_SLVQUAL0_QUALMODE0_Pos)               /*!< I2C1 SLVQUAL0: QUALMODE0 Mask         */
#define I2C1_SLVQUAL0_SLVQUAL0_Pos          1                                                       /*!< I2C1 SLVQUAL0: SLVQUAL0 Position      */
#define I2C1_SLVQUAL0_SLVQUAL0_Msk          (0x7fUL << I2C1_SLVQUAL0_SLVQUAL0_Pos)                /*!< I2C1 SLVQUAL0: SLVQUAL0 Mask          */

/* -------------------------------  u1_i2c_MONRXDAT  ------------------------------ */
#define I2C1_MONRXDAT_MONRXDAT_Pos          0                                                       /*!< I2C1 MONRXDAT: MONRXDAT Position      */
#define I2C1_MONRXDAT_MONRXDAT_Msk          (0x000000ffUL << I2C1_MONRXDAT_MONRXDAT_Pos)          /*!< I2C1 MONRXDAT: MONRXDAT Mask          */
#define I2C1_MONRXDAT_MONSTART_Pos          8                                                       /*!< I2C1 MONRXDAT: MONSTART Position      */
#define I2C1_MONRXDAT_MONSTART_Msk          (0x01UL << I2C1_MONRXDAT_MONSTART_Pos)                /*!< I2C1 MONRXDAT: MONSTART Mask          */
#define I2C1_MONRXDAT_MONRESTART_Pos        9                                                       /*!< I2C1 MONRXDAT: MONRESTART Position    */
#define I2C1_MONRXDAT_MONRESTART_Msk        (0x01UL << I2C1_MONRXDAT_MONRESTART_Pos)              /*!< I2C1 MONRXDAT: MONRESTART Mask        */
#define I2C1_MONRXDAT_MONNACK_Pos           10                                                      /*!< I2C1 MONRXDAT: MONNACK Position       */
#define I2C1_MONRXDAT_MONNACK_Msk           (0x01UL << I2C1_MONRXDAT_MONNACK_Pos)                 /*!< I2C1 MONRXDAT: MONNACK Mask           */

/* ----------------------------------  u1_i2c_ID  --------------------------------- */
#define I2C1_ID_APERTURE_Pos                0                                                       /*!< I2C1 ID: APERTURE Position            */
#define I2C1_ID_APERTURE_Msk                (0x000000ffUL << I2C1_ID_APERTURE_Pos)                /*!< I2C1 ID: APERTURE Mask                */
#define I2C1_ID_MIN_REV_Pos                 8                                                       /*!< I2C1 ID: MIN_REV Position             */
#define I2C1_ID_MIN_REV_Msk                 (0x0fUL << I2C1_ID_MIN_REV_Pos)                       /*!< I2C1 ID: MIN_REV Mask                 */
#define I2C1_ID_MAJ_REV_Pos                 12                                                      /*!< I2C1 ID: MAJ_REV Position             */
#define I2C1_ID_MAJ_REV_Msk                 (0x0fUL << I2C1_ID_MAJ_REV_Pos)                       /*!< I2C1 ID: MAJ_REV Mask                 */
#define I2C1_ID_ID_Pos                      16                                                      /*!< I2C1 ID: ID Position                  */
#define I2C1_ID_ID_Msk                      (0x0000ffffUL << I2C1_ID_ID_Pos)                      /*!< I2C1 ID: ID Mask                      */


/* ================================================================================ */
/* ================         struct 'u2_i2c' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u2_i2c_CFG  --------------------------------- */
#define I2C2_CFG_MSTEN_Pos                  0                                                       /*!< I2C2 CFG: MSTEN Position              */
#define I2C2_CFG_MSTEN_Msk                  (0x01UL << I2C2_CFG_MSTEN_Pos)                        /*!< I2C2 CFG: MSTEN Mask                  */
#define I2C2_CFG_SLVEN_Pos                  1                                                       /*!< I2C2 CFG: SLVEN Position              */
#define I2C2_CFG_SLVEN_Msk                  (0x01UL << I2C2_CFG_SLVEN_Pos)                        /*!< I2C2 CFG: SLVEN Mask                  */
#define I2C2_CFG_MONEN_Pos                  2                                                       /*!< I2C2 CFG: MONEN Position              */
#define I2C2_CFG_MONEN_Msk                  (0x01UL << I2C2_CFG_MONEN_Pos)                        /*!< I2C2 CFG: MONEN Mask                  */
#define I2C2_CFG_TIMEOUT_Pos                3                                                       /*!< I2C2 CFG: TIMEOUT Position            */
#define I2C2_CFG_TIMEOUT_Msk                (0x01UL << I2C2_CFG_TIMEOUT_Pos)                      /*!< I2C2 CFG: TIMEOUT Mask                */
#define I2C2_CFG_MONCLKSTR_Pos              4                                                       /*!< I2C2 CFG: MONCLKSTR Position          */
#define I2C2_CFG_MONCLKSTR_Msk              (0x01UL << I2C2_CFG_MONCLKSTR_Pos)                    /*!< I2C2 CFG: MONCLKSTR Mask              */
#define I2C2_CFG_HSCAPABLE_Pos              5                                                       /*!< I2C2 CFG: HSCAPABLE Position          */
#define I2C2_CFG_HSCAPABLE_Msk              (0x01UL << I2C2_CFG_HSCAPABLE_Pos)                    /*!< I2C2 CFG: HSCAPABLE Mask              */

/* ---------------------------------  u2_i2c_STAT  -------------------------------- */
#define I2C2_STAT_MSTPENDING_Pos            0                                                       /*!< I2C2 STAT: MSTPENDING Position        */
#define I2C2_STAT_MSTPENDING_Msk            (0x01UL << I2C2_STAT_MSTPENDING_Pos)                  /*!< I2C2 STAT: MSTPENDING Mask            */
#define I2C2_STAT_MSTSTATE_Pos              1                                                       /*!< I2C2 STAT: MSTSTATE Position          */
#define I2C2_STAT_MSTSTATE_Msk              (0x07UL << I2C2_STAT_MSTSTATE_Pos)                    /*!< I2C2 STAT: MSTSTATE Mask              */
#define I2C2_STAT_MSTARBLOSS_Pos            4                                                       /*!< I2C2 STAT: MSTARBLOSS Position        */
#define I2C2_STAT_MSTARBLOSS_Msk            (0x01UL << I2C2_STAT_MSTARBLOSS_Pos)                  /*!< I2C2 STAT: MSTARBLOSS Mask            */
#define I2C2_STAT_MSTSTSTPERR_Pos           6                                                       /*!< I2C2 STAT: MSTSTSTPERR Position       */
#define I2C2_STAT_MSTSTSTPERR_Msk           (0x01UL << I2C2_STAT_MSTSTSTPERR_Pos)                 /*!< I2C2 STAT: MSTSTSTPERR Mask           */
#define I2C2_STAT_SLVPENDING_Pos            8                                                       /*!< I2C2 STAT: SLVPENDING Position        */
#define I2C2_STAT_SLVPENDING_Msk            (0x01UL << I2C2_STAT_SLVPENDING_Pos)                  /*!< I2C2 STAT: SLVPENDING Mask            */
#define I2C2_STAT_SLVSTATE_Pos              9                                                       /*!< I2C2 STAT: SLVSTATE Position          */
#define I2C2_STAT_SLVSTATE_Msk              (0x03UL << I2C2_STAT_SLVSTATE_Pos)                    /*!< I2C2 STAT: SLVSTATE Mask              */
#define I2C2_STAT_SLVNOTSTR_Pos             11                                                      /*!< I2C2 STAT: SLVNOTSTR Position         */
#define I2C2_STAT_SLVNOTSTR_Msk             (0x01UL << I2C2_STAT_SLVNOTSTR_Pos)                   /*!< I2C2 STAT: SLVNOTSTR Mask             */
#define I2C2_STAT_SLVIDX_Pos                12                                                      /*!< I2C2 STAT: SLVIDX Position            */
#define I2C2_STAT_SLVIDX_Msk                (0x03UL << I2C2_STAT_SLVIDX_Pos)                      /*!< I2C2 STAT: SLVIDX Mask                */
#define I2C2_STAT_SLVSEL_Pos                14                                                      /*!< I2C2 STAT: SLVSEL Position            */
#define I2C2_STAT_SLVSEL_Msk                (0x01UL << I2C2_STAT_SLVSEL_Pos)                      /*!< I2C2 STAT: SLVSEL Mask                */
#define I2C2_STAT_SLVDESEL_Pos              15                                                      /*!< I2C2 STAT: SLVDESEL Position          */
#define I2C2_STAT_SLVDESEL_Msk              (0x01UL << I2C2_STAT_SLVDESEL_Pos)                    /*!< I2C2 STAT: SLVDESEL Mask              */
#define I2C2_STAT_MONRDY_Pos                16                                                      /*!< I2C2 STAT: MONRDY Position            */
#define I2C2_STAT_MONRDY_Msk                (0x01UL << I2C2_STAT_MONRDY_Pos)                      /*!< I2C2 STAT: MONRDY Mask                */
#define I2C2_STAT_MONOV_Pos                 17                                                      /*!< I2C2 STAT: MONOV Position             */
#define I2C2_STAT_MONOV_Msk                 (0x01UL << I2C2_STAT_MONOV_Pos)                       /*!< I2C2 STAT: MONOV Mask                 */
#define I2C2_STAT_MONACTIVE_Pos             18                                                      /*!< I2C2 STAT: MONACTIVE Position         */
#define I2C2_STAT_MONACTIVE_Msk             (0x01UL << I2C2_STAT_MONACTIVE_Pos)                   /*!< I2C2 STAT: MONACTIVE Mask             */
#define I2C2_STAT_MONIDLE_Pos               19                                                      /*!< I2C2 STAT: MONIDLE Position           */
#define I2C2_STAT_MONIDLE_Msk               (0x01UL << I2C2_STAT_MONIDLE_Pos)                     /*!< I2C2 STAT: MONIDLE Mask               */
#define I2C2_STAT_EVENTTIMEOUT_Pos          24                                                      /*!< I2C2 STAT: EVENTTIMEOUT Position      */
#define I2C2_STAT_EVENTTIMEOUT_Msk          (0x01UL << I2C2_STAT_EVENTTIMEOUT_Pos)                /*!< I2C2 STAT: EVENTTIMEOUT Mask          */
#define I2C2_STAT_SCLTIMEOUT_Pos            25                                                      /*!< I2C2 STAT: SCLTIMEOUT Position        */
#define I2C2_STAT_SCLTIMEOUT_Msk            (0x01UL << I2C2_STAT_SCLTIMEOUT_Pos)                  /*!< I2C2 STAT: SCLTIMEOUT Mask            */

/* -------------------------------  u2_i2c_INTENSET  ------------------------------ */
#define I2C2_INTENSET_MSTPENDINGEN_Pos      0                                                       /*!< I2C2 INTENSET: MSTPENDINGEN Position  */
#define I2C2_INTENSET_MSTPENDINGEN_Msk      (0x01UL << I2C2_INTENSET_MSTPENDINGEN_Pos)            /*!< I2C2 INTENSET: MSTPENDINGEN Mask      */
#define I2C2_INTENSET_MSTARBLOSSEN_Pos      4                                                       /*!< I2C2 INTENSET: MSTARBLOSSEN Position  */
#define I2C2_INTENSET_MSTARBLOSSEN_Msk      (0x01UL << I2C2_INTENSET_MSTARBLOSSEN_Pos)            /*!< I2C2 INTENSET: MSTARBLOSSEN Mask      */
#define I2C2_INTENSET_MSTSTSTPERREN_Pos     6                                                       /*!< I2C2 INTENSET: MSTSTSTPERREN Position */
#define I2C2_INTENSET_MSTSTSTPERREN_Msk     (0x01UL << I2C2_INTENSET_MSTSTSTPERREN_Pos)           /*!< I2C2 INTENSET: MSTSTSTPERREN Mask     */
#define I2C2_INTENSET_SLVPENDINGEN_Pos      8                                                       /*!< I2C2 INTENSET: SLVPENDINGEN Position  */
#define I2C2_INTENSET_SLVPENDINGEN_Msk      (0x01UL << I2C2_INTENSET_SLVPENDINGEN_Pos)            /*!< I2C2 INTENSET: SLVPENDINGEN Mask      */
#define I2C2_INTENSET_SLVNOTSTREN_Pos       11                                                      /*!< I2C2 INTENSET: SLVNOTSTREN Position   */
#define I2C2_INTENSET_SLVNOTSTREN_Msk       (0x01UL << I2C2_INTENSET_SLVNOTSTREN_Pos)             /*!< I2C2 INTENSET: SLVNOTSTREN Mask       */
#define I2C2_INTENSET_SLVDESELEN_Pos        15                                                      /*!< I2C2 INTENSET: SLVDESELEN Position    */
#define I2C2_INTENSET_SLVDESELEN_Msk        (0x01UL << I2C2_INTENSET_SLVDESELEN_Pos)              /*!< I2C2 INTENSET: SLVDESELEN Mask        */
#define I2C2_INTENSET_MONRDYEN_Pos          16                                                      /*!< I2C2 INTENSET: MONRDYEN Position      */
#define I2C2_INTENSET_MONRDYEN_Msk          (0x01UL << I2C2_INTENSET_MONRDYEN_Pos)                /*!< I2C2 INTENSET: MONRDYEN Mask          */
#define I2C2_INTENSET_MONOVEN_Pos           17                                                      /*!< I2C2 INTENSET: MONOVEN Position       */
#define I2C2_INTENSET_MONOVEN_Msk           (0x01UL << I2C2_INTENSET_MONOVEN_Pos)                 /*!< I2C2 INTENSET: MONOVEN Mask           */
#define I2C2_INTENSET_MONIDLEEN_Pos         19                                                      /*!< I2C2 INTENSET: MONIDLEEN Position     */
#define I2C2_INTENSET_MONIDLEEN_Msk         (0x01UL << I2C2_INTENSET_MONIDLEEN_Pos)               /*!< I2C2 INTENSET: MONIDLEEN Mask         */
#define I2C2_INTENSET_EVENTTIMEOUTEN_Pos    24                                                      /*!< I2C2 INTENSET: EVENTTIMEOUTEN Position */
#define I2C2_INTENSET_EVENTTIMEOUTEN_Msk    (0x01UL << I2C2_INTENSET_EVENTTIMEOUTEN_Pos)          /*!< I2C2 INTENSET: EVENTTIMEOUTEN Mask    */
#define I2C2_INTENSET_SCLTIMEOUTEN_Pos      25                                                      /*!< I2C2 INTENSET: SCLTIMEOUTEN Position  */
#define I2C2_INTENSET_SCLTIMEOUTEN_Msk      (0x01UL << I2C2_INTENSET_SCLTIMEOUTEN_Pos)            /*!< I2C2 INTENSET: SCLTIMEOUTEN Mask      */

/* -------------------------------  u2_i2c_INTENCLR  ------------------------------ */
#define I2C2_INTENCLR_MSTPCLRDINGCLR_Pos    0                                                       /*!< I2C2 INTENCLR: MSTPCLRDINGCLR Position */
#define I2C2_INTENCLR_MSTPCLRDINGCLR_Msk    (0x01UL << I2C2_INTENCLR_MSTPCLRDINGCLR_Pos)          /*!< I2C2 INTENCLR: MSTPCLRDINGCLR Mask    */
#define I2C2_INTENCLR_MSTARBLOSSCLR_Pos     4                                                       /*!< I2C2 INTENCLR: MSTARBLOSSCLR Position */
#define I2C2_INTENCLR_MSTARBLOSSCLR_Msk     (0x01UL << I2C2_INTENCLR_MSTARBLOSSCLR_Pos)           /*!< I2C2 INTENCLR: MSTARBLOSSCLR Mask     */
#define I2C2_INTENCLR_MSTSTSTPERRCLR_Pos    6                                                       /*!< I2C2 INTENCLR: MSTSTSTPERRCLR Position */
#define I2C2_INTENCLR_MSTSTSTPERRCLR_Msk    (0x01UL << I2C2_INTENCLR_MSTSTSTPERRCLR_Pos)          /*!< I2C2 INTENCLR: MSTSTSTPERRCLR Mask    */
#define I2C2_INTENCLR_SLVPENDINGCLR_Pos     8                                                       /*!< I2C2 INTENCLR: SLVPENDINGCLR Position */
#define I2C2_INTENCLR_SLVPENDINGCLR_Msk     (0x01UL << I2C2_INTENCLR_SLVPENDINGCLR_Pos)           /*!< I2C2 INTENCLR: SLVPENDINGCLR Mask     */
#define I2C2_INTENCLR_SLVNOTSTRCLR_Pos      11                                                      /*!< I2C2 INTENCLR: SLVNOTSTRCLR Position  */
#define I2C2_INTENCLR_SLVNOTSTRCLR_Msk      (0x01UL << I2C2_INTENCLR_SLVNOTSTRCLR_Pos)            /*!< I2C2 INTENCLR: SLVNOTSTRCLR Mask      */
#define I2C2_INTENCLR_SLVDESELCLR_Pos       15                                                      /*!< I2C2 INTENCLR: SLVDESELCLR Position   */
#define I2C2_INTENCLR_SLVDESELCLR_Msk       (0x01UL << I2C2_INTENCLR_SLVDESELCLR_Pos)             /*!< I2C2 INTENCLR: SLVDESELCLR Mask       */
#define I2C2_INTENCLR_MONRDYCLR_Pos         16                                                      /*!< I2C2 INTENCLR: MONRDYCLR Position     */
#define I2C2_INTENCLR_MONRDYCLR_Msk         (0x01UL << I2C2_INTENCLR_MONRDYCLR_Pos)               /*!< I2C2 INTENCLR: MONRDYCLR Mask         */
#define I2C2_INTENCLR_MONOVCLR_Pos          17                                                      /*!< I2C2 INTENCLR: MONOVCLR Position      */
#define I2C2_INTENCLR_MONOVCLR_Msk          (0x01UL << I2C2_INTENCLR_MONOVCLR_Pos)                /*!< I2C2 INTENCLR: MONOVCLR Mask          */
#define I2C2_INTENCLR_MONIDLECLR_Pos        19                                                      /*!< I2C2 INTENCLR: MONIDLECLR Position    */
#define I2C2_INTENCLR_MONIDLECLR_Msk        (0x01UL << I2C2_INTENCLR_MONIDLECLR_Pos)              /*!< I2C2 INTENCLR: MONIDLECLR Mask        */
#define I2C2_INTENCLR_EVCLRTTIMEOUTCLR_Pos  24                                                      /*!< I2C2 INTENCLR: EVCLRTTIMEOUTCLR Position */
#define I2C2_INTENCLR_EVCLRTTIMEOUTCLR_Msk  (0x01UL << I2C2_INTENCLR_EVCLRTTIMEOUTCLR_Pos)        /*!< I2C2 INTENCLR: EVCLRTTIMEOUTCLR Mask  */
#define I2C2_INTENCLR_SCLTIMEOUTCLR_Pos     25                                                      /*!< I2C2 INTENCLR: SCLTIMEOUTCLR Position */
#define I2C2_INTENCLR_SCLTIMEOUTCLR_Msk     (0x01UL << I2C2_INTENCLR_SCLTIMEOUTCLR_Pos)           /*!< I2C2 INTENCLR: SCLTIMEOUTCLR Mask     */

/* -------------------------------  u2_i2c_TIMEOUT  ------------------------------- */
#define I2C2_TIMEOUT_TOMIN_Pos              0                                                       /*!< I2C2 TIMEOUT: TOMIN Position          */
#define I2C2_TIMEOUT_TOMIN_Msk              (0x0fUL << I2C2_TIMEOUT_TOMIN_Pos)                    /*!< I2C2 TIMEOUT: TOMIN Mask              */
#define I2C2_TIMEOUT_TO_Pos                 4                                                       /*!< I2C2 TIMEOUT: TO Position             */
#define I2C2_TIMEOUT_TO_Msk                 (0x00000fffUL << I2C2_TIMEOUT_TO_Pos)                 /*!< I2C2 TIMEOUT: TO Mask                 */

/* --------------------------------  u2_i2c_CLKDIV  ------------------------------- */
#define I2C2_CLKDIV_DIVVAL_Pos              0                                                       /*!< I2C2 CLKDIV: DIVVAL Position          */
#define I2C2_CLKDIV_DIVVAL_Msk              (0x0000ffffUL << I2C2_CLKDIV_DIVVAL_Pos)              /*!< I2C2 CLKDIV: DIVVAL Mask              */

/* -------------------------------  u2_i2c_INTSTAT  ------------------------------- */
#define I2C2_INTSTAT_MSTPDING_Pos           0                                                       /*!< I2C2 INTSTAT: MSTPDING Position       */
#define I2C2_INTSTAT_MSTPDING_Msk           (0x01UL << I2C2_INTSTAT_MSTPDING_Pos)                 /*!< I2C2 INTSTAT: MSTPDING Mask           */
#define I2C2_INTSTAT_MSTARBLOSS_Pos         4                                                       /*!< I2C2 INTSTAT: MSTARBLOSS Position     */
#define I2C2_INTSTAT_MSTARBLOSS_Msk         (0x01UL << I2C2_INTSTAT_MSTARBLOSS_Pos)               /*!< I2C2 INTSTAT: MSTARBLOSS Mask         */
#define I2C2_INTSTAT_MSTSTSTPERR_Pos        6                                                       /*!< I2C2 INTSTAT: MSTSTSTPERR Position    */
#define I2C2_INTSTAT_MSTSTSTPERR_Msk        (0x01UL << I2C2_INTSTAT_MSTSTSTPERR_Pos)              /*!< I2C2 INTSTAT: MSTSTSTPERR Mask        */
#define I2C2_INTSTAT_SLVPENDING_Pos         8                                                       /*!< I2C2 INTSTAT: SLVPENDING Position     */
#define I2C2_INTSTAT_SLVPENDING_Msk         (0x01UL << I2C2_INTSTAT_SLVPENDING_Pos)               /*!< I2C2 INTSTAT: SLVPENDING Mask         */
#define I2C2_INTSTAT_SLVNOTSTR_Pos          11                                                      /*!< I2C2 INTSTAT: SLVNOTSTR Position      */
#define I2C2_INTSTAT_SLVNOTSTR_Msk          (0x01UL << I2C2_INTSTAT_SLVNOTSTR_Pos)                /*!< I2C2 INTSTAT: SLVNOTSTR Mask          */
#define I2C2_INTSTAT_SLVDESEL_Pos           15                                                      /*!< I2C2 INTSTAT: SLVDESEL Position       */
#define I2C2_INTSTAT_SLVDESEL_Msk           (0x01UL << I2C2_INTSTAT_SLVDESEL_Pos)                 /*!< I2C2 INTSTAT: SLVDESEL Mask           */
#define I2C2_INTSTAT_MONRDY_Pos             16                                                      /*!< I2C2 INTSTAT: MONRDY Position         */
#define I2C2_INTSTAT_MONRDY_Msk             (0x01UL << I2C2_INTSTAT_MONRDY_Pos)                   /*!< I2C2 INTSTAT: MONRDY Mask             */
#define I2C2_INTSTAT_MONOV_Pos              17                                                      /*!< I2C2 INTSTAT: MONOV Position          */
#define I2C2_INTSTAT_MONOV_Msk              (0x01UL << I2C2_INTSTAT_MONOV_Pos)                    /*!< I2C2 INTSTAT: MONOV Mask              */
#define I2C2_INTSTAT_MONIDLE_Pos            19                                                      /*!< I2C2 INTSTAT: MONIDLE Position        */
#define I2C2_INTSTAT_MONIDLE_Msk            (0x01UL << I2C2_INTSTAT_MONIDLE_Pos)                  /*!< I2C2 INTSTAT: MONIDLE Mask            */
#define I2C2_INTSTAT_EVTTIMEOUT_Pos         24                                                      /*!< I2C2 INTSTAT: EVTTIMEOUT Position     */
#define I2C2_INTSTAT_EVTTIMEOUT_Msk         (0x01UL << I2C2_INTSTAT_EVTTIMEOUT_Pos)               /*!< I2C2 INTSTAT: EVTTIMEOUT Mask         */
#define I2C2_INTSTAT_SCLTIMEOUT_Pos         25                                                      /*!< I2C2 INTSTAT: SCLTIMEOUT Position     */
#define I2C2_INTSTAT_SCLTIMEOUT_Msk         (0x01UL << I2C2_INTSTAT_SCLTIMEOUT_Pos)               /*!< I2C2 INTSTAT: SCLTIMEOUT Mask         */

/* --------------------------------  u2_i2c_MSTCTL  ------------------------------- */
#define I2C2_MSTCTL_MSTCONTINUE_Pos         0                                                       /*!< I2C2 MSTCTL: MSTCONTINUE Position     */
#define I2C2_MSTCTL_MSTCONTINUE_Msk         (0x01UL << I2C2_MSTCTL_MSTCONTINUE_Pos)               /*!< I2C2 MSTCTL: MSTCONTINUE Mask         */
#define I2C2_MSTCTL_MSTSTART_Pos            1                                                       /*!< I2C2 MSTCTL: MSTSTART Position        */
#define I2C2_MSTCTL_MSTSTART_Msk            (0x01UL << I2C2_MSTCTL_MSTSTART_Pos)                  /*!< I2C2 MSTCTL: MSTSTART Mask            */
#define I2C2_MSTCTL_MSTSTOP_Pos             2                                                       /*!< I2C2 MSTCTL: MSTSTOP Position         */
#define I2C2_MSTCTL_MSTSTOP_Msk             (0x01UL << I2C2_MSTCTL_MSTSTOP_Pos)                   /*!< I2C2 MSTCTL: MSTSTOP Mask             */
#define I2C2_MSTCTL_MSTDMA_Pos              3                                                       /*!< I2C2 MSTCTL: MSTDMA Position          */
#define I2C2_MSTCTL_MSTDMA_Msk              (0x01UL << I2C2_MSTCTL_MSTDMA_Pos)                    /*!< I2C2 MSTCTL: MSTDMA Mask              */

/* -------------------------------  u2_i2c_MSTTIME  ------------------------------- */
#define I2C2_MSTTIME_MSTSCLLOW_Pos          0                                                       /*!< I2C2 MSTTIME: MSTSCLLOW Position      */
#define I2C2_MSTTIME_MSTSCLLOW_Msk          (0x07UL << I2C2_MSTTIME_MSTSCLLOW_Pos)                /*!< I2C2 MSTTIME: MSTSCLLOW Mask          */
#define I2C2_MSTTIME_MSTSCLHIGH_Pos         4                                                       /*!< I2C2 MSTTIME: MSTSCLHIGH Position     */
#define I2C2_MSTTIME_MSTSCLHIGH_Msk         (0x07UL << I2C2_MSTTIME_MSTSCLHIGH_Pos)               /*!< I2C2 MSTTIME: MSTSCLHIGH Mask         */

/* --------------------------------  u2_i2c_MSTDAT  ------------------------------- */
#define I2C2_MSTDAT_DATA_Pos                0                                                       /*!< I2C2 MSTDAT: DATA Position            */
#define I2C2_MSTDAT_DATA_Msk                (0x000000ffUL << I2C2_MSTDAT_DATA_Pos)                /*!< I2C2 MSTDAT: DATA Mask                */

/* --------------------------------  u2_i2c_SLVCTL  ------------------------------- */
#define I2C2_SLVCTL_SLVCONTINUE_Pos         0                                                       /*!< I2C2 SLVCTL: SLVCONTINUE Position     */
#define I2C2_SLVCTL_SLVCONTINUE_Msk         (0x01UL << I2C2_SLVCTL_SLVCONTINUE_Pos)               /*!< I2C2 SLVCTL: SLVCONTINUE Mask         */
#define I2C2_SLVCTL_SLVNACK_Pos             1                                                       /*!< I2C2 SLVCTL: SLVNACK Position         */
#define I2C2_SLVCTL_SLVNACK_Msk             (0x01UL << I2C2_SLVCTL_SLVNACK_Pos)                   /*!< I2C2 SLVCTL: SLVNACK Mask             */
#define I2C2_SLVCTL_SLVDMA_Pos              3                                                       /*!< I2C2 SLVCTL: SLVDMA Position          */
#define I2C2_SLVCTL_SLVDMA_Msk              (0x01UL << I2C2_SLVCTL_SLVDMA_Pos)                    /*!< I2C2 SLVCTL: SLVDMA Mask              */
#define I2C2_SLVCTL_AUTOACK_Pos             8                                                       /*!< I2C2 SLVCTL: AUTOACK Position         */
#define I2C2_SLVCTL_AUTOACK_Msk             (0x01UL << I2C2_SLVCTL_AUTOACK_Pos)                   /*!< I2C2 SLVCTL: AUTOACK Mask             */
#define I2C2_SLVCTL_AUTOMATCHREAD_Pos       9                                                       /*!< I2C2 SLVCTL: AUTOMATCHREAD Position   */
#define I2C2_SLVCTL_AUTOMATCHREAD_Msk       (0x01UL << I2C2_SLVCTL_AUTOMATCHREAD_Pos)             /*!< I2C2 SLVCTL: AUTOMATCHREAD Mask       */

/* --------------------------------  u2_i2c_SLVDAT  ------------------------------- */
#define I2C2_SLVDAT_DATA_Pos                0                                                       /*!< I2C2 SLVDAT: DATA Position            */
#define I2C2_SLVDAT_DATA_Msk                (0x000000ffUL << I2C2_SLVDAT_DATA_Pos)                /*!< I2C2 SLVDAT: DATA Mask                */

/* -------------------------------  u2_i2c_SLVADR0  ------------------------------- */
#define I2C2_SLVADR0_SADISABLE0_Pos         0                                                       /*!< I2C2 SLVADR0: SADISABLE0 Position     */
#define I2C2_SLVADR0_SADISABLE0_Msk         (0x01UL << I2C2_SLVADR0_SADISABLE0_Pos)               /*!< I2C2 SLVADR0: SADISABLE0 Mask         */
#define I2C2_SLVADR0_SLVADR0_Pos            1                                                       /*!< I2C2 SLVADR0: SLVADR0 Position        */
#define I2C2_SLVADR0_SLVADR0_Msk            (0x7fUL << I2C2_SLVADR0_SLVADR0_Pos)                  /*!< I2C2 SLVADR0: SLVADR0 Mask            */
#define I2C2_SLVADR0_AUTONACK_Pos           15                                                      /*!< I2C2 SLVADR0: AUTONACK Position       */
#define I2C2_SLVADR0_AUTONACK_Msk           (0x01UL << I2C2_SLVADR0_AUTONACK_Pos)                 /*!< I2C2 SLVADR0: AUTONACK Mask           */

/* -------------------------------  u2_i2c_SLVADR1  ------------------------------- */
#define I2C2_SLVADR1_SADISABLE_Pos          0                                                       /*!< I2C2 SLVADR1: SADISABLE Position      */
#define I2C2_SLVADR1_SADISABLE_Msk          (0x01UL << I2C2_SLVADR1_SADISABLE_Pos)                /*!< I2C2 SLVADR1: SADISABLE Mask          */
#define I2C2_SLVADR1_SLVADR_Pos             1                                                       /*!< I2C2 SLVADR1: SLVADR Position         */
#define I2C2_SLVADR1_SLVADR_Msk             (0x7fUL << I2C2_SLVADR1_SLVADR_Pos)                   /*!< I2C2 SLVADR1: SLVADR Mask             */

/* -------------------------------  u2_i2c_SLVADR2  ------------------------------- */
#define I2C2_SLVADR2_SADISABLE_Pos          0                                                       /*!< I2C2 SLVADR2: SADISABLE Position      */
#define I2C2_SLVADR2_SADISABLE_Msk          (0x01UL << I2C2_SLVADR2_SADISABLE_Pos)                /*!< I2C2 SLVADR2: SADISABLE Mask          */
#define I2C2_SLVADR2_SLVADR_Pos             1                                                       /*!< I2C2 SLVADR2: SLVADR Position         */
#define I2C2_SLVADR2_SLVADR_Msk             (0x7fUL << I2C2_SLVADR2_SLVADR_Pos)                   /*!< I2C2 SLVADR2: SLVADR Mask             */

/* -------------------------------  u2_i2c_SLVADR3  ------------------------------- */
#define I2C2_SLVADR3_SADISABLE_Pos          0                                                       /*!< I2C2 SLVADR3: SADISABLE Position      */
#define I2C2_SLVADR3_SADISABLE_Msk          (0x01UL << I2C2_SLVADR3_SADISABLE_Pos)                /*!< I2C2 SLVADR3: SADISABLE Mask          */
#define I2C2_SLVADR3_SLVADR_Pos             1                                                       /*!< I2C2 SLVADR3: SLVADR Position         */
#define I2C2_SLVADR3_SLVADR_Msk             (0x7fUL << I2C2_SLVADR3_SLVADR_Pos)                   /*!< I2C2 SLVADR3: SLVADR Mask             */

/* -------------------------------  u2_i2c_SLVQUAL0  ------------------------------ */
#define I2C2_SLVQUAL0_QUALMODE0_Pos         0                                                       /*!< I2C2 SLVQUAL0: QUALMODE0 Position     */
#define I2C2_SLVQUAL0_QUALMODE0_Msk         (0x01UL << I2C2_SLVQUAL0_QUALMODE0_Pos)               /*!< I2C2 SLVQUAL0: QUALMODE0 Mask         */
#define I2C2_SLVQUAL0_SLVQUAL0_Pos          1                                                       /*!< I2C2 SLVQUAL0: SLVQUAL0 Position      */
#define I2C2_SLVQUAL0_SLVQUAL0_Msk          (0x7fUL << I2C2_SLVQUAL0_SLVQUAL0_Pos)                /*!< I2C2 SLVQUAL0: SLVQUAL0 Mask          */

/* -------------------------------  u2_i2c_MONRXDAT  ------------------------------ */
#define I2C2_MONRXDAT_MONRXDAT_Pos          0                                                       /*!< I2C2 MONRXDAT: MONRXDAT Position      */
#define I2C2_MONRXDAT_MONRXDAT_Msk          (0x000000ffUL << I2C2_MONRXDAT_MONRXDAT_Pos)          /*!< I2C2 MONRXDAT: MONRXDAT Mask          */
#define I2C2_MONRXDAT_MONSTART_Pos          8                                                       /*!< I2C2 MONRXDAT: MONSTART Position      */
#define I2C2_MONRXDAT_MONSTART_Msk          (0x01UL << I2C2_MONRXDAT_MONSTART_Pos)                /*!< I2C2 MONRXDAT: MONSTART Mask          */
#define I2C2_MONRXDAT_MONRESTART_Pos        9                                                       /*!< I2C2 MONRXDAT: MONRESTART Position    */
#define I2C2_MONRXDAT_MONRESTART_Msk        (0x01UL << I2C2_MONRXDAT_MONRESTART_Pos)              /*!< I2C2 MONRXDAT: MONRESTART Mask        */
#define I2C2_MONRXDAT_MONNACK_Pos           10                                                      /*!< I2C2 MONRXDAT: MONNACK Position       */
#define I2C2_MONRXDAT_MONNACK_Msk           (0x01UL << I2C2_MONRXDAT_MONNACK_Pos)                 /*!< I2C2 MONRXDAT: MONNACK Mask           */

/* ----------------------------------  u2_i2c_ID  --------------------------------- */
#define I2C2_ID_APERTURE_Pos                0                                                       /*!< I2C2 ID: APERTURE Position            */
#define I2C2_ID_APERTURE_Msk                (0x000000ffUL << I2C2_ID_APERTURE_Pos)                /*!< I2C2 ID: APERTURE Mask                */
#define I2C2_ID_MIN_REV_Pos                 8                                                       /*!< I2C2 ID: MIN_REV Position             */
#define I2C2_ID_MIN_REV_Msk                 (0x0fUL << I2C2_ID_MIN_REV_Pos)                       /*!< I2C2 ID: MIN_REV Mask                 */
#define I2C2_ID_MAJ_REV_Pos                 12                                                      /*!< I2C2 ID: MAJ_REV Position             */
#define I2C2_ID_MAJ_REV_Msk                 (0x0fUL << I2C2_ID_MAJ_REV_Pos)                       /*!< I2C2 ID: MAJ_REV Mask                 */
#define I2C2_ID_ID_Pos                      16                                                      /*!< I2C2 ID: ID Position                  */
#define I2C2_ID_ID_Msk                      (0x0000ffffUL << I2C2_ID_ID_Pos)                      /*!< I2C2 ID: ID Mask                      */


/* ================================================================================ */
/* ================       struct 'u_iso7816' Position & Mask       ================ */
/* ================================================================================ */


/* --------------------------------  u_iso7816_SSR  ------------------------------- */
#define ISO7816_SSR_SOFTRESETN_Pos          0                                                       /*!< ISO7816 SSR: SOFTRESETN Position      */
#define ISO7816_SSR_SOFTRESETN_Msk          (0x01UL << ISO7816_SSR_SOFTRESETN_Pos)                /*!< ISO7816 SSR: SOFTRESETN Mask          */

/* -----------------------------  u_iso7816_PDR1_LSB  ----------------------------- */
#define ISO7816_PDR1_LSB_PDR1_LSB_Pos       0                                                       /*!< ISO7816 PDR1_LSB: PDR1_LSB Position   */
#define ISO7816_PDR1_LSB_PDR1_LSB_Msk       (0xffffffffUL << ISO7816_PDR1_LSB_PDR1_LSB_Pos)       /*!< ISO7816 PDR1_LSB: PDR1_LSB Mask       */

/* -----------------------------  u_iso7816_PDR1_MSB  ----------------------------- */
#define ISO7816_PDR1_MSB_PDR1_MSB_Pos       0                                                       /*!< ISO7816 PDR1_MSB: PDR1_MSB Position   */
#define ISO7816_PDR1_MSB_PDR1_MSB_Msk       (0xffffffffUL << ISO7816_PDR1_MSB_PDR1_MSB_Pos)       /*!< ISO7816 PDR1_MSB: PDR1_MSB Mask       */

/* --------------------------------  u_iso7816_FCR  ------------------------------- */
#define ISO7816_FCR_FTC_Pos                 0                                                       /*!< ISO7816 FCR: FTC Position             */
#define ISO7816_FCR_FTC_Msk                 (0x1fUL << ISO7816_FCR_FTC_Pos)                       /*!< ISO7816 FCR: FTC Mask                 */
#define ISO7816_FCR_PEC_Pos                 5                                                       /*!< ISO7816 FCR: PEC Position             */
#define ISO7816_FCR_PEC_Msk                 (0x07UL << ISO7816_FCR_PEC_Pos)                       /*!< ISO7816 FCR: PEC Mask                 */

/* -------------------------------  u_iso7816_GTR1  ------------------------------- */
#define ISO7816_GTR1_GTR1_Pos               0                                                       /*!< ISO7816 GTR1: GTR1 Position           */
#define ISO7816_GTR1_GTR1_Msk               (0xffffffffUL << ISO7816_GTR1_GTR1_Pos)               /*!< ISO7816 GTR1: GTR1 Mask               */

/* -------------------------------  u_iso7816_UCR11  ------------------------------ */
#define ISO7816_UCR11_CONV_Pos              0                                                       /*!< ISO7816 UCR11: CONV Position          */
#define ISO7816_UCR11_CONV_Msk              (0x01UL << ISO7816_UCR11_CONV_Pos)                    /*!< ISO7816 UCR11: CONV Mask              */
#define ISO7816_UCR11_LCT_Pos               1                                                       /*!< ISO7816 UCR11: LCT Position           */
#define ISO7816_UCR11_LCT_Msk               (0x01UL << ISO7816_UCR11_LCT_Pos)                     /*!< ISO7816 UCR11: LCT Mask               */
#define ISO7816_UCR11_T_R_Pos               2                                                       /*!< ISO7816 UCR11: T_R Position           */
#define ISO7816_UCR11_T_R_Msk               (0x01UL << ISO7816_UCR11_T_R_Pos)                     /*!< ISO7816 UCR11: T_R Mask               */
#define ISO7816_UCR11_PROT_Pos              3                                                       /*!< ISO7816 UCR11: PROT Position          */
#define ISO7816_UCR11_PROT_Msk              (0x01UL << ISO7816_UCR11_PROT_Pos)                    /*!< ISO7816 UCR11: PROT Mask              */
#define ISO7816_UCR11_FC_Pos                4                                                       /*!< ISO7816 UCR11: FC Position            */
#define ISO7816_UCR11_FC_Msk                (0x01UL << ISO7816_UCR11_FC_Pos)                      /*!< ISO7816 UCR11: FC Mask                */
#define ISO7816_UCR11_FIP_Pos               5                                                       /*!< ISO7816 UCR11: FIP Position           */
#define ISO7816_UCR11_FIP_Msk               (0x01UL << ISO7816_UCR11_FIP_Pos)                     /*!< ISO7816 UCR11: FIP Mask               */

/* -------------------------------  u_iso7816_UCR21  ------------------------------ */
#define ISO7816_UCR21_AUTOCONVN_Pos         0                                                       /*!< ISO7816 UCR21: AUTOCONVN Position     */
#define ISO7816_UCR21_AUTOCONVN_Msk         (0x01UL << ISO7816_UCR21_AUTOCONVN_Pos)               /*!< ISO7816 UCR21: AUTOCONVN Mask         */
#define ISO7816_UCR21_MANBGT_Pos            1                                                       /*!< ISO7816 UCR21: MANBGT Position        */
#define ISO7816_UCR21_MANBGT_Msk            (0x01UL << ISO7816_UCR21_MANBGT_Pos)                  /*!< ISO7816 UCR21: MANBGT Mask            */
#define ISO7816_UCR21_DISFT_Pos             2                                                       /*!< ISO7816 UCR21: DISFT Position         */
#define ISO7816_UCR21_DISFT_Msk             (0x01UL << ISO7816_UCR21_DISFT_Pos)                   /*!< ISO7816 UCR21: DISFT Mask             */
#define ISO7816_UCR21_DISPE_Pos             3                                                       /*!< ISO7816 UCR21: DISPE Position         */
#define ISO7816_UCR21_DISPE_Msk             (0x01UL << ISO7816_UCR21_DISPE_Pos)                   /*!< ISO7816 UCR21: DISPE Mask             */
#define ISO7816_UCR21_DISATRCOUNTER_Pos     4                                                       /*!< ISO7816 UCR21: DISATRCOUNTER Position */
#define ISO7816_UCR21_DISATRCOUNTER_Msk     (0x01UL << ISO7816_UCR21_DISATRCOUNTER_Pos)           /*!< ISO7816 UCR21: DISATRCOUNTER Mask     */
#define ISO7816_UCR21_FIFOFLUSH_Pos         6                                                       /*!< ISO7816 UCR21: FIFOFLUSH Position     */
#define ISO7816_UCR21_FIFOFLUSH_Msk         (0x01UL << ISO7816_UCR21_FIFOFLUSH_Pos)               /*!< ISO7816 UCR21: FIFOFLUSH Mask         */
#define ISO7816_UCR21_WRDACC_Pos            7                                                       /*!< ISO7816 UCR21: WRDACC Position        */
#define ISO7816_UCR21_WRDACC_Msk            (0x01UL << ISO7816_UCR21_WRDACC_Pos)                  /*!< ISO7816 UCR21: WRDACC Mask            */

/* -------------------------------  u_iso7816_CCR1  ------------------------------- */
#define ISO7816_CCR1_ACC_Pos                0                                                       /*!< ISO7816 CCR1: ACC Position            */
#define ISO7816_CCR1_ACC_Msk                (0x07UL << ISO7816_CCR1_ACC_Pos)                      /*!< ISO7816 CCR1: ACC Mask                */
#define ISO7816_CCR1_SAN_Pos                3                                                       /*!< ISO7816 CCR1: SAN Position            */
#define ISO7816_CCR1_SAN_Msk                (0x01UL << ISO7816_CCR1_SAN_Pos)                      /*!< ISO7816 CCR1: SAN Mask                */
#define ISO7816_CCR1_CST_Pos                4                                                       /*!< ISO7816 CCR1: CST Position            */
#define ISO7816_CCR1_CST_Msk                (0x01UL << ISO7816_CCR1_CST_Pos)                      /*!< ISO7816 CCR1: CST Mask                */
#define ISO7816_CCR1_SHL_Pos                5                                                       /*!< ISO7816 CCR1: SHL Position            */
#define ISO7816_CCR1_SHL_Msk                (0x01UL << ISO7816_CCR1_SHL_Pos)                      /*!< ISO7816 CCR1: SHL Mask                */

/* --------------------------------  u_iso7816_PCR  ------------------------------- */
#define ISO7816_PCR_PCR_Pos                 0                                                       /*!< ISO7816 PCR: PCR Position             */
#define ISO7816_PCR_PCR_Msk                 (0xffffffffUL << ISO7816_PCR_PCR_Pos)                 /*!< ISO7816 PCR: PCR Mask                 */

/* --------------------------------  u_iso7816_ECR  ------------------------------- */
#define ISO7816_ECR_ECR_Pos                 0                                                       /*!< ISO7816 ECR: ECR Position             */
#define ISO7816_ECR_ECR_Msk                 (0xffffffffUL << ISO7816_ECR_ECR_Pos)                 /*!< ISO7816 ECR: ECR Mask                 */

/* -----------------------------  u_iso7816_MCRL_LSB  ----------------------------- */
#define ISO7816_MCRL_LSB_MCRL_LSB_Pos       0                                                       /*!< ISO7816 MCRL_LSB: MCRL_LSB Position   */
#define ISO7816_MCRL_LSB_MCRL_LSB_Msk       (0xffffffffUL << ISO7816_MCRL_LSB_MCRL_LSB_Pos)       /*!< ISO7816 MCRL_LSB: MCRL_LSB Mask       */

/* -----------------------------  u_iso7816_MCRL_MSB  ----------------------------- */
#define ISO7816_MCRL_MSB_MCRL_MSB_Pos       0                                                       /*!< ISO7816 MCRL_MSB: MCRL_MSB Position   */
#define ISO7816_MCRL_MSB_MCRL_MSB_Msk       (0xffffffffUL << ISO7816_MCRL_MSB_MCRL_MSB_Pos)       /*!< ISO7816 MCRL_MSB: MCRL_MSB Mask       */

/* -----------------------------  u_iso7816_MCRH_LSB  ----------------------------- */
#define ISO7816_MCRH_LSB_MCRH_LSB_Pos       0                                                       /*!< ISO7816 MCRH_LSB: MCRH_LSB Position   */
#define ISO7816_MCRH_LSB_MCRH_LSB_Msk       (0xffffffffUL << ISO7816_MCRH_LSB_MCRH_LSB_Pos)       /*!< ISO7816 MCRH_LSB: MCRH_LSB Mask       */

/* -----------------------------  u_iso7816_MCRH_MSB  ----------------------------- */
#define ISO7816_MCRH_MSB_MCRH_MSB_Pos       0                                                       /*!< ISO7816 MCRH_MSB: MCRH_MSB Position   */
#define ISO7816_MCRH_MSB_MCRH_MSB_Msk       (0xffffffffUL << ISO7816_MCRH_MSB_MCRH_MSB_Pos)       /*!< ISO7816 MCRH_MSB: MCRH_MSB Mask       */

/* --------------------------------  u_iso7816_SRR  ------------------------------- */
#define ISO7816_SRR_SRR_Pos                 0                                                       /*!< ISO7816 SRR: SRR Position             */
#define ISO7816_SRR_SRR_Msk                 (0xffffffffUL << ISO7816_SRR_SRR_Pos)                 /*!< ISO7816 SRR: SRR Mask                 */

/* ------------------------------  u_iso7816_URR_UTR  ----------------------------- */
#define ISO7816_URR_UTR_URR_UTR_Pos         0                                                       /*!< ISO7816 URR_UTR: URR_UTR Position     */
#define ISO7816_URR_UTR_URR_UTR_Msk         (0xffffffffUL << ISO7816_URR_UTR_URR_UTR_Pos)         /*!< ISO7816 URR_UTR: URR_UTR Mask         */

/* -------------------------------  u_iso7816_TOR1  ------------------------------- */
#define ISO7816_TOR1_TOR1_Pos               0                                                       /*!< ISO7816 TOR1: TOR1 Position           */
#define ISO7816_TOR1_TOR1_Msk               (0xffffffffUL << ISO7816_TOR1_TOR1_Pos)               /*!< ISO7816 TOR1: TOR1 Mask               */

/* -------------------------------  u_iso7816_TOR2  ------------------------------- */
#define ISO7816_TOR2_TOR2_Pos               0                                                       /*!< ISO7816 TOR2: TOR2 Position           */
#define ISO7816_TOR2_TOR2_Msk               (0xffffffffUL << ISO7816_TOR2_TOR2_Pos)               /*!< ISO7816 TOR2: TOR2 Mask               */

/* -------------------------------  u_iso7816_TOR3  ------------------------------- */
#define ISO7816_TOR3_TOR3_Pos               0                                                       /*!< ISO7816 TOR3: TOR3 Position           */
#define ISO7816_TOR3_TOR3_Msk               (0xffffffffUL << ISO7816_TOR3_TOR3_Pos)               /*!< ISO7816 TOR3: TOR3 Mask               */

/* --------------------------------  u_iso7816_TOC  ------------------------------- */
#define ISO7816_TOC_TOC_Pos                 0                                                       /*!< ISO7816 TOC: TOC Position             */
#define ISO7816_TOC_TOC_Msk                 (0xffffffffUL << ISO7816_TOC_TOC_Pos)                 /*!< ISO7816 TOC: TOC Mask                 */

/* --------------------------------  u_iso7816_FSR  ------------------------------- */
#define ISO7816_FSR_FSR_Pos                 0                                                       /*!< ISO7816 FSR: FSR Position             */
#define ISO7816_FSR_FSR_Msk                 (0xffffffffUL << ISO7816_FSR_FSR_Pos)                 /*!< ISO7816 FSR: FSR Mask                 */

/* --------------------------------  u_iso7816_MSR  ------------------------------- */
#define ISO7816_MSR_MSR_Pos                 0                                                       /*!< ISO7816 MSR: MSR Position             */
#define ISO7816_MSR_MSR_Msk                 (0xffffffffUL << ISO7816_MSR_MSR_Pos)                 /*!< ISO7816 MSR: MSR Mask                 */

/* -------------------------------  u_iso7816_USR1  ------------------------------- */
#define ISO7816_USR1_USR1_Pos               0                                                       /*!< ISO7816 USR1: USR1 Position           */
#define ISO7816_USR1_USR1_Msk               (0xffffffffUL << ISO7816_USR1_USR1_Pos)               /*!< ISO7816 USR1: USR1 Mask               */

/* -------------------------------  u_iso7816_USR2  ------------------------------- */
#define ISO7816_USR2_USR2_Pos               0                                                       /*!< ISO7816 USR2: USR2 Position           */
#define ISO7816_USR2_USR2_Msk               (0xffffffffUL << ISO7816_USR2_USR2_Pos)               /*!< ISO7816 USR2: USR2 Mask               */


/* ================================================================================ */
/* ================       struct 'u_cic_irb' Position & Mask       ================ */
/* ================================================================================ */


/* -------------------------------  u_cic_irb_CONF  ------------------------------- */
#define IRB_CONF_ENV_INI_Pos            0                                                       /*!< IRB CONF: ENV_INI Position        */
#define IRB_CONF_ENV_INI_Msk            (0x01UL << IRB_CONF_ENV_INI_Pos)                  /*!< IRB CONF: ENV_INI Mask            */
#define IRB_CONF_MODE_Pos               1                                                       /*!< IRB CONF: MODE Position           */
#define IRB_CONF_MODE_Msk               (0x01UL << IRB_CONF_MODE_Pos)                     /*!< IRB CONF: MODE Mask               */
#define IRB_CONF_OUT_Pos                2                                                       /*!< IRB CONF: OUT Position            */
#define IRB_CONF_OUT_Msk                (0x03UL << IRB_CONF_OUT_Pos)                      /*!< IRB CONF: OUT Mask                */
#define IRB_CONF_NO_CAR_Pos             4                                                       /*!< IRB CONF: NO_CAR Position         */
#define IRB_CONF_NO_CAR_Msk             (0x01UL << IRB_CONF_NO_CAR_Pos)                   /*!< IRB CONF: NO_CAR Mask             */
#define IRB_CONF_CAR_INI_Pos            5                                                       /*!< IRB CONF: CAR_INI Position        */
#define IRB_CONF_CAR_INI_Msk            (0x01UL << IRB_CONF_CAR_INI_Pos)                  /*!< IRB CONF: CAR_INI Mask            */

/* ------------------------------  u_cic_irb_CARRIER  ----------------------------- */
#define IRB_CARRIER_CTU_Pos             0                                                       /*!< IRB CARRIER: CTU Position         */
#define IRB_CARRIER_CTU_Msk             (0x0000ffffUL << IRB_CARRIER_CTU_Pos)             /*!< IRB CARRIER: CTU Mask             */
#define IRB_CARRIER_CLOW_Pos            16                                                      /*!< IRB CARRIER: CLOW Position        */
#define IRB_CARRIER_CLOW_Msk            (0x07UL << IRB_CARRIER_CLOW_Pos)                  /*!< IRB CARRIER: CLOW Mask            */
#define IRB_CARRIER_CHIGH_Pos           19                                                      /*!< IRB CARRIER: CHIGH Position       */
#define IRB_CARRIER_CHIGH_Msk           (0x03UL << IRB_CARRIER_CHIGH_Pos)                 /*!< IRB CARRIER: CHIGH Mask           */

/* ------------------------------  u_cic_irb_FIFO_IN  ----------------------------- */
#define IRB_FIFO_IN_ENV_Pos             0                                                       /*!< IRB FIFO_IN: ENV Position         */
#define IRB_FIFO_IN_ENV_Msk             (0x00000fffUL << IRB_FIFO_IN_ENV_Pos)             /*!< IRB FIFO_IN: ENV Mask             */
#define IRB_FIFO_IN_ENV_INT_Pos         12                                                      /*!< IRB FIFO_IN: ENV_INT Position     */
#define IRB_FIFO_IN_ENV_INT_Msk         (0x01UL << IRB_FIFO_IN_ENV_INT_Pos)               /*!< IRB FIFO_IN: ENV_INT Mask         */
#define IRB_FIFO_IN_ENV_LAST_Pos        13                                                      /*!< IRB FIFO_IN: ENV_LAST Position    */
#define IRB_FIFO_IN_ENV_LAST_Msk        (0x01UL << IRB_FIFO_IN_ENV_LAST_Pos)              /*!< IRB FIFO_IN: ENV_LAST Mask        */

/* ------------------------------  u_cic_irb_STATUS  ------------------------------ */
#define IRB_STATUS_FIFO_LVL_Pos         0                                                       /*!< IRB STATUS: FIFO_LVL Position     */
#define IRB_STATUS_FIFO_LVL_Msk         (0x1fUL << IRB_STATUS_FIFO_LVL_Pos)               /*!< IRB STATUS: FIFO_LVL Mask         */
#define IRB_STATUS_FIFO_FULL_Pos        5                                                       /*!< IRB STATUS: FIFO_FULL Position    */
#define IRB_STATUS_FIFO_FULL_Msk        (0x01UL << IRB_STATUS_FIFO_FULL_Pos)              /*!< IRB STATUS: FIFO_FULL Mask        */
#define IRB_STATUS_FIFO_EMPTY_Pos       6                                                       /*!< IRB STATUS: FIFO_EMPTY Position   */
#define IRB_STATUS_FIFO_EMPTY_Msk       (0x01UL << IRB_STATUS_FIFO_EMPTY_Pos)             /*!< IRB STATUS: FIFO_EMPTY Mask       */
#define IRB_STATUS_ENA_ST_Pos           7                                                       /*!< IRB STATUS: ENA_ST Position       */
#define IRB_STATUS_ENA_ST_Msk           (0x01UL << IRB_STATUS_ENA_ST_Pos)                 /*!< IRB STATUS: ENA_ST Mask           */
#define IRB_STATUS_RUN_ST_Pos           8                                                       /*!< IRB STATUS: RUN_ST Position       */
#define IRB_STATUS_RUN_ST_Msk           (0x01UL << IRB_STATUS_RUN_ST_Pos)                 /*!< IRB STATUS: RUN_ST Mask           */

/* --------------------------------  u_cic_irb_CMD  ------------------------------- */
#define IRB_CMD_ENA_Pos                 0                                                       /*!< IRB CMD: ENA Position             */
#define IRB_CMD_ENA_Msk                 (0x01UL << IRB_CMD_ENA_Pos)                       /*!< IRB CMD: ENA Mask                 */
#define IRB_CMD_DIS_Pos                 1                                                       /*!< IRB CMD: DIS Position             */
#define IRB_CMD_DIS_Msk                 (0x01UL << IRB_CMD_DIS_Pos)                       /*!< IRB CMD: DIS Mask                 */
#define IRB_CMD_START_Pos               2                                                       /*!< IRB CMD: START Position           */
#define IRB_CMD_START_Msk               (0x01UL << IRB_CMD_START_Pos)                     /*!< IRB CMD: START Mask               */
#define IRB_CMD_FIFO_RST_Pos            3                                                       /*!< IRB CMD: FIFO_RST Position        */
#define IRB_CMD_FIFO_RST_Msk            (0x01UL << IRB_CMD_FIFO_RST_Pos)                  /*!< IRB CMD: FIFO_RST Mask            */

/* ----------------------------  u_cic_irb_INT_STATUS  ---------------------------- */
#define IRB_INT_STATUS_ENV_START_INT_Pos 0                                                      /*!< IRB INT_STATUS: ENV_START_INT Position */
#define IRB_INT_STATUS_ENV_START_INT_Msk (0x01UL << IRB_INT_STATUS_ENV_START_INT_Pos)     /*!< IRB INT_STATUS: ENV_START_INT Mask */
#define IRB_INT_STATUS_ENV_LAST_INT_Pos 1                                                       /*!< IRB INT_STATUS: ENV_LAST_INT Position */
#define IRB_INT_STATUS_ENV_LAST_INT_Msk (0x01UL << IRB_INT_STATUS_ENV_LAST_INT_Pos)       /*!< IRB INT_STATUS: ENV_LAST_INT Mask */
#define IRB_INT_STATUS_FIFO_UFL_INT_Pos 2                                                       /*!< IRB INT_STATUS: FIFO_UFL_INT Position */
#define IRB_INT_STATUS_FIFO_UFL_INT_Msk (0x01UL << IRB_INT_STATUS_FIFO_UFL_INT_Pos)       /*!< IRB INT_STATUS: FIFO_UFL_INT Mask */

/* ------------------------------  u_cic_irb_INT_ENA  ----------------------------- */
#define IRB_INT_ENA_ENV_START_ENA_Pos   0                                                       /*!< IRB INT_ENA: ENV_START_ENA Position */
#define IRB_INT_ENA_ENV_START_ENA_Msk   (0x01UL << IRB_INT_ENA_ENV_START_ENA_Pos)         /*!< IRB INT_ENA: ENV_START_ENA Mask   */
#define IRB_INT_ENA_ENV_LAST_ENA_Pos    1                                                       /*!< IRB INT_ENA: ENV_LAST_ENA Position */
#define IRB_INT_ENA_ENV_LAST_ENA_Msk    (0x01UL << IRB_INT_ENA_ENV_LAST_ENA_Pos)          /*!< IRB INT_ENA: ENV_LAST_ENA Mask    */
#define IRB_INT_ENA_FIFO_UFL_ENA_Pos    2                                                       /*!< IRB INT_ENA: FIFO_UFL_ENA Position */
#define IRB_INT_ENA_FIFO_UFL_ENA_Msk    (0x01UL << IRB_INT_ENA_FIFO_UFL_ENA_Pos)          /*!< IRB INT_ENA: FIFO_UFL_ENA Mask    */

/* ------------------------------  u_cic_irb_INT_CLR  ----------------------------- */
#define IRB_INT_CLR_ENV_START_CLR_Pos   0                                                       /*!< IRB INT_CLR: ENV_START_CLR Position */
#define IRB_INT_CLR_ENV_START_CLR_Msk   (0x01UL << IRB_INT_CLR_ENV_START_CLR_Pos)         /*!< IRB INT_CLR: ENV_START_CLR Mask   */
#define IRB_INT_CLR_ENV_LAST_CLR_Pos    1                                                       /*!< IRB INT_CLR: ENV_LAST_CLR Position */
#define IRB_INT_CLR_ENV_LAST_CLR_Msk    (0x01UL << IRB_INT_CLR_ENV_LAST_CLR_Pos)          /*!< IRB INT_CLR: ENV_LAST_CLR Mask    */
#define IRB_INT_CLR_FIFO_UFL_CLR_Pos    2                                                       /*!< IRB INT_CLR: FIFO_UFL_CLR Position */
#define IRB_INT_CLR_FIFO_UFL_CLR_Msk    (0x01UL << IRB_INT_CLR_FIFO_UFL_CLR_Pos)          /*!< IRB INT_CLR: FIFO_UFL_CLR Mask    */

/* ------------------------------  u_cic_irb_INT_SET  ----------------------------- */
#define IRB_INT_SET_ENV_START_SET_Pos   0                                                       /*!< IRB INT_SET: ENV_START_SET Position */
#define IRB_INT_SET_ENV_START_SET_Msk   (0x01UL << IRB_INT_SET_ENV_START_SET_Pos)         /*!< IRB INT_SET: ENV_START_SET Mask   */
#define IRB_INT_SET_ENV_LAST_SET_Pos    1                                                       /*!< IRB INT_SET: ENV_LAST_SET Position */
#define IRB_INT_SET_ENV_LAST_SET_Msk    (0x01UL << IRB_INT_SET_ENV_LAST_SET_Pos)          /*!< IRB INT_SET: ENV_LAST_SET Mask    */
#define IRB_INT_SET_FIFO_UFL_SET_Pos    2                                                       /*!< IRB INT_SET: FIFO_UFL_SET Position */
#define IRB_INT_SET_FIFO_UFL_SET_Msk    (0x01UL << IRB_INT_SET_FIFO_UFL_SET_Pos)          /*!< IRB INT_SET: FIFO_UFL_SET Mask    */

/* -----------------------------  u_cic_irb_MODULE_ID  ---------------------------- */
#define IRB_MODULE_ID_APERTURE_Pos      0                                                       /*!< IRB MODULE_ID: APERTURE Position  */
#define IRB_MODULE_ID_APERTURE_Msk      (0x000000ffUL << IRB_MODULE_ID_APERTURE_Pos)      /*!< IRB MODULE_ID: APERTURE Mask      */
#define IRB_MODULE_ID_MIN_REV_Pos       8                                                       /*!< IRB MODULE_ID: MIN_REV Position   */
#define IRB_MODULE_ID_MIN_REV_Msk       (0x0fUL << IRB_MODULE_ID_MIN_REV_Pos)             /*!< IRB MODULE_ID: MIN_REV Mask       */
#define IRB_MODULE_ID_MAJ_REV_Pos       12                                                      /*!< IRB MODULE_ID: MAJ_REV Position   */
#define IRB_MODULE_ID_MAJ_REV_Msk       (0x0fUL << IRB_MODULE_ID_MAJ_REV_Pos)             /*!< IRB MODULE_ID: MAJ_REV Mask       */
#define IRB_MODULE_ID_ID_Pos            16                                                      /*!< IRB MODULE_ID: ID Position        */
#define IRB_MODULE_ID_ID_Msk            (0x0000ffffUL << IRB_MODULE_ID_ID_Pos)            /*!< IRB MODULE_ID: ID Mask            */


/* ================================================================================ */
/* ================      struct 'u_codepatch' Position & Mask      ================ */
/* ================================================================================ */


/* ------------------------  u_codepatch_PATCH_CONTROL_REG  ----------------------- */
#define CODEPATCH_PATCH_CONTROL_REG_PATCH_EN_Pos 0                                                  /*!< CODEPATCH PATCH_CONTROL_REG: PATCH_EN Position */
#define CODEPATCH_PATCH_CONTROL_REG_PATCH_EN_Msk (0x01UL << CODEPATCH_PATCH_CONTROL_REG_PATCH_EN_Pos)/*!< CODEPATCH PATCH_CONTROL_REG: PATCH_EN Mask */

/* --------------------------  u_codepatch_CONTROL_1_REG  ------------------------- */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_1_Pos 0                                                /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_1 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_1_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_1_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_1 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_2_Pos 1                                                /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_2 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_2_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_2_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_2 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_3_Pos 2                                                /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_3 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_3_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_3_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_3 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_4_Pos 3                                                /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_4 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_4_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_4_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_4 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_5_Pos 4                                                /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_5 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_5_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_5_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_5 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_6_Pos 5                                                /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_6 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_6_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_6_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_6 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_7_Pos 6                                                /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_7 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_7_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_7_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_7 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_8_Pos 7                                                /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_8 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_8_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_8_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_8 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_9_Pos 8                                                /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_9 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_9_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_9_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_9 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_10_Pos 9                                               /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_10 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_10_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_10_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_10 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_11_Pos 10                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_11 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_11_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_11_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_11 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_12_Pos 11                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_12 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_12_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_12_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_12 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_13_Pos 12                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_13 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_13_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_13_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_13 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_14_Pos 13                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_14 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_14_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_14_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_14 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_15_Pos 14                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_15 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_15_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_15_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_15 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_16_Pos 15                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_16 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_16_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_16_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_16 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_17_Pos 16                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_17 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_17_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_17_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_17 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_18_Pos 17                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_18 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_18_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_18_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_18 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_19_Pos 18                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_19 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_19_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_19_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_19 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_20_Pos 19                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_20 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_20_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_20_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_20 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_21_Pos 20                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_21 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_21_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_21_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_21 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_22_Pos 21                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_22 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_22_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_22_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_22 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_23_Pos 22                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_23 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_23_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_23_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_23 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_24_Pos 23                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_24 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_24_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_24_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_24 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_25_Pos 24                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_25 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_25_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_25_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_25 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_26_Pos 25                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_26 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_26_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_26_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_26 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_27_Pos 26                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_27 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_27_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_27_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_27 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_28_Pos 27                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_28 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_28_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_28_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_28 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_29_Pos 28                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_29 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_29_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_29_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_29 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_30_Pos 29                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_30 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_30_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_30_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_30 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_31_Pos 30                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_31 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_31_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_31_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_31 Mask */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_32_Pos 31                                              /*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_32 Position */
#define CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_32_Msk (0x01UL << CODEPATCH_CONTROL_1_REG_ENABLE_PATCH_32_Pos)/*!< CODEPATCH CONTROL_1_REG: ENABLE_PATCH_32 Mask */

/* --------------------------  u_codepatch_CONTROL_2_REG  ------------------------- */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_33_Pos 0                                               /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_33 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_33_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_33_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_33 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_34_Pos 1                                               /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_34 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_34_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_34_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_34 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_35_Pos 2                                               /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_35 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_35_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_35_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_35 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_36_Pos 3                                               /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_36 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_36_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_36_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_36 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_37_Pos 4                                               /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_37 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_37_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_37_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_37 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_38_Pos 5                                               /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_38 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_38_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_38_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_38 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_39_Pos 6                                               /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_39 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_39_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_39_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_39 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_40_Pos 7                                               /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_40 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_40_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_40_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_40 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_41_Pos 8                                               /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_41 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_41_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_41_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_41 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_42_Pos 9                                               /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_42 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_42_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_42_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_42 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_43_Pos 10                                              /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_43 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_43_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_43_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_43 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_44_Pos 11                                              /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_44 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_44_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_44_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_44 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_45_Pos 12                                              /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_45 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_45_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_45_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_45 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_46_Pos 13                                              /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_46 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_46_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_46_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_46 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_47_Pos 14                                              /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_47 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_47_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_47_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_47 Mask */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_48_Pos 15                                              /*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_48 Position */
#define CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_48_Msk (0x01UL << CODEPATCH_CONTROL_2_REG_ENABLE_PATCH_48_Pos)/*!< CODEPATCH CONTROL_2_REG: ENABLE_PATCH_48 Mask */

/* -------------------------  u_codepatch_TRAP_STATUS_REG  ------------------------ */
#define CODEPATCH_TRAP_STATUS_REG_LAST_TRAP_0_Pos 0                                                 /*!< CODEPATCH TRAP_STATUS_REG: LAST_TRAP_0 Position */
#define CODEPATCH_TRAP_STATUS_REG_LAST_TRAP_0_Msk (0x7fUL << CODEPATCH_TRAP_STATUS_REG_LAST_TRAP_0_Pos)/*!< CODEPATCH TRAP_STATUS_REG: LAST_TRAP_0 Mask */
#define CODEPATCH_TRAP_STATUS_REG_LAST_TRAP_1_Pos 8                                                 /*!< CODEPATCH TRAP_STATUS_REG: LAST_TRAP_1 Position */
#define CODEPATCH_TRAP_STATUS_REG_LAST_TRAP_1_Msk (0x7fUL << CODEPATCH_TRAP_STATUS_REG_LAST_TRAP_1_Pos)/*!< CODEPATCH TRAP_STATUS_REG: LAST_TRAP_1 Mask */

/* --------------------------  u_codepatch_VT_REMAP_REG  -------------------------- */
#define CODEPATCH_VT_REMAP_REG_VT_REMAP_EN_Pos 0                                                    /*!< CODEPATCH VT_REMAP_REG: VT_REMAP_EN Position */
#define CODEPATCH_VT_REMAP_REG_VT_REMAP_EN_Msk (0x01UL << CODEPATCH_VT_REMAP_REG_VT_REMAP_EN_Pos) /*!< CODEPATCH VT_REMAP_REG: VT_REMAP_EN Mask */

/* -------------------------  u_codepatch_TESTBUS_SEL_REG  ------------------------ */
#define CODEPATCH_TESTBUS_SEL_REG_TESTBUS_SEL_REG_Pos 0                                             /*!< CODEPATCH TESTBUS_SEL_REG: TESTBUS_SEL_REG Position */
#define CODEPATCH_TESTBUS_SEL_REG_TESTBUS_SEL_REG_Msk (0xffffffffUL << CODEPATCH_TESTBUS_SEL_REG_TESTBUS_SEL_REG_Pos)/*!< CODEPATCH TESTBUS_SEL_REG: TESTBUS_SEL_REG Mask */

/* ---------------------------  u_codepatch_OFFSET_REG  --------------------------- */
#define CODEPATCH_OFFSET_REG_OFFSET_ADDR_Pos 0                                                      /*!< CODEPATCH OFFSET_REG: OFFSET_ADDR Position */
#define CODEPATCH_OFFSET_REG_OFFSET_ADDR_Msk (0x0003ffffUL << CODEPATCH_OFFSET_REG_OFFSET_ADDR_Pos)/*!< CODEPATCH OFFSET_REG: OFFSET_ADDR Mask */


/* ================================================================================ */
/* ================        struct 'u_flash' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u_flash_CMD  -------------------------------- */
#define FLASH_CMD_CMD_Pos                   0                                                       /*!< FLASH CMD: CMD Position               */
#define FLASH_CMD_CMD_Msk                   (0xffffffffUL << FLASH_CMD_CMD_Pos)                   /*!< FLASH CMD: CMD Mask                   */

/* --------------------------------  u_flash_EVENT  ------------------------------- */
#define FLASH_EVENT_RST_Pos                 0                                                       /*!< FLASH EVENT: RST Position             */
#define FLASH_EVENT_RST_Msk                 (0x01UL << FLASH_EVENT_RST_Pos)                       /*!< FLASH EVENT: RST Mask                 */
#define FLASH_EVENT_WAKEUP_Pos              1                                                       /*!< FLASH EVENT: WAKEUP Position          */
#define FLASH_EVENT_WAKEUP_Msk              (0x01UL << FLASH_EVENT_WAKEUP_Pos)                    /*!< FLASH EVENT: WAKEUP Mask              */
#define FLASH_EVENT_ABORT_Pos               2                                                       /*!< FLASH EVENT: ABORT Position           */
#define FLASH_EVENT_ABORT_Msk               (0x01UL << FLASH_EVENT_ABORT_Pos)                     /*!< FLASH EVENT: ABORT Mask               */

/* ------------------------------  u_flash_AUTOPROG  ------------------------------ */
#define FLASH_AUTOPROG_AUTOPROG_Pos         0                                                       /*!< FLASH AUTOPROG: AUTOPROG Position     */
#define FLASH_AUTOPROG_AUTOPROG_Msk         (0x03UL << FLASH_AUTOPROG_AUTOPROG_Pos)               /*!< FLASH AUTOPROG: AUTOPROG Mask         */

/* -------------------------------  u_flash_STARTA  ------------------------------- */
#define FLASH_STARTA_STARTA_Pos             0                                                       /*!< FLASH STARTA: STARTA Position         */
#define FLASH_STARTA_STARTA_Msk             (0x0003ffffUL << FLASH_STARTA_STARTA_Pos)             /*!< FLASH STARTA: STARTA Mask             */

/* --------------------------------  u_flash_STOPA  ------------------------------- */
#define FLASH_STOPA_STOPA_Pos               0                                                       /*!< FLASH STOPA: STOPA Position           */
#define FLASH_STOPA_STOPA_Msk               (0x0003ffffUL << FLASH_STOPA_STOPA_Pos)               /*!< FLASH STOPA: STOPA Mask               */

/* --------------------------------  u_flash_TEST  -------------------------------- */
#define FLASH_TEST_DCM1_Pos                 0                                                       /*!< FLASH TEST: DCM1 Position             */
#define FLASH_TEST_DCM1_Msk                 (0x000000ffUL << FLASH_TEST_DCM1_Pos)                 /*!< FLASH TEST: DCM1 Mask                 */
#define FLASH_TEST_DCM2_Pos                 8                                                       /*!< FLASH TEST: DCM2 Position             */
#define FLASH_TEST_DCM2_Msk                 (0x000000ffUL << FLASH_TEST_DCM2_Pos)                 /*!< FLASH TEST: DCM2 Mask                 */
#define FLASH_TEST_EXT48_Pos                16                                                      /*!< FLASH TEST: EXT48 Position            */
#define FLASH_TEST_EXT48_Msk                (0x01UL << FLASH_TEST_EXT48_Pos)                      /*!< FLASH TEST: EXT48 Mask                */

/* --------------------------------  u_flash_PARW  -------------------------------- */
#define FLASH_PARW_PARW_Pos                 0                                                       /*!< FLASH PARW: PARW Position             */
#define FLASH_PARW_PARW_Msk                 (0xffffffffUL << FLASH_PARW_PARW_Pos)                 /*!< FLASH PARW: PARW Mask                 */

/* ---------------------------------  u_flash_FSQ  -------------------------------- */
#define FLASH_FSQ_ST1_Pos                   0                                                       /*!< FLASH FSQ: ST1 Position               */
#define FLASH_FSQ_ST1_Msk                   (0x000000ffUL << FLASH_FSQ_ST1_Pos)                   /*!< FLASH FSQ: ST1 Mask                   */
#define FLASH_FSQ_EN1_Pos                   8                                                       /*!< FLASH FSQ: EN1 Position               */
#define FLASH_FSQ_EN1_Msk                   (0x000000ffUL << FLASH_FSQ_EN1_Pos)                   /*!< FLASH FSQ: EN1 Mask                   */
#define FLASH_FSQ_ST2_Pos                   16                                                      /*!< FLASH FSQ: ST2 Position               */
#define FLASH_FSQ_ST2_Msk                   (0x000000ffUL << FLASH_FSQ_ST2_Pos)                   /*!< FLASH FSQ: ST2 Mask                   */
#define FLASH_FSQ_EN2_Pos                   24                                                      /*!< FLASH FSQ: EN2 Position               */
#define FLASH_FSQ_EN2_Msk                   (0x000000ffUL << FLASH_FSQ_EN2_Pos)                   /*!< FLASH FSQ: EN2 Mask                   */

/* --------------------------------  u_flash_DATAW  ------------------------------- */
#define FLASH_DATAW_DATAW_Pos               0                                                       /*!< FLASH DATAW: DATAW Position           */
#define FLASH_DATAW_DATAW_Msk               (0xffffffffUL << FLASH_DATAW_DATAW_Pos)               /*!< FLASH DATAW: DATAW Mask               */

/* ---------------------------  u_flash_INT_CLR_ENABLE  --------------------------- */
#define FLASH_INT_CLR_ENABLE_FAIL_Pos       0                                                       /*!< FLASH INT_CLR_ENABLE: FAIL Position   */
#define FLASH_INT_CLR_ENABLE_FAIL_Msk       (0x01UL << FLASH_INT_CLR_ENABLE_FAIL_Pos)             /*!< FLASH INT_CLR_ENABLE: FAIL Mask       */
#define FLASH_INT_CLR_ENABLE_ERR_Pos        1                                                       /*!< FLASH INT_CLR_ENABLE: ERR Position    */
#define FLASH_INT_CLR_ENABLE_ERR_Msk        (0x01UL << FLASH_INT_CLR_ENABLE_ERR_Pos)              /*!< FLASH INT_CLR_ENABLE: ERR Mask        */
#define FLASH_INT_CLR_ENABLE_DONE_Pos       2                                                       /*!< FLASH INT_CLR_ENABLE: DONE Position   */
#define FLASH_INT_CLR_ENABLE_DONE_Msk       (0x01UL << FLASH_INT_CLR_ENABLE_DONE_Pos)             /*!< FLASH INT_CLR_ENABLE: DONE Mask       */
#define FLASH_INT_CLR_ENABLE_ECC_ERR_Pos    3                                                       /*!< FLASH INT_CLR_ENABLE: ECC_ERR Position */
#define FLASH_INT_CLR_ENABLE_ECC_ERR_Msk    (0x01UL << FLASH_INT_CLR_ENABLE_ECC_ERR_Pos)          /*!< FLASH INT_CLR_ENABLE: ECC_ERR Mask    */

/* ---------------------------  u_flash_INT_SET_ENABLE  --------------------------- */
#define FLASH_INT_SET_ENABLE_FAIL_Pos       0                                                       /*!< FLASH INT_SET_ENABLE: FAIL Position   */
#define FLASH_INT_SET_ENABLE_FAIL_Msk       (0x01UL << FLASH_INT_SET_ENABLE_FAIL_Pos)             /*!< FLASH INT_SET_ENABLE: FAIL Mask       */
#define FLASH_INT_SET_ENABLE_ERR_Pos        1                                                       /*!< FLASH INT_SET_ENABLE: ERR Position    */
#define FLASH_INT_SET_ENABLE_ERR_Msk        (0x01UL << FLASH_INT_SET_ENABLE_ERR_Pos)              /*!< FLASH INT_SET_ENABLE: ERR Mask        */
#define FLASH_INT_SET_ENABLE_DONE_Pos       2                                                       /*!< FLASH INT_SET_ENABLE: DONE Position   */
#define FLASH_INT_SET_ENABLE_DONE_Msk       (0x01UL << FLASH_INT_SET_ENABLE_DONE_Pos)             /*!< FLASH INT_SET_ENABLE: DONE Mask       */
#define FLASH_INT_SET_ENABLE_ECC_ERR_Pos    3                                                       /*!< FLASH INT_SET_ENABLE: ECC_ERR Position */
#define FLASH_INT_SET_ENABLE_ECC_ERR_Msk    (0x01UL << FLASH_INT_SET_ENABLE_ECC_ERR_Pos)          /*!< FLASH INT_SET_ENABLE: ECC_ERR Mask    */

/* -----------------------------  u_flash_INT_STATUS  ----------------------------- */
#define FLASH_INT_STATUS_FAIL_Pos           0                                                       /*!< FLASH INT_STATUS: FAIL Position       */
#define FLASH_INT_STATUS_FAIL_Msk           (0x01UL << FLASH_INT_STATUS_FAIL_Pos)                 /*!< FLASH INT_STATUS: FAIL Mask           */
#define FLASH_INT_STATUS_ERR_Pos            1                                                       /*!< FLASH INT_STATUS: ERR Position        */
#define FLASH_INT_STATUS_ERR_Msk            (0x01UL << FLASH_INT_STATUS_ERR_Pos)                  /*!< FLASH INT_STATUS: ERR Mask            */
#define FLASH_INT_STATUS_DONE_Pos           2                                                       /*!< FLASH INT_STATUS: DONE Position       */
#define FLASH_INT_STATUS_DONE_Msk           (0x01UL << FLASH_INT_STATUS_DONE_Pos)                 /*!< FLASH INT_STATUS: DONE Mask           */
#define FLASH_INT_STATUS_ECC_ERR_Pos        3                                                       /*!< FLASH INT_STATUS: ECC_ERR Position    */
#define FLASH_INT_STATUS_ECC_ERR_Msk        (0x01UL << FLASH_INT_STATUS_ECC_ERR_Pos)              /*!< FLASH INT_STATUS: ECC_ERR Mask        */

/* -----------------------------  u_flash_INT_ENABLE  ----------------------------- */
#define FLASH_INT_ENABLE_FAIL_Pos           0                                                       /*!< FLASH INT_ENABLE: FAIL Position       */
#define FLASH_INT_ENABLE_FAIL_Msk           (0x01UL << FLASH_INT_ENABLE_FAIL_Pos)                 /*!< FLASH INT_ENABLE: FAIL Mask           */
#define FLASH_INT_ENABLE_ERR_Pos            1                                                       /*!< FLASH INT_ENABLE: ERR Position        */
#define FLASH_INT_ENABLE_ERR_Msk            (0x01UL << FLASH_INT_ENABLE_ERR_Pos)                  /*!< FLASH INT_ENABLE: ERR Mask            */
#define FLASH_INT_ENABLE_DONE_Pos           2                                                       /*!< FLASH INT_ENABLE: DONE Position       */
#define FLASH_INT_ENABLE_DONE_Msk           (0x01UL << FLASH_INT_ENABLE_DONE_Pos)                 /*!< FLASH INT_ENABLE: DONE Mask           */
#define FLASH_INT_ENABLE_ECC_ERR_Pos        3                                                       /*!< FLASH INT_ENABLE: ECC_ERR Position    */
#define FLASH_INT_ENABLE_ECC_ERR_Msk        (0x01UL << FLASH_INT_ENABLE_ECC_ERR_Pos)              /*!< FLASH INT_ENABLE: ECC_ERR Mask        */

/* ---------------------------  u_flash_INT_CLR_STATUS  --------------------------- */
#define FLASH_INT_CLR_STATUS_FAIL_Pos       0                                                       /*!< FLASH INT_CLR_STATUS: FAIL Position   */
#define FLASH_INT_CLR_STATUS_FAIL_Msk       (0x01UL << FLASH_INT_CLR_STATUS_FAIL_Pos)             /*!< FLASH INT_CLR_STATUS: FAIL Mask       */
#define FLASH_INT_CLR_STATUS_ERR_Pos        1                                                       /*!< FLASH INT_CLR_STATUS: ERR Position    */
#define FLASH_INT_CLR_STATUS_ERR_Msk        (0x01UL << FLASH_INT_CLR_STATUS_ERR_Pos)              /*!< FLASH INT_CLR_STATUS: ERR Mask        */
#define FLASH_INT_CLR_STATUS_DONE_Pos       2                                                       /*!< FLASH INT_CLR_STATUS: DONE Position   */
#define FLASH_INT_CLR_STATUS_DONE_Msk       (0x01UL << FLASH_INT_CLR_STATUS_DONE_Pos)             /*!< FLASH INT_CLR_STATUS: DONE Mask       */
#define FLASH_INT_CLR_STATUS_ECC_ERR_Pos    3                                                       /*!< FLASH INT_CLR_STATUS: ECC_ERR Position */
#define FLASH_INT_CLR_STATUS_ECC_ERR_Msk    (0x01UL << FLASH_INT_CLR_STATUS_ECC_ERR_Pos)          /*!< FLASH INT_CLR_STATUS: ECC_ERR Mask    */

/* ---------------------------  u_flash_INT_SET_STATUS  --------------------------- */
#define FLASH_INT_SET_STATUS_FAIL_Pos       0                                                       /*!< FLASH INT_SET_STATUS: FAIL Position   */
#define FLASH_INT_SET_STATUS_FAIL_Msk       (0x01UL << FLASH_INT_SET_STATUS_FAIL_Pos)             /*!< FLASH INT_SET_STATUS: FAIL Mask       */
#define FLASH_INT_SET_STATUS_ERR_Pos        1                                                       /*!< FLASH INT_SET_STATUS: ERR Position    */
#define FLASH_INT_SET_STATUS_ERR_Msk        (0x01UL << FLASH_INT_SET_STATUS_ERR_Pos)              /*!< FLASH INT_SET_STATUS: ERR Mask        */
#define FLASH_INT_SET_STATUS_DONE_Pos       2                                                       /*!< FLASH INT_SET_STATUS: DONE Position   */
#define FLASH_INT_SET_STATUS_DONE_Msk       (0x01UL << FLASH_INT_SET_STATUS_DONE_Pos)             /*!< FLASH INT_SET_STATUS: DONE Mask       */
#define FLASH_INT_SET_STATUS_ECC_ERR_Pos    3                                                       /*!< FLASH INT_SET_STATUS: ECC_ERR Position */
#define FLASH_INT_SET_STATUS_ECC_ERR_Msk    (0x01UL << FLASH_INT_SET_STATUS_ECC_ERR_Pos)          /*!< FLASH INT_SET_STATUS: ECC_ERR Mask    */

/* ------------------------------  u_flash_MODULE_ID  ----------------------------- */
#define FLASH_MODULE_ID_APERTURE_Pos        0                                                       /*!< FLASH MODULE_ID: APERTURE Position    */
#define FLASH_MODULE_ID_APERTURE_Msk        (0x000000ffUL << FLASH_MODULE_ID_APERTURE_Pos)        /*!< FLASH MODULE_ID: APERTURE Mask        */
#define FLASH_MODULE_ID_MINOR_REV_Pos       8                                                       /*!< FLASH MODULE_ID: MINOR_REV Position   */
#define FLASH_MODULE_ID_MINOR_REV_Msk       (0x0fUL << FLASH_MODULE_ID_MINOR_REV_Pos)             /*!< FLASH MODULE_ID: MINOR_REV Mask       */
#define FLASH_MODULE_ID_MAJOR_REV_Pos       12                                                      /*!< FLASH MODULE_ID: MAJOR_REV Position   */
#define FLASH_MODULE_ID_MAJOR_REV_Msk       (0x0fUL << FLASH_MODULE_ID_MAJOR_REV_Pos)             /*!< FLASH MODULE_ID: MAJOR_REV Mask       */
#define FLASH_MODULE_ID_ID_Pos              16                                                      /*!< FLASH MODULE_ID: ID Position          */
#define FLASH_MODULE_ID_ID_Msk              (0x0000ffffUL << FLASH_MODULE_ID_ID_Pos)              /*!< FLASH MODULE_ID: ID Mask              */


/* ================================================================================ */
/* ================         struct 'u_wwdt' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u_wwdt_MOD  --------------------------------- */
#define WWDT_MOD_WDEN_Pos                   0                                                       /*!< WWDT MOD: WDEN Position               */
#define WWDT_MOD_WDEN_Msk                   (0x01UL << WWDT_MOD_WDEN_Pos)                         /*!< WWDT MOD: WDEN Mask                   */
#define WWDT_MOD_WDRESET_Pos                1                                                       /*!< WWDT MOD: WDRESET Position            */
#define WWDT_MOD_WDRESET_Msk                (0x01UL << WWDT_MOD_WDRESET_Pos)                      /*!< WWDT MOD: WDRESET Mask                */
#define WWDT_MOD_WDTOF_Pos                  2                                                       /*!< WWDT MOD: WDTOF Position              */
#define WWDT_MOD_WDTOF_Msk                  (0x01UL << WWDT_MOD_WDTOF_Pos)                        /*!< WWDT MOD: WDTOF Mask                  */
#define WWDT_MOD_WDINT_Pos                  3                                                       /*!< WWDT MOD: WDINT Position              */
#define WWDT_MOD_WDINT_Msk                  (0x01UL << WWDT_MOD_WDINT_Pos)                        /*!< WWDT MOD: WDINT Mask                  */
#define WWDT_MOD_WDPROTECT_Pos              4                                                       /*!< WWDT MOD: WDPROTECT Position          */
#define WWDT_MOD_WDPROTECT_Msk              (0x01UL << WWDT_MOD_WDPROTECT_Pos)                    /*!< WWDT MOD: WDPROTECT Mask              */
#define WWDT_MOD_LOCK_Pos                   5                                                       /*!< WWDT MOD: LOCK Position               */
#define WWDT_MOD_LOCK_Msk                   (0x01UL << WWDT_MOD_LOCK_Pos)                         /*!< WWDT MOD: LOCK Mask                   */

/* ----------------------------------  u_wwdt_TC  --------------------------------- */
#define WWDT_TC_COUNT_Pos                   0                                                       /*!< WWDT TC: COUNT Position               */
#define WWDT_TC_COUNT_Msk                   (0x00ffffffUL << WWDT_TC_COUNT_Pos)                   /*!< WWDT TC: COUNT Mask                   */

/* ---------------------------------  u_wwdt_FEED  -------------------------------- */
#define WWDT_FEED_FEED_Pos                  0                                                       /*!< WWDT FEED: FEED Position              */
#define WWDT_FEED_FEED_Msk                  (0x000000ffUL << WWDT_FEED_FEED_Pos)                  /*!< WWDT FEED: FEED Mask                  */

/* ----------------------------------  u_wwdt_TV  --------------------------------- */
#define WWDT_TV_COUNT_Pos                   0                                                       /*!< WWDT TV: COUNT Position               */
#define WWDT_TV_COUNT_Msk                   (0x00ffffffUL << WWDT_TV_COUNT_Pos)                   /*!< WWDT TV: COUNT Mask                   */

/* -------------------------------  u_wwdt_WARNINT  ------------------------------- */
#define WWDT_WARNINT_WARNINT_Pos            0                                                       /*!< WWDT WARNINT: WARNINT Position        */
#define WWDT_WARNINT_WARNINT_Msk            (0x000003ffUL << WWDT_WARNINT_WARNINT_Pos)            /*!< WWDT WARNINT: WARNINT Mask            */

/* --------------------------------  u_wwdt_WINDOW  ------------------------------- */
#define WWDT_WINDOW_WINDOW_Pos              0                                                       /*!< WWDT WINDOW: WINDOW Position          */
#define WWDT_WINDOW_WINDOW_Msk              (0x00ffffffUL << WWDT_WINDOW_WINDOW_Pos)              /*!< WWDT WINDOW: WINDOW Mask              */


/* ================================================================================ */
/* ================         struct 'u_rtc' Position & Mask         ================ */
/* ================================================================================ */


/* ---------------------------------  u_rtc_CTRL  --------------------------------- */
#define RTC_CTRL_SWRESET_Pos                0                                                       /*!< RTC CTRL: SWRESET Position            */
#define RTC_CTRL_SWRESET_Msk                (0x01UL << RTC_CTRL_SWRESET_Pos)                      /*!< RTC CTRL: SWRESET Mask                */
#define RTC_CTRL_ALARMT32B_Pos              2                                                       /*!< RTC CTRL: ALARMT32B Position          */
#define RTC_CTRL_ALARMT32B_Msk              (0x01UL << RTC_CTRL_ALARMT32B_Pos)                    /*!< RTC CTRL: ALARMT32B Mask              */
#define RTC_CTRL_WAKET16B_Pos               3                                                       /*!< RTC CTRL: WAKET16B Position           */
#define RTC_CTRL_WAKET16B_Msk               (0x01UL << RTC_CTRL_WAKET16B_Pos)                     /*!< RTC CTRL: WAKET16B Mask               */
#define RTC_CTRL_ALARMDPD_EN_Pos            4                                                       /*!< RTC CTRL: ALARMDPD_EN Position        */
#define RTC_CTRL_ALARMDPD_EN_Msk            (0x01UL << RTC_CTRL_ALARMDPD_EN_Pos)                  /*!< RTC CTRL: ALARMDPD_EN Mask            */
#define RTC_CTRL_WAKEDPD_EN_Pos             5                                                       /*!< RTC CTRL: WAKEDPD_EN Position         */
#define RTC_CTRL_WAKEDPD_EN_Msk             (0x01UL << RTC_CTRL_WAKEDPD_EN_Pos)                   /*!< RTC CTRL: WAKEDPD_EN Mask             */
#define RTC_CTRL_RTCT16B_EN_Pos             6                                                       /*!< RTC CTRL: RTCT16B_EN Position         */
#define RTC_CTRL_RTCT16B_EN_Msk             (0x01UL << RTC_CTRL_RTCT16B_EN_Pos)                   /*!< RTC CTRL: RTCT16B_EN Mask             */
#define RTC_CTRL_RTC_EN_Pos                 7                                                       /*!< RTC CTRL: RTC_EN Position             */
#define RTC_CTRL_RTC_EN_Msk                 (0x01UL << RTC_CTRL_RTC_EN_Pos)                       /*!< RTC CTRL: RTC_EN Mask                 */

/* ---------------------------------  u_rtc_MATCH  -------------------------------- */
#define RTC_MATCH_MATVAL_Pos                0                                                       /*!< RTC MATCH: MATVAL Position            */
#define RTC_MATCH_MATVAL_Msk                (0xffffffffUL << RTC_MATCH_MATVAL_Pos)                /*!< RTC MATCH: MATVAL Mask                */

/* ---------------------------------  u_rtc_COUNT  -------------------------------- */
#define RTC_COUNT_VAL_Pos                   0                                                       /*!< RTC COUNT: VAL Position               */
#define RTC_COUNT_VAL_Msk                   (0xffffffffUL << RTC_COUNT_VAL_Pos)                   /*!< RTC COUNT: VAL Mask                   */

/* ---------------------------------  u_rtc_WAKE  --------------------------------- */
#define RTC_WAKE_VAL_Pos                    0                                                       /*!< RTC WAKE: VAL Position                */
#define RTC_WAKE_VAL_Msk                    (0x0000ffffUL << RTC_WAKE_VAL_Pos)                    /*!< RTC WAKE: VAL Mask                    */


/* ================================================================================ */
/* ================         struct 'u_pwm' Position & Mask         ================ */
/* ================================================================================ */


/* ---------------------------------  u_pwm_CTRL0  -------------------------------- */
#define PWM_CTRL0_PWM_EN_0_Pos              0                                                       /*!< PWM CTRL0: PWM_EN_0 Position          */
#define PWM_CTRL0_PWM_EN_0_Msk              (0x01UL << PWM_CTRL0_PWM_EN_0_Pos)                    /*!< PWM CTRL0: PWM_EN_0 Mask              */
#define PWM_CTRL0_PWM_EN_1_Pos              1                                                       /*!< PWM CTRL0: PWM_EN_1 Position          */
#define PWM_CTRL0_PWM_EN_1_Msk              (0x01UL << PWM_CTRL0_PWM_EN_1_Pos)                    /*!< PWM CTRL0: PWM_EN_1 Mask              */
#define PWM_CTRL0_PWM_EN_2_Pos              2                                                       /*!< PWM CTRL0: PWM_EN_2 Position          */
#define PWM_CTRL0_PWM_EN_2_Msk              (0x01UL << PWM_CTRL0_PWM_EN_2_Pos)                    /*!< PWM CTRL0: PWM_EN_2 Mask              */
#define PWM_CTRL0_PWM_EN_3_Pos              3                                                       /*!< PWM CTRL0: PWM_EN_3 Position          */
#define PWM_CTRL0_PWM_EN_3_Msk              (0x01UL << PWM_CTRL0_PWM_EN_3_Pos)                    /*!< PWM CTRL0: PWM_EN_3 Mask              */
#define PWM_CTRL0_PWM_EN_4_Pos              4                                                       /*!< PWM CTRL0: PWM_EN_4 Position          */
#define PWM_CTRL0_PWM_EN_4_Msk              (0x01UL << PWM_CTRL0_PWM_EN_4_Pos)                    /*!< PWM CTRL0: PWM_EN_4 Mask              */
#define PWM_CTRL0_PWM_EN_5_Pos              5                                                       /*!< PWM CTRL0: PWM_EN_5 Position          */
#define PWM_CTRL0_PWM_EN_5_Msk              (0x01UL << PWM_CTRL0_PWM_EN_5_Pos)                    /*!< PWM CTRL0: PWM_EN_5 Mask              */
#define PWM_CTRL0_PWM_EN_6_Pos              6                                                       /*!< PWM CTRL0: PWM_EN_6 Position          */
#define PWM_CTRL0_PWM_EN_6_Msk              (0x01UL << PWM_CTRL0_PWM_EN_6_Pos)                    /*!< PWM CTRL0: PWM_EN_6 Mask              */
#define PWM_CTRL0_PWM_EN_7_Pos              7                                                       /*!< PWM CTRL0: PWM_EN_7 Position          */
#define PWM_CTRL0_PWM_EN_7_Msk              (0x01UL << PWM_CTRL0_PWM_EN_7_Pos)                    /*!< PWM CTRL0: PWM_EN_7 Mask              */
#define PWM_CTRL0_PWM_EN_8_Pos              8                                                       /*!< PWM CTRL0: PWM_EN_8 Position          */
#define PWM_CTRL0_PWM_EN_8_Msk              (0x01UL << PWM_CTRL0_PWM_EN_8_Pos)                    /*!< PWM CTRL0: PWM_EN_8 Mask              */
#define PWM_CTRL0_PWM_EN_9_Pos              9                                                       /*!< PWM CTRL0: PWM_EN_9 Position          */
#define PWM_CTRL0_PWM_EN_9_Msk              (0x01UL << PWM_CTRL0_PWM_EN_9_Pos)                    /*!< PWM CTRL0: PWM_EN_9 Mask              */
#define PWM_CTRL0_PWM_EN_10_Pos             10                                                      /*!< PWM CTRL0: PWM_EN_10 Position         */
#define PWM_CTRL0_PWM_EN_10_Msk             (0x01UL << PWM_CTRL0_PWM_EN_10_Pos)                   /*!< PWM CTRL0: PWM_EN_10 Mask             */
#define PWM_CTRL0_INT_EN_0_Pos              16                                                      /*!< PWM CTRL0: INT_EN_0 Position          */
#define PWM_CTRL0_INT_EN_0_Msk              (0x01UL << PWM_CTRL0_INT_EN_0_Pos)                    /*!< PWM CTRL0: INT_EN_0 Mask              */
#define PWM_CTRL0_INT_EN_1_Pos              17                                                      /*!< PWM CTRL0: INT_EN_1 Position          */
#define PWM_CTRL0_INT_EN_1_Msk              (0x01UL << PWM_CTRL0_INT_EN_1_Pos)                    /*!< PWM CTRL0: INT_EN_1 Mask              */
#define PWM_CTRL0_INT_EN_2_Pos              18                                                      /*!< PWM CTRL0: INT_EN_2 Position          */
#define PWM_CTRL0_INT_EN_2_Msk              (0x01UL << PWM_CTRL0_INT_EN_2_Pos)                    /*!< PWM CTRL0: INT_EN_2 Mask              */
#define PWM_CTRL0_INT_EN_3_Pos              19                                                      /*!< PWM CTRL0: INT_EN_3 Position          */
#define PWM_CTRL0_INT_EN_3_Msk              (0x01UL << PWM_CTRL0_INT_EN_3_Pos)                    /*!< PWM CTRL0: INT_EN_3 Mask              */
#define PWM_CTRL0_INT_EN_4_Pos              20                                                      /*!< PWM CTRL0: INT_EN_4 Position          */
#define PWM_CTRL0_INT_EN_4_Msk              (0x01UL << PWM_CTRL0_INT_EN_4_Pos)                    /*!< PWM CTRL0: INT_EN_4 Mask              */
#define PWM_CTRL0_INT_EN_5_Pos              21                                                      /*!< PWM CTRL0: INT_EN_5 Position          */
#define PWM_CTRL0_INT_EN_5_Msk              (0x01UL << PWM_CTRL0_INT_EN_5_Pos)                    /*!< PWM CTRL0: INT_EN_5 Mask              */
#define PWM_CTRL0_INT_EN_6_Pos              22                                                      /*!< PWM CTRL0: INT_EN_6 Position          */
#define PWM_CTRL0_INT_EN_6_Msk              (0x01UL << PWM_CTRL0_INT_EN_6_Pos)                    /*!< PWM CTRL0: INT_EN_6 Mask              */
#define PWM_CTRL0_INT_EN_7_Pos              23                                                      /*!< PWM CTRL0: INT_EN_7 Position          */
#define PWM_CTRL0_INT_EN_7_Msk              (0x01UL << PWM_CTRL0_INT_EN_7_Pos)                    /*!< PWM CTRL0: INT_EN_7 Mask              */
#define PWM_CTRL0_INT_EN_8_Pos              24                                                      /*!< PWM CTRL0: INT_EN_8 Position          */
#define PWM_CTRL0_INT_EN_8_Msk              (0x01UL << PWM_CTRL0_INT_EN_8_Pos)                    /*!< PWM CTRL0: INT_EN_8 Mask              */
#define PWM_CTRL0_INT_EN_9_Pos              25                                                      /*!< PWM CTRL0: INT_EN_9 Position          */
#define PWM_CTRL0_INT_EN_9_Msk              (0x01UL << PWM_CTRL0_INT_EN_9_Pos)                    /*!< PWM CTRL0: INT_EN_9 Mask              */
#define PWM_CTRL0_INT_EN_10_Pos             26                                                      /*!< PWM CTRL0: INT_EN_10 Position         */
#define PWM_CTRL0_INT_EN_10_Msk             (0x01UL << PWM_CTRL0_INT_EN_10_Pos)                   /*!< PWM CTRL0: INT_EN_10 Mask             */

/* ---------------------------------  u_pwm_CTRL1  -------------------------------- */
#define PWM_CTRL1_POL_0_Pos                 0                                                       /*!< PWM CTRL1: POL_0 Position             */
#define PWM_CTRL1_POL_0_Msk                 (0x01UL << PWM_CTRL1_POL_0_Pos)                       /*!< PWM CTRL1: POL_0 Mask                 */
#define PWM_CTRL1_POL_1_Pos                 1                                                       /*!< PWM CTRL1: POL_1 Position             */
#define PWM_CTRL1_POL_1_Msk                 (0x01UL << PWM_CTRL1_POL_1_Pos)                       /*!< PWM CTRL1: POL_1 Mask                 */
#define PWM_CTRL1_POL_2_Pos                 2                                                       /*!< PWM CTRL1: POL_2 Position             */
#define PWM_CTRL1_POL_2_Msk                 (0x01UL << PWM_CTRL1_POL_2_Pos)                       /*!< PWM CTRL1: POL_2 Mask                 */
#define PWM_CTRL1_POL_3_Pos                 3                                                       /*!< PWM CTRL1: POL_3 Position             */
#define PWM_CTRL1_POL_3_Msk                 (0x01UL << PWM_CTRL1_POL_3_Pos)                       /*!< PWM CTRL1: POL_3 Mask                 */
#define PWM_CTRL1_POL_4_Pos                 4                                                       /*!< PWM CTRL1: POL_4 Position             */
#define PWM_CTRL1_POL_4_Msk                 (0x01UL << PWM_CTRL1_POL_4_Pos)                       /*!< PWM CTRL1: POL_4 Mask                 */
#define PWM_CTRL1_POL_5_Pos                 5                                                       /*!< PWM CTRL1: POL_5 Position             */
#define PWM_CTRL1_POL_5_Msk                 (0x01UL << PWM_CTRL1_POL_5_Pos)                       /*!< PWM CTRL1: POL_5 Mask                 */
#define PWM_CTRL1_POL_6_Pos                 6                                                       /*!< PWM CTRL1: POL_6 Position             */
#define PWM_CTRL1_POL_6_Msk                 (0x01UL << PWM_CTRL1_POL_6_Pos)                       /*!< PWM CTRL1: POL_6 Mask                 */
#define PWM_CTRL1_POL_7_Pos                 7                                                       /*!< PWM CTRL1: POL_7 Position             */
#define PWM_CTRL1_POL_7_Msk                 (0x01UL << PWM_CTRL1_POL_7_Pos)                       /*!< PWM CTRL1: POL_7 Mask                 */
#define PWM_CTRL1_POL_8_Pos                 8                                                       /*!< PWM CTRL1: POL_8 Position             */
#define PWM_CTRL1_POL_8_Msk                 (0x01UL << PWM_CTRL1_POL_8_Pos)                       /*!< PWM CTRL1: POL_8 Mask                 */
#define PWM_CTRL1_POL_9_Pos                 9                                                       /*!< PWM CTRL1: POL_9 Position             */
#define PWM_CTRL1_POL_9_Msk                 (0x01UL << PWM_CTRL1_POL_9_Pos)                       /*!< PWM CTRL1: POL_9 Mask                 */
#define PWM_CTRL1_POL_10_Pos                10                                                      /*!< PWM CTRL1: POL_10 Position            */
#define PWM_CTRL1_POL_10_Msk                (0x01UL << PWM_CTRL1_POL_10_Pos)                      /*!< PWM CTRL1: POL_10 Mask                */
#define PWM_CTRL1_DIS_LEVEL_0_Pos           16                                                      /*!< PWM CTRL1: DIS_LEVEL_0 Position       */
#define PWM_CTRL1_DIS_LEVEL_0_Msk           (0x01UL << PWM_CTRL1_DIS_LEVEL_0_Pos)                 /*!< PWM CTRL1: DIS_LEVEL_0 Mask           */
#define PWM_CTRL1_DIS_LEVEL_1_Pos           17                                                      /*!< PWM CTRL1: DIS_LEVEL_1 Position       */
#define PWM_CTRL1_DIS_LEVEL_1_Msk           (0x01UL << PWM_CTRL1_DIS_LEVEL_1_Pos)                 /*!< PWM CTRL1: DIS_LEVEL_1 Mask           */
#define PWM_CTRL1_DIS_LEVEL_2_Pos           18                                                      /*!< PWM CTRL1: DIS_LEVEL_2 Position       */
#define PWM_CTRL1_DIS_LEVEL_2_Msk           (0x01UL << PWM_CTRL1_DIS_LEVEL_2_Pos)                 /*!< PWM CTRL1: DIS_LEVEL_2 Mask           */
#define PWM_CTRL1_DIS_LEVEL_3_Pos           19                                                      /*!< PWM CTRL1: DIS_LEVEL_3 Position       */
#define PWM_CTRL1_DIS_LEVEL_3_Msk           (0x01UL << PWM_CTRL1_DIS_LEVEL_3_Pos)                 /*!< PWM CTRL1: DIS_LEVEL_3 Mask           */
#define PWM_CTRL1_DIS_LEVEL_4_Pos           20                                                      /*!< PWM CTRL1: DIS_LEVEL_4 Position       */
#define PWM_CTRL1_DIS_LEVEL_4_Msk           (0x01UL << PWM_CTRL1_DIS_LEVEL_4_Pos)                 /*!< PWM CTRL1: DIS_LEVEL_4 Mask           */
#define PWM_CTRL1_DIS_LEVEL_5_Pos           21                                                      /*!< PWM CTRL1: DIS_LEVEL_5 Position       */
#define PWM_CTRL1_DIS_LEVEL_5_Msk           (0x01UL << PWM_CTRL1_DIS_LEVEL_5_Pos)                 /*!< PWM CTRL1: DIS_LEVEL_5 Mask           */
#define PWM_CTRL1_DIS_LEVEL_6_Pos           22                                                      /*!< PWM CTRL1: DIS_LEVEL_6 Position       */
#define PWM_CTRL1_DIS_LEVEL_6_Msk           (0x01UL << PWM_CTRL1_DIS_LEVEL_6_Pos)                 /*!< PWM CTRL1: DIS_LEVEL_6 Mask           */
#define PWM_CTRL1_DIS_LEVEL_7_Pos           23                                                      /*!< PWM CTRL1: DIS_LEVEL_7 Position       */
#define PWM_CTRL1_DIS_LEVEL_7_Msk           (0x01UL << PWM_CTRL1_DIS_LEVEL_7_Pos)                 /*!< PWM CTRL1: DIS_LEVEL_7 Mask           */
#define PWM_CTRL1_DIS_LEVEL_8_Pos           24                                                      /*!< PWM CTRL1: DIS_LEVEL_8 Position       */
#define PWM_CTRL1_DIS_LEVEL_8_Msk           (0x01UL << PWM_CTRL1_DIS_LEVEL_8_Pos)                 /*!< PWM CTRL1: DIS_LEVEL_8 Mask           */
#define PWM_CTRL1_DIS_LEVEL_9_Pos           25                                                      /*!< PWM CTRL1: DIS_LEVEL_9 Position       */
#define PWM_CTRL1_DIS_LEVEL_9_Msk           (0x01UL << PWM_CTRL1_DIS_LEVEL_9_Pos)                 /*!< PWM CTRL1: DIS_LEVEL_9 Mask           */

/* --------------------------------  u_pwm_PSCL01  -------------------------------- */
#define PWM_PSCL01_PSCL_0_Pos               0                                                       /*!< PWM PSCL01: PSCL_0 Position           */
#define PWM_PSCL01_PSCL_0_Msk               (0x000003ffUL << PWM_PSCL01_PSCL_0_Pos)               /*!< PWM PSCL01: PSCL_0 Mask               */
#define PWM_PSCL01_PSCL_1_Pos               16                                                      /*!< PWM PSCL01: PSCL_1 Position           */
#define PWM_PSCL01_PSCL_1_Msk               (0x000003ffUL << PWM_PSCL01_PSCL_1_Pos)               /*!< PWM PSCL01: PSCL_1 Mask               */

/* --------------------------------  u_pwm_PSCL23  -------------------------------- */
#define PWM_PSCL23_PSCL_2_Pos               0                                                       /*!< PWM PSCL23: PSCL_2 Position           */
#define PWM_PSCL23_PSCL_2_Msk               (0x000003ffUL << PWM_PSCL23_PSCL_2_Pos)               /*!< PWM PSCL23: PSCL_2 Mask               */
#define PWM_PSCL23_PSCL_3_Pos               16                                                      /*!< PWM PSCL23: PSCL_3 Position           */
#define PWM_PSCL23_PSCL_3_Msk               (0x000003ffUL << PWM_PSCL23_PSCL_3_Pos)               /*!< PWM PSCL23: PSCL_3 Mask               */

/* --------------------------------  u_pwm_PSCL45  -------------------------------- */
#define PWM_PSCL45_PSCL_4_Pos               0                                                       /*!< PWM PSCL45: PSCL_4 Position           */
#define PWM_PSCL45_PSCL_4_Msk               (0x000003ffUL << PWM_PSCL45_PSCL_4_Pos)               /*!< PWM PSCL45: PSCL_4 Mask               */
#define PWM_PSCL45_PSCL_5_Pos               16                                                      /*!< PWM PSCL45: PSCL_5 Position           */
#define PWM_PSCL45_PSCL_5_Msk               (0x000003ffUL << PWM_PSCL45_PSCL_5_Pos)               /*!< PWM PSCL45: PSCL_5 Mask               */

/* --------------------------------  u_pwm_PSCL67  -------------------------------- */
#define PWM_PSCL67_PSCL_6_Pos               0                                                       /*!< PWM PSCL67: PSCL_6 Position           */
#define PWM_PSCL67_PSCL_6_Msk               (0x000003ffUL << PWM_PSCL67_PSCL_6_Pos)               /*!< PWM PSCL67: PSCL_6 Mask               */
#define PWM_PSCL67_PSCL_7_Pos               16                                                      /*!< PWM PSCL67: PSCL_7 Position           */
#define PWM_PSCL67_PSCL_7_Msk               (0x000003ffUL << PWM_PSCL67_PSCL_7_Pos)               /*!< PWM PSCL67: PSCL_7 Mask               */

/* --------------------------------  u_pwm_PSCL89  -------------------------------- */
#define PWM_PSCL89_PSCL_8_Pos               0                                                       /*!< PWM PSCL89: PSCL_8 Position           */
#define PWM_PSCL89_PSCL_8_Msk               (0x000003ffUL << PWM_PSCL89_PSCL_8_Pos)               /*!< PWM PSCL89: PSCL_8 Mask               */
#define PWM_PSCL89_PSCL_9_Pos               16                                                      /*!< PWM PSCL89: PSCL_9 Position           */
#define PWM_PSCL89_PSCL_9_Msk               (0x000003ffUL << PWM_PSCL89_PSCL_9_Pos)               /*!< PWM PSCL89: PSCL_9 Mask               */

/* -------------------------------  u_pwm_PSCL1011  ------------------------------- */
#define PWM_PSCL1011_PSCL_10_Pos            0                                                       /*!< PWM PSCL1011: PSCL_10 Position        */
#define PWM_PSCL1011_PSCL_10_Msk            (0x000003ffUL << PWM_PSCL1011_PSCL_10_Pos)            /*!< PWM PSCL1011: PSCL_10 Mask            */

/* ---------------------------------  u_pwm_PCP0  --------------------------------- */
#define PWM_PCP0_PERIOD_Pos                 0                                                       /*!< PWM PCP0: PERIOD Position             */
#define PWM_PCP0_PERIOD_Msk                 (0x0000ffffUL << PWM_PCP0_PERIOD_Pos)                 /*!< PWM PCP0: PERIOD Mask                 */
#define PWM_PCP0_COMPARE_Pos                16                                                      /*!< PWM PCP0: COMPARE Position            */
#define PWM_PCP0_COMPARE_Msk                (0x0000ffffUL << PWM_PCP0_COMPARE_Pos)                /*!< PWM PCP0: COMPARE Mask                */

/* ---------------------------------  u_pwm_PCP1  --------------------------------- */
#define PWM_PCP1_PERIOD_Pos                 0                                                       /*!< PWM PCP1: PERIOD Position             */
#define PWM_PCP1_PERIOD_Msk                 (0x0000ffffUL << PWM_PCP1_PERIOD_Pos)                 /*!< PWM PCP1: PERIOD Mask                 */
#define PWM_PCP1_COMPARE_Pos                16                                                      /*!< PWM PCP1: COMPARE Position            */
#define PWM_PCP1_COMPARE_Msk                (0x0000ffffUL << PWM_PCP1_COMPARE_Pos)                /*!< PWM PCP1: COMPARE Mask                */

/* ---------------------------------  u_pwm_PCP2  --------------------------------- */
#define PWM_PCP2_PERIOD_Pos                 0                                                       /*!< PWM PCP2: PERIOD Position             */
#define PWM_PCP2_PERIOD_Msk                 (0x0000ffffUL << PWM_PCP2_PERIOD_Pos)                 /*!< PWM PCP2: PERIOD Mask                 */
#define PWM_PCP2_COMPARE_Pos                16                                                      /*!< PWM PCP2: COMPARE Position            */
#define PWM_PCP2_COMPARE_Msk                (0x0000ffffUL << PWM_PCP2_COMPARE_Pos)                /*!< PWM PCP2: COMPARE Mask                */

/* ---------------------------------  u_pwm_PCP3  --------------------------------- */
#define PWM_PCP3_PERIOD_Pos                 0                                                       /*!< PWM PCP3: PERIOD Position             */
#define PWM_PCP3_PERIOD_Msk                 (0x0000ffffUL << PWM_PCP3_PERIOD_Pos)                 /*!< PWM PCP3: PERIOD Mask                 */
#define PWM_PCP3_COMPARE_Pos                16                                                      /*!< PWM PCP3: COMPARE Position            */
#define PWM_PCP3_COMPARE_Msk                (0x0000ffffUL << PWM_PCP3_COMPARE_Pos)                /*!< PWM PCP3: COMPARE Mask                */

/* ---------------------------------  u_pwm_PCP4  --------------------------------- */
#define PWM_PCP4_PERIOD_Pos                 0                                                       /*!< PWM PCP4: PERIOD Position             */
#define PWM_PCP4_PERIOD_Msk                 (0x0000ffffUL << PWM_PCP4_PERIOD_Pos)                 /*!< PWM PCP4: PERIOD Mask                 */
#define PWM_PCP4_COMPARE_Pos                16                                                      /*!< PWM PCP4: COMPARE Position            */
#define PWM_PCP4_COMPARE_Msk                (0x0000ffffUL << PWM_PCP4_COMPARE_Pos)                /*!< PWM PCP4: COMPARE Mask                */

/* ---------------------------------  u_pwm_PCP5  --------------------------------- */
#define PWM_PCP5_PERIOD_Pos                 0                                                       /*!< PWM PCP5: PERIOD Position             */
#define PWM_PCP5_PERIOD_Msk                 (0x0000ffffUL << PWM_PCP5_PERIOD_Pos)                 /*!< PWM PCP5: PERIOD Mask                 */
#define PWM_PCP5_COMPARE_Pos                16                                                      /*!< PWM PCP5: COMPARE Position            */
#define PWM_PCP5_COMPARE_Msk                (0x0000ffffUL << PWM_PCP5_COMPARE_Pos)                /*!< PWM PCP5: COMPARE Mask                */

/* ---------------------------------  u_pwm_PCP6  --------------------------------- */
#define PWM_PCP6_PERIOD_Pos                 0                                                       /*!< PWM PCP6: PERIOD Position             */
#define PWM_PCP6_PERIOD_Msk                 (0x0000ffffUL << PWM_PCP6_PERIOD_Pos)                 /*!< PWM PCP6: PERIOD Mask                 */
#define PWM_PCP6_COMPARE_Pos                16                                                      /*!< PWM PCP6: COMPARE Position            */
#define PWM_PCP6_COMPARE_Msk                (0x0000ffffUL << PWM_PCP6_COMPARE_Pos)                /*!< PWM PCP6: COMPARE Mask                */

/* ---------------------------------  u_pwm_PCP7  --------------------------------- */
#define PWM_PCP7_PERIOD_Pos                 0                                                       /*!< PWM PCP7: PERIOD Position             */
#define PWM_PCP7_PERIOD_Msk                 (0x0000ffffUL << PWM_PCP7_PERIOD_Pos)                 /*!< PWM PCP7: PERIOD Mask                 */
#define PWM_PCP7_COMPARE_Pos                16                                                      /*!< PWM PCP7: COMPARE Position            */
#define PWM_PCP7_COMPARE_Msk                (0x0000ffffUL << PWM_PCP7_COMPARE_Pos)                /*!< PWM PCP7: COMPARE Mask                */

/* ---------------------------------  u_pwm_PCP8  --------------------------------- */
#define PWM_PCP8_PERIOD_Pos                 0                                                       /*!< PWM PCP8: PERIOD Position             */
#define PWM_PCP8_PERIOD_Msk                 (0x0000ffffUL << PWM_PCP8_PERIOD_Pos)                 /*!< PWM PCP8: PERIOD Mask                 */
#define PWM_PCP8_COMPARE_Pos                16                                                      /*!< PWM PCP8: COMPARE Position            */
#define PWM_PCP8_COMPARE_Msk                (0x0000ffffUL << PWM_PCP8_COMPARE_Pos)                /*!< PWM PCP8: COMPARE Mask                */

/* ---------------------------------  u_pwm_PCP9  --------------------------------- */
#define PWM_PCP9_PERIOD_Pos                 0                                                       /*!< PWM PCP9: PERIOD Position             */
#define PWM_PCP9_PERIOD_Msk                 (0x0000ffffUL << PWM_PCP9_PERIOD_Pos)                 /*!< PWM PCP9: PERIOD Mask                 */
#define PWM_PCP9_COMPARE_Pos                16                                                      /*!< PWM PCP9: COMPARE Position            */
#define PWM_PCP9_COMPARE_Msk                (0x0000ffffUL << PWM_PCP9_COMPARE_Pos)                /*!< PWM PCP9: COMPARE Mask                */

/* ---------------------------------  u_pwm_PCP10  -------------------------------- */
#define PWM_PCP10_PERIOD_Pos                0                                                       /*!< PWM PCP10: PERIOD Position            */
#define PWM_PCP10_PERIOD_Msk                (0x0000ffffUL << PWM_PCP10_PERIOD_Pos)                /*!< PWM PCP10: PERIOD Mask                */
#define PWM_PCP10_COMPARE_Pos               16                                                      /*!< PWM PCP10: COMPARE Position           */
#define PWM_PCP10_COMPARE_Msk               (0x0000ffffUL << PWM_PCP10_COMPARE_Pos)               /*!< PWM PCP10: COMPARE Mask               */

/* ---------------------------------  u_pwm_PST0  --------------------------------- */
#define PWM_PST0_INT_FLG_0_Pos              0                                                       /*!< PWM PST0: INT_FLG_0 Position          */
#define PWM_PST0_INT_FLG_0_Msk              (0x01UL << PWM_PST0_INT_FLG_0_Pos)                    /*!< PWM PST0: INT_FLG_0 Mask              */
#define PWM_PST0_INT_FLG_1_Pos              8                                                       /*!< PWM PST0: INT_FLG_1 Position          */
#define PWM_PST0_INT_FLG_1_Msk              (0x01UL << PWM_PST0_INT_FLG_1_Pos)                    /*!< PWM PST0: INT_FLG_1 Mask              */
#define PWM_PST0_INT_FLG_2_Pos              16                                                      /*!< PWM PST0: INT_FLG_2 Position          */
#define PWM_PST0_INT_FLG_2_Msk              (0x01UL << PWM_PST0_INT_FLG_2_Pos)                    /*!< PWM PST0: INT_FLG_2 Mask              */
#define PWM_PST0_INT_FLG_3_Pos              24                                                      /*!< PWM PST0: INT_FLG_3 Position          */
#define PWM_PST0_INT_FLG_3_Msk              (0x01UL << PWM_PST0_INT_FLG_3_Pos)                    /*!< PWM PST0: INT_FLG_3 Mask              */

/* ---------------------------------  u_pwm_PST1  --------------------------------- */
#define PWM_PST1_INT_FLG_4_Pos              0                                                       /*!< PWM PST1: INT_FLG_4 Position          */
#define PWM_PST1_INT_FLG_4_Msk              (0x01UL << PWM_PST1_INT_FLG_4_Pos)                    /*!< PWM PST1: INT_FLG_4 Mask              */
#define PWM_PST1_INT_FLG_5_Pos              8                                                       /*!< PWM PST1: INT_FLG_5 Position          */
#define PWM_PST1_INT_FLG_5_Msk              (0x01UL << PWM_PST1_INT_FLG_5_Pos)                    /*!< PWM PST1: INT_FLG_5 Mask              */
#define PWM_PST1_INT_FLG_6_Pos              16                                                      /*!< PWM PST1: INT_FLG_6 Position          */
#define PWM_PST1_INT_FLG_6_Msk              (0x01UL << PWM_PST1_INT_FLG_6_Pos)                    /*!< PWM PST1: INT_FLG_6 Mask              */
#define PWM_PST1_INT_FLG_7_Pos              24                                                      /*!< PWM PST1: INT_FLG_7 Position          */
#define PWM_PST1_INT_FLG_7_Msk              (0x01UL << PWM_PST1_INT_FLG_7_Pos)                    /*!< PWM PST1: INT_FLG_7 Mask              */

/* ---------------------------------  u_pwm_PST2  --------------------------------- */
#define PWM_PST2_INT_FLG_8_Pos              0                                                       /*!< PWM PST2: INT_FLG_8 Position          */
#define PWM_PST2_INT_FLG_8_Msk              (0x01UL << PWM_PST2_INT_FLG_8_Pos)                    /*!< PWM PST2: INT_FLG_8 Mask              */
#define PWM_PST2_INT_FLG_9_Pos              8                                                       /*!< PWM PST2: INT_FLG_9 Position          */
#define PWM_PST2_INT_FLG_9_Msk              (0x01UL << PWM_PST2_INT_FLG_9_Pos)                    /*!< PWM PST2: INT_FLG_9 Mask              */
#define PWM_PST2_INT_FLG_10_Pos             16                                                      /*!< PWM PST2: INT_FLG_10 Position         */
#define PWM_PST2_INT_FLG_10_Msk             (0x01UL << PWM_PST2_INT_FLG_10_Pos)                   /*!< PWM PST2: INT_FLG_10 Mask             */

/* -------------------------------  u_pwm_MODULE_ID  ------------------------------ */
#define PWM_MODULE_ID_APERTURE_Pos          0                                                       /*!< PWM MODULE_ID: APERTURE Position      */
#define PWM_MODULE_ID_APERTURE_Msk          (0x000000ffUL << PWM_MODULE_ID_APERTURE_Pos)          /*!< PWM MODULE_ID: APERTURE Mask          */
#define PWM_MODULE_ID_MIN_REV_Pos           8                                                       /*!< PWM MODULE_ID: MIN_REV Position       */
#define PWM_MODULE_ID_MIN_REV_Msk           (0x0fUL << PWM_MODULE_ID_MIN_REV_Pos)                 /*!< PWM MODULE_ID: MIN_REV Mask           */
#define PWM_MODULE_ID_MAJ_REV_Pos           12                                                      /*!< PWM MODULE_ID: MAJ_REV Position       */
#define PWM_MODULE_ID_MAJ_REV_Msk           (0x0fUL << PWM_MODULE_ID_MAJ_REV_Pos)                 /*!< PWM MODULE_ID: MAJ_REV Mask           */
#define PWM_MODULE_ID_ID_Pos                16                                                      /*!< PWM MODULE_ID: ID Position            */
#define PWM_MODULE_ID_ID_Msk                (0x0000ffffUL << PWM_MODULE_ID_ID_Pos)                /*!< PWM MODULE_ID: ID Mask                */


/* ================================================================================ */
/* ================         struct 'u_rng' Position & Mask         ================ */
/* ================================================================================ */


/* -----------------------------  u_rng_RANDOM_NUMBER  ---------------------------- */
#define RNG_RANDOM_NUMBER_RANDOM_NUMBER_Pos 0                                                       /*!< RNG RANDOM_NUMBER: RANDOM_NUMBER Position */
#define RNG_RANDOM_NUMBER_RANDOM_NUMBER_Msk (0xffffffffUL << RNG_RANDOM_NUMBER_RANDOM_NUMBER_Pos) /*!< RNG RANDOM_NUMBER: RANDOM_NUMBER Mask */

/* ---------------------------  u_rng_ENCRYPTED_NUMBER  --------------------------- */
#define RNG_ENCRYPTED_NUMBER_ENCRYPTED_NUMBER_Pos 0                                                 /*!< RNG ENCRYPTED_NUMBER: ENCRYPTED_NUMBER Position */
#define RNG_ENCRYPTED_NUMBER_ENCRYPTED_NUMBER_Msk (0xffffffffUL << RNG_ENCRYPTED_NUMBER_ENCRYPTED_NUMBER_Pos)/*!< RNG ENCRYPTED_NUMBER: ENCRYPTED_NUMBER Mask */

/* ------------------------------  u_rng_COUNTER_VAL  ----------------------------- */
#define RNG_COUNTER_VAL_CLK_RATIO_Pos       0                                                       /*!< RNG COUNTER_VAL: CLK_RATIO Position   */
#define RNG_COUNTER_VAL_CLK_RATIO_Msk       (0x000000ffUL << RNG_COUNTER_VAL_CLK_RATIO_Pos)       /*!< RNG COUNTER_VAL: CLK_RATIO Mask       */
#define RNG_COUNTER_VAL_REFRESH_CNT_Pos     8                                                       /*!< RNG COUNTER_VAL: REFRESH_CNT Position */
#define RNG_COUNTER_VAL_REFRESH_CNT_Msk     (0x1fUL << RNG_COUNTER_VAL_REFRESH_CNT_Pos)           /*!< RNG COUNTER_VAL: REFRESH_CNT Mask     */

/* ------------------------------  u_rng_COUNTER_CFG  ----------------------------- */
#define RNG_COUNTER_CFG_MODE_Pos            0                                                       /*!< RNG COUNTER_CFG: MODE Position        */
#define RNG_COUNTER_CFG_MODE_Msk            (0x03UL << RNG_COUNTER_CFG_MODE_Pos)                  /*!< RNG COUNTER_CFG: MODE Mask            */
#define RNG_COUNTER_CFG_CLOCK_SEL_Pos       2                                                       /*!< RNG COUNTER_CFG: CLOCK_SEL Position   */
#define RNG_COUNTER_CFG_CLOCK_SEL_Msk       (0x07UL << RNG_COUNTER_CFG_CLOCK_SEL_Pos)             /*!< RNG COUNTER_CFG: CLOCK_SEL Mask       */
#define RNG_COUNTER_CFG_SHIFT4X_Pos         5                                                       /*!< RNG COUNTER_CFG: SHIFT4X Position     */
#define RNG_COUNTER_CFG_SHIFT4X_Msk         (0x07UL << RNG_COUNTER_CFG_SHIFT4X_Pos)               /*!< RNG COUNTER_CFG: SHIFT4X Mask         */
#define RNG_COUNTER_CFG_DIS_ENH_ENTR_REFILL_Pos 8                                                   /*!< RNG COUNTER_CFG: DIS_ENH_ENTR_REFILL Position */
#define RNG_COUNTER_CFG_DIS_ENH_ENTR_REFILL_Msk (0x01UL << RNG_COUNTER_CFG_DIS_ENH_ENTR_REFILL_Pos)/*!< RNG COUNTER_CFG: DIS_ENH_ENTR_REFILL Mask */
#define RNG_COUNTER_CFG_FORCE_ENTR_SPREADING_Pos 9                                                  /*!< RNG COUNTER_CFG: FORCE_ENTR_SPREADING Position */
#define RNG_COUNTER_CFG_FORCE_ENTR_SPREADING_Msk (0x01UL << RNG_COUNTER_CFG_FORCE_ENTR_SPREADING_Pos)/*!< RNG COUNTER_CFG: FORCE_ENTR_SPREADING Mask */

/* ----------------------------  u_rng_ONLINE_TEST_CFG  --------------------------- */
#define RNG_ONLINE_TEST_CFG_ACTIVATE_Pos    0                                                       /*!< RNG ONLINE_TEST_CFG: ACTIVATE Position */
#define RNG_ONLINE_TEST_CFG_ACTIVATE_Msk    (0x01UL << RNG_ONLINE_TEST_CFG_ACTIVATE_Pos)          /*!< RNG ONLINE_TEST_CFG: ACTIVATE Mask    */
#define RNG_ONLINE_TEST_CFG_DATA_SEL_Pos    1                                                       /*!< RNG ONLINE_TEST_CFG: DATA_SEL Position */
#define RNG_ONLINE_TEST_CFG_DATA_SEL_Msk    (0x03UL << RNG_ONLINE_TEST_CFG_DATA_SEL_Pos)          /*!< RNG ONLINE_TEST_CFG: DATA_SEL Mask    */

/* ----------------------------  u_rng_ONLINE_TEST_VAL  --------------------------- */
#define RNG_ONLINE_TEST_VAL_LIVE_CHI_SQUARED_Pos 0                                                  /*!< RNG ONLINE_TEST_VAL: LIVE_CHI_SQUARED Position */
#define RNG_ONLINE_TEST_VAL_LIVE_CHI_SQUARED_Msk (0x0fUL << RNG_ONLINE_TEST_VAL_LIVE_CHI_SQUARED_Pos)/*!< RNG ONLINE_TEST_VAL: LIVE_CHI_SQUARED Mask */
#define RNG_ONLINE_TEST_VAL_MIN_CHI_SQUARED_Pos 4                                                   /*!< RNG ONLINE_TEST_VAL: MIN_CHI_SQUARED Position */
#define RNG_ONLINE_TEST_VAL_MIN_CHI_SQUARED_Msk (0x0fUL << RNG_ONLINE_TEST_VAL_MIN_CHI_SQUARED_Pos)/*!< RNG ONLINE_TEST_VAL: MIN_CHI_SQUARED Mask */
#define RNG_ONLINE_TEST_VAL_MAX_CHI_SQUARED_Pos 8                                                   /*!< RNG ONLINE_TEST_VAL: MAX_CHI_SQUARED Position */
#define RNG_ONLINE_TEST_VAL_MAX_CHI_SQUARED_Msk (0x0fUL << RNG_ONLINE_TEST_VAL_MAX_CHI_SQUARED_Pos)/*!< RNG ONLINE_TEST_VAL: MAX_CHI_SQUARED Mask */

/* -------------------------------  u_rng_MISC_CFG  ------------------------------- */
#define RNG_MISC_CFG_AES_RESEED_Pos         0                                                       /*!< RNG MISC_CFG: AES_RESEED Position     */
#define RNG_MISC_CFG_AES_RESEED_Msk         (0x01UL << RNG_MISC_CFG_AES_RESEED_Pos)               /*!< RNG MISC_CFG: AES_RESEED Mask         */
#define RNG_MISC_CFG_AES_DT_CFG_Pos         1                                                       /*!< RNG MISC_CFG: AES_DT_CFG Position     */
#define RNG_MISC_CFG_AES_DT_CFG_Msk         (0x01UL << RNG_MISC_CFG_AES_DT_CFG_Pos)               /*!< RNG MISC_CFG: AES_DT_CFG Mask         */

/* -------------------------------  u_rng_POWERDOWN  ------------------------------ */
#define RNG_POWERDOWN_SOFT_RESET_Pos        0                                                       /*!< RNG POWERDOWN: SOFT_RESET Position    */
#define RNG_POWERDOWN_SOFT_RESET_Msk        (0x01UL << RNG_POWERDOWN_SOFT_RESET_Pos)              /*!< RNG POWERDOWN: SOFT_RESET Mask        */
#define RNG_POWERDOWN_FORCE_SOFT_RESET_Pos  1                                                       /*!< RNG POWERDOWN: FORCE_SOFT_RESET Position */
#define RNG_POWERDOWN_FORCE_SOFT_RESET_Msk  (0x01UL << RNG_POWERDOWN_FORCE_SOFT_RESET_Pos)        /*!< RNG POWERDOWN: FORCE_SOFT_RESET Mask  */
#define RNG_POWERDOWN_POWERDOWN_Pos         31                                                      /*!< RNG POWERDOWN: POWERDOWN Position     */
#define RNG_POWERDOWN_POWERDOWN_Msk         (0x01UL << RNG_POWERDOWN_POWERDOWN_Pos)               /*!< RNG POWERDOWN: POWERDOWN Mask         */

/* -------------------------------  u_rng_MODULEID  ------------------------------- */
#define RNG_MODULEID_APERTURE_Pos           0                                                       /*!< RNG MODULEID: APERTURE Position       */
#define RNG_MODULEID_APERTURE_Msk           (0x000000ffUL << RNG_MODULEID_APERTURE_Pos)           /*!< RNG MODULEID: APERTURE Mask           */
#define RNG_MODULEID_MIN_REV_Pos            8                                                       /*!< RNG MODULEID: MIN_REV Position        */
#define RNG_MODULEID_MIN_REV_Msk            (0x0fUL << RNG_MODULEID_MIN_REV_Pos)                  /*!< RNG MODULEID: MIN_REV Mask            */
#define RNG_MODULEID_MAJ_REV_Pos            12                                                      /*!< RNG MODULEID: MAJ_REV Position        */
#define RNG_MODULEID_MAJ_REV_Msk            (0x0fUL << RNG_MODULEID_MAJ_REV_Pos)                  /*!< RNG MODULEID: MAJ_REV Mask            */
#define RNG_MODULEID_ID_Pos                 16                                                      /*!< RNG MODULEID: ID Position             */
#define RNG_MODULEID_ID_Msk                 (0x0000ffffUL << RNG_MODULEID_ID_Pos)                 /*!< RNG MODULEID: ID Mask                 */


/* ================================================================================ */
/* ================        struct 'u_inmux' Position & Mask        ================ */
/* ================================================================================ */


/* -------------------------------  u_inmux_PINTSEL  ------------------------------ */
#define INMUX_PINTSEL_INTPIN_Pos            0                                                       /*!< INMUX PINTSEL: INTPIN Position        */
#define INMUX_PINTSEL_INTPIN_Msk            (0x1fUL << INMUX_PINTSEL_INTPIN_Pos)                  /*!< INMUX PINTSEL: INTPIN Mask            */

/* ---------------------------  u_inmux_DMA_ITRIG_INMUX  -------------------------- */
#define INMUX_DMA_ITRIG_INMUX_INP_Pos       0                                                       /*!< INMUX DMA_ITRIG_INMUX: INP Position   */
#define INMUX_DMA_ITRIG_INMUX_INP_Msk       (0x1fUL << INMUX_DMA_ITRIG_INMUX_INP_Pos)             /*!< INMUX DMA_ITRIG_INMUX: INP Mask       */

/* ---------------------------  u_inmux_DMA_OTRIG_INMUX  -------------------------- */
#define INMUX_DMA_OTRIG_INMUX_INP_Pos       0                                                       /*!< INMUX DMA_OTRIG_INMUX: INP Position   */
#define INMUX_DMA_OTRIG_INMUX_INP_Msk       (0x1fUL << INMUX_DMA_OTRIG_INMUX_INP_Pos)             /*!< INMUX DMA_OTRIG_INMUX: INP Mask       */

/* ----------------------------  u_inmux_FREQMEAS_REF  ---------------------------- */
#define INMUX_FREQMEAS_REF_CLKIN_Pos        0                                                       /*!< INMUX FREQMEAS_REF: CLKIN Position    */
#define INMUX_FREQMEAS_REF_CLKIN_Msk        (0x0fUL << INMUX_FREQMEAS_REF_CLKIN_Pos)              /*!< INMUX FREQMEAS_REF: CLKIN Mask        */

/* ---------------------------  u_inmux_FREQMEAS_TARGET  -------------------------- */
#define INMUX_FREQMEAS_TARGET_CLKIN_Pos     0                                                       /*!< INMUX FREQMEAS_TARGET: CLKIN Position */
#define INMUX_FREQMEAS_TARGET_CLKIN_Msk     (0x0fUL << INMUX_FREQMEAS_TARGET_CLKIN_Pos)           /*!< INMUX FREQMEAS_TARGET: CLKIN Mask     */


/* ================================================================================ */
/* ================        struct 'u_iocon' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u_iocon_PIO  -------------------------------- */
#define IOCON_PIO_FUNC_Pos                  0                                                       /*!< IOCON PIO: FUNC Position              */
#define IOCON_PIO_FUNC_Msk                  (0x07UL << IOCON_PIO_FUNC_Pos)                        /*!< IOCON PIO: FUNC Mask                  */
#define IOCON_PIO_MODE_Pos                  3                                                       /*!< IOCON PIO: MODE Position              */
#define IOCON_PIO_MODE_Msk                  (0x03UL << IOCON_PIO_MODE_Pos)                        /*!< IOCON PIO: MODE Mask                  */
#define IOCON_PIO_SLEW0_Pos                 5                                                       /*!< IOCON PIO: SLEW0 Position             */
#define IOCON_PIO_SLEW0_Msk                 (0x01UL << IOCON_PIO_SLEW0_Pos)                       /*!< IOCON PIO: SLEW0 Mask                 */
#define IOCON_PIO_INVERT_Pos                6                                                       /*!< IOCON PIO: INVERT Position            */
#define IOCON_PIO_INVERT_Msk                (0x01UL << IOCON_PIO_INVERT_Pos)                      /*!< IOCON PIO: INVERT Mask                */
#define IOCON_PIO_DIGIMODE_Pos              7                                                       /*!< IOCON PIO: DIGIMODE Position          */
#define IOCON_PIO_DIGIMODE_Msk              (0x01UL << IOCON_PIO_DIGIMODE_Pos)                    /*!< IOCON PIO: DIGIMODE Mask              */
#define IOCON_PIO_FILTEROFF_Pos             8                                                       /*!< IOCON PIO: FILTEROFF Position         */
#define IOCON_PIO_FILTEROFF_Msk             (0x01UL << IOCON_PIO_FILTEROFF_Pos)                   /*!< IOCON PIO: FILTEROFF Mask             */
#define IOCON_PIO_SLEW1_Pos                 9                                                       /*!< IOCON PIO: SLEW1 Position             */
#define IOCON_PIO_SLEW1_Msk                 (0x01UL << IOCON_PIO_SLEW1_Pos)                       /*!< IOCON PIO: SLEW1 Mask                 */
#define IOCON_PIO_OD_Pos                    10                                                      /*!< IOCON PIO: OD Position                */
#define IOCON_PIO_OD_Msk                    (0x01UL << IOCON_PIO_OD_Pos)                          /*!< IOCON PIO: OD Mask                    */
#define IOCON_PIO_SSEL_Pos                  11                                                      /*!< IOCON PIO: SSEL Position              */
#define IOCON_PIO_SSEL_Msk                  (0x01UL << IOCON_PIO_SSEL_Pos)                        /*!< IOCON PIO: SSEL Mask                  */
#define IOCON_PIO_DBG_FUNC_Pos              12                                                      /*!< IOCON PIO: DBG_FUNC Position          */
#define IOCON_PIO_DBG_FUNC_Msk              (0x0fUL << IOCON_PIO_DBG_FUNC_Pos)                    /*!< IOCON PIO: DBG_FUNC Mask              */
#define IOCON_PIO_DBG_MODE_Pos              16                                                      /*!< IOCON PIO: DBG_MODE Position          */
#define IOCON_PIO_DBG_MODE_Msk              (0x01UL << IOCON_PIO_DBG_MODE_Pos)                    /*!< IOCON PIO: DBG_MODE Mask              */


/* ================================================================================ */
/* ================         struct 'u_pint' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u_pint_ISEL  -------------------------------- */
#define PININT_ISEL_PMODE_PIN0_Pos            0                                                       /*!< PININT ISEL: PMODE_PIN0 Position        */
#define PININT_ISEL_PMODE_PIN0_Msk            (0x01UL << PININT_ISEL_PMODE_PIN0_Pos)                  /*!< PININT ISEL: PMODE_PIN0 Mask            */
#define PININT_ISEL_PMODE_PIN1_Pos            1                                                       /*!< PININT ISEL: PMODE_PIN1 Position        */
#define PININT_ISEL_PMODE_PIN1_Msk            (0x01UL << PININT_ISEL_PMODE_PIN1_Pos)                  /*!< PININT ISEL: PMODE_PIN1 Mask            */
#define PININT_ISEL_PMODE_PIN2_Pos            2                                                       /*!< PININT ISEL: PMODE_PIN2 Position        */
#define PININT_ISEL_PMODE_PIN2_Msk            (0x01UL << PININT_ISEL_PMODE_PIN2_Pos)                  /*!< PININT ISEL: PMODE_PIN2 Mask            */
#define PININT_ISEL_PMODE_PIN3_Pos            3                                                       /*!< PININT ISEL: PMODE_PIN3 Position        */
#define PININT_ISEL_PMODE_PIN3_Msk            (0x01UL << PININT_ISEL_PMODE_PIN3_Pos)                  /*!< PININT ISEL: PMODE_PIN3 Mask            */
#define PININT_ISEL_PMODE_PIN4_Pos            4                                                       /*!< PININT ISEL: PMODE_PIN4 Position        */
#define PININT_ISEL_PMODE_PIN4_Msk            (0x01UL << PININT_ISEL_PMODE_PIN4_Pos)                  /*!< PININT ISEL: PMODE_PIN4 Mask            */
#define PININT_ISEL_PMODE_PIN5_Pos            5                                                       /*!< PININT ISEL: PMODE_PIN5 Position        */
#define PININT_ISEL_PMODE_PIN5_Msk            (0x01UL << PININT_ISEL_PMODE_PIN5_Pos)                  /*!< PININT ISEL: PMODE_PIN5 Mask            */
#define PININT_ISEL_PMODE_PIN6_Pos            6                                                       /*!< PININT ISEL: PMODE_PIN6 Position        */
#define PININT_ISEL_PMODE_PIN6_Msk            (0x01UL << PININT_ISEL_PMODE_PIN6_Pos)                  /*!< PININT ISEL: PMODE_PIN6 Mask            */
#define PININT_ISEL_PMODE_PIN7_Pos            7                                                       /*!< PININT ISEL: PMODE_PIN7 Position        */
#define PININT_ISEL_PMODE_PIN7_Msk            (0x01UL << PININT_ISEL_PMODE_PIN7_Pos)                  /*!< PININT ISEL: PMODE_PIN7 Mask            */

/* ---------------------------------  u_pint_IENR  -------------------------------- */
#define PININT_IENR_ENRL_PIN0_Pos             0                                                       /*!< PININT IENR: ENRL_PIN0 Position         */
#define PININT_IENR_ENRL_PIN0_Msk             (0x01UL << PININT_IENR_ENRL_PIN0_Pos)                   /*!< PININT IENR: ENRL_PIN0 Mask             */
#define PININT_IENR_ENRL_PIN1_Pos             1                                                       /*!< PININT IENR: ENRL_PIN1 Position         */
#define PININT_IENR_ENRL_PIN1_Msk             (0x01UL << PININT_IENR_ENRL_PIN1_Pos)                   /*!< PININT IENR: ENRL_PIN1 Mask             */
#define PININT_IENR_ENRL_PIN2_Pos             2                                                       /*!< PININT IENR: ENRL_PIN2 Position         */
#define PININT_IENR_ENRL_PIN2_Msk             (0x01UL << PININT_IENR_ENRL_PIN2_Pos)                   /*!< PININT IENR: ENRL_PIN2 Mask             */
#define PININT_IENR_ENRL_PIN3_Pos             3                                                       /*!< PININT IENR: ENRL_PIN3 Position         */
#define PININT_IENR_ENRL_PIN3_Msk             (0x01UL << PININT_IENR_ENRL_PIN3_Pos)                   /*!< PININT IENR: ENRL_PIN3 Mask             */
#define PININT_IENR_ENRL_PIN4_Pos             4                                                       /*!< PININT IENR: ENRL_PIN4 Position         */
#define PININT_IENR_ENRL_PIN4_Msk             (0x01UL << PININT_IENR_ENRL_PIN4_Pos)                   /*!< PININT IENR: ENRL_PIN4 Mask             */
#define PININT_IENR_ENRL_PIN5_Pos             5                                                       /*!< PININT IENR: ENRL_PIN5 Position         */
#define PININT_IENR_ENRL_PIN5_Msk             (0x01UL << PININT_IENR_ENRL_PIN5_Pos)                   /*!< PININT IENR: ENRL_PIN5 Mask             */
#define PININT_IENR_ENRL_PIN6_Pos             6                                                       /*!< PININT IENR: ENRL_PIN6 Position         */
#define PININT_IENR_ENRL_PIN6_Msk             (0x01UL << PININT_IENR_ENRL_PIN6_Pos)                   /*!< PININT IENR: ENRL_PIN6 Mask             */
#define PININT_IENR_ENRL_PIN7_Pos             7                                                       /*!< PININT IENR: ENRL_PIN7 Position         */
#define PININT_IENR_ENRL_PIN7_Msk             (0x01UL << PININT_IENR_ENRL_PIN7_Pos)                   /*!< PININT IENR: ENRL_PIN7 Mask             */

/* --------------------------------  u_pint_SIENR  -------------------------------- */
#define PININT_SIENR_SETENRL_PIN0_Pos         0                                                       /*!< PININT SIENR: SETENRL_PIN0 Position     */
#define PININT_SIENR_SETENRL_PIN0_Msk         (0x01UL << PININT_SIENR_SETENRL_PIN0_Pos)               /*!< PININT SIENR: SETENRL_PIN0 Mask         */
#define PININT_SIENR_SETENRL_PIN1_Pos         1                                                       /*!< PININT SIENR: SETENRL_PIN1 Position     */
#define PININT_SIENR_SETENRL_PIN1_Msk         (0x01UL << PININT_SIENR_SETENRL_PIN1_Pos)               /*!< PININT SIENR: SETENRL_PIN1 Mask         */
#define PININT_SIENR_SETENRL_PIN2_Pos         2                                                       /*!< PININT SIENR: SETENRL_PIN2 Position     */
#define PININT_SIENR_SETENRL_PIN2_Msk         (0x01UL << PININT_SIENR_SETENRL_PIN2_Pos)               /*!< PININT SIENR: SETENRL_PIN2 Mask         */
#define PININT_SIENR_SETENRL_PIN3_Pos         3                                                       /*!< PININT SIENR: SETENRL_PIN3 Position     */
#define PININT_SIENR_SETENRL_PIN3_Msk         (0x01UL << PININT_SIENR_SETENRL_PIN3_Pos)               /*!< PININT SIENR: SETENRL_PIN3 Mask         */
#define PININT_SIENR_SETENRL_PIN4_Pos         4                                                       /*!< PININT SIENR: SETENRL_PIN4 Position     */
#define PININT_SIENR_SETENRL_PIN4_Msk         (0x01UL << PININT_SIENR_SETENRL_PIN4_Pos)               /*!< PININT SIENR: SETENRL_PIN4 Mask         */
#define PININT_SIENR_SETENRL_PIN5_Pos         5                                                       /*!< PININT SIENR: SETENRL_PIN5 Position     */
#define PININT_SIENR_SETENRL_PIN5_Msk         (0x01UL << PININT_SIENR_SETENRL_PIN5_Pos)               /*!< PININT SIENR: SETENRL_PIN5 Mask         */
#define PININT_SIENR_SETENRL_PIN6_Pos         6                                                       /*!< PININT SIENR: SETENRL_PIN6 Position     */
#define PININT_SIENR_SETENRL_PIN6_Msk         (0x01UL << PININT_SIENR_SETENRL_PIN6_Pos)               /*!< PININT SIENR: SETENRL_PIN6 Mask         */
#define PININT_SIENR_SETENRL_PIN7_Pos         7                                                       /*!< PININT SIENR: SETENRL_PIN7 Position     */
#define PININT_SIENR_SETENRL_PIN7_Msk         (0x01UL << PININT_SIENR_SETENRL_PIN7_Pos)               /*!< PININT SIENR: SETENRL_PIN7 Mask         */

/* --------------------------------  u_pint_CIENR  -------------------------------- */
#define PININT_CIENR_CLRENRL_PIN0_Pos         0                                                       /*!< PININT CIENR: CLRENRL_PIN0 Position     */
#define PININT_CIENR_CLRENRL_PIN0_Msk         (0x01UL << PININT_CIENR_CLRENRL_PIN0_Pos)               /*!< PININT CIENR: CLRENRL_PIN0 Mask         */
#define PININT_CIENR_CLRENRL_PIN1_Pos         1                                                       /*!< PININT CIENR: CLRENRL_PIN1 Position     */
#define PININT_CIENR_CLRENRL_PIN1_Msk         (0x01UL << PININT_CIENR_CLRENRL_PIN1_Pos)               /*!< PININT CIENR: CLRENRL_PIN1 Mask         */
#define PININT_CIENR_CLRENRL_PIN2_Pos         2                                                       /*!< PININT CIENR: CLRENRL_PIN2 Position     */
#define PININT_CIENR_CLRENRL_PIN2_Msk         (0x01UL << PININT_CIENR_CLRENRL_PIN2_Pos)               /*!< PININT CIENR: CLRENRL_PIN2 Mask         */
#define PININT_CIENR_CLRENRL_PIN3_Pos         3                                                       /*!< PININT CIENR: CLRENRL_PIN3 Position     */
#define PININT_CIENR_CLRENRL_PIN3_Msk         (0x01UL << PININT_CIENR_CLRENRL_PIN3_Pos)               /*!< PININT CIENR: CLRENRL_PIN3 Mask         */
#define PININT_CIENR_CLRENRL_PIN4_Pos         4                                                       /*!< PININT CIENR: CLRENRL_PIN4 Position     */
#define PININT_CIENR_CLRENRL_PIN4_Msk         (0x01UL << PININT_CIENR_CLRENRL_PIN4_Pos)               /*!< PININT CIENR: CLRENRL_PIN4 Mask         */
#define PININT_CIENR_CLRENRL_PIN5_Pos         5                                                       /*!< PININT CIENR: CLRENRL_PIN5 Position     */
#define PININT_CIENR_CLRENRL_PIN5_Msk         (0x01UL << PININT_CIENR_CLRENRL_PIN5_Pos)               /*!< PININT CIENR: CLRENRL_PIN5 Mask         */
#define PININT_CIENR_CLRENRL_PIN6_Pos         6                                                       /*!< PININT CIENR: CLRENRL_PIN6 Position     */
#define PININT_CIENR_CLRENRL_PIN6_Msk         (0x01UL << PININT_CIENR_CLRENRL_PIN6_Pos)               /*!< PININT CIENR: CLRENRL_PIN6 Mask         */
#define PININT_CIENR_CLRENRL_PIN7_Pos         7                                                       /*!< PININT CIENR: CLRENRL_PIN7 Position     */
#define PININT_CIENR_CLRENRL_PIN7_Msk         (0x01UL << PININT_CIENR_CLRENRL_PIN7_Pos)               /*!< PININT CIENR: CLRENRL_PIN7 Mask         */

/* ---------------------------------  u_pint_IENF  -------------------------------- */
#define PININT_IENF_ENAF_PIN0_Pos             0                                                       /*!< PININT IENF: ENAF_PIN0 Position         */
#define PININT_IENF_ENAF_PIN0_Msk             (0x01UL << PININT_IENF_ENAF_PIN0_Pos)                   /*!< PININT IENF: ENAF_PIN0 Mask             */
#define PININT_IENF_ENAF_PIN1_Pos             1                                                       /*!< PININT IENF: ENAF_PIN1 Position         */
#define PININT_IENF_ENAF_PIN1_Msk             (0x01UL << PININT_IENF_ENAF_PIN1_Pos)                   /*!< PININT IENF: ENAF_PIN1 Mask             */
#define PININT_IENF_ENAF_PIN2_Pos             2                                                       /*!< PININT IENF: ENAF_PIN2 Position         */
#define PININT_IENF_ENAF_PIN2_Msk             (0x01UL << PININT_IENF_ENAF_PIN2_Pos)                   /*!< PININT IENF: ENAF_PIN2 Mask             */
#define PININT_IENF_ENAF_PIN3_Pos             3                                                       /*!< PININT IENF: ENAF_PIN3 Position         */
#define PININT_IENF_ENAF_PIN3_Msk             (0x01UL << PININT_IENF_ENAF_PIN3_Pos)                   /*!< PININT IENF: ENAF_PIN3 Mask             */
#define PININT_IENF_ENAF_PIN4_Pos             4                                                       /*!< PININT IENF: ENAF_PIN4 Position         */
#define PININT_IENF_ENAF_PIN4_Msk             (0x01UL << PININT_IENF_ENAF_PIN4_Pos)                   /*!< PININT IENF: ENAF_PIN4 Mask             */
#define PININT_IENF_ENAF_PIN5_Pos             5                                                       /*!< PININT IENF: ENAF_PIN5 Position         */
#define PININT_IENF_ENAF_PIN5_Msk             (0x01UL << PININT_IENF_ENAF_PIN5_Pos)                   /*!< PININT IENF: ENAF_PIN5 Mask             */
#define PININT_IENF_ENAF_PIN6_Pos             6                                                       /*!< PININT IENF: ENAF_PIN6 Position         */
#define PININT_IENF_ENAF_PIN6_Msk             (0x01UL << PININT_IENF_ENAF_PIN6_Pos)                   /*!< PININT IENF: ENAF_PIN6 Mask             */
#define PININT_IENF_ENAF_PIN7_Pos             7                                                       /*!< PININT IENF: ENAF_PIN7 Position         */
#define PININT_IENF_ENAF_PIN7_Msk             (0x01UL << PININT_IENF_ENAF_PIN7_Pos)                   /*!< PININT IENF: ENAF_PIN7 Mask             */

/* --------------------------------  u_pint_SIENF  -------------------------------- */
#define PININT_SIENF_SETENAF_PIN0_Pos         0                                                       /*!< PININT SIENF: SETENAF_PIN0 Position     */
#define PININT_SIENF_SETENAF_PIN0_Msk         (0x01UL << PININT_SIENF_SETENAF_PIN0_Pos)               /*!< PININT SIENF: SETENAF_PIN0 Mask         */
#define PININT_SIENF_SETENAF_PIN1_Pos         1                                                       /*!< PININT SIENF: SETENAF_PIN1 Position     */
#define PININT_SIENF_SETENAF_PIN1_Msk         (0x01UL << PININT_SIENF_SETENAF_PIN1_Pos)               /*!< PININT SIENF: SETENAF_PIN1 Mask         */
#define PININT_SIENF_SETENAF_PIN2_Pos         2                                                       /*!< PININT SIENF: SETENAF_PIN2 Position     */
#define PININT_SIENF_SETENAF_PIN2_Msk         (0x01UL << PININT_SIENF_SETENAF_PIN2_Pos)               /*!< PININT SIENF: SETENAF_PIN2 Mask         */
#define PININT_SIENF_SETENAF_PIN3_Pos         3                                                       /*!< PININT SIENF: SETENAF_PIN3 Position     */
#define PININT_SIENF_SETENAF_PIN3_Msk         (0x01UL << PININT_SIENF_SETENAF_PIN3_Pos)               /*!< PININT SIENF: SETENAF_PIN3 Mask         */
#define PININT_SIENF_SETENAF_PIN4_Pos         4                                                       /*!< PININT SIENF: SETENAF_PIN4 Position     */
#define PININT_SIENF_SETENAF_PIN4_Msk         (0x01UL << PININT_SIENF_SETENAF_PIN4_Pos)               /*!< PININT SIENF: SETENAF_PIN4 Mask         */
#define PININT_SIENF_SETENAF_PIN5_Pos         5                                                       /*!< PININT SIENF: SETENAF_PIN5 Position     */
#define PININT_SIENF_SETENAF_PIN5_Msk         (0x01UL << PININT_SIENF_SETENAF_PIN5_Pos)               /*!< PININT SIENF: SETENAF_PIN5 Mask         */
#define PININT_SIENF_SETENAF_PIN6_Pos         6                                                       /*!< PININT SIENF: SETENAF_PIN6 Position     */
#define PININT_SIENF_SETENAF_PIN6_Msk         (0x01UL << PININT_SIENF_SETENAF_PIN6_Pos)               /*!< PININT SIENF: SETENAF_PIN6 Mask         */
#define PININT_SIENF_SETENAF_PIN7_Pos         7                                                       /*!< PININT SIENF: SETENAF_PIN7 Position     */
#define PININT_SIENF_SETENAF_PIN7_Msk         (0x01UL << PININT_SIENF_SETENAF_PIN7_Pos)               /*!< PININT SIENF: SETENAF_PIN7 Mask         */

/* --------------------------------  u_pint_CIENF  -------------------------------- */
#define PININT_CIENF_CLRENAF_PIN0_Pos         0                                                       /*!< PININT CIENF: CLRENAF_PIN0 Position     */
#define PININT_CIENF_CLRENAF_PIN0_Msk         (0x01UL << PININT_CIENF_CLRENAF_PIN0_Pos)               /*!< PININT CIENF: CLRENAF_PIN0 Mask         */
#define PININT_CIENF_CLRENAF_PIN1_Pos         1                                                       /*!< PININT CIENF: CLRENAF_PIN1 Position     */
#define PININT_CIENF_CLRENAF_PIN1_Msk         (0x01UL << PININT_CIENF_CLRENAF_PIN1_Pos)               /*!< PININT CIENF: CLRENAF_PIN1 Mask         */
#define PININT_CIENF_CLRENAF_PIN2_Pos         2                                                       /*!< PININT CIENF: CLRENAF_PIN2 Position     */
#define PININT_CIENF_CLRENAF_PIN2_Msk         (0x01UL << PININT_CIENF_CLRENAF_PIN2_Pos)               /*!< PININT CIENF: CLRENAF_PIN2 Mask         */
#define PININT_CIENF_CLRENAF_PIN3_Pos         3                                                       /*!< PININT CIENF: CLRENAF_PIN3 Position     */
#define PININT_CIENF_CLRENAF_PIN3_Msk         (0x01UL << PININT_CIENF_CLRENAF_PIN3_Pos)               /*!< PININT CIENF: CLRENAF_PIN3 Mask         */
#define PININT_CIENF_CLRENAF_PIN4_Pos         4                                                       /*!< PININT CIENF: CLRENAF_PIN4 Position     */
#define PININT_CIENF_CLRENAF_PIN4_Msk         (0x01UL << PININT_CIENF_CLRENAF_PIN4_Pos)               /*!< PININT CIENF: CLRENAF_PIN4 Mask         */
#define PININT_CIENF_CLRENAF_PIN5_Pos         5                                                       /*!< PININT CIENF: CLRENAF_PIN5 Position     */
#define PININT_CIENF_CLRENAF_PIN5_Msk         (0x01UL << PININT_CIENF_CLRENAF_PIN5_Pos)               /*!< PININT CIENF: CLRENAF_PIN5 Mask         */
#define PININT_CIENF_CLRENAF_PIN6_Pos         6                                                       /*!< PININT CIENF: CLRENAF_PIN6 Position     */
#define PININT_CIENF_CLRENAF_PIN6_Msk         (0x01UL << PININT_CIENF_CLRENAF_PIN6_Pos)               /*!< PININT CIENF: CLRENAF_PIN6 Mask         */
#define PININT_CIENF_CLRENAF_PIN7_Pos         7                                                       /*!< PININT CIENF: CLRENAF_PIN7 Position     */
#define PININT_CIENF_CLRENAF_PIN7_Msk         (0x01UL << PININT_CIENF_CLRENAF_PIN7_Pos)               /*!< PININT CIENF: CLRENAF_PIN7 Mask         */

/* ---------------------------------  u_pint_RISE  -------------------------------- */
#define PININT_RISE_RDET_PIN0_Pos             0                                                       /*!< PININT RISE: RDET_PIN0 Position         */
#define PININT_RISE_RDET_PIN0_Msk             (0x01UL << PININT_RISE_RDET_PIN0_Pos)                   /*!< PININT RISE: RDET_PIN0 Mask             */
#define PININT_RISE_RDET_PIN1_Pos             1                                                       /*!< PININT RISE: RDET_PIN1 Position         */
#define PININT_RISE_RDET_PIN1_Msk             (0x01UL << PININT_RISE_RDET_PIN1_Pos)                   /*!< PININT RISE: RDET_PIN1 Mask             */
#define PININT_RISE_RDET_PIN2_Pos             2                                                       /*!< PININT RISE: RDET_PIN2 Position         */
#define PININT_RISE_RDET_PIN2_Msk             (0x01UL << PININT_RISE_RDET_PIN2_Pos)                   /*!< PININT RISE: RDET_PIN2 Mask             */
#define PININT_RISE_RDET_PIN3_Pos             3                                                       /*!< PININT RISE: RDET_PIN3 Position         */
#define PININT_RISE_RDET_PIN3_Msk             (0x01UL << PININT_RISE_RDET_PIN3_Pos)                   /*!< PININT RISE: RDET_PIN3 Mask             */
#define PININT_RISE_RDET_PIN4_Pos             4                                                       /*!< PININT RISE: RDET_PIN4 Position         */
#define PININT_RISE_RDET_PIN4_Msk             (0x01UL << PININT_RISE_RDET_PIN4_Pos)                   /*!< PININT RISE: RDET_PIN4 Mask             */
#define PININT_RISE_RDET_PIN5_Pos             5                                                       /*!< PININT RISE: RDET_PIN5 Position         */
#define PININT_RISE_RDET_PIN5_Msk             (0x01UL << PININT_RISE_RDET_PIN5_Pos)                   /*!< PININT RISE: RDET_PIN5 Mask             */
#define PININT_RISE_RDET_PIN6_Pos             6                                                       /*!< PININT RISE: RDET_PIN6 Position         */
#define PININT_RISE_RDET_PIN6_Msk             (0x01UL << PININT_RISE_RDET_PIN6_Pos)                   /*!< PININT RISE: RDET_PIN6 Mask             */
#define PININT_RISE_RDET_PIN7_Pos             7                                                       /*!< PININT RISE: RDET_PIN7 Position         */
#define PININT_RISE_RDET_PIN7_Msk             (0x01UL << PININT_RISE_RDET_PIN7_Pos)                   /*!< PININT RISE: RDET_PIN7 Mask             */

/* ---------------------------------  u_pint_FALL  -------------------------------- */
#define PININT_FALL_FDET_PIN0_Pos             0                                                       /*!< PININT FALL: FDET_PIN0 Position         */
#define PININT_FALL_FDET_PIN0_Msk             (0x01UL << PININT_FALL_FDET_PIN0_Pos)                   /*!< PININT FALL: FDET_PIN0 Mask             */
#define PININT_FALL_FDET_PIN1_Pos             1                                                       /*!< PININT FALL: FDET_PIN1 Position         */
#define PININT_FALL_FDET_PIN1_Msk             (0x01UL << PININT_FALL_FDET_PIN1_Pos)                   /*!< PININT FALL: FDET_PIN1 Mask             */
#define PININT_FALL_FDET_PIN2_Pos             2                                                       /*!< PININT FALL: FDET_PIN2 Position         */
#define PININT_FALL_FDET_PIN2_Msk             (0x01UL << PININT_FALL_FDET_PIN2_Pos)                   /*!< PININT FALL: FDET_PIN2 Mask             */
#define PININT_FALL_FDET_PIN3_Pos             3                                                       /*!< PININT FALL: FDET_PIN3 Position         */
#define PININT_FALL_FDET_PIN3_Msk             (0x01UL << PININT_FALL_FDET_PIN3_Pos)                   /*!< PININT FALL: FDET_PIN3 Mask             */
#define PININT_FALL_FDET_PIN4_Pos             4                                                       /*!< PININT FALL: FDET_PIN4 Position         */
#define PININT_FALL_FDET_PIN4_Msk             (0x01UL << PININT_FALL_FDET_PIN4_Pos)                   /*!< PININT FALL: FDET_PIN4 Mask             */
#define PININT_FALL_FDET_PIN5_Pos             5                                                       /*!< PININT FALL: FDET_PIN5 Position         */
#define PININT_FALL_FDET_PIN5_Msk             (0x01UL << PININT_FALL_FDET_PIN5_Pos)                   /*!< PININT FALL: FDET_PIN5 Mask             */
#define PININT_FALL_FDET_PIN6_Pos             6                                                       /*!< PININT FALL: FDET_PIN6 Position         */
#define PININT_FALL_FDET_PIN6_Msk             (0x01UL << PININT_FALL_FDET_PIN6_Pos)                   /*!< PININT FALL: FDET_PIN6 Mask             */
#define PININT_FALL_FDET_PIN7_Pos             7                                                       /*!< PININT FALL: FDET_PIN7 Position         */
#define PININT_FALL_FDET_PIN7_Msk             (0x01UL << PININT_FALL_FDET_PIN7_Pos)                   /*!< PININT FALL: FDET_PIN7 Mask             */

/* ---------------------------------  u_pint_IST  --------------------------------- */
#define PININT_IST_PSTAT_PIN0_Pos             0                                                       /*!< PININT IST: PSTAT_PIN0 Position         */
#define PININT_IST_PSTAT_PIN0_Msk             (0x01UL << PININT_IST_PSTAT_PIN0_Pos)                   /*!< PININT IST: PSTAT_PIN0 Mask             */
#define PININT_IST_PSTAT_PIN1_Pos             1                                                       /*!< PININT IST: PSTAT_PIN1 Position         */
#define PININT_IST_PSTAT_PIN1_Msk             (0x01UL << PININT_IST_PSTAT_PIN1_Pos)                   /*!< PININT IST: PSTAT_PIN1 Mask             */
#define PININT_IST_PSTAT_PIN2_Pos             2                                                       /*!< PININT IST: PSTAT_PIN2 Position         */
#define PININT_IST_PSTAT_PIN2_Msk             (0x01UL << PININT_IST_PSTAT_PIN2_Pos)                   /*!< PININT IST: PSTAT_PIN2 Mask             */
#define PININT_IST_PSTAT_PIN3_Pos             3                                                       /*!< PININT IST: PSTAT_PIN3 Position         */
#define PININT_IST_PSTAT_PIN3_Msk             (0x01UL << PININT_IST_PSTAT_PIN3_Pos)                   /*!< PININT IST: PSTAT_PIN3 Mask             */
#define PININT_IST_PSTAT_PIN4_Pos             4                                                       /*!< PININT IST: PSTAT_PIN4 Position         */
#define PININT_IST_PSTAT_PIN4_Msk             (0x01UL << PININT_IST_PSTAT_PIN4_Pos)                   /*!< PININT IST: PSTAT_PIN4 Mask             */
#define PININT_IST_PSTAT_PIN5_Pos             5                                                       /*!< PININT IST: PSTAT_PIN5 Position         */
#define PININT_IST_PSTAT_PIN5_Msk             (0x01UL << PININT_IST_PSTAT_PIN5_Pos)                   /*!< PININT IST: PSTAT_PIN5 Mask             */
#define PININT_IST_PSTAT_PIN6_Pos             6                                                       /*!< PININT IST: PSTAT_PIN6 Position         */
#define PININT_IST_PSTAT_PIN6_Msk             (0x01UL << PININT_IST_PSTAT_PIN6_Pos)                   /*!< PININT IST: PSTAT_PIN6 Mask             */
#define PININT_IST_PSTAT_PIN7_Pos             7                                                       /*!< PININT IST: PSTAT_PIN7 Position         */
#define PININT_IST_PSTAT_PIN7_Msk             (0x01UL << PININT_IST_PSTAT_PIN7_Pos)                   /*!< PININT IST: PSTAT_PIN7 Mask             */

/* --------------------------------  u_pint_PMCTRL  ------------------------------- */
#define PININT_PMCTRL_SEL_PMATCH_Pos          0                                                       /*!< PININT PMCTRL: SEL_PMATCH Position      */
#define PININT_PMCTRL_SEL_PMATCH_Msk          (0x01UL << PININT_PMCTRL_SEL_PMATCH_Pos)                /*!< PININT PMCTRL: SEL_PMATCH Mask          */
#define PININT_PMCTRL_ENA_RXEV_Pos            1                                                       /*!< PININT PMCTRL: ENA_RXEV Position        */
#define PININT_PMCTRL_ENA_RXEV_Msk            (0x01UL << PININT_PMCTRL_ENA_RXEV_Pos)                  /*!< PININT PMCTRL: ENA_RXEV Mask            */
#define PININT_PMCTRL_PMAT_Pos                24                                                      /*!< PININT PMCTRL: PMAT Position            */
#define PININT_PMCTRL_PMAT_Msk                (0x000000ffUL << PININT_PMCTRL_PMAT_Pos)                /*!< PININT PMCTRL: PMAT Mask                */

/* --------------------------------  u_pint_PMSRC  -------------------------------- */
#define PININT_PMSRC_SRC0_Pos                 8                                                       /*!< PININT PMSRC: SRC0 Position             */
#define PININT_PMSRC_SRC0_Msk                 (0x07UL << PININT_PMSRC_SRC0_Pos)                       /*!< PININT PMSRC: SRC0 Mask                 */
#define PININT_PMSRC_SRC1_Pos                 11                                                      /*!< PININT PMSRC: SRC1 Position             */
#define PININT_PMSRC_SRC1_Msk                 (0x07UL << PININT_PMSRC_SRC1_Pos)                       /*!< PININT PMSRC: SRC1 Mask                 */
#define PININT_PMSRC_SRC2_Pos                 14                                                      /*!< PININT PMSRC: SRC2 Position             */
#define PININT_PMSRC_SRC2_Msk                 (0x07UL << PININT_PMSRC_SRC2_Pos)                       /*!< PININT PMSRC: SRC2 Mask                 */
#define PININT_PMSRC_SRC3_Pos                 17                                                      /*!< PININT PMSRC: SRC3 Position             */
#define PININT_PMSRC_SRC3_Msk                 (0x07UL << PININT_PMSRC_SRC3_Pos)                       /*!< PININT PMSRC: SRC3 Mask                 */
#define PININT_PMSRC_SRC4_Pos                 20                                                      /*!< PININT PMSRC: SRC4 Position             */
#define PININT_PMSRC_SRC4_Msk                 (0x07UL << PININT_PMSRC_SRC4_Pos)                       /*!< PININT PMSRC: SRC4 Mask                 */
#define PININT_PMSRC_SRC5_Pos                 23                                                      /*!< PININT PMSRC: SRC5 Position             */
#define PININT_PMSRC_SRC5_Msk                 (0x07UL << PININT_PMSRC_SRC5_Pos)                       /*!< PININT PMSRC: SRC5 Mask                 */
#define PININT_PMSRC_SRC6_Pos                 26                                                      /*!< PININT PMSRC: SRC6 Position             */
#define PININT_PMSRC_SRC6_Msk                 (0x07UL << PININT_PMSRC_SRC6_Pos)                       /*!< PININT PMSRC: SRC6 Mask                 */
#define PININT_PMSRC_SRC7_Pos                 29                                                      /*!< PININT PMSRC: SRC7 Position             */
#define PININT_PMSRC_SRC7_Msk                 (0x07UL << PININT_PMSRC_SRC7_Pos)                       /*!< PININT PMSRC: SRC7 Mask                 */

/* --------------------------------  u_pint_PMCFG  -------------------------------- */
#define PININT_PMCFG_PROD_ENDPTS0_Pos         0                                                       /*!< PININT PMCFG: PROD_ENDPTS0 Position     */
#define PININT_PMCFG_PROD_ENDPTS0_Msk         (0x01UL << PININT_PMCFG_PROD_ENDPTS0_Pos)               /*!< PININT PMCFG: PROD_ENDPTS0 Mask         */
#define PININT_PMCFG_PROD_ENDPTS1_Pos         1                                                       /*!< PININT PMCFG: PROD_ENDPTS1 Position     */
#define PININT_PMCFG_PROD_ENDPTS1_Msk         (0x01UL << PININT_PMCFG_PROD_ENDPTS1_Pos)               /*!< PININT PMCFG: PROD_ENDPTS1 Mask         */
#define PININT_PMCFG_PROD_ENDPTS2_Pos         2                                                       /*!< PININT PMCFG: PROD_ENDPTS2 Position     */
#define PININT_PMCFG_PROD_ENDPTS2_Msk         (0x01UL << PININT_PMCFG_PROD_ENDPTS2_Pos)               /*!< PININT PMCFG: PROD_ENDPTS2 Mask         */
#define PININT_PMCFG_PROD_ENDPTS3_Pos         3                                                       /*!< PININT PMCFG: PROD_ENDPTS3 Position     */
#define PININT_PMCFG_PROD_ENDPTS3_Msk         (0x01UL << PININT_PMCFG_PROD_ENDPTS3_Pos)               /*!< PININT PMCFG: PROD_ENDPTS3 Mask         */
#define PININT_PMCFG_PROD_ENDPTS4_Pos         4                                                       /*!< PININT PMCFG: PROD_ENDPTS4 Position     */
#define PININT_PMCFG_PROD_ENDPTS4_Msk         (0x01UL << PININT_PMCFG_PROD_ENDPTS4_Pos)               /*!< PININT PMCFG: PROD_ENDPTS4 Mask         */
#define PININT_PMCFG_PROD_ENDPTS5_Pos         5                                                       /*!< PININT PMCFG: PROD_ENDPTS5 Position     */
#define PININT_PMCFG_PROD_ENDPTS5_Msk         (0x01UL << PININT_PMCFG_PROD_ENDPTS5_Pos)               /*!< PININT PMCFG: PROD_ENDPTS5 Mask         */
#define PININT_PMCFG_PROD_ENDPTS6_Pos         6                                                       /*!< PININT PMCFG: PROD_ENDPTS6 Position     */
#define PININT_PMCFG_PROD_ENDPTS6_Msk         (0x01UL << PININT_PMCFG_PROD_ENDPTS6_Pos)               /*!< PININT PMCFG: PROD_ENDPTS6 Mask         */
#define PININT_PMCFG_CFG0_Pos                 8                                                       /*!< PININT PMCFG: CFG0 Position             */
#define PININT_PMCFG_CFG0_Msk                 (0x07UL << PININT_PMCFG_CFG0_Pos)                       /*!< PININT PMCFG: CFG0 Mask                 */
#define PININT_PMCFG_CFG1_Pos                 11                                                      /*!< PININT PMCFG: CFG1 Position             */
#define PININT_PMCFG_CFG1_Msk                 (0x07UL << PININT_PMCFG_CFG1_Pos)                       /*!< PININT PMCFG: CFG1 Mask                 */
#define PININT_PMCFG_CFG2_Pos                 14                                                      /*!< PININT PMCFG: CFG2 Position             */
#define PININT_PMCFG_CFG2_Msk                 (0x07UL << PININT_PMCFG_CFG2_Pos)                       /*!< PININT PMCFG: CFG2 Mask                 */
#define PININT_PMCFG_CFG3_Pos                 17                                                      /*!< PININT PMCFG: CFG3 Position             */
#define PININT_PMCFG_CFG3_Msk                 (0x07UL << PININT_PMCFG_CFG3_Pos)                       /*!< PININT PMCFG: CFG3 Mask                 */
#define PININT_PMCFG_CFG4_Pos                 20                                                      /*!< PININT PMCFG: CFG4 Position             */
#define PININT_PMCFG_CFG4_Msk                 (0x07UL << PININT_PMCFG_CFG4_Pos)                       /*!< PININT PMCFG: CFG4 Mask                 */
#define PININT_PMCFG_CFG5_Pos                 23                                                      /*!< PININT PMCFG: CFG5 Position             */
#define PININT_PMCFG_CFG5_Msk                 (0x07UL << PININT_PMCFG_CFG5_Pos)                       /*!< PININT PMCFG: CFG5 Mask                 */
#define PININT_PMCFG_CFG6_Pos                 26                                                      /*!< PININT PMCFG: CFG6 Position             */
#define PININT_PMCFG_CFG6_Msk                 (0x07UL << PININT_PMCFG_CFG6_Pos)                       /*!< PININT PMCFG: CFG6 Mask                 */
#define PININT_PMCFG_CFG7_Pos                 29                                                      /*!< PININT PMCFG: CFG7 Position             */
#define PININT_PMCFG_CFG7_Msk                 (0x07UL << PININT_PMCFG_CFG7_Pos)                       /*!< PININT PMCFG: CFG7 Mask                 */


/* ================================================================================ */
/* ================         struct 'u_gint' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u_gint_CTRL  -------------------------------- */
#define GPIOINT_CTRL_INT_Pos                   0                                                       /*!< GPIOINT CTRL: INT Position               */
#define GPIOINT_CTRL_INT_Msk                   (0x01UL << GPIOINT_CTRL_INT_Pos)                         /*!< GPIOINT CTRL: INT Mask                   */
#define GPIOINT_CTRL_COMB_Pos                  1                                                       /*!< GPIOINT CTRL: COMB Position              */
#define GPIOINT_CTRL_COMB_Msk                  (0x01UL << GPIOINT_CTRL_COMB_Pos)                        /*!< GPIOINT CTRL: COMB Mask                  */
#define GPIOINT_CTRL_TRIG_Pos                  2                                                       /*!< GPIOINT CTRL: TRIG Position              */
#define GPIOINT_CTRL_TRIG_Msk                  (0x01UL << GPIOINT_CTRL_TRIG_Pos)                        /*!< GPIOINT CTRL: TRIG Mask                  */

/* ------------------------------  u_gint_PORT_POL0  ------------------------------ */
#define GPIOINT_PORT_POL0_POL_PIO0_Pos         0                                                       /*!< GPIOINT PORT_POL0: POL_PIO0 Position     */
#define GPIOINT_PORT_POL0_POL_PIO0_Msk         (0x01UL << GPIOINT_PORT_POL0_POL_PIO0_Pos)               /*!< GPIOINT PORT_POL0: POL_PIO0 Mask         */
#define GPIOINT_PORT_POL0_POL_PIO1_Pos         1                                                       /*!< GPIOINT PORT_POL0: POL_PIO1 Position     */
#define GPIOINT_PORT_POL0_POL_PIO1_Msk         (0x01UL << GPIOINT_PORT_POL0_POL_PIO1_Pos)               /*!< GPIOINT PORT_POL0: POL_PIO1 Mask         */
#define GPIOINT_PORT_POL0_POL_PIO2_Pos         2                                                       /*!< GPIOINT PORT_POL0: POL_PIO2 Position     */
#define GPIOINT_PORT_POL0_POL_PIO2_Msk         (0x01UL << GPIOINT_PORT_POL0_POL_PIO2_Pos)               /*!< GPIOINT PORT_POL0: POL_PIO2 Mask         */
#define GPIOINT_PORT_POL0_POL_PIO3_Pos         3                                                       /*!< GPIOINT PORT_POL0: POL_PIO3 Position     */
#define GPIOINT_PORT_POL0_POL_PIO3_Msk         (0x01UL << GPIOINT_PORT_POL0_POL_PIO3_Pos)               /*!< GPIOINT PORT_POL0: POL_PIO3 Mask         */
#define GPIOINT_PORT_POL0_POL_PIO4_Pos         4                                                       /*!< GPIOINT PORT_POL0: POL_PIO4 Position     */
#define GPIOINT_PORT_POL0_POL_PIO4_Msk         (0x01UL << GPIOINT_PORT_POL0_POL_PIO4_Pos)               /*!< GPIOINT PORT_POL0: POL_PIO4 Mask         */
#define GPIOINT_PORT_POL0_POL_PIO5_Pos         5                                                       /*!< GPIOINT PORT_POL0: POL_PIO5 Position     */
#define GPIOINT_PORT_POL0_POL_PIO5_Msk         (0x01UL << GPIOINT_PORT_POL0_POL_PIO5_Pos)               /*!< GPIOINT PORT_POL0: POL_PIO5 Mask         */
#define GPIOINT_PORT_POL0_POL_PIO6_Pos         6                                                       /*!< GPIOINT PORT_POL0: POL_PIO6 Position     */
#define GPIOINT_PORT_POL0_POL_PIO6_Msk         (0x01UL << GPIOINT_PORT_POL0_POL_PIO6_Pos)               /*!< GPIOINT PORT_POL0: POL_PIO6 Mask         */
#define GPIOINT_PORT_POL0_POL_PIO7_Pos         7                                                       /*!< GPIOINT PORT_POL0: POL_PIO7 Position     */
#define GPIOINT_PORT_POL0_POL_PIO7_Msk         (0x01UL << GPIOINT_PORT_POL0_POL_PIO7_Pos)               /*!< GPIOINT PORT_POL0: POL_PIO7 Mask         */
#define GPIOINT_PORT_POL0_POL_PIO8_Pos         8                                                       /*!< GPIOINT PORT_POL0: POL_PIO8 Position     */
#define GPIOINT_PORT_POL0_POL_PIO8_Msk         (0x01UL << GPIOINT_PORT_POL0_POL_PIO8_Pos)               /*!< GPIOINT PORT_POL0: POL_PIO8 Mask         */
#define GPIOINT_PORT_POL0_POL_PIO9_Pos         9                                                       /*!< GPIOINT PORT_POL0: POL_PIO9 Position     */
#define GPIOINT_PORT_POL0_POL_PIO9_Msk         (0x01UL << GPIOINT_PORT_POL0_POL_PIO9_Pos)               /*!< GPIOINT PORT_POL0: POL_PIO9 Mask         */
#define GPIOINT_PORT_POL0_POL_PIO10_Pos        10                                                      /*!< GPIOINT PORT_POL0: POL_PIO10 Position    */
#define GPIOINT_PORT_POL0_POL_PIO10_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO10_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO10 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO11_Pos        11                                                      /*!< GPIOINT PORT_POL0: POL_PIO11 Position    */
#define GPIOINT_PORT_POL0_POL_PIO11_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO11_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO11 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO12_Pos        12                                                      /*!< GPIOINT PORT_POL0: POL_PIO12 Position    */
#define GPIOINT_PORT_POL0_POL_PIO12_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO12_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO12 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO13_Pos        13                                                      /*!< GPIOINT PORT_POL0: POL_PIO13 Position    */
#define GPIOINT_PORT_POL0_POL_PIO13_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO13_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO13 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO14_Pos        14                                                      /*!< GPIOINT PORT_POL0: POL_PIO14 Position    */
#define GPIOINT_PORT_POL0_POL_PIO14_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO14_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO14 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO15_Pos        15                                                      /*!< GPIOINT PORT_POL0: POL_PIO15 Position    */
#define GPIOINT_PORT_POL0_POL_PIO15_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO15_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO15 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO16_Pos        16                                                      /*!< GPIOINT PORT_POL0: POL_PIO16 Position    */
#define GPIOINT_PORT_POL0_POL_PIO16_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO16_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO16 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO17_Pos        17                                                      /*!< GPIOINT PORT_POL0: POL_PIO17 Position    */
#define GPIOINT_PORT_POL0_POL_PIO17_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO17_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO17 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO18_Pos        18                                                      /*!< GPIOINT PORT_POL0: POL_PIO18 Position    */
#define GPIOINT_PORT_POL0_POL_PIO18_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO18_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO18 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO19_Pos        19                                                      /*!< GPIOINT PORT_POL0: POL_PIO19 Position    */
#define GPIOINT_PORT_POL0_POL_PIO19_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO19_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO19 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO20_Pos        20                                                      /*!< GPIOINT PORT_POL0: POL_PIO20 Position    */
#define GPIOINT_PORT_POL0_POL_PIO20_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO20_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO20 Mask        */
#define GPIOINT_PORT_POL0_POL_PIO21_Pos        21                                                      /*!< GPIOINT PORT_POL0: POL_PIO21 Position    */
#define GPIOINT_PORT_POL0_POL_PIO21_Msk        (0x01UL << GPIOINT_PORT_POL0_POL_PIO21_Pos)              /*!< GPIOINT PORT_POL0: POL_PIO21 Mask        */

/* ------------------------------  u_gint_PORT_ENA0  ------------------------------ */
#define GPIOINT_PORT_ENA0_ENA_PIO0_Pos         0                                                       /*!< GPIOINT PORT_ENA0: ENA_PIO0 Position     */
#define GPIOINT_PORT_ENA0_ENA_PIO0_Msk         (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO0_Pos)               /*!< GPIOINT PORT_ENA0: ENA_PIO0 Mask         */
#define GPIOINT_PORT_ENA0_ENA_PIO1_Pos         1                                                       /*!< GPIOINT PORT_ENA0: ENA_PIO1 Position     */
#define GPIOINT_PORT_ENA0_ENA_PIO1_Msk         (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO1_Pos)               /*!< GPIOINT PORT_ENA0: ENA_PIO1 Mask         */
#define GPIOINT_PORT_ENA0_ENA_PIO2_Pos         2                                                       /*!< GPIOINT PORT_ENA0: ENA_PIO2 Position     */
#define GPIOINT_PORT_ENA0_ENA_PIO2_Msk         (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO2_Pos)               /*!< GPIOINT PORT_ENA0: ENA_PIO2 Mask         */
#define GPIOINT_PORT_ENA0_ENA_PIO3_Pos         3                                                       /*!< GPIOINT PORT_ENA0: ENA_PIO3 Position     */
#define GPIOINT_PORT_ENA0_ENA_PIO3_Msk         (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO3_Pos)               /*!< GPIOINT PORT_ENA0: ENA_PIO3 Mask         */
#define GPIOINT_PORT_ENA0_ENA_PIO4_Pos         4                                                       /*!< GPIOINT PORT_ENA0: ENA_PIO4 Position     */
#define GPIOINT_PORT_ENA0_ENA_PIO4_Msk         (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO4_Pos)               /*!< GPIOINT PORT_ENA0: ENA_PIO4 Mask         */
#define GPIOINT_PORT_ENA0_ENA_PIO5_Pos         5                                                       /*!< GPIOINT PORT_ENA0: ENA_PIO5 Position     */
#define GPIOINT_PORT_ENA0_ENA_PIO5_Msk         (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO5_Pos)               /*!< GPIOINT PORT_ENA0: ENA_PIO5 Mask         */
#define GPIOINT_PORT_ENA0_ENA_PIO6_Pos         6                                                       /*!< GPIOINT PORT_ENA0: ENA_PIO6 Position     */
#define GPIOINT_PORT_ENA0_ENA_PIO6_Msk         (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO6_Pos)               /*!< GPIOINT PORT_ENA0: ENA_PIO6 Mask         */
#define GPIOINT_PORT_ENA0_ENA_PIO7_Pos         7                                                       /*!< GPIOINT PORT_ENA0: ENA_PIO7 Position     */
#define GPIOINT_PORT_ENA0_ENA_PIO7_Msk         (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO7_Pos)               /*!< GPIOINT PORT_ENA0: ENA_PIO7 Mask         */
#define GPIOINT_PORT_ENA0_ENA_PIO8_Pos         8                                                       /*!< GPIOINT PORT_ENA0: ENA_PIO8 Position     */
#define GPIOINT_PORT_ENA0_ENA_PIO8_Msk         (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO8_Pos)               /*!< GPIOINT PORT_ENA0: ENA_PIO8 Mask         */
#define GPIOINT_PORT_ENA0_ENA_PIO9_Pos         9                                                       /*!< GPIOINT PORT_ENA0: ENA_PIO9 Position     */
#define GPIOINT_PORT_ENA0_ENA_PIO9_Msk         (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO9_Pos)               /*!< GPIOINT PORT_ENA0: ENA_PIO9 Mask         */
#define GPIOINT_PORT_ENA0_ENA_PIO10_Pos        10                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO10 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO10_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO10_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO10 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO11_Pos        11                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO11 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO11_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO11_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO11 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO12_Pos        12                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO12 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO12_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO12_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO12 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO13_Pos        13                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO13 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO13_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO13_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO13 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO14_Pos        14                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO14 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO14_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO14_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO14 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO15_Pos        15                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO15 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO15_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO15_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO15 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO16_Pos        16                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO16 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO16_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO16_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO16 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO17_Pos        17                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO17 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO17_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO17_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO17 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO18_Pos        18                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO18 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO18_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO18_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO18 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO19_Pos        19                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO19 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO19_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO19_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO19 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO20_Pos        20                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO20 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO20_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO20_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO20 Mask        */
#define GPIOINT_PORT_ENA0_ENA_PIO21_Pos        21                                                      /*!< GPIOINT PORT_ENA0: ENA_PIO21 Position    */
#define GPIOINT_PORT_ENA0_ENA_PIO21_Msk        (0x01UL << GPIOINT_PORT_ENA0_ENA_PIO21_Pos)              /*!< GPIOINT PORT_ENA0: ENA_PIO21 Mask        */


/* ================================================================================ */
/* ================         struct 'u_pmc' Position & Mask         ================ */
/* ================================================================================ */


/* ---------------------------------  u_pmc_CTRL  --------------------------------- */
#define PMC_CTRL_LPMODE_Pos                 0                                                       /*!< PMC CTRL: LPMODE Position             */
#define PMC_CTRL_LPMODE_Msk                 (0x03UL << PMC_CTRL_LPMODE_Pos)                       /*!< PMC CTRL: LPMODE Mask                 */
#define PMC_CTRL_SYSTEMRESETENABLE_Pos      2                                                       /*!< PMC CTRL: SYSTEMRESETENABLE Position  */
#define PMC_CTRL_SYSTEMRESETENABLE_Msk      (0x01UL << PMC_CTRL_SYSTEMRESETENABLE_Pos)            /*!< PMC CTRL: SYSTEMRESETENABLE Mask      */
#define PMC_CTRL_WDTRESETENABLE_Pos         3                                                       /*!< PMC CTRL: WDTRESETENABLE Position     */
#define PMC_CTRL_WDTRESETENABLE_Msk         (0x01UL << PMC_CTRL_WDTRESETENABLE_Pos)               /*!< PMC CTRL: WDTRESETENABLE Mask         */
#define PMC_CTRL_WAKUPRESETENABLE_Pos       4                                                       /*!< PMC CTRL: WAKUPRESETENABLE Position   */
#define PMC_CTRL_WAKUPRESETENABLE_Msk       (0x01UL << PMC_CTRL_WAKUPRESETENABLE_Pos)             /*!< PMC CTRL: WAKUPRESETENABLE Mask       */
#define PMC_CTRL_NTAGWAKUPRESETENABLE_Pos   5                                                       /*!< PMC CTRL: NTAGWAKUPRESETENABLE Position */
#define PMC_CTRL_NTAGWAKUPRESETENABLE_Msk   (0x01UL << PMC_CTRL_NTAGWAKUPRESETENABLE_Pos)         /*!< PMC CTRL: NTAGWAKUPRESETENABLE Mask   */
#define PMC_CTRL_RESERVED6_Pos              6                                                       /*!< PMC CTRL: RESERVED6 Position          */
#define PMC_CTRL_RESERVED6_Msk              (0x01UL << PMC_CTRL_RESERVED6_Pos)                    /*!< PMC CTRL: RESERVED6 Mask              */
#define PMC_CTRL_SELCLOCK_Pos               7                                                       /*!< PMC CTRL: SELCLOCK Position           */
#define PMC_CTRL_SELCLOCK_Msk               (0x01UL << PMC_CTRL_SELCLOCK_Pos)                     /*!< PMC CTRL: SELCLOCK Mask               */
#define PMC_CTRL_SELLDOVOLTAGE_Pos          8                                                       /*!< PMC CTRL: SELLDOVOLTAGE Position      */
#define PMC_CTRL_SELLDOVOLTAGE_Msk          (0x01UL << PMC_CTRL_SELLDOVOLTAGE_Pos)                /*!< PMC CTRL: SELLDOVOLTAGE Mask          */
#define PMC_CTRL_SWRRESETENABLE_Pos         9                                                       /*!< PMC CTRL: SWRRESETENABLE Position     */
#define PMC_CTRL_SWRRESETENABLE_Msk         (0x01UL << PMC_CTRL_SWRRESETENABLE_Pos)               /*!< PMC CTRL: SWRRESETENABLE Mask         */

/* ---------------------------------  u_pmc_DCDC0  -------------------------------- */
#define PMC_DCDC0_RC_Pos                    0                                                       /*!< PMC DCDC0: RC Position                */
#define PMC_DCDC0_RC_Msk                    (0x3fUL << PMC_DCDC0_RC_Pos)                          /*!< PMC DCDC0: RC Mask                    */
#define PMC_DCDC0_ICOMP_Pos                 6                                                       /*!< PMC DCDC0: ICOMP Position             */
#define PMC_DCDC0_ICOMP_Msk                 (0x03UL << PMC_DCDC0_ICOMP_Pos)                       /*!< PMC DCDC0: ICOMP Mask                 */
#define PMC_DCDC0_ISEL_Pos                  8                                                       /*!< PMC DCDC0: ISEL Position              */
#define PMC_DCDC0_ISEL_Msk                  (0x03UL << PMC_DCDC0_ISEL_Pos)                        /*!< PMC DCDC0: ISEL Mask                  */
#define PMC_DCDC0_ICENABLE_Pos              10                                                      /*!< PMC DCDC0: ICENABLE Position          */
#define PMC_DCDC0_ICENABLE_Msk              (0x01UL << PMC_DCDC0_ICENABLE_Pos)                    /*!< PMC DCDC0: ICENABLE Mask              */
#define PMC_DCDC0_TMOS_Pos                  11                                                      /*!< PMC DCDC0: TMOS Position              */
#define PMC_DCDC0_TMOS_Msk                  (0x1fUL << PMC_DCDC0_TMOS_Pos)                        /*!< PMC DCDC0: TMOS Mask                  */
#define PMC_DCDC0_DISABLEISENSE_Pos         16                                                      /*!< PMC DCDC0: DISABLEISENSE Position     */
#define PMC_DCDC0_DISABLEISENSE_Msk         (0x01UL << PMC_DCDC0_DISABLEISENSE_Pos)               /*!< PMC DCDC0: DISABLEISENSE Mask         */
#define PMC_DCDC0_VOUT_Pos                  17                                                      /*!< PMC DCDC0: VOUT Position              */
#define PMC_DCDC0_VOUT_Msk                  (0x07UL << PMC_DCDC0_VOUT_Pos)                        /*!< PMC DCDC0: VOUT Mask                  */
#define PMC_DCDC0_SLICINGENABLE_Pos         20                                                      /*!< PMC DCDC0: SLICINGENABLE Position     */
#define PMC_DCDC0_SLICINGENABLE_Msk         (0x01UL << PMC_DCDC0_SLICINGENABLE_Pos)               /*!< PMC DCDC0: SLICINGENABLE Mask         */
#define PMC_DCDC0_SLICINGPMOS_Pos           21                                                      /*!< PMC DCDC0: SLICINGPMOS Position       */
#define PMC_DCDC0_SLICINGPMOS_Msk           (0x03UL << PMC_DCDC0_SLICINGPMOS_Pos)                 /*!< PMC DCDC0: SLICINGPMOS Mask           */
#define PMC_DCDC0_SLICINGNMOS_Pos           23                                                      /*!< PMC DCDC0: SLICINGNMOS Position       */
#define PMC_DCDC0_SLICINGNMOS_Msk           (0x03UL << PMC_DCDC0_SLICINGNMOS_Pos)                 /*!< PMC DCDC0: SLICINGNMOS Mask           */
#define PMC_DCDC0_INDUCTORCLAMPENABLE_Pos   25                                                      /*!< PMC DCDC0: INDUCTORCLAMPENABLE Position */
#define PMC_DCDC0_INDUCTORCLAMPENABLE_Msk   (0x01UL << PMC_DCDC0_INDUCTORCLAMPENABLE_Pos)         /*!< PMC DCDC0: INDUCTORCLAMPENABLE Mask   */
#define PMC_DCDC0_CONTINUOUSMODEENABLE_Pos  26                                                      /*!< PMC DCDC0: CONTINUOUSMODEENABLE Position */
#define PMC_DCDC0_CONTINUOUSMODEENABLE_Msk  (0x01UL << PMC_DCDC0_CONTINUOUSMODEENABLE_Pos)        /*!< PMC DCDC0: CONTINUOUSMODEENABLE Mask  */

/* ---------------------------------  u_pmc_DCDC1  -------------------------------- */
#define PMC_DCDC1_RTRIMOFFET_Pos            0                                                       /*!< PMC DCDC1: RTRIMOFFET Position        */
#define PMC_DCDC1_RTRIMOFFET_Msk            (0x0fUL << PMC_DCDC1_RTRIMOFFET_Pos)                  /*!< PMC DCDC1: RTRIMOFFET Mask            */
#define PMC_DCDC1_RSENSETRIM_Pos            4                                                       /*!< PMC DCDC1: RSENSETRIM Position        */
#define PMC_DCDC1_RSENSETRIM_Msk            (0x0fUL << PMC_DCDC1_RSENSETRIM_Pos)                  /*!< PMC DCDC1: RSENSETRIM Mask            */
#define PMC_DCDC1_USEEXTREF_Pos             8                                                       /*!< PMC DCDC1: USEEXTREF Position         */
#define PMC_DCDC1_USEEXTREF_Msk             (0x01UL << PMC_DCDC1_USEEXTREF_Pos)                   /*!< PMC DCDC1: USEEXTREF Mask             */
#define PMC_DCDC1_DTESTENABLE_Pos           9                                                       /*!< PMC DCDC1: DTESTENABLE Position       */
#define PMC_DCDC1_DTESTENABLE_Msk           (0x01UL << PMC_DCDC1_DTESTENABLE_Pos)                 /*!< PMC DCDC1: DTESTENABLE Mask           */
#define PMC_DCDC1_SETCURVE_Pos              10                                                      /*!< PMC DCDC1: SETCURVE Position          */
#define PMC_DCDC1_SETCURVE_Msk              (0x03UL << PMC_DCDC1_SETCURVE_Pos)                    /*!< PMC DCDC1: SETCURVE Mask              */
#define PMC_DCDC1_SETDC_Pos                 12                                                      /*!< PMC DCDC1: SETDC Position             */
#define PMC_DCDC1_SETDC_Msk                 (0x0fUL << PMC_DCDC1_SETDC_Pos)                       /*!< PMC DCDC1: SETDC Mask                 */
#define PMC_DCDC1_DTESTSEL_Pos              16                                                      /*!< PMC DCDC1: DTESTSEL Position          */
#define PMC_DCDC1_DTESTSEL_Msk              (0x07UL << PMC_DCDC1_DTESTSEL_Pos)                    /*!< PMC DCDC1: DTESTSEL Mask              */
#define PMC_DCDC1_ISCALEENABLE_Pos          19                                                      /*!< PMC DCDC1: ISCALEENABLE Position      */
#define PMC_DCDC1_ISCALEENABLE_Msk          (0x01UL << PMC_DCDC1_ISCALEENABLE_Pos)                /*!< PMC DCDC1: ISCALEENABLE Mask          */
#define PMC_DCDC1_FORCEBYPASS_Pos           20                                                      /*!< PMC DCDC1: FORCEBYPASS Position       */
#define PMC_DCDC1_FORCEBYPASS_Msk           (0x01UL << PMC_DCDC1_FORCEBYPASS_Pos)                 /*!< PMC DCDC1: FORCEBYPASS Mask           */
#define PMC_DCDC1_TRIMAUTOCOT_Pos           21                                                      /*!< PMC DCDC1: TRIMAUTOCOT Position       */
#define PMC_DCDC1_TRIMAUTOCOT_Msk           (0x0fUL << PMC_DCDC1_TRIMAUTOCOT_Pos)                 /*!< PMC DCDC1: TRIMAUTOCOT Mask           */
#define PMC_DCDC1_LCENABLE_Pos              25                                                      /*!< PMC DCDC1: LCENABLE Position          */
#define PMC_DCDC1_LCENABLE_Msk              (0x01UL << PMC_DCDC1_LCENABLE_Pos)                    /*!< PMC DCDC1: LCENABLE Mask              */
#define PMC_DCDC1_FORCEFULLCYCLE_Pos        26                                                      /*!< PMC DCDC1: FORCEFULLCYCLE Position    */
#define PMC_DCDC1_FORCEFULLCYCLE_Msk        (0x01UL << PMC_DCDC1_FORCEFULLCYCLE_Pos)              /*!< PMC DCDC1: FORCEFULLCYCLE Mask        */

/* ---------------------------------  u_pmc_BIAS  --------------------------------- */
#define PMC_BIAS_DCBGAP_Pos                 0                                                       /*!< PMC BIAS: DCBGAP Position             */
#define PMC_BIAS_DCBGAP_Msk                 (0x1fUL << PMC_BIAS_DCBGAP_Pos)                       /*!< PMC BIAS: DCBGAP Mask                 */
#define PMC_BIAS_CURVE_Pos                  5                                                       /*!< PMC BIAS: CURVE Position              */
#define PMC_BIAS_CURVE_Msk                  (0x03UL << PMC_BIAS_CURVE_Pos)                        /*!< PMC BIAS: CURVE Mask                  */
#define PMC_BIAS_TRIM_Pos                   8                                                       /*!< PMC BIAS: TRIM Position               */
#define PMC_BIAS_TRIM_Msk                   (0x0fUL << PMC_BIAS_TRIM_Pos)                         /*!< PMC BIAS: TRIM Mask                   */
#define PMC_BIAS_IREFTRIM_Pos               12                                                      /*!< PMC BIAS: IREFTRIM Position           */
#define PMC_BIAS_IREFTRIM_Msk               (0x3fUL << PMC_BIAS_IREFTRIM_Pos)                     /*!< PMC BIAS: IREFTRIM Mask               */
#define PMC_BIAS_ATBENABLE_Pos              18                                                      /*!< PMC BIAS: ATBENABLE Position          */
#define PMC_BIAS_ATBENABLE_Msk              (0x01UL << PMC_BIAS_ATBENABLE_Pos)                    /*!< PMC BIAS: ATBENABLE Mask              */
#define PMC_BIAS_ATB_Pos                    19                                                      /*!< PMC BIAS: ATB Position                */
#define PMC_BIAS_ATB_Msk                    (0x03UL << PMC_BIAS_ATB_Pos)                          /*!< PMC BIAS: ATB Mask                    */

/* --------------------------------  u_pmc_LDOPMU  -------------------------------- */
#define PMC_LDOPMU_VADJ_Pos                 0                                                       /*!< PMC LDOPMU: VADJ Position             */
#define PMC_LDOPMU_VADJ_Msk                 (0x1fUL << PMC_LDOPMU_VADJ_Pos)                       /*!< PMC LDOPMU: VADJ Mask                 */
#define PMC_LDOPMU_VADJ_PWD_Pos             5                                                       /*!< PMC LDOPMU: VADJ_PWD Position         */
#define PMC_LDOPMU_VADJ_PWD_Msk             (0x1fUL << PMC_LDOPMU_VADJ_PWD_Pos)                   /*!< PMC LDOPMU: VADJ_PWD Mask             */
#define PMC_LDOPMU_STAB_Pos                 10                                                      /*!< PMC LDOPMU: STAB Position             */
#define PMC_LDOPMU_STAB_Msk                 (0x01UL << PMC_LDOPMU_STAB_Pos)                       /*!< PMC LDOPMU: STAB Mask                 */
#define PMC_LDOPMU_HIGHCUR_Pos              11                                                      /*!< PMC LDOPMU: HIGHCUR Position          */
#define PMC_LDOPMU_HIGHCUR_Msk              (0x01UL << PMC_LDOPMU_HIGHCUR_Pos)                    /*!< PMC LDOPMU: HIGHCUR Mask              */
#define PMC_LDOPMU_VADJ_BOOST_Pos           12                                                      /*!< PMC LDOPMU: VADJ_BOOST Position       */
#define PMC_LDOPMU_VADJ_BOOST_Msk           (0x1fUL << PMC_LDOPMU_VADJ_BOOST_Pos)                 /*!< PMC LDOPMU: VADJ_BOOST Mask           */
#define PMC_LDOPMU_VADJ_BOOST_PWD_Pos       17                                                      /*!< PMC LDOPMU: VADJ_BOOST_PWD Position   */
#define PMC_LDOPMU_VADJ_BOOST_PWD_Msk       (0x1fUL << PMC_LDOPMU_VADJ_BOOST_PWD_Pos)             /*!< PMC LDOPMU: VADJ_BOOST_PWD Mask       */
#define PMC_LDOPMU_BOOSTADJ_Pos             22                                                      /*!< PMC LDOPMU: BOOSTADJ Position         */
#define PMC_LDOPMU_BOOSTADJ_Msk             (0x01UL << PMC_LDOPMU_BOOSTADJ_Pos)                   /*!< PMC LDOPMU: BOOSTADJ Mask             */
#define PMC_LDOPMU_BOOSTADJ_PWD_Pos         23                                                      /*!< PMC LDOPMU: BOOSTADJ_PWD Position     */
#define PMC_LDOPMU_BOOSTADJ_PWD_Msk         (0x01UL << PMC_LDOPMU_BOOSTADJ_PWD_Pos)               /*!< PMC LDOPMU: BOOSTADJ_PWD Mask         */
#define PMC_LDOPMU_VADJ_2_Pos               24                                                      /*!< PMC LDOPMU: VADJ_2 Position           */
#define PMC_LDOPMU_VADJ_2_Msk               (0x1fUL << PMC_LDOPMU_VADJ_2_Pos)                     /*!< PMC LDOPMU: VADJ_2 Mask               */
#define PMC_LDOPMU_BOOSTADJ_2_Pos           29                                                      /*!< PMC LDOPMU: BOOSTADJ_2 Position       */
#define PMC_LDOPMU_BOOSTADJ_2_Msk           (0x01UL << PMC_LDOPMU_BOOSTADJ_2_Pos)                 /*!< PMC LDOPMU: BOOSTADJ_2 Mask           */

/* --------------------------------  u_pmc_LDOMEM  -------------------------------- */
#define PMC_LDOMEM_VADJ_Pos                 0                                                       /*!< PMC LDOMEM: VADJ Position             */
#define PMC_LDOMEM_VADJ_Msk                 (0x1fUL << PMC_LDOMEM_VADJ_Pos)                       /*!< PMC LDOMEM: VADJ Mask                 */
#define PMC_LDOMEM_VADJ_PWD_Pos             5                                                       /*!< PMC LDOMEM: VADJ_PWD Position         */
#define PMC_LDOMEM_VADJ_PWD_Msk             (0x1fUL << PMC_LDOMEM_VADJ_PWD_Pos)                   /*!< PMC LDOMEM: VADJ_PWD Mask             */
#define PMC_LDOMEM_STAB_Pos                 10                                                      /*!< PMC LDOMEM: STAB Position             */
#define PMC_LDOMEM_STAB_Msk                 (0x01UL << PMC_LDOMEM_STAB_Pos)                       /*!< PMC LDOMEM: STAB Mask                 */
#define PMC_LDOMEM_HIGHCUR_Pos              11                                                      /*!< PMC LDOMEM: HIGHCUR Position          */
#define PMC_LDOMEM_HIGHCUR_Msk              (0x01UL << PMC_LDOMEM_HIGHCUR_Pos)                    /*!< PMC LDOMEM: HIGHCUR Mask              */
#define PMC_LDOMEM_VADJ_BOOST_Pos           12                                                      /*!< PMC LDOMEM: VADJ_BOOST Position       */
#define PMC_LDOMEM_VADJ_BOOST_Msk           (0x1fUL << PMC_LDOMEM_VADJ_BOOST_Pos)                 /*!< PMC LDOMEM: VADJ_BOOST Mask           */
#define PMC_LDOMEM_VADJ_BOOST_PWD_Pos       17                                                      /*!< PMC LDOMEM: VADJ_BOOST_PWD Position   */
#define PMC_LDOMEM_VADJ_BOOST_PWD_Msk       (0x1fUL << PMC_LDOMEM_VADJ_BOOST_PWD_Pos)             /*!< PMC LDOMEM: VADJ_BOOST_PWD Mask       */
#define PMC_LDOMEM_BLEED_Pos                22                                                      /*!< PMC LDOMEM: BLEED Position            */
#define PMC_LDOMEM_BLEED_Msk                (0x01UL << PMC_LDOMEM_BLEED_Pos)                      /*!< PMC LDOMEM: BLEED Mask                */
#define PMC_LDOMEM_VADJ_2_Pos               23                                                      /*!< PMC LDOMEM: VADJ_2 Position           */
#define PMC_LDOMEM_VADJ_2_Msk               (0x1fUL << PMC_LDOMEM_VADJ_2_Pos)                     /*!< PMC LDOMEM: VADJ_2 Mask               */

/* --------------------------------  u_pmc_LDOCORE  ------------------------------- */
#define PMC_LDOCORE_VADJ_Pos                0                                                       /*!< PMC LDOCORE: VADJ Position            */
#define PMC_LDOCORE_VADJ_Msk                (0x07UL << PMC_LDOCORE_VADJ_Pos)                      /*!< PMC LDOCORE: VADJ Mask                */
#define PMC_LDOCORE_VADJ_PWD_Pos            3                                                       /*!< PMC LDOCORE: VADJ_PWD Position        */
#define PMC_LDOCORE_VADJ_PWD_Msk            (0x07UL << PMC_LDOCORE_VADJ_PWD_Pos)                  /*!< PMC LDOCORE: VADJ_PWD Mask            */
#define PMC_LDOCORE_BYPASS_Pos              6                                                       /*!< PMC LDOCORE: BYPASS Position          */
#define PMC_LDOCORE_BYPASS_Msk              (0x01UL << PMC_LDOCORE_BYPASS_Pos)                    /*!< PMC LDOCORE: BYPASS Mask              */
#define PMC_LDOCORE_IBIAS_Pos               8                                                       /*!< PMC LDOCORE: IBIAS Position           */
#define PMC_LDOCORE_IBIAS_Msk               (0x03UL << PMC_LDOCORE_IBIAS_Pos)                     /*!< PMC LDOCORE: IBIAS Mask               */
#define PMC_LDOCORE_STABMODE_Pos            10                                                      /*!< PMC LDOCORE: STABMODE Position        */
#define PMC_LDOCORE_STABMODE_Msk            (0x03UL << PMC_LDOCORE_STABMODE_Pos)                  /*!< PMC LDOCORE: STABMODE Mask            */
#define PMC_LDOCORE_VADJ_2_Pos              12                                                      /*!< PMC LDOCORE: VADJ_2 Position          */
#define PMC_LDOCORE_VADJ_2_Msk              (0x07UL << PMC_LDOCORE_VADJ_2_Pos)                    /*!< PMC LDOCORE: VADJ_2 Mask              */

/* ------------------------------  u_pmc_LDOFLASHNV  ------------------------------ */
#define PMC_LDOFLASHNV_VADJ_Pos             0                                                       /*!< PMC LDOFLASHNV: VADJ Position         */
#define PMC_LDOFLASHNV_VADJ_Msk             (0x07UL << PMC_LDOFLASHNV_VADJ_Pos)                   /*!< PMC LDOFLASHNV: VADJ Mask             */
#define PMC_LDOFLASHNV_BYPASS_Pos           3                                                       /*!< PMC LDOFLASHNV: BYPASS Position       */
#define PMC_LDOFLASHNV_BYPASS_Msk           (0x01UL << PMC_LDOFLASHNV_BYPASS_Pos)                 /*!< PMC LDOFLASHNV: BYPASS Mask           */
#define PMC_LDOFLASHNV_HIGHZ_Pos            4                                                       /*!< PMC LDOFLASHNV: HIGHZ Position        */
#define PMC_LDOFLASHNV_HIGHZ_Msk            (0x01UL << PMC_LDOFLASHNV_HIGHZ_Pos)                  /*!< PMC LDOFLASHNV: HIGHZ Mask            */
#define PMC_LDOFLASHNV_IBIAS_Pos            5                                                       /*!< PMC LDOFLASHNV: IBIAS Position        */
#define PMC_LDOFLASHNV_IBIAS_Msk            (0x03UL << PMC_LDOFLASHNV_IBIAS_Pos)                  /*!< PMC LDOFLASHNV: IBIAS Mask            */
#define PMC_LDOFLASHNV_STABMODE_Pos         7                                                       /*!< PMC LDOFLASHNV: STABMODE Position     */
#define PMC_LDOFLASHNV_STABMODE_Msk         (0x01UL << PMC_LDOFLASHNV_STABMODE_Pos)               /*!< PMC LDOFLASHNV: STABMODE Mask         */
#define PMC_LDOFLASHNV_TRIMR_Pos            10                                                      /*!< PMC LDOFLASHNV: TRIMR Position        */
#define PMC_LDOFLASHNV_TRIMR_Msk            (0x1fUL << PMC_LDOFLASHNV_TRIMR_Pos)                  /*!< PMC LDOFLASHNV: TRIMR Mask            */
#define PMC_LDOFLASHNV_VADJ_2_Pos           15                                                      /*!< PMC LDOFLASHNV: VADJ_2 Position       */
#define PMC_LDOFLASHNV_VADJ_2_Msk           (0x07UL << PMC_LDOFLASHNV_VADJ_2_Pos)                 /*!< PMC LDOFLASHNV: VADJ_2 Mask           */

/* -----------------------------  u_pmc_LDOFLASHCORE  ----------------------------- */
#define PMC_LDOFLASHCORE_VADJ_Pos           0                                                       /*!< PMC LDOFLASHCORE: VADJ Position       */
#define PMC_LDOFLASHCORE_VADJ_Msk           (0x07UL << PMC_LDOFLASHCORE_VADJ_Pos)                 /*!< PMC LDOFLASHCORE: VADJ Mask           */
#define PMC_LDOFLASHCORE_BYPASS_Pos         3                                                       /*!< PMC LDOFLASHCORE: BYPASS Position     */
#define PMC_LDOFLASHCORE_BYPASS_Msk         (0x01UL << PMC_LDOFLASHCORE_BYPASS_Pos)               /*!< PMC LDOFLASHCORE: BYPASS Mask         */
#define PMC_LDOFLASHCORE_HIGHZ_Pos          4                                                       /*!< PMC LDOFLASHCORE: HIGHZ Position      */
#define PMC_LDOFLASHCORE_HIGHZ_Msk          (0x01UL << PMC_LDOFLASHCORE_HIGHZ_Pos)                /*!< PMC LDOFLASHCORE: HIGHZ Mask          */
#define PMC_LDOFLASHCORE_IBIAS_Pos          5                                                       /*!< PMC LDOFLASHCORE: IBIAS Position      */
#define PMC_LDOFLASHCORE_IBIAS_Msk          (0x03UL << PMC_LDOFLASHCORE_IBIAS_Pos)                /*!< PMC LDOFLASHCORE: IBIAS Mask          */
#define PMC_LDOFLASHCORE_STABMODE_Pos       7                                                       /*!< PMC LDOFLASHCORE: STABMODE Position   */
#define PMC_LDOFLASHCORE_STABMODE_Msk       (0x03UL << PMC_LDOFLASHCORE_STABMODE_Pos)             /*!< PMC LDOFLASHCORE: STABMODE Mask       */
#define PMC_LDOFLASHCORE_VADJ_2_Pos         9                                                       /*!< PMC LDOFLASHCORE: VADJ_2 Position     */
#define PMC_LDOFLASHCORE_VADJ_2_Msk         (0x07UL << PMC_LDOFLASHCORE_VADJ_2_Pos)               /*!< PMC LDOFLASHCORE: VADJ_2 Mask         */

/* --------------------------------  u_pmc_LDOADC  -------------------------------- */
#define PMC_LDOADC_VADJ_Pos                 0                                                       /*!< PMC LDOADC: VADJ Position             */
#define PMC_LDOADC_VADJ_Msk                 (0x07UL << PMC_LDOADC_VADJ_Pos)                       /*!< PMC LDOADC: VADJ Mask                 */
#define PMC_LDOADC_BYPASS_Pos               3                                                       /*!< PMC LDOADC: BYPASS Position           */
#define PMC_LDOADC_BYPASS_Msk               (0x01UL << PMC_LDOADC_BYPASS_Pos)                     /*!< PMC LDOADC: BYPASS Mask               */
#define PMC_LDOADC_HIGHZ_Pos                4                                                       /*!< PMC LDOADC: HIGHZ Position            */
#define PMC_LDOADC_HIGHZ_Msk                (0x01UL << PMC_LDOADC_HIGHZ_Pos)                      /*!< PMC LDOADC: HIGHZ Mask                */
#define PMC_LDOADC_IBIAS_Pos                5                                                       /*!< PMC LDOADC: IBIAS Position            */
#define PMC_LDOADC_IBIAS_Msk                (0x03UL << PMC_LDOADC_IBIAS_Pos)                      /*!< PMC LDOADC: IBIAS Mask                */
#define PMC_LDOADC_STABMODE_Pos             7                                                       /*!< PMC LDOADC: STABMODE Position         */
#define PMC_LDOADC_STABMODE_Msk             (0x03UL << PMC_LDOADC_STABMODE_Pos)                   /*!< PMC LDOADC: STABMODE Mask             */
#define PMC_LDOADC_VADJ_2_Pos               9                                                       /*!< PMC LDOADC: VADJ_2 Position           */
#define PMC_LDOADC_VADJ_2_Msk               (0x07UL << PMC_LDOADC_VADJ_2_Pos)                     /*!< PMC LDOADC: VADJ_2 Mask               */

/* --------------------------------  u_pmc_BODVBAT  ------------------------------- */
#define PMC_BODVBAT_TRIGLVL_Pos             0                                                       /*!< PMC BODVBAT: TRIGLVL Position         */
#define PMC_BODVBAT_TRIGLVL_Msk             (0x1fUL << PMC_BODVBAT_TRIGLVL_Pos)                   /*!< PMC BODVBAT: TRIGLVL Mask             */
#define PMC_BODVBAT_HYST_Pos                5                                                       /*!< PMC BODVBAT: HYST Position            */
#define PMC_BODVBAT_HYST_Msk                (0x03UL << PMC_BODVBAT_HYST_Pos)                      /*!< PMC BODVBAT: HYST Mask                */
#define PMC_BODVBAT_RESETENABLE_Pos         7                                                       /*!< PMC BODVBAT: RESETENABLE Position     */
#define PMC_BODVBAT_RESETENABLE_Msk         (0x01UL << PMC_BODVBAT_RESETENABLE_Pos)               /*!< PMC BODVBAT: RESETENABLE Mask         */

/* --------------------------------  u_pmc_BODMEM  -------------------------------- */
#define PMC_BODMEM_TRIGLVL_Pos              0                                                       /*!< PMC BODMEM: TRIGLVL Position          */
#define PMC_BODMEM_TRIGLVL_Msk              (0x0fUL << PMC_BODMEM_TRIGLVL_Pos)                    /*!< PMC BODMEM: TRIGLVL Mask              */
#define PMC_BODMEM_HYST_Pos                 4                                                       /*!< PMC BODMEM: HYST Position             */
#define PMC_BODMEM_HYST_Msk                 (0x03UL << PMC_BODMEM_HYST_Pos)                       /*!< PMC BODMEM: HYST Mask                 */
#define PMC_BODMEM_RESETENABLE_Pos          6                                                       /*!< PMC BODMEM: RESETENABLE Position      */
#define PMC_BODMEM_RESETENABLE_Msk          (0x01UL << PMC_BODMEM_RESETENABLE_Pos)                /*!< PMC BODMEM: RESETENABLE Mask          */

/* --------------------------------  u_pmc_BODCORE  ------------------------------- */
#define PMC_BODCORE_TRIGLVL_Pos             0                                                       /*!< PMC BODCORE: TRIGLVL Position         */
#define PMC_BODCORE_TRIGLVL_Msk             (0x0fUL << PMC_BODCORE_TRIGLVL_Pos)                   /*!< PMC BODCORE: TRIGLVL Mask             */
#define PMC_BODCORE_HYST_Pos                4                                                       /*!< PMC BODCORE: HYST Position            */
#define PMC_BODCORE_HYST_Msk                (0x03UL << PMC_BODCORE_HYST_Pos)                      /*!< PMC BODCORE: HYST Mask                */
#define PMC_BODCORE_RESETENABLE_Pos         6                                                       /*!< PMC BODCORE: RESETENABLE Position     */
#define PMC_BODCORE_RESETENABLE_Msk         (0x01UL << PMC_BODCORE_RESETENABLE_Pos)               /*!< PMC BODCORE: RESETENABLE Mask         */

/* --------------------------------  u_pmc_FRO192M  ------------------------------- */
#define PMC_FRO192M_TEMPTRIM_Pos            0                                                       /*!< PMC FRO192M: TEMPTRIM Position        */
#define PMC_FRO192M_TEMPTRIM_Msk            (0x3fUL << PMC_FRO192M_TEMPTRIM_Pos)                  /*!< PMC FRO192M: TEMPTRIM Mask            */
#define PMC_FRO192M_BIASTRIM_Pos            6                                                       /*!< PMC FRO192M: BIASTRIM Position        */
#define PMC_FRO192M_BIASTRIM_Msk            (0x3fUL << PMC_FRO192M_BIASTRIM_Pos)                  /*!< PMC FRO192M: BIASTRIM Mask            */
#define PMC_FRO192M_DACTRIM_Pos             12                                                      /*!< PMC FRO192M: DACTRIM Position         */
#define PMC_FRO192M_DACTRIM_Msk             (0x000000ffUL << PMC_FRO192M_DACTRIM_Pos)             /*!< PMC FRO192M: DACTRIM Mask             */
#define PMC_FRO192M_DIVSEL_Pos              20                                                      /*!< PMC FRO192M: DIVSEL Position          */
#define PMC_FRO192M_DIVSEL_Msk              (0x1fUL << PMC_FRO192M_DIVSEL_Pos)                    /*!< PMC FRO192M: DIVSEL Mask              */
#define PMC_FRO192M_ATBCTRL_Pos             25                                                      /*!< PMC FRO192M: ATBCTRL Position         */
#define PMC_FRO192M_ATBCTRL_Msk             (0x03UL << PMC_FRO192M_ATBCTRL_Pos)                   /*!< PMC FRO192M: ATBCTRL Mask             */

/* ---------------------------------  u_pmc_FRO1M  -------------------------------- */
#define PMC_FRO1M_FREQSEL_Pos               0                                                       /*!< PMC FRO1M: FREQSEL Position           */
#define PMC_FRO1M_FREQSEL_Msk               (0x7fUL << PMC_FRO1M_FREQSEL_Pos)                     /*!< PMC FRO1M: FREQSEL Mask               */
#define PMC_FRO1M_ATBCTRL_Pos               7                                                       /*!< PMC FRO1M: ATBCTRL Position           */
#define PMC_FRO1M_ATBCTRL_Msk               (0x03UL << PMC_FRO1M_ATBCTRL_Pos)                     /*!< PMC FRO1M: ATBCTRL Mask               */
#define PMC_FRO1M_DIVSEL_Pos                9                                                       /*!< PMC FRO1M: DIVSEL Position            */
#define PMC_FRO1M_DIVSEL_Msk                (0x1fUL << PMC_FRO1M_DIVSEL_Pos)                      /*!< PMC FRO1M: DIVSEL Mask                */

/* --------------------------------  u_pmc_FRO32K  -------------------------------- */
#define PMC_FRO32K_NTAT_Pos                 1                                                       /*!< PMC FRO32K: NTAT Position             */
#define PMC_FRO32K_NTAT_Msk                 (0x07UL << PMC_FRO32K_NTAT_Pos)                       /*!< PMC FRO32K: NTAT Mask                 */
#define PMC_FRO32K_PTAT_Pos                 4                                                       /*!< PMC FRO32K: PTAT Position             */
#define PMC_FRO32K_PTAT_Msk                 (0x07UL << PMC_FRO32K_PTAT_Pos)                       /*!< PMC FRO32K: PTAT Mask                 */
#define PMC_FRO32K_CAPCAL_Pos               7                                                       /*!< PMC FRO32K: CAPCAL Position           */
#define PMC_FRO32K_CAPCAL_Msk               (0x000001ffUL << PMC_FRO32K_CAPCAL_Pos)               /*!< PMC FRO32K: CAPCAL Mask               */
#define PMC_FRO32K_ATBCTRL_Pos              16                                                      /*!< PMC FRO32K: ATBCTRL Position          */
#define PMC_FRO32K_ATBCTRL_Msk              (0x03UL << PMC_FRO32K_ATBCTRL_Pos)                    /*!< PMC FRO32K: ATBCTRL Mask              */

/* --------------------------------  u_pmc_XTAL32K  ------------------------------- */
#define PMC_XTAL32K_IREF_Pos                1                                                       /*!< PMC XTAL32K: IREF Position            */
#define PMC_XTAL32K_IREF_Msk                (0x03UL << PMC_XTAL32K_IREF_Pos)                      /*!< PMC XTAL32K: IREF Mask                */
#define PMC_XTAL32K_TEST_Pos                3                                                       /*!< PMC XTAL32K: TEST Position            */
#define PMC_XTAL32K_TEST_Msk                (0x01UL << PMC_XTAL32K_TEST_Pos)                      /*!< PMC XTAL32K: TEST Mask                */
#define PMC_XTAL32K_IBIAS_Pos               4                                                       /*!< PMC XTAL32K: IBIAS Position           */
#define PMC_XTAL32K_IBIAS_Msk               (0x03UL << PMC_XTAL32K_IBIAS_Pos)                     /*!< PMC XTAL32K: IBIAS Mask               */
#define PMC_XTAL32K_AMPL_Pos                6                                                       /*!< PMC XTAL32K: AMPL Position            */
#define PMC_XTAL32K_AMPL_Msk                (0x03UL << PMC_XTAL32K_AMPL_Pos)                      /*!< PMC XTAL32K: AMPL Mask                */

/* ------------------------------  u_pmc_ANAMUXCOMP  ------------------------------ */
#define PMC_ANAMUXCOMP_COMP_HYST_Pos        1                                                       /*!< PMC ANAMUXCOMP: COMP_HYST Position    */
#define PMC_ANAMUXCOMP_COMP_HYST_Msk        (0x01UL << PMC_ANAMUXCOMP_COMP_HYST_Pos)              /*!< PMC ANAMUXCOMP: COMP_HYST Mask        */
#define PMC_ANAMUXCOMP_COMP_INNINT_Pos      2                                                       /*!< PMC ANAMUXCOMP: COMP_INNINT Position  */
#define PMC_ANAMUXCOMP_COMP_INNINT_Msk      (0x01UL << PMC_ANAMUXCOMP_COMP_INNINT_Pos)            /*!< PMC ANAMUXCOMP: COMP_INNINT Mask      */
#define PMC_ANAMUXCOMP_COMP_LOWPOWER_Pos    3                                                       /*!< PMC ANAMUXCOMP: COMP_LOWPOWER Position */
#define PMC_ANAMUXCOMP_COMP_LOWPOWER_Msk    (0x01UL << PMC_ANAMUXCOMP_COMP_LOWPOWER_Pos)          /*!< PMC ANAMUXCOMP: COMP_LOWPOWER Mask    */
#define PMC_ANAMUXCOMP_COMP_INPUTSWAP_Pos   4                                                       /*!< PMC ANAMUXCOMP: COMP_INPUTSWAP Position */
#define PMC_ANAMUXCOMP_COMP_INPUTSWAP_Msk   (0x01UL << PMC_ANAMUXCOMP_COMP_INPUTSWAP_Pos)         /*!< PMC ANAMUXCOMP: COMP_INPUTSWAP Mask   */
#define PMC_ANAMUXCOMP_MUX_1_SEL_Pos        5                                                       /*!< PMC ANAMUXCOMP: MUX_1_SEL Position    */
#define PMC_ANAMUXCOMP_MUX_1_SEL_Msk        (0x07UL << PMC_ANAMUXCOMP_MUX_1_SEL_Pos)              /*!< PMC ANAMUXCOMP: MUX_1_SEL Mask        */
#define PMC_ANAMUXCOMP_MUX_2_SEL_Pos        8                                                       /*!< PMC ANAMUXCOMP: MUX_2_SEL Position    */
#define PMC_ANAMUXCOMP_MUX_2_SEL_Msk        (0x07UL << PMC_ANAMUXCOMP_MUX_2_SEL_Pos)              /*!< PMC ANAMUXCOMP: MUX_2_SEL Mask        */

/* -------------------------------  u_pmc_PWRSWACK  ------------------------------- */
#define PMC_PWRSWACK_RESERVED0_Pos          0                                                       /*!< PMC PWRSWACK: RESERVED0 Position      */
#define PMC_PWRSWACK_RESERVED0_Msk          (0x01UL << PMC_PWRSWACK_RESERVED0_Pos)                /*!< PMC PWRSWACK: RESERVED0 Mask          */
#define PMC_PWRSWACK_PDCOMM0_Pos            1                                                       /*!< PMC PWRSWACK: PDCOMM0 Position        */
#define PMC_PWRSWACK_PDCOMM0_Msk            (0x01UL << PMC_PWRSWACK_PDCOMM0_Pos)                  /*!< PMC PWRSWACK: PDCOMM0 Mask            */
#define PMC_PWRSWACK_PDSYSTEM_Pos           2                                                       /*!< PMC PWRSWACK: PDSYSTEM Position       */
#define PMC_PWRSWACK_PDSYSTEM_Msk           (0x01UL << PMC_PWRSWACK_PDSYSTEM_Pos)                 /*!< PMC PWRSWACK: PDSYSTEM Mask           */
#define PMC_PWRSWACK_PDMCURETENTION_Pos     3                                                       /*!< PMC PWRSWACK: PDMCURETENTION Position */
#define PMC_PWRSWACK_PDMCURETENTION_Msk     (0x01UL << PMC_PWRSWACK_PDMCURETENTION_Pos)           /*!< PMC PWRSWACK: PDMCURETENTION Mask     */
#define PMC_PWRSWACK_RESERVED4_Pos          4                                                       /*!< PMC PWRSWACK: RESERVED4 Position      */
#define PMC_PWRSWACK_RESERVED4_Msk          (0x01UL << PMC_PWRSWACK_RESERVED4_Pos)                /*!< PMC PWRSWACK: RESERVED4 Mask          */

/* -------------------------------  u_pmc_DPDWKSRC  ------------------------------- */
#define PMC_DPDWKSRC_PIO0_Pos               0                                                       /*!< PMC DPDWKSRC: PIO0 Position           */
#define PMC_DPDWKSRC_PIO0_Msk               (0x01UL << PMC_DPDWKSRC_PIO0_Pos)                     /*!< PMC DPDWKSRC: PIO0 Mask               */
#define PMC_DPDWKSRC_PIO1_Pos               1                                                       /*!< PMC DPDWKSRC: PIO1 Position           */
#define PMC_DPDWKSRC_PIO1_Msk               (0x01UL << PMC_DPDWKSRC_PIO1_Pos)                     /*!< PMC DPDWKSRC: PIO1 Mask               */
#define PMC_DPDWKSRC_PIO2_Pos               2                                                       /*!< PMC DPDWKSRC: PIO2 Position           */
#define PMC_DPDWKSRC_PIO2_Msk               (0x01UL << PMC_DPDWKSRC_PIO2_Pos)                     /*!< PMC DPDWKSRC: PIO2 Mask               */
#define PMC_DPDWKSRC_PIO3_Pos               3                                                       /*!< PMC DPDWKSRC: PIO3 Position           */
#define PMC_DPDWKSRC_PIO3_Msk               (0x01UL << PMC_DPDWKSRC_PIO3_Pos)                     /*!< PMC DPDWKSRC: PIO3 Mask               */
#define PMC_DPDWKSRC_PIO4_Pos               4                                                       /*!< PMC DPDWKSRC: PIO4 Position           */
#define PMC_DPDWKSRC_PIO4_Msk               (0x01UL << PMC_DPDWKSRC_PIO4_Pos)                     /*!< PMC DPDWKSRC: PIO4 Mask               */
#define PMC_DPDWKSRC_PIO5_Pos               5                                                       /*!< PMC DPDWKSRC: PIO5 Position           */
#define PMC_DPDWKSRC_PIO5_Msk               (0x01UL << PMC_DPDWKSRC_PIO5_Pos)                     /*!< PMC DPDWKSRC: PIO5 Mask               */
#define PMC_DPDWKSRC_PIO6_Pos               6                                                       /*!< PMC DPDWKSRC: PIO6 Position           */
#define PMC_DPDWKSRC_PIO6_Msk               (0x01UL << PMC_DPDWKSRC_PIO6_Pos)                     /*!< PMC DPDWKSRC: PIO6 Mask               */
#define PMC_DPDWKSRC_PIO7_Pos               7                                                       /*!< PMC DPDWKSRC: PIO7 Position           */
#define PMC_DPDWKSRC_PIO7_Msk               (0x01UL << PMC_DPDWKSRC_PIO7_Pos)                     /*!< PMC DPDWKSRC: PIO7 Mask               */
#define PMC_DPDWKSRC_PIO8_Pos               8                                                       /*!< PMC DPDWKSRC: PIO8 Position           */
#define PMC_DPDWKSRC_PIO8_Msk               (0x01UL << PMC_DPDWKSRC_PIO8_Pos)                     /*!< PMC DPDWKSRC: PIO8 Mask               */
#define PMC_DPDWKSRC_PIO9_Pos               9                                                       /*!< PMC DPDWKSRC: PIO9 Position           */
#define PMC_DPDWKSRC_PIO9_Msk               (0x01UL << PMC_DPDWKSRC_PIO9_Pos)                     /*!< PMC DPDWKSRC: PIO9 Mask               */
#define PMC_DPDWKSRC_PIO10_Pos              10                                                      /*!< PMC DPDWKSRC: PIO10 Position          */
#define PMC_DPDWKSRC_PIO10_Msk              (0x01UL << PMC_DPDWKSRC_PIO10_Pos)                    /*!< PMC DPDWKSRC: PIO10 Mask              */
#define PMC_DPDWKSRC_PIO11_Pos              11                                                      /*!< PMC DPDWKSRC: PIO11 Position          */
#define PMC_DPDWKSRC_PIO11_Msk              (0x01UL << PMC_DPDWKSRC_PIO11_Pos)                    /*!< PMC DPDWKSRC: PIO11 Mask              */
#define PMC_DPDWKSRC_PIO12_Pos              12                                                      /*!< PMC DPDWKSRC: PIO12 Position          */
#define PMC_DPDWKSRC_PIO12_Msk              (0x01UL << PMC_DPDWKSRC_PIO12_Pos)                    /*!< PMC DPDWKSRC: PIO12 Mask              */
#define PMC_DPDWKSRC_PIO13_Pos              13                                                      /*!< PMC DPDWKSRC: PIO13 Position          */
#define PMC_DPDWKSRC_PIO13_Msk              (0x01UL << PMC_DPDWKSRC_PIO13_Pos)                    /*!< PMC DPDWKSRC: PIO13 Mask              */
#define PMC_DPDWKSRC_PIO14_Pos              14                                                      /*!< PMC DPDWKSRC: PIO14 Position          */
#define PMC_DPDWKSRC_PIO14_Msk              (0x01UL << PMC_DPDWKSRC_PIO14_Pos)                    /*!< PMC DPDWKSRC: PIO14 Mask              */
#define PMC_DPDWKSRC_PIO15_Pos              15                                                      /*!< PMC DPDWKSRC: PIO15 Position          */
#define PMC_DPDWKSRC_PIO15_Msk              (0x01UL << PMC_DPDWKSRC_PIO15_Pos)                    /*!< PMC DPDWKSRC: PIO15 Mask              */
#define PMC_DPDWKSRC_PIO16_Pos              16                                                      /*!< PMC DPDWKSRC: PIO16 Position          */
#define PMC_DPDWKSRC_PIO16_Msk              (0x01UL << PMC_DPDWKSRC_PIO16_Pos)                    /*!< PMC DPDWKSRC: PIO16 Mask              */
#define PMC_DPDWKSRC_PIO17_Pos              17                                                      /*!< PMC DPDWKSRC: PIO17 Position          */
#define PMC_DPDWKSRC_PIO17_Msk              (0x01UL << PMC_DPDWKSRC_PIO17_Pos)                    /*!< PMC DPDWKSRC: PIO17 Mask              */
#define PMC_DPDWKSRC_PIO18_Pos              18                                                      /*!< PMC DPDWKSRC: PIO18 Position          */
#define PMC_DPDWKSRC_PIO18_Msk              (0x01UL << PMC_DPDWKSRC_PIO18_Pos)                    /*!< PMC DPDWKSRC: PIO18 Mask              */
#define PMC_DPDWKSRC_PIO19_Pos              19                                                      /*!< PMC DPDWKSRC: PIO19 Position          */
#define PMC_DPDWKSRC_PIO19_Msk              (0x01UL << PMC_DPDWKSRC_PIO19_Pos)                    /*!< PMC DPDWKSRC: PIO19 Mask              */
#define PMC_DPDWKSRC_PIO20_Pos              20                                                      /*!< PMC DPDWKSRC: PIO20 Position          */
#define PMC_DPDWKSRC_PIO20_Msk              (0x01UL << PMC_DPDWKSRC_PIO20_Pos)                    /*!< PMC DPDWKSRC: PIO20 Mask              */
#define PMC_DPDWKSRC_PIO21_Pos              21                                                      /*!< PMC DPDWKSRC: PIO21 Position          */
#define PMC_DPDWKSRC_PIO21_Msk              (0x01UL << PMC_DPDWKSRC_PIO21_Pos)                    /*!< PMC DPDWKSRC: PIO21 Mask              */
#define PMC_DPDWKSRC_NTAG_FD_Pos            22                                                      /*!< PMC DPDWKSRC: NTAG_FD Position        */
#define PMC_DPDWKSRC_NTAG_FD_Msk            (0x01UL << PMC_DPDWKSRC_NTAG_FD_Pos)                  /*!< PMC DPDWKSRC: NTAG_FD Mask            */

/* -------------------------------  u_pmc_STATUSPWR  ------------------------------ */
#define PMC_STATUSPWR_DCDCPWROK_Pos         0                                                       /*!< PMC STATUSPWR: DCDCPWROK Position     */
#define PMC_STATUSPWR_DCDCPWROK_Msk         (0x01UL << PMC_STATUSPWR_DCDCPWROK_Pos)               /*!< PMC STATUSPWR: DCDCPWROK Mask         */
#define PMC_STATUSPWR_DCDCVXCTRLMON_Pos     1                                                       /*!< PMC STATUSPWR: DCDCVXCTRLMON Position */
#define PMC_STATUSPWR_DCDCVXCTRLMON_Msk     (0x01UL << PMC_STATUSPWR_DCDCVXCTRLMON_Pos)           /*!< PMC STATUSPWR: DCDCVXCTRLMON Mask     */
#define PMC_STATUSPWR_LDOCOREPWROK_Pos      2                                                       /*!< PMC STATUSPWR: LDOCOREPWROK Position  */
#define PMC_STATUSPWR_LDOCOREPWROK_Msk      (0x01UL << PMC_STATUSPWR_LDOCOREPWROK_Pos)            /*!< PMC STATUSPWR: LDOCOREPWROK Mask      */
#define PMC_STATUSPWR_LDOFLASHNVPWROK_Pos   3                                                       /*!< PMC STATUSPWR: LDOFLASHNVPWROK Position */
#define PMC_STATUSPWR_LDOFLASHNVPWROK_Msk   (0x01UL << PMC_STATUSPWR_LDOFLASHNVPWROK_Pos)         /*!< PMC STATUSPWR: LDOFLASHNVPWROK Mask   */
#define PMC_STATUSPWR_LDOFLASHCOREPWROK_Pos 4                                                       /*!< PMC STATUSPWR: LDOFLASHCOREPWROK Position */
#define PMC_STATUSPWR_LDOFLASHCOREPWROK_Msk (0x01UL << PMC_STATUSPWR_LDOFLASHCOREPWROK_Pos)       /*!< PMC STATUSPWR: LDOFLASHCOREPWROK Mask */
#define PMC_STATUSPWR_LDOADC1V1PWROK_Pos    5                                                       /*!< PMC STATUSPWR: LDOADC1V1PWROK Position */
#define PMC_STATUSPWR_LDOADC1V1PWROK_Msk    (0x01UL << PMC_STATUSPWR_LDOADC1V1PWROK_Pos)          /*!< PMC STATUSPWR: LDOADC1V1PWROK Mask    */

/* -------------------------------  u_pmc_STATUSCLK  ------------------------------ */
#define PMC_STATUSCLK_FRO192MCLKVALID_Pos   0                                                       /*!< PMC STATUSCLK: FRO192MCLKVALID Position */
#define PMC_STATUSCLK_FRO192MCLKVALID_Msk   (0x01UL << PMC_STATUSCLK_FRO192MCLKVALID_Pos)         /*!< PMC STATUSCLK: FRO192MCLKVALID Mask   */
#define PMC_STATUSCLK_XTAL32KOK_Pos         1                                                       /*!< PMC STATUSCLK: XTAL32KOK Position     */
#define PMC_STATUSCLK_XTAL32KOK_Msk         (0x01UL << PMC_STATUSCLK_XTAL32KOK_Pos)               /*!< PMC STATUSCLK: XTAL32KOK Mask         */
#define PMC_STATUSCLK_FRO1MCLKVALID_Pos     2                                                       /*!< PMC STATUSCLK: FRO1MCLKVALID Position */
#define PMC_STATUSCLK_FRO1MCLKVALID_Msk     (0x01UL << PMC_STATUSCLK_FRO1MCLKVALID_Pos)           /*!< PMC STATUSCLK: FRO1MCLKVALID Mask     */

/* ------------------------------  u_pmc_RESETCAUSE  ------------------------------ */
#define PMC_RESETCAUSE_POR_Pos              0                                                       /*!< PMC RESETCAUSE: POR Position          */
#define PMC_RESETCAUSE_POR_Msk              (0x01UL << PMC_RESETCAUSE_POR_Pos)                    /*!< PMC RESETCAUSE: POR Mask              */
#define PMC_RESETCAUSE_PADRESET_Pos         1                                                       /*!< PMC RESETCAUSE: PADRESET Position     */
#define PMC_RESETCAUSE_PADRESET_Msk         (0x01UL << PMC_RESETCAUSE_PADRESET_Pos)               /*!< PMC RESETCAUSE: PADRESET Mask         */
#define PMC_RESETCAUSE_BODRESET_Pos         2                                                       /*!< PMC RESETCAUSE: BODRESET Position     */
#define PMC_RESETCAUSE_BODRESET_Msk         (0x01UL << PMC_RESETCAUSE_BODRESET_Pos)               /*!< PMC RESETCAUSE: BODRESET Mask         */
#define PMC_RESETCAUSE_SYSTEMRESET_Pos      3                                                       /*!< PMC RESETCAUSE: SYSTEMRESET Position  */
#define PMC_RESETCAUSE_SYSTEMRESET_Msk      (0x01UL << PMC_RESETCAUSE_SYSTEMRESET_Pos)            /*!< PMC RESETCAUSE: SYSTEMRESET Mask      */
#define PMC_RESETCAUSE_WDTRESET_Pos         4                                                       /*!< PMC RESETCAUSE: WDTRESET Position     */
#define PMC_RESETCAUSE_WDTRESET_Msk         (0x01UL << PMC_RESETCAUSE_WDTRESET_Pos)               /*!< PMC RESETCAUSE: WDTRESET Mask         */
#define PMC_RESETCAUSE_WAKEUPIORESET_Pos    5                                                       /*!< PMC RESETCAUSE: WAKEUPIORESET Position */
#define PMC_RESETCAUSE_WAKEUPIORESET_Msk    (0x01UL << PMC_RESETCAUSE_WAKEUPIORESET_Pos)          /*!< PMC RESETCAUSE: WAKEUPIORESET Mask    */
#define PMC_RESETCAUSE_WAKEUPPWDNRESET_Pos  6                                                       /*!< PMC RESETCAUSE: WAKEUPPWDNRESET Position */
#define PMC_RESETCAUSE_WAKEUPPWDNRESET_Msk  (0x01UL << PMC_RESETCAUSE_WAKEUPPWDNRESET_Pos)        /*!< PMC RESETCAUSE: WAKEUPPWDNRESET Mask  */
#define PMC_RESETCAUSE_SWRRESET_Pos         7                                                       /*!< PMC RESETCAUSE: SWRRESET Position     */
#define PMC_RESETCAUSE_SWRRESET_Msk         (0x01UL << PMC_RESETCAUSE_SWRRESET_Pos)               /*!< PMC RESETCAUSE: SWRRESET Mask         */

/* --------------------------------  u_pmc_AOREG0  -------------------------------- */
#define PMC_AOREG0_DATA31_0_Pos             0                                                       /*!< PMC AOREG0: DATA31_0 Position         */
#define PMC_AOREG0_DATA31_0_Msk             (0xffffffffUL << PMC_AOREG0_DATA31_0_Pos)             /*!< PMC AOREG0: DATA31_0 Mask             */

/* --------------------------------  u_pmc_AOREG1  -------------------------------- */
#define PMC_AOREG1_DATA31_0_Pos             0                                                       /*!< PMC AOREG1: DATA31_0 Position         */
#define PMC_AOREG1_DATA31_0_Msk             (0xffffffffUL << PMC_AOREG1_DATA31_0_Pos)             /*!< PMC AOREG1: DATA31_0 Mask             */

/* --------------------------------  u_pmc_AOREG2  -------------------------------- */
#define PMC_AOREG2_DATA31_0_Pos             0                                                       /*!< PMC AOREG2: DATA31_0 Position         */
#define PMC_AOREG2_DATA31_0_Msk             (0xffffffffUL << PMC_AOREG2_DATA31_0_Pos)             /*!< PMC AOREG2: DATA31_0 Mask             */

/* -------------------------------  u_pmc_DUMMYCTRL  ------------------------------ */
#define PMC_DUMMYCTRL_DUMMYCTRL_Pos         0                                                       /*!< PMC DUMMYCTRL: DUMMYCTRL Position     */
#define PMC_DUMMYCTRL_DUMMYCTRL_Msk         (0xffffffffUL << PMC_DUMMYCTRL_DUMMYCTRL_Pos)         /*!< PMC DUMMYCTRL: DUMMYCTRL Mask         */

/* ------------------------------  u_pmc_DUMMYSTATUS  ----------------------------- */
#define PMC_DUMMYSTATUS_DUMMYSTATUS_Pos     0                                                       /*!< PMC DUMMYSTATUS: DUMMYSTATUS Position */
#define PMC_DUMMYSTATUS_DUMMYSTATUS_Msk     (0x000000ffUL << PMC_DUMMYSTATUS_DUMMYSTATUS_Pos)     /*!< PMC DUMMYSTATUS: DUMMYSTATUS Mask     */

/* --------------------------------  u_pmc_DPDCTRL  ------------------------------- */
#define PMC_DPDCTRL_XTAL32MSTARTENA_Pos     0                                                       /*!< PMC DPDCTRL: XTAL32MSTARTENA Position */
#define PMC_DPDCTRL_XTAL32MSTARTENA_Msk     (0x01UL << PMC_DPDCTRL_XTAL32MSTARTENA_Pos)           /*!< PMC DPDCTRL: XTAL32MSTARTENA Mask     */
#define PMC_DPDCTRL_XTAL32MSTARTDLY_Pos     1                                                       /*!< PMC DPDCTRL: XTAL32MSTARTDLY Position */
#define PMC_DPDCTRL_XTAL32MSTARTDLY_Msk     (0x03UL << PMC_DPDCTRL_XTAL32MSTARTDLY_Pos)           /*!< PMC DPDCTRL: XTAL32MSTARTDLY Mask     */

/* -------------------------------  u_pmc_PIOPORCAP  ------------------------------ */
#define PMC_PIOPORCAP_PIOPORCAP_Pos         0                                                       /*!< PMC PIOPORCAP: PIOPORCAP Position     */
#define PMC_PIOPORCAP_PIOPORCAP_Msk         (0xffffffffUL << PMC_PIOPORCAP_PIOPORCAP_Pos)         /*!< PMC PIOPORCAP: PIOPORCAP Mask         */

/* -------------------------------  u_pmc_PIORESCAP  ------------------------------ */
#define PMC_PIORESCAP_PIORESCAP_Pos         0                                                       /*!< PMC PIORESCAP: PIORESCAP Position     */
#define PMC_PIORESCAP_PIORESCAP_Msk         (0xffffffffUL << PMC_PIORESCAP_PIORESCAP_Pos)         /*!< PMC PIORESCAP: PIORESCAP Mask         */

/* -----------------------------  u_pmc_TIMEOUTEVENTS  ---------------------------- */
#define PMC_TIMEOUTEVENTS_TIMEOUTEVENTS_Pos 0                                                       /*!< PMC TIMEOUTEVENTS: TIMEOUTEVENTS Position */
#define PMC_TIMEOUTEVENTS_TIMEOUTEVENTS_Msk (0xffffffffUL << PMC_TIMEOUTEVENTS_TIMEOUTEVENTS_Pos) /*!< PMC TIMEOUTEVENTS: TIMEOUTEVENTS Mask */

/* --------------------------------  u_pmc_TIMEOUT  ------------------------------- */
#define PMC_TIMEOUT_PMUPOWEROK_Pos          0                                                       /*!< PMC TIMEOUT: PMUPOWEROK Position      */
#define PMC_TIMEOUT_PMUPOWEROK_Msk          (0x00001fffUL << PMC_TIMEOUT_PMUPOWEROK_Pos)          /*!< PMC TIMEOUT: PMUPOWEROK Mask          */
#define PMC_TIMEOUT_LDOFLASHNVDEACTIVATE_Pos 13                                                     /*!< PMC TIMEOUT: LDOFLASHNVDEACTIVATE Position */
#define PMC_TIMEOUT_LDOFLASHNVDEACTIVATE_Msk (0x000001ffUL << PMC_TIMEOUT_LDOFLASHNVDEACTIVATE_Pos)/*!< PMC TIMEOUT: LDOFLASHNVDEACTIVATE Mask */

/* ------------------------------  u_pmc_PDSLEEPCFG  ------------------------------ */
#define PMC_PDSLEEPCFG_PDEN_DCDC_Pos        0                                                       /*!< PMC PDSLEEPCFG: PDEN_DCDC Position    */
#define PMC_PDSLEEPCFG_PDEN_DCDC_Msk        (0x01UL << PMC_PDSLEEPCFG_PDEN_DCDC_Pos)              /*!< PMC PDSLEEPCFG: PDEN_DCDC Mask        */
#define PMC_PDSLEEPCFG_PDEN_BIAS_Pos        1                                                       /*!< PMC PDSLEEPCFG: PDEN_BIAS Position    */
#define PMC_PDSLEEPCFG_PDEN_BIAS_Msk        (0x01UL << PMC_PDSLEEPCFG_PDEN_BIAS_Pos)              /*!< PMC PDSLEEPCFG: PDEN_BIAS Mask        */
#define PMC_PDSLEEPCFG_PDEN_LDO_MEM_Pos     2                                                       /*!< PMC PDSLEEPCFG: PDEN_LDO_MEM Position */
#define PMC_PDSLEEPCFG_PDEN_LDO_MEM_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_LDO_MEM_Pos)           /*!< PMC PDSLEEPCFG: PDEN_LDO_MEM Mask     */
#define PMC_PDSLEEPCFG_PDEN_VBAT_BOD_Pos    3                                                       /*!< PMC PDSLEEPCFG: PDEN_VBAT_BOD Position */
#define PMC_PDSLEEPCFG_PDEN_VBAT_BOD_Msk    (0x01UL << PMC_PDSLEEPCFG_PDEN_VBAT_BOD_Pos)          /*!< PMC PDSLEEPCFG: PDEN_VBAT_BOD Mask    */
#define PMC_PDSLEEPCFG_PDEN_FRO192M_Pos     4                                                       /*!< PMC PDSLEEPCFG: PDEN_FRO192M Position */
#define PMC_PDSLEEPCFG_PDEN_FRO192M_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_FRO192M_Pos)           /*!< PMC PDSLEEPCFG: PDEN_FRO192M Mask     */
#define PMC_PDSLEEPCFG_PDEN_FRO1M_Pos       5                                                       /*!< PMC PDSLEEPCFG: PDEN_FRO1M Position   */
#define PMC_PDSLEEPCFG_PDEN_FRO1M_Msk       (0x01UL << PMC_PDSLEEPCFG_PDEN_FRO1M_Pos)             /*!< PMC PDSLEEPCFG: PDEN_FRO1M Mask       */
#define PMC_PDSLEEPCFG_PDEN_PD_FLASH_Pos    6                                                       /*!< PMC PDSLEEPCFG: PDEN_PD_FLASH Position */
#define PMC_PDSLEEPCFG_PDEN_PD_FLASH_Msk    (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_FLASH_Pos)          /*!< PMC PDSLEEPCFG: PDEN_PD_FLASH Mask    */
#define PMC_PDSLEEPCFG_PDEN_PD_COMM0_Pos    7                                                       /*!< PMC PDSLEEPCFG: PDEN_PD_COMM0 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_COMM0_Msk    (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_COMM0_Pos)          /*!< PMC PDSLEEPCFG: PDEN_PD_COMM0 Mask    */
#define PMC_PDSLEEPCFG_EN_PDMCU_RETENTION_Pos 8                                                     /*!< PMC PDSLEEPCFG: EN_PDMCU_RETENTION Position */
#define PMC_PDSLEEPCFG_EN_PDMCU_RETENTION_Msk (0x01UL << PMC_PDSLEEPCFG_EN_PDMCU_RETENTION_Pos)   /*!< PMC PDSLEEPCFG: EN_PDMCU_RETENTION Mask */
#define PMC_PDSLEEPCFG_RESERVED9_Pos        9                                                       /*!< PMC PDSLEEPCFG: RESERVED9 Position    */
#define PMC_PDSLEEPCFG_RESERVED9_Msk        (0x01UL << PMC_PDSLEEPCFG_RESERVED9_Pos)              /*!< PMC PDSLEEPCFG: RESERVED9 Mask        */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM0_Pos     10                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM0 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM0_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM0_Pos)           /*!< PMC PDSLEEPCFG: PDEN_PD_MEM0 Mask     */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM1_Pos     11                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM1 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM1_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM1_Pos)           /*!< PMC PDSLEEPCFG: PDEN_PD_MEM1 Mask     */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM2_Pos     12                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM2 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM2_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM2_Pos)           /*!< PMC PDSLEEPCFG: PDEN_PD_MEM2 Mask     */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM3_Pos     13                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM3 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM3_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM3_Pos)           /*!< PMC PDSLEEPCFG: PDEN_PD_MEM3 Mask     */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM4_Pos     14                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM4 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM4_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM4_Pos)           /*!< PMC PDSLEEPCFG: PDEN_PD_MEM4 Mask     */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM5_Pos     15                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM5 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM5_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM5_Pos)           /*!< PMC PDSLEEPCFG: PDEN_PD_MEM5 Mask     */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM6_Pos     16                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM6 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM6_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM6_Pos)           /*!< PMC PDSLEEPCFG: PDEN_PD_MEM6 Mask     */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM7_Pos     17                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM7 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM7_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM7_Pos)           /*!< PMC PDSLEEPCFG: PDEN_PD_MEM7 Mask     */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM8_Pos     18                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM8 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM8_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM8_Pos)           /*!< PMC PDSLEEPCFG: PDEN_PD_MEM8 Mask     */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM9_Pos     19                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM9 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM9_Msk     (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM9_Pos)           /*!< PMC PDSLEEPCFG: PDEN_PD_MEM9 Mask     */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM10_Pos    20                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM10 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM10_Msk    (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM10_Pos)          /*!< PMC PDSLEEPCFG: PDEN_PD_MEM10 Mask    */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM11_Pos    21                                                      /*!< PMC PDSLEEPCFG: PDEN_PD_MEM11 Position */
#define PMC_PDSLEEPCFG_PDEN_PD_MEM11_Msk    (0x01UL << PMC_PDSLEEPCFG_PDEN_PD_MEM11_Pos)          /*!< PMC PDSLEEPCFG: PDEN_PD_MEM11 Mask    */

/* -------------------------------  u_pmc_PDRUNCFG  ------------------------------- */
#define PMC_PDRUNCFG_ENA_LDO_ADC_Pos        22                                                      /*!< PMC PDRUNCFG: ENA_LDO_ADC Position    */
#define PMC_PDRUNCFG_ENA_LDO_ADC_Msk        (0x01UL << PMC_PDRUNCFG_ENA_LDO_ADC_Pos)              /*!< PMC PDRUNCFG: ENA_LDO_ADC Mask        */
#define PMC_PDRUNCFG_ENA_BOD_MEM_Pos        23                                                      /*!< PMC PDRUNCFG: ENA_BOD_MEM Position    */
#define PMC_PDRUNCFG_ENA_BOD_MEM_Msk        (0x01UL << PMC_PDRUNCFG_ENA_BOD_MEM_Pos)              /*!< PMC PDRUNCFG: ENA_BOD_MEM Mask        */
#define PMC_PDRUNCFG_ENA_BOD_CORE_Pos       24                                                      /*!< PMC PDRUNCFG: ENA_BOD_CORE Position   */
#define PMC_PDRUNCFG_ENA_BOD_CORE_Msk       (0x01UL << PMC_PDRUNCFG_ENA_BOD_CORE_Pos)             /*!< PMC PDRUNCFG: ENA_BOD_CORE Mask       */
#define PMC_PDRUNCFG_ENA_FRO32K_Pos         25                                                      /*!< PMC PDRUNCFG: ENA_FRO32K Position     */
#define PMC_PDRUNCFG_ENA_FRO32K_Msk         (0x01UL << PMC_PDRUNCFG_ENA_FRO32K_Pos)               /*!< PMC PDRUNCFG: ENA_FRO32K Mask         */
#define PMC_PDRUNCFG_ENA_XTAL32K_Pos        26                                                      /*!< PMC PDRUNCFG: ENA_XTAL32K Position    */
#define PMC_PDRUNCFG_ENA_XTAL32K_Msk        (0x01UL << PMC_PDRUNCFG_ENA_XTAL32K_Pos)              /*!< PMC PDRUNCFG: ENA_XTAL32K Mask        */
#define PMC_PDRUNCFG_ENA_ANA_COMP_Pos       27                                                      /*!< PMC PDRUNCFG: ENA_ANA_COMP Position   */
#define PMC_PDRUNCFG_ENA_ANA_COMP_Msk       (0x01UL << PMC_PDRUNCFG_ENA_ANA_COMP_Pos)             /*!< PMC PDRUNCFG: ENA_ANA_COMP Mask       */

/* ------------------------------  u_pmc_WAKEIOCAUSE  ----------------------------- */
#define PMC_WAKEIOCAUSE_GPIO00_Pos          0                                                       /*!< PMC WAKEIOCAUSE: GPIO00 Position      */
#define PMC_WAKEIOCAUSE_GPIO00_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO00_Pos)                /*!< PMC WAKEIOCAUSE: GPIO00 Mask          */
#define PMC_WAKEIOCAUSE_GPIO01_Pos          1                                                       /*!< PMC WAKEIOCAUSE: GPIO01 Position      */
#define PMC_WAKEIOCAUSE_GPIO01_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO01_Pos)                /*!< PMC WAKEIOCAUSE: GPIO01 Mask          */
#define PMC_WAKEIOCAUSE_GPIO02_Pos          2                                                       /*!< PMC WAKEIOCAUSE: GPIO02 Position      */
#define PMC_WAKEIOCAUSE_GPIO02_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO02_Pos)                /*!< PMC WAKEIOCAUSE: GPIO02 Mask          */
#define PMC_WAKEIOCAUSE_GPIO03_Pos          3                                                       /*!< PMC WAKEIOCAUSE: GPIO03 Position      */
#define PMC_WAKEIOCAUSE_GPIO03_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO03_Pos)                /*!< PMC WAKEIOCAUSE: GPIO03 Mask          */
#define PMC_WAKEIOCAUSE_GPIO04_Pos          4                                                       /*!< PMC WAKEIOCAUSE: GPIO04 Position      */
#define PMC_WAKEIOCAUSE_GPIO04_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO04_Pos)                /*!< PMC WAKEIOCAUSE: GPIO04 Mask          */
#define PMC_WAKEIOCAUSE_GPIO05_Pos          5                                                       /*!< PMC WAKEIOCAUSE: GPIO05 Position      */
#define PMC_WAKEIOCAUSE_GPIO05_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO05_Pos)                /*!< PMC WAKEIOCAUSE: GPIO05 Mask          */
#define PMC_WAKEIOCAUSE_GPIO06_Pos          6                                                       /*!< PMC WAKEIOCAUSE: GPIO06 Position      */
#define PMC_WAKEIOCAUSE_GPIO06_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO06_Pos)                /*!< PMC WAKEIOCAUSE: GPIO06 Mask          */
#define PMC_WAKEIOCAUSE_GPIO07_Pos          7                                                       /*!< PMC WAKEIOCAUSE: GPIO07 Position      */
#define PMC_WAKEIOCAUSE_GPIO07_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO07_Pos)                /*!< PMC WAKEIOCAUSE: GPIO07 Mask          */
#define PMC_WAKEIOCAUSE_GPIO08_Pos          8                                                       /*!< PMC WAKEIOCAUSE: GPIO08 Position      */
#define PMC_WAKEIOCAUSE_GPIO08_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO08_Pos)                /*!< PMC WAKEIOCAUSE: GPIO08 Mask          */
#define PMC_WAKEIOCAUSE_GPIO09_Pos          9                                                       /*!< PMC WAKEIOCAUSE: GPIO09 Position      */
#define PMC_WAKEIOCAUSE_GPIO09_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO09_Pos)                /*!< PMC WAKEIOCAUSE: GPIO09 Mask          */
#define PMC_WAKEIOCAUSE_GPIO10_Pos          10                                                      /*!< PMC WAKEIOCAUSE: GPIO10 Position      */
#define PMC_WAKEIOCAUSE_GPIO10_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO10_Pos)                /*!< PMC WAKEIOCAUSE: GPIO10 Mask          */
#define PMC_WAKEIOCAUSE_GPIO11_Pos          11                                                      /*!< PMC WAKEIOCAUSE: GPIO11 Position      */
#define PMC_WAKEIOCAUSE_GPIO11_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO11_Pos)                /*!< PMC WAKEIOCAUSE: GPIO11 Mask          */
#define PMC_WAKEIOCAUSE_GPIO12_Pos          12                                                      /*!< PMC WAKEIOCAUSE: GPIO12 Position      */
#define PMC_WAKEIOCAUSE_GPIO12_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO12_Pos)                /*!< PMC WAKEIOCAUSE: GPIO12 Mask          */
#define PMC_WAKEIOCAUSE_GPIO13_Pos          13                                                      /*!< PMC WAKEIOCAUSE: GPIO13 Position      */
#define PMC_WAKEIOCAUSE_GPIO13_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO13_Pos)                /*!< PMC WAKEIOCAUSE: GPIO13 Mask          */
#define PMC_WAKEIOCAUSE_GPIO14_Pos          14                                                      /*!< PMC WAKEIOCAUSE: GPIO14 Position      */
#define PMC_WAKEIOCAUSE_GPIO14_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO14_Pos)                /*!< PMC WAKEIOCAUSE: GPIO14 Mask          */
#define PMC_WAKEIOCAUSE_GPIO15_Pos          15                                                      /*!< PMC WAKEIOCAUSE: GPIO15 Position      */
#define PMC_WAKEIOCAUSE_GPIO15_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO15_Pos)                /*!< PMC WAKEIOCAUSE: GPIO15 Mask          */
#define PMC_WAKEIOCAUSE_GPIO16_Pos          16                                                      /*!< PMC WAKEIOCAUSE: GPIO16 Position      */
#define PMC_WAKEIOCAUSE_GPIO16_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO16_Pos)                /*!< PMC WAKEIOCAUSE: GPIO16 Mask          */
#define PMC_WAKEIOCAUSE_GPIO17_Pos          17                                                      /*!< PMC WAKEIOCAUSE: GPIO17 Position      */
#define PMC_WAKEIOCAUSE_GPIO17_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO17_Pos)                /*!< PMC WAKEIOCAUSE: GPIO17 Mask          */
#define PMC_WAKEIOCAUSE_GPIO18_Pos          18                                                      /*!< PMC WAKEIOCAUSE: GPIO18 Position      */
#define PMC_WAKEIOCAUSE_GPIO18_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO18_Pos)                /*!< PMC WAKEIOCAUSE: GPIO18 Mask          */
#define PMC_WAKEIOCAUSE_GPIO19_Pos          19                                                      /*!< PMC WAKEIOCAUSE: GPIO19 Position      */
#define PMC_WAKEIOCAUSE_GPIO19_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO19_Pos)                /*!< PMC WAKEIOCAUSE: GPIO19 Mask          */
#define PMC_WAKEIOCAUSE_GPIO20_Pos          20                                                      /*!< PMC WAKEIOCAUSE: GPIO20 Position      */
#define PMC_WAKEIOCAUSE_GPIO20_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO20_Pos)                /*!< PMC WAKEIOCAUSE: GPIO20 Mask          */
#define PMC_WAKEIOCAUSE_GPIO21_Pos          21                                                      /*!< PMC WAKEIOCAUSE: GPIO21 Position      */
#define PMC_WAKEIOCAUSE_GPIO21_Msk          (0x01UL << PMC_WAKEIOCAUSE_GPIO21_Pos)                /*!< PMC WAKEIOCAUSE: GPIO21 Mask          */
#define PMC_WAKEIOCAUSE_NTAG_FD_Pos         22                                                      /*!< PMC WAKEIOCAUSE: NTAG_FD Position     */
#define PMC_WAKEIOCAUSE_NTAG_FD_Msk         (0x01UL << PMC_WAKEIOCAUSE_NTAG_FD_Pos)               /*!< PMC WAKEIOCAUSE: NTAG_FD Mask         */

/* --------------------------------  u_pmc_EFUSE0  -------------------------------- */
#define PMC_EFUSE0_EFUSE0_VAL_Pos           0                                                       /*!< PMC EFUSE0: EFUSE0_VAL Position       */
#define PMC_EFUSE0_EFUSE0_VAL_Msk           (0xffffffffUL << PMC_EFUSE0_EFUSE0_VAL_Pos)           /*!< PMC EFUSE0: EFUSE0_VAL Mask           */

/* --------------------------------  u_pmc_EFUSE1  -------------------------------- */
#define PMC_EFUSE1_EFUSE1_VAL_Pos           0                                                       /*!< PMC EFUSE1: EFUSE1_VAL Position       */
#define PMC_EFUSE1_EFUSE1_VAL_Msk           (0xffffffffUL << PMC_EFUSE1_EFUSE1_VAL_Pos)           /*!< PMC EFUSE1: EFUSE1_VAL Mask           */

/* --------------------------------  u_pmc_EFUSE2  -------------------------------- */
#define PMC_EFUSE2_EFUSE2_VAL_Pos           0                                                       /*!< PMC EFUSE2: EFUSE2_VAL Position       */
#define PMC_EFUSE2_EFUSE2_VAL_Msk           (0x0000ffffUL << PMC_EFUSE2_EFUSE2_VAL_Pos)           /*!< PMC EFUSE2: EFUSE2_VAL Mask           */

/* -------------------------------  u_pmc_CTRLNORST  ------------------------------ */
#define PMC_CTRLNORST_FASTLDOENABLE_Pos     0                                                       /*!< PMC CTRLNORST: FASTLDOENABLE Position */
#define PMC_CTRLNORST_FASTLDOENABLE_Msk     (0x07UL << PMC_CTRLNORST_FASTLDOENABLE_Pos)           /*!< PMC CTRLNORST: FASTLDOENABLE Mask     */


/* ================================================================================ */
/* ================      struct 'u_ble_dp_top' Position & Mask     ================ */
/* ================================================================================ */


/* -----------------------  u_ble_dp_top_DP_TOP_SYSTEM_CTRL  ---------------------- */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_PDU_LEN_IN_Pos 0                                           /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: RX_PDU_LEN_IN Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_PDU_LEN_IN_Msk (0x00003fffUL << BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_PDU_LEN_IN_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: RX_PDU_LEN_IN Mask */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_AA_SEL_Pos 14                                                 /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: AA_SEL Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_AA_SEL_Msk (0x01UL << BLEMODEM_DP_TOP_SYSTEM_CTRL_AA_SEL_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: AA_SEL Mask */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_PDU_LEN_SEL_Pos 15                                            /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: PDU_LEN_SEL Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_PDU_LEN_SEL_Msk (0x01UL << BLEMODEM_DP_TOP_SYSTEM_CTRL_PDU_LEN_SEL_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: PDU_LEN_SEL Mask */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_H_IDX_Pos 16                                                  /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: H_IDX Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_H_IDX_Msk (0x000000ffUL << BLEMODEM_DP_TOP_SYSTEM_CTRL_H_IDX_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: H_IDX Mask */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_EN_SEL_Pos 24                                              /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: RX_EN_SEL Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_EN_SEL_Msk (0x01UL << BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_EN_SEL_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: RX_EN_SEL Mask */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_TX_EN_SEL_Pos 25                                              /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: TX_EN_SEL Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_TX_EN_SEL_Msk (0x01UL << BLEMODEM_DP_TOP_SYSTEM_CTRL_TX_EN_SEL_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: TX_EN_SEL Mask */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_REQ_Pos 26                                                 /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: RX_REQ Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_REQ_Msk (0x01UL << BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_REQ_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: RX_REQ Mask */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_TX_REQ_Pos 27                                                 /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: TX_REQ Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_TX_REQ_Msk (0x01UL << BLEMODEM_DP_TOP_SYSTEM_CTRL_TX_REQ_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: TX_REQ Mask */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_MODE_Pos 28                                                /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: RX_MODE Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_MODE_Msk (0x03UL << BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_MODE_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: RX_MODE Mask */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_ANT_DATA_START_Pos 30                                         /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: ANT_DATA_START Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_ANT_DATA_START_Msk (0x01UL << BLEMODEM_DP_TOP_SYSTEM_CTRL_ANT_DATA_START_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: ANT_DATA_START Mask */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_DET_MODE_Pos 31                                               /*!< BLEMODEM DP_TOP_SYSTEM_CTRL: DET_MODE Position */
#define BLEMODEM_DP_TOP_SYSTEM_CTRL_DET_MODE_Msk (0x01UL << BLEMODEM_DP_TOP_SYSTEM_CTRL_DET_MODE_Pos)/*!< BLEMODEM DP_TOP_SYSTEM_CTRL: DET_MODE Mask */

/* -------------------------  u_ble_dp_top_PROP_MODE_CTRL  ------------------------ */
#define BLEMODEM_PROP_MODE_CTRL_PROP_MODE_CTRL_Pos 0                                              /*!< BLEMODEM PROP_MODE_CTRL: PROP_MODE_CTRL Position */
#define BLEMODEM_PROP_MODE_CTRL_PROP_MODE_CTRL_Msk (0xffffffffUL << BLEMODEM_PROP_MODE_CTRL_PROP_MODE_CTRL_Pos)/*!< BLEMODEM PROP_MODE_CTRL: PROP_MODE_CTRL Mask */

/* -------------------------  u_ble_dp_top_ACCESS_ADDRESS  ------------------------ */
#define BLEMODEM_ACCESS_ADDRESS_AA_ADDR_IN_Pos 0                                                  /*!< BLEMODEM ACCESS_ADDRESS: AA_ADDR_IN Position */
#define BLEMODEM_ACCESS_ADDRESS_AA_ADDR_IN_Msk (0xffffffffUL << BLEMODEM_ACCESS_ADDRESS_AA_ADDR_IN_Pos)/*!< BLEMODEM ACCESS_ADDRESS: AA_ADDR_IN Mask */

/* -------------------------  u_ble_dp_top_ANT_PDU_DATA0  ------------------------- */
#define BLEMODEM_ANT_PDU_DATA0_ANT_PDU_DATA0_Pos 0                                                /*!< BLEMODEM ANT_PDU_DATA0: ANT_PDU_DATA0 Position */
#define BLEMODEM_ANT_PDU_DATA0_ANT_PDU_DATA0_Msk (0xffffffffUL << BLEMODEM_ANT_PDU_DATA0_ANT_PDU_DATA0_Pos)/*!< BLEMODEM ANT_PDU_DATA0: ANT_PDU_DATA0 Mask */

/* -------------------------  u_ble_dp_top_ANT_PDU_DATA1  ------------------------- */
#define BLEMODEM_ANT_PDU_DATA1_ANT_PDU_DATA1_Pos 0                                                /*!< BLEMODEM ANT_PDU_DATA1: ANT_PDU_DATA1 Position */
#define BLEMODEM_ANT_PDU_DATA1_ANT_PDU_DATA1_Msk (0xffffffffUL << BLEMODEM_ANT_PDU_DATA1_ANT_PDU_DATA1_Pos)/*!< BLEMODEM ANT_PDU_DATA1: ANT_PDU_DATA1 Mask */

/* -------------------------  u_ble_dp_top_ANT_PDU_DATA2  ------------------------- */
#define BLEMODEM_ANT_PDU_DATA2_ANT_PDU_DATA2_Pos 0                                                /*!< BLEMODEM ANT_PDU_DATA2: ANT_PDU_DATA2 Position */
#define BLEMODEM_ANT_PDU_DATA2_ANT_PDU_DATA2_Msk (0xffffffffUL << BLEMODEM_ANT_PDU_DATA2_ANT_PDU_DATA2_Pos)/*!< BLEMODEM ANT_PDU_DATA2: ANT_PDU_DATA2 Mask */

/* -------------------------  u_ble_dp_top_ANT_PDU_DATA3  ------------------------- */
#define BLEMODEM_ANT_PDU_DATA3_ANT_PDU_DATA3_Pos 0                                                /*!< BLEMODEM ANT_PDU_DATA3: ANT_PDU_DATA3 Position */
#define BLEMODEM_ANT_PDU_DATA3_ANT_PDU_DATA3_Msk (0xffffffffUL << BLEMODEM_ANT_PDU_DATA3_ANT_PDU_DATA3_Pos)/*!< BLEMODEM ANT_PDU_DATA3: ANT_PDU_DATA3 Mask */

/* -------------------------  u_ble_dp_top_ANT_PDU_DATA4  ------------------------- */
#define BLEMODEM_ANT_PDU_DATA4_ANT_PDU_DATA4_Pos 0                                                /*!< BLEMODEM ANT_PDU_DATA4: ANT_PDU_DATA4 Position */
#define BLEMODEM_ANT_PDU_DATA4_ANT_PDU_DATA4_Msk (0xffffffffUL << BLEMODEM_ANT_PDU_DATA4_ANT_PDU_DATA4_Pos)/*!< BLEMODEM ANT_PDU_DATA4: ANT_PDU_DATA4 Mask */

/* -------------------------  u_ble_dp_top_ANT_PDU_DATA5  ------------------------- */
#define BLEMODEM_ANT_PDU_DATA5_ANT_PDU_DATA5_Pos 0                                                /*!< BLEMODEM ANT_PDU_DATA5: ANT_PDU_DATA5 Position */
#define BLEMODEM_ANT_PDU_DATA5_ANT_PDU_DATA5_Msk (0xffffffffUL << BLEMODEM_ANT_PDU_DATA5_ANT_PDU_DATA5_Pos)/*!< BLEMODEM ANT_PDU_DATA5: ANT_PDU_DATA5 Mask */

/* -------------------------  u_ble_dp_top_ANT_PDU_DATA6  ------------------------- */
#define BLEMODEM_ANT_PDU_DATA6_ANT_PDU_DATA6_Pos 0                                                /*!< BLEMODEM ANT_PDU_DATA6: ANT_PDU_DATA6 Position */
#define BLEMODEM_ANT_PDU_DATA6_ANT_PDU_DATA6_Msk (0xffffffffUL << BLEMODEM_ANT_PDU_DATA6_ANT_PDU_DATA6_Pos)/*!< BLEMODEM ANT_PDU_DATA6: ANT_PDU_DATA6 Mask */

/* -------------------------  u_ble_dp_top_ANT_PDU_DATA7  ------------------------- */
#define BLEMODEM_ANT_PDU_DATA7_ANT_PDU_DATA7_Pos 0                                                /*!< BLEMODEM ANT_PDU_DATA7: ANT_PDU_DATA7 Position */
#define BLEMODEM_ANT_PDU_DATA7_ANT_PDU_DATA7_Msk (0xffffffffUL << BLEMODEM_ANT_PDU_DATA7_ANT_PDU_DATA7_Pos)/*!< BLEMODEM ANT_PDU_DATA7: ANT_PDU_DATA7 Mask */

/* ----------------------------  u_ble_dp_top_CRC_SEED  --------------------------- */
#define BLEMODEM_CRC_SEED_CRC_SEED_IN_Pos 0                                                       /*!< BLEMODEM CRC_SEED: CRC_SEED_IN Position */
#define BLEMODEM_CRC_SEED_CRC_SEED_IN_Msk (0x00ffffffUL << BLEMODEM_CRC_SEED_CRC_SEED_IN_Pos) /*!< BLEMODEM CRC_SEED: CRC_SEED_IN Mask */
#define BLEMODEM_CRC_SEED_CRC_SEED_WEN_Pos 24                                                     /*!< BLEMODEM CRC_SEED: CRC_SEED_WEN Position */
#define BLEMODEM_CRC_SEED_CRC_SEED_WEN_Msk (0x01UL << BLEMODEM_CRC_SEED_CRC_SEED_WEN_Pos)     /*!< BLEMODEM CRC_SEED: CRC_SEED_WEN Mask */

/* ------------------------  u_ble_dp_top_DP_FUNCTION_CTRL  ----------------------- */
#define BLEMODEM_DP_FUNCTION_CTRL_DP_STATISTICS_SEL_Pos 0                                         /*!< BLEMODEM DP_FUNCTION_CTRL: DP_STATISTICS_SEL Position */
#define BLEMODEM_DP_FUNCTION_CTRL_DP_STATISTICS_SEL_Msk (0x07UL << BLEMODEM_DP_FUNCTION_CTRL_DP_STATISTICS_SEL_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: DP_STATISTICS_SEL Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_CHF_COEF_WEN_Pos 3                                              /*!< BLEMODEM DP_FUNCTION_CTRL: CHF_COEF_WEN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_CHF_COEF_WEN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_CHF_COEF_WEN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: CHF_COEF_WEN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_CHF_COEF_IDX_Pos 4                                              /*!< BLEMODEM DP_FUNCTION_CTRL: CHF_COEF_IDX Position */
#define BLEMODEM_DP_FUNCTION_CTRL_CHF_COEF_IDX_Msk (0x03UL << BLEMODEM_DP_FUNCTION_CTRL_CHF_COEF_IDX_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: CHF_COEF_IDX Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_LP_SNR_LEN_AUTO_Pos 6                                           /*!< BLEMODEM DP_FUNCTION_CTRL: LP_SNR_LEN_AUTO Position */
#define BLEMODEM_DP_FUNCTION_CTRL_LP_SNR_LEN_AUTO_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_LP_SNR_LEN_AUTO_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: LP_SNR_LEN_AUTO Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_DOUT_ADJ_DIS_Pos 7                                              /*!< BLEMODEM DP_FUNCTION_CTRL: DOUT_ADJ_DIS Position */
#define BLEMODEM_DP_FUNCTION_CTRL_DOUT_ADJ_DIS_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_DOUT_ADJ_DIS_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: DOUT_ADJ_DIS Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_LP_ADJ_MODE_Pos 8                                               /*!< BLEMODEM DP_FUNCTION_CTRL: LP_ADJ_MODE Position */
#define BLEMODEM_DP_FUNCTION_CTRL_LP_ADJ_MODE_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_LP_ADJ_MODE_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: LP_ADJ_MODE Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_FR_OFFSET_EN_Pos 9                                              /*!< BLEMODEM DP_FUNCTION_CTRL: FR_OFFSET_EN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_FR_OFFSET_EN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_FR_OFFSET_EN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: FR_OFFSET_EN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_DC_AVE_EN_Pos 10                                                /*!< BLEMODEM DP_FUNCTION_CTRL: DC_AVE_EN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_DC_AVE_EN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_DC_AVE_EN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: DC_AVE_EN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_FIX_DELAY_EN_Pos 11                                             /*!< BLEMODEM DP_FUNCTION_CTRL: FIX_DELAY_EN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_FIX_DELAY_EN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_FIX_DELAY_EN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: FIX_DELAY_EN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_TRACK_LEN_Pos 12                                                /*!< BLEMODEM DP_FUNCTION_CTRL: TRACK_LEN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_TRACK_LEN_Msk (0x03UL << BLEMODEM_DP_FUNCTION_CTRL_TRACK_LEN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: TRACK_LEN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_TRACK_LEN_WEN_Pos 14                                            /*!< BLEMODEM DP_FUNCTION_CTRL: TRACK_LEN_WEN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_TRACK_LEN_WEN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_TRACK_LEN_WEN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: TRACK_LEN_WEN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_XCORR_FILT_EN_Pos 16                                            /*!< BLEMODEM DP_FUNCTION_CTRL: XCORR_FILT_EN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_XCORR_FILT_EN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_XCORR_FILT_EN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: XCORR_FILT_EN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_XCORR_FULLWIN_EN_Pos 17                                         /*!< BLEMODEM DP_FUNCTION_CTRL: XCORR_FULLWIN_EN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_XCORR_FULLWIN_EN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_XCORR_FULLWIN_EN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: XCORR_FULLWIN_EN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_XCORR_AA_LEN_Pos 18                                             /*!< BLEMODEM DP_FUNCTION_CTRL: XCORR_AA_LEN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_XCORR_AA_LEN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_XCORR_AA_LEN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: XCORR_AA_LEN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_XCORR_AA_LEN_WEN_Pos 19                                         /*!< BLEMODEM DP_FUNCTION_CTRL: XCORR_AA_LEN_WEN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_XCORR_AA_LEN_WEN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_XCORR_AA_LEN_WEN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: XCORR_AA_LEN_WEN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_XCORR_WIN_AUTO_EN_Pos 20                                        /*!< BLEMODEM DP_FUNCTION_CTRL: XCORR_WIN_AUTO_EN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_XCORR_WIN_AUTO_EN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_XCORR_WIN_AUTO_EN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: XCORR_WIN_AUTO_EN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_RESAMPLER_TAP_Pos 21                                            /*!< BLEMODEM DP_FUNCTION_CTRL: RESAMPLER_TAP Position */
#define BLEMODEM_DP_FUNCTION_CTRL_RESAMPLER_TAP_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_RESAMPLER_TAP_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: RESAMPLER_TAP Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_RESAMPLER_TAP_WEN_Pos 22                                        /*!< BLEMODEM DP_FUNCTION_CTRL: RESAMPLER_TAP_WEN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_RESAMPLER_TAP_WEN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_RESAMPLER_TAP_WEN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: RESAMPLER_TAP_WEN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_RESAMPLER_BP_Pos 23                                             /*!< BLEMODEM DP_FUNCTION_CTRL: RESAMPLER_BP Position */
#define BLEMODEM_DP_FUNCTION_CTRL_RESAMPLER_BP_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_RESAMPLER_BP_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: RESAMPLER_BP Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_FAGC_WIN_LEN_Pos 24                                             /*!< BLEMODEM DP_FUNCTION_CTRL: FAGC_WIN_LEN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_FAGC_WIN_LEN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_FAGC_WIN_LEN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: FAGC_WIN_LEN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_FAGC_WEN_Pos 25                                                 /*!< BLEMODEM DP_FUNCTION_CTRL: FAGC_WEN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_FAGC_WEN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_FAGC_WEN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: FAGC_WEN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_HP_CFO_EN_Pos 26                                                /*!< BLEMODEM DP_FUNCTION_CTRL: HP_CFO_EN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_HP_CFO_EN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_HP_CFO_EN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: HP_CFO_EN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_CFO_TRACK_EN_Pos 27                                             /*!< BLEMODEM DP_FUNCTION_CTRL: CFO_TRACK_EN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_CFO_TRACK_EN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_CFO_TRACK_EN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: CFO_TRACK_EN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_CFO_INI_EN_Pos 28                                               /*!< BLEMODEM DP_FUNCTION_CTRL: CFO_INI_EN Position */
#define BLEMODEM_DP_FUNCTION_CTRL_CFO_INI_EN_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_CFO_INI_EN_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: CFO_INI_EN Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_ADC_IN_FLIP_Pos 29                                              /*!< BLEMODEM DP_FUNCTION_CTRL: ADC_IN_FLIP Position */
#define BLEMODEM_DP_FUNCTION_CTRL_ADC_IN_FLIP_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_ADC_IN_FLIP_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: ADC_IN_FLIP Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_TX_EN_MODE_Pos 30                                               /*!< BLEMODEM DP_FUNCTION_CTRL: TX_EN_MODE Position */
#define BLEMODEM_DP_FUNCTION_CTRL_TX_EN_MODE_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_TX_EN_MODE_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: TX_EN_MODE Mask */
#define BLEMODEM_DP_FUNCTION_CTRL_RX_EN_MODE_Pos 31                                               /*!< BLEMODEM DP_FUNCTION_CTRL: RX_EN_MODE Position */
#define BLEMODEM_DP_FUNCTION_CTRL_RX_EN_MODE_Msk (0x01UL << BLEMODEM_DP_FUNCTION_CTRL_RX_EN_MODE_Pos)/*!< BLEMODEM DP_FUNCTION_CTRL: RX_EN_MODE Mask */

/* --------------------------  u_ble_dp_top_DP_TEST_CTRL  ------------------------- */
#define BLEMODEM_DP_TEST_CTRL_DP_TEST_CTRL_Pos 0                                                  /*!< BLEMODEM DP_TEST_CTRL: DP_TEST_CTRL Position */
#define BLEMODEM_DP_TEST_CTRL_DP_TEST_CTRL_Msk (0xffffffffUL << BLEMODEM_DP_TEST_CTRL_DP_TEST_CTRL_Pos)/*!< BLEMODEM DP_TEST_CTRL: DP_TEST_CTRL Mask */

/* -------------------------  u_ble_dp_top_BLE_DP_STATUS1  ------------------------ */
#define BLEMODEM_BLE_DP_STATUS1_SNR_EST_Pos 0                                                     /*!< BLEMODEM BLE_DP_STATUS1: SNR_EST Position */
#define BLEMODEM_BLE_DP_STATUS1_SNR_EST_Msk (0x000000ffUL << BLEMODEM_BLE_DP_STATUS1_SNR_EST_Pos)/*!< BLEMODEM BLE_DP_STATUS1: SNR_EST Mask */
#define BLEMODEM_BLE_DP_STATUS1_CNR_EST_Pos 8                                                     /*!< BLEMODEM BLE_DP_STATUS1: CNR_EST Position */
#define BLEMODEM_BLE_DP_STATUS1_CNR_EST_Msk (0x3fUL << BLEMODEM_BLE_DP_STATUS1_CNR_EST_Pos)   /*!< BLEMODEM BLE_DP_STATUS1: CNR_EST Mask */
#define BLEMODEM_BLE_DP_STATUS1_AGC_RSSI_Pos 16                                                   /*!< BLEMODEM BLE_DP_STATUS1: AGC_RSSI Position */
#define BLEMODEM_BLE_DP_STATUS1_AGC_RSSI_Msk (0x000000ffUL << BLEMODEM_BLE_DP_STATUS1_AGC_RSSI_Pos)/*!< BLEMODEM BLE_DP_STATUS1: AGC_RSSI Mask */
#define BLEMODEM_BLE_DP_STATUS1_AGC_RSSI_READY_Pos 24                                             /*!< BLEMODEM BLE_DP_STATUS1: AGC_RSSI_READY Position */
#define BLEMODEM_BLE_DP_STATUS1_AGC_RSSI_READY_Msk (0x01UL << BLEMODEM_BLE_DP_STATUS1_AGC_RSSI_READY_Pos)/*!< BLEMODEM BLE_DP_STATUS1: AGC_RSSI_READY Mask */
#define BLEMODEM_BLE_DP_STATUS1_SNR_VLD_Pos 25                                                    /*!< BLEMODEM BLE_DP_STATUS1: SNR_VLD Position */
#define BLEMODEM_BLE_DP_STATUS1_SNR_VLD_Msk (0x01UL << BLEMODEM_BLE_DP_STATUS1_SNR_VLD_Pos)   /*!< BLEMODEM BLE_DP_STATUS1: SNR_VLD Mask */
#define BLEMODEM_BLE_DP_STATUS1_CNR_VLD_Pos 26                                                    /*!< BLEMODEM BLE_DP_STATUS1: CNR_VLD Position */
#define BLEMODEM_BLE_DP_STATUS1_CNR_VLD_Msk (0x01UL << BLEMODEM_BLE_DP_STATUS1_CNR_VLD_Pos)   /*!< BLEMODEM BLE_DP_STATUS1: CNR_VLD Mask */
#define BLEMODEM_BLE_DP_STATUS1_TX_BUSY_Pos 27                                                    /*!< BLEMODEM BLE_DP_STATUS1: TX_BUSY Position */
#define BLEMODEM_BLE_DP_STATUS1_TX_BUSY_Msk (0x01UL << BLEMODEM_BLE_DP_STATUS1_TX_BUSY_Pos)   /*!< BLEMODEM BLE_DP_STATUS1: TX_BUSY Mask */

/* -------------------------  u_ble_dp_top_BLE_DP_STATUS2  ------------------------ */
#define BLEMODEM_BLE_DP_STATUS2_VALID_PCK_NUM_Pos 0                                               /*!< BLEMODEM BLE_DP_STATUS2: VALID_PCK_NUM Position */
#define BLEMODEM_BLE_DP_STATUS2_VALID_PCK_NUM_Msk (0x0000ffffUL << BLEMODEM_BLE_DP_STATUS2_VALID_PCK_NUM_Pos)/*!< BLEMODEM BLE_DP_STATUS2: VALID_PCK_NUM Mask */
#define BLEMODEM_BLE_DP_STATUS2_AA_ERR_NUM_Pos 16                                                 /*!< BLEMODEM BLE_DP_STATUS2: AA_ERR_NUM Position */
#define BLEMODEM_BLE_DP_STATUS2_AA_ERR_NUM_Msk (0x3fUL << BLEMODEM_BLE_DP_STATUS2_AA_ERR_NUM_Pos)/*!< BLEMODEM BLE_DP_STATUS2: AA_ERR_NUM Mask */
#define BLEMODEM_BLE_DP_STATUS2_CRC_ERROR_Pos 29                                                  /*!< BLEMODEM BLE_DP_STATUS2: CRC_ERROR Position */
#define BLEMODEM_BLE_DP_STATUS2_CRC_ERROR_Msk (0x01UL << BLEMODEM_BLE_DP_STATUS2_CRC_ERROR_Pos)/*!< BLEMODEM BLE_DP_STATUS2: CRC_ERROR Mask */
#define BLEMODEM_BLE_DP_STATUS2_BURST_DET_Pos 30                                                  /*!< BLEMODEM BLE_DP_STATUS2: BURST_DET Position */
#define BLEMODEM_BLE_DP_STATUS2_BURST_DET_Msk (0x01UL << BLEMODEM_BLE_DP_STATUS2_BURST_DET_Pos)/*!< BLEMODEM BLE_DP_STATUS2: BURST_DET Mask */
#define BLEMODEM_BLE_DP_STATUS2_DP_STATUS_VLD_0_Pos 31                                            /*!< BLEMODEM BLE_DP_STATUS2: DP_STATUS_VLD_0 Position */
#define BLEMODEM_BLE_DP_STATUS2_DP_STATUS_VLD_0_Msk (0x01UL << BLEMODEM_BLE_DP_STATUS2_DP_STATUS_VLD_0_Pos)/*!< BLEMODEM BLE_DP_STATUS2: DP_STATUS_VLD_0 Mask */

/* -------------------------  u_ble_dp_top_BLE_DP_STATUS3  ------------------------ */
#define BLEMODEM_BLE_DP_STATUS3_FD_CFO_TRACK_Pos 0                                                /*!< BLEMODEM BLE_DP_STATUS3: FD_CFO_TRACK Position */
#define BLEMODEM_BLE_DP_STATUS3_FD_CFO_TRACK_Msk (0x000007ffUL << BLEMODEM_BLE_DP_STATUS3_FD_CFO_TRACK_Pos)/*!< BLEMODEM BLE_DP_STATUS3: FD_CFO_TRACK Mask */
#define BLEMODEM_BLE_DP_STATUS3_CFO_EST_FD_Pos 16                                                 /*!< BLEMODEM BLE_DP_STATUS3: CFO_EST_FD Position */
#define BLEMODEM_BLE_DP_STATUS3_CFO_EST_FD_Msk (0x000007ffUL << BLEMODEM_BLE_DP_STATUS3_CFO_EST_FD_Pos)/*!< BLEMODEM BLE_DP_STATUS3: CFO_EST_FD Mask */

/* -------------------------  u_ble_dp_top_BLE_DP_STATUS4  ------------------------ */
#define BLEMODEM_BLE_DP_STATUS4_RESAMPLER_PH_Pos 0                                                /*!< BLEMODEM BLE_DP_STATUS4: RESAMPLER_PH Position */
#define BLEMODEM_BLE_DP_STATUS4_RESAMPLER_PH_Msk (0x000003ffUL << BLEMODEM_BLE_DP_STATUS4_RESAMPLER_PH_Pos)/*!< BLEMODEM BLE_DP_STATUS4: RESAMPLER_PH Mask */
#define BLEMODEM_BLE_DP_STATUS4_HP_CFO_Pos 16                                                     /*!< BLEMODEM BLE_DP_STATUS4: HP_CFO Position */
#define BLEMODEM_BLE_DP_STATUS4_HP_CFO_Msk (0x00000fffUL << BLEMODEM_BLE_DP_STATUS4_HP_CFO_Pos)/*!< BLEMODEM BLE_DP_STATUS4: HP_CFO Mask */
#define BLEMODEM_BLE_DP_STATUS4_HP_CFO_VLD_Pos 31                                                 /*!< BLEMODEM BLE_DP_STATUS4: HP_CFO_VLD Position */
#define BLEMODEM_BLE_DP_STATUS4_HP_CFO_VLD_Msk (0x01UL << BLEMODEM_BLE_DP_STATUS4_HP_CFO_VLD_Pos)/*!< BLEMODEM BLE_DP_STATUS4: HP_CFO_VLD Mask */

/* -----------------------  u_ble_dp_top_RX_FRONT_END_CTRL1  ---------------------- */
#define BLEMODEM_RX_FRONT_END_CTRL1_CFO_COMP_Pos 0                                                /*!< BLEMODEM RX_FRONT_END_CTRL1: CFO_COMP Position */
#define BLEMODEM_RX_FRONT_END_CTRL1_CFO_COMP_Msk (0x00007fffUL << BLEMODEM_RX_FRONT_END_CTRL1_CFO_COMP_Pos)/*!< BLEMODEM RX_FRONT_END_CTRL1: CFO_COMP Mask */
#define BLEMODEM_RX_FRONT_END_CTRL1_DCNOTCH_GIN_Pos 16                                            /*!< BLEMODEM RX_FRONT_END_CTRL1: DCNOTCH_GIN Position */
#define BLEMODEM_RX_FRONT_END_CTRL1_DCNOTCH_GIN_Msk (0x03UL << BLEMODEM_RX_FRONT_END_CTRL1_DCNOTCH_GIN_Pos)/*!< BLEMODEM RX_FRONT_END_CTRL1: DCNOTCH_GIN Mask */

/* -----------------------  u_ble_dp_top_RX_FRONT_END_CTRL2  ---------------------- */
#define BLEMODEM_RX_FRONT_END_CTRL2_FAGC_GAIN_Pos 0                                               /*!< BLEMODEM RX_FRONT_END_CTRL2: FAGC_GAIN Position */
#define BLEMODEM_RX_FRONT_END_CTRL2_FAGC_GAIN_Msk (0x000007ffUL << BLEMODEM_RX_FRONT_END_CTRL2_FAGC_GAIN_Pos)/*!< BLEMODEM RX_FRONT_END_CTRL2: FAGC_GAIN Mask */
#define BLEMODEM_RX_FRONT_END_CTRL2_FAGC_INI_VAL_Pos 11                                           /*!< BLEMODEM RX_FRONT_END_CTRL2: FAGC_INI_VAL Position */
#define BLEMODEM_RX_FRONT_END_CTRL2_FAGC_INI_VAL_Msk (0x01UL << BLEMODEM_RX_FRONT_END_CTRL2_FAGC_INI_VAL_Pos)/*!< BLEMODEM RX_FRONT_END_CTRL2: FAGC_INI_VAL Mask */
#define BLEMODEM_RX_FRONT_END_CTRL2_CNR_IDX_DELTA_Pos 12                                          /*!< BLEMODEM RX_FRONT_END_CTRL2: CNR_IDX_DELTA Position */
#define BLEMODEM_RX_FRONT_END_CTRL2_CNR_IDX_DELTA_Msk (0x0fUL << BLEMODEM_RX_FRONT_END_CTRL2_CNR_IDX_DELTA_Pos)/*!< BLEMODEM RX_FRONT_END_CTRL2: CNR_IDX_DELTA Mask */
#define BLEMODEM_RX_FRONT_END_CTRL2_FAGC_REF_Pos 16                                               /*!< BLEMODEM RX_FRONT_END_CTRL2: FAGC_REF Position */
#define BLEMODEM_RX_FRONT_END_CTRL2_FAGC_REF_Msk (0x000000ffUL << BLEMODEM_RX_FRONT_END_CTRL2_FAGC_REF_Pos)/*!< BLEMODEM RX_FRONT_END_CTRL2: FAGC_REF Mask */
#define BLEMODEM_RX_FRONT_END_CTRL2_CORDIC_MIN_VIN_TH_Pos 24                                      /*!< BLEMODEM RX_FRONT_END_CTRL2: CORDIC_MIN_VIN_TH Position */
#define BLEMODEM_RX_FRONT_END_CTRL2_CORDIC_MIN_VIN_TH_Msk (0x0fUL << BLEMODEM_RX_FRONT_END_CTRL2_CORDIC_MIN_VIN_TH_Pos)/*!< BLEMODEM RX_FRONT_END_CTRL2: CORDIC_MIN_VIN_TH Mask */
#define BLEMODEM_RX_FRONT_END_CTRL2_FREQ_TRADE_EN_Pos 28                                          /*!< BLEMODEM RX_FRONT_END_CTRL2: FREQ_TRADE_EN Position */
#define BLEMODEM_RX_FRONT_END_CTRL2_FREQ_TRADE_EN_Msk (0x01UL << BLEMODEM_RX_FRONT_END_CTRL2_FREQ_TRADE_EN_Pos)/*!< BLEMODEM RX_FRONT_END_CTRL2: FREQ_TRADE_EN Mask */
#define BLEMODEM_RX_FRONT_END_CTRL2_CHN_SHIFT_Pos 29                                              /*!< BLEMODEM RX_FRONT_END_CTRL2: CHN_SHIFT Position */
#define BLEMODEM_RX_FRONT_END_CTRL2_CHN_SHIFT_Msk (0x07UL << BLEMODEM_RX_FRONT_END_CTRL2_CHN_SHIFT_Pos)/*!< BLEMODEM RX_FRONT_END_CTRL2: CHN_SHIFT Mask */

/* -----------------------  u_ble_dp_top_FREQ_DOMAIN_CTRL1  ----------------------- */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_SYNC_WORD_IN0_Pos 0                                            /*!< BLEMODEM FREQ_DOMAIN_CTRL1: SYNC_WORD_IN0 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_SYNC_WORD_IN0_Msk (0x000000ffUL << BLEMODEM_FREQ_DOMAIN_CTRL1_SYNC_WORD_IN0_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL1: SYNC_WORD_IN0 Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_SYNC_WORD_WEN_Pos 8                                            /*!< BLEMODEM FREQ_DOMAIN_CTRL1: SYNC_WORD_WEN Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_SYNC_WORD_WEN_Msk (0x01UL << BLEMODEM_FREQ_DOMAIN_CTRL1_SYNC_WORD_WEN_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL1: SYNC_WORD_WEN Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_SYNC_P_SEL_Pos 15                                              /*!< BLEMODEM FREQ_DOMAIN_CTRL1: SYNC_P_SEL Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_SYNC_P_SEL_Msk (0x01UL << BLEMODEM_FREQ_DOMAIN_CTRL1_SYNC_P_SEL_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL1: SYNC_P_SEL Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_RD_EXBIT_EN_Pos 16                                             /*!< BLEMODEM FREQ_DOMAIN_CTRL1: RD_EXBIT_EN Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_RD_EXBIT_EN_Msk (0x01UL << BLEMODEM_FREQ_DOMAIN_CTRL1_RD_EXBIT_EN_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL1: RD_EXBIT_EN Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_RFAGC_TRACK_DLY_Pos 17                                         /*!< BLEMODEM FREQ_DOMAIN_CTRL1: RFAGC_TRACK_DLY Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_RFAGC_TRACK_DLY_Msk (0x07UL << BLEMODEM_FREQ_DOMAIN_CTRL1_RFAGC_TRACK_DLY_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL1: RFAGC_TRACK_DLY Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_PROP_DF_16US_Pos 24                                            /*!< BLEMODEM FREQ_DOMAIN_CTRL1: PROP_DF_16US Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL1_PROP_DF_16US_Msk (0x000000ffUL << BLEMODEM_FREQ_DOMAIN_CTRL1_PROP_DF_16US_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL1: PROP_DF_16US Mask */

/* -----------------------  u_ble_dp_top_FREQ_DOMAIN_CTRL2  ----------------------- */
#define BLEMODEM_FREQ_DOMAIN_CTRL2_SYNC_WORD_IN1_Pos 0                                            /*!< BLEMODEM FREQ_DOMAIN_CTRL2: SYNC_WORD_IN1 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL2_SYNC_WORD_IN1_Msk (0xffffffffUL << BLEMODEM_FREQ_DOMAIN_CTRL2_SYNC_WORD_IN1_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL2: SYNC_WORD_IN1 Mask */

/* -----------------------  u_ble_dp_top_FREQ_DOMAIN_CTRL3  ----------------------- */
#define BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH3_Pos 0                                            /*!< BLEMODEM FREQ_DOMAIN_CTRL3: XCORR_PAR_TH3 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH3_Msk (0x3fUL << BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH3_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL3: XCORR_PAR_TH3 Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH2_Pos 8                                            /*!< BLEMODEM FREQ_DOMAIN_CTRL3: XCORR_PAR_TH2 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH2_Msk (0x3fUL << BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH2_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL3: XCORR_PAR_TH2 Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH1_Pos 16                                           /*!< BLEMODEM FREQ_DOMAIN_CTRL3: XCORR_PAR_TH1 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH1_Msk (0x3fUL << BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH1_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL3: XCORR_PAR_TH1 Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH0_Pos 24                                           /*!< BLEMODEM FREQ_DOMAIN_CTRL3: XCORR_PAR_TH0 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH0_Msk (0x3fUL << BLEMODEM_FREQ_DOMAIN_CTRL3_XCORR_PAR_TH0_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL3: XCORR_PAR_TH0 Mask */

/* -----------------------  u_ble_dp_top_FREQ_DOMAIN_CTRL4  ----------------------- */
#define BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH3_Pos 0                                            /*!< BLEMODEM FREQ_DOMAIN_CTRL4: XCORR_POW_TH3 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH3_Msk (0x3fUL << BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH3_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL4: XCORR_POW_TH3 Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH2_Pos 8                                            /*!< BLEMODEM FREQ_DOMAIN_CTRL4: XCORR_POW_TH2 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH2_Msk (0x3fUL << BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH2_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL4: XCORR_POW_TH2 Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH1_Pos 16                                           /*!< BLEMODEM FREQ_DOMAIN_CTRL4: XCORR_POW_TH1 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH1_Msk (0x3fUL << BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH1_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL4: XCORR_POW_TH1 Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH0_Pos 24                                           /*!< BLEMODEM FREQ_DOMAIN_CTRL4: XCORR_POW_TH0 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH0_Msk (0x3fUL << BLEMODEM_FREQ_DOMAIN_CTRL4_XCORR_POW_TH0_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL4: XCORR_POW_TH0 Mask */

/* -----------------------  u_ble_dp_top_FREQ_DOMAIN_CTRL5  ----------------------- */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_GAIN_TED_Pos 0                                                 /*!< BLEMODEM FREQ_DOMAIN_CTRL5: GAIN_TED Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_GAIN_TED_Msk (0x03UL << BLEMODEM_FREQ_DOMAIN_CTRL5_GAIN_TED_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL5: GAIN_TED Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_VALUE_Pos 4                                       /*!< BLEMODEM FREQ_DOMAIN_CTRL5: SYNC_DIN_SAT_VALUE Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_VALUE_Msk (0x07UL << BLEMODEM_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_VALUE_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL5: SYNC_DIN_SAT_VALUE Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_EN_Pos 7                                          /*!< BLEMODEM FREQ_DOMAIN_CTRL5: SYNC_DIN_SAT_EN Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_EN_Msk (0x01UL << BLEMODEM_FREQ_DOMAIN_CTRL5_SYNC_DIN_SAT_EN_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL5: SYNC_DIN_SAT_EN Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_CNT_SETTLE_IDX_Pos 8                                           /*!< BLEMODEM FREQ_DOMAIN_CTRL5: CNT_SETTLE_IDX Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_CNT_SETTLE_IDX_Msk (0x07UL << BLEMODEM_FREQ_DOMAIN_CTRL5_CNT_SETTLE_IDX_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL5: CNT_SETTLE_IDX Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_TRIG_XCORR_CNT_Pos 12                                          /*!< BLEMODEM FREQ_DOMAIN_CTRL5: TRIG_XCORR_CNT Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_TRIG_XCORR_CNT_Msk (0x0fUL << BLEMODEM_FREQ_DOMAIN_CTRL5_TRIG_XCORR_CNT_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL5: TRIG_XCORR_CNT Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH3_Pos 16                                          /*!< BLEMODEM FREQ_DOMAIN_CTRL5: XCORR_RSSI_TH3 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH3_Msk (0x0fUL << BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH3_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL5: XCORR_RSSI_TH3 Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH2_Pos 20                                          /*!< BLEMODEM FREQ_DOMAIN_CTRL5: XCORR_RSSI_TH2 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH2_Msk (0x0fUL << BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH2_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL5: XCORR_RSSI_TH2 Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH1_Pos 24                                          /*!< BLEMODEM FREQ_DOMAIN_CTRL5: XCORR_RSSI_TH1 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH1_Msk (0x0fUL << BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH1_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL5: XCORR_RSSI_TH1 Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH0_Pos 28                                          /*!< BLEMODEM FREQ_DOMAIN_CTRL5: XCORR_RSSI_TH0 Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH0_Msk (0x0fUL << BLEMODEM_FREQ_DOMAIN_CTRL5_XCORR_RSSI_TH0_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL5: XCORR_RSSI_TH0 Mask */

/* -----------------------  u_ble_dp_top_FREQ_DOMAIN_CTRL6  ----------------------- */
#define BLEMODEM_FREQ_DOMAIN_CTRL6_HP_TRAIN_SIZ_Pos 0                                             /*!< BLEMODEM FREQ_DOMAIN_CTRL6: HP_TRAIN_SIZ Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL6_HP_TRAIN_SIZ_Msk (0x1fUL << BLEMODEM_FREQ_DOMAIN_CTRL6_HP_TRAIN_SIZ_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL6: HP_TRAIN_SIZ Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL6_HP_HIDX_GAIN_Pos 8                                             /*!< BLEMODEM FREQ_DOMAIN_CTRL6: HP_HIDX_GAIN Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL6_HP_HIDX_GAIN_Msk (0x000000ffUL << BLEMODEM_FREQ_DOMAIN_CTRL6_HP_HIDX_GAIN_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL6: HP_HIDX_GAIN Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL6_H_REF_GAIN_Pos 16                                              /*!< BLEMODEM FREQ_DOMAIN_CTRL6: H_REF_GAIN Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL6_H_REF_GAIN_Msk (0x3fUL << BLEMODEM_FREQ_DOMAIN_CTRL6_H_REF_GAIN_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL6: H_REF_GAIN Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL6_DET_FR_IDX_Pos 24                                              /*!< BLEMODEM FREQ_DOMAIN_CTRL6: DET_FR_IDX Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL6_DET_FR_IDX_Msk (0x03UL << BLEMODEM_FREQ_DOMAIN_CTRL6_DET_FR_IDX_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL6: DET_FR_IDX Mask */
#define BLEMODEM_FREQ_DOMAIN_CTRL6_CFO_FR_IDX_Pos 28                                              /*!< BLEMODEM FREQ_DOMAIN_CTRL6: CFO_FR_IDX Position */
#define BLEMODEM_FREQ_DOMAIN_CTRL6_CFO_FR_IDX_Msk (0x03UL << BLEMODEM_FREQ_DOMAIN_CTRL6_CFO_FR_IDX_Pos)/*!< BLEMODEM FREQ_DOMAIN_CTRL6: CFO_FR_IDX Mask */

/* -------------------------  u_ble_dp_top_HP_MODE_CTRL1  ------------------------- */
#define BLEMODEM_HP_MODE_CTRL1_HP_BMC_P_TRACK_Pos 0                                               /*!< BLEMODEM HP_MODE_CTRL1: HP_BMC_P_TRACK Position */
#define BLEMODEM_HP_MODE_CTRL1_HP_BMC_P_TRACK_Msk (0x3fUL << BLEMODEM_HP_MODE_CTRL1_HP_BMC_P_TRACK_Pos)/*!< BLEMODEM HP_MODE_CTRL1: HP_BMC_P_TRACK Mask */
#define BLEMODEM_HP_MODE_CTRL1_HP_BMC_P_TRAIN_Pos 8                                               /*!< BLEMODEM HP_MODE_CTRL1: HP_BMC_P_TRAIN Position */
#define BLEMODEM_HP_MODE_CTRL1_HP_BMC_P_TRAIN_Msk (0x3fUL << BLEMODEM_HP_MODE_CTRL1_HP_BMC_P_TRAIN_Pos)/*!< BLEMODEM HP_MODE_CTRL1: HP_BMC_P_TRAIN Mask */
#define BLEMODEM_HP_MODE_CTRL1_HP_BMC_CZ1_Pos 16                                                  /*!< BLEMODEM HP_MODE_CTRL1: HP_BMC_CZ1 Position */
#define BLEMODEM_HP_MODE_CTRL1_HP_BMC_CZ1_Msk (0x3fUL << BLEMODEM_HP_MODE_CTRL1_HP_BMC_CZ1_Pos)/*!< BLEMODEM HP_MODE_CTRL1: HP_BMC_CZ1 Mask */
#define BLEMODEM_HP_MODE_CTRL1_BUF_IDX_DELTA_Pos 24                                               /*!< BLEMODEM HP_MODE_CTRL1: BUF_IDX_DELTA Position */
#define BLEMODEM_HP_MODE_CTRL1_BUF_IDX_DELTA_Msk (0x0fUL << BLEMODEM_HP_MODE_CTRL1_BUF_IDX_DELTA_Pos)/*!< BLEMODEM HP_MODE_CTRL1: BUF_IDX_DELTA Mask */
#define BLEMODEM_HP_MODE_CTRL1_WMF2_DSAMP_IDX_Pos 28                                              /*!< BLEMODEM HP_MODE_CTRL1: WMF2_DSAMP_IDX Position */
#define BLEMODEM_HP_MODE_CTRL1_WMF2_DSAMP_IDX_Msk (0x07UL << BLEMODEM_HP_MODE_CTRL1_WMF2_DSAMP_IDX_Pos)/*!< BLEMODEM HP_MODE_CTRL1: WMF2_DSAMP_IDX Mask */
#define BLEMODEM_HP_MODE_CTRL1_HP_TRAIN_SIZ_FIX_Pos 31                                            /*!< BLEMODEM HP_MODE_CTRL1: HP_TRAIN_SIZ_FIX Position */
#define BLEMODEM_HP_MODE_CTRL1_HP_TRAIN_SIZ_FIX_Msk (0x01UL << BLEMODEM_HP_MODE_CTRL1_HP_TRAIN_SIZ_FIX_Pos)/*!< BLEMODEM HP_MODE_CTRL1: HP_TRAIN_SIZ_FIX Mask */

/* -------------------------  u_ble_dp_top_HP_MODE_CTRL2  ------------------------- */
#define BLEMODEM_HP_MODE_CTRL2_SNR_EST_REF_Pos 0                                                  /*!< BLEMODEM HP_MODE_CTRL2: SNR_EST_REF Position */
#define BLEMODEM_HP_MODE_CTRL2_SNR_EST_REF_Msk (0x000000ffUL << BLEMODEM_HP_MODE_CTRL2_SNR_EST_REF_Pos)/*!< BLEMODEM HP_MODE_CTRL2: SNR_EST_REF Mask */
#define BLEMODEM_HP_MODE_CTRL2_SNR_EST_LEN_Pos 8                                                  /*!< BLEMODEM HP_MODE_CTRL2: SNR_EST_LEN Position */
#define BLEMODEM_HP_MODE_CTRL2_SNR_EST_LEN_Msk (0x03UL << BLEMODEM_HP_MODE_CTRL2_SNR_EST_LEN_Pos)/*!< BLEMODEM HP_MODE_CTRL2: SNR_EST_LEN Mask */
#define BLEMODEM_HP_MODE_CTRL2_SNR_EST_EN_Pos 12                                                  /*!< BLEMODEM HP_MODE_CTRL2: SNR_EST_EN Position */
#define BLEMODEM_HP_MODE_CTRL2_SNR_EST_EN_Msk (0x01UL << BLEMODEM_HP_MODE_CTRL2_SNR_EST_EN_Pos)/*!< BLEMODEM HP_MODE_CTRL2: SNR_EST_EN Mask */
#define BLEMODEM_HP_MODE_CTRL2_HP_BMC_Q_TRACK_Pos 16                                              /*!< BLEMODEM HP_MODE_CTRL2: HP_BMC_Q_TRACK Position */
#define BLEMODEM_HP_MODE_CTRL2_HP_BMC_Q_TRACK_Msk (0x000000ffUL << BLEMODEM_HP_MODE_CTRL2_HP_BMC_Q_TRACK_Pos)/*!< BLEMODEM HP_MODE_CTRL2: HP_BMC_Q_TRACK Mask */
#define BLEMODEM_HP_MODE_CTRL2_HP_BMC_Q_TRAIN_Pos 24                                              /*!< BLEMODEM HP_MODE_CTRL2: HP_BMC_Q_TRAIN Position */
#define BLEMODEM_HP_MODE_CTRL2_HP_BMC_Q_TRAIN_Msk (0x000000ffUL << BLEMODEM_HP_MODE_CTRL2_HP_BMC_Q_TRAIN_Pos)/*!< BLEMODEM HP_MODE_CTRL2: HP_BMC_Q_TRAIN Mask */

/* ----------------------  u_ble_dp_top_FREQ_DOMAIN_STATUS1  ---------------------- */
#define BLEMODEM_FREQ_DOMAIN_STATUS1_MAX_XCORR_Pos 0                                              /*!< BLEMODEM FREQ_DOMAIN_STATUS1: MAX_XCORR Position */
#define BLEMODEM_FREQ_DOMAIN_STATUS1_MAX_XCORR_Msk (0x000003ffUL << BLEMODEM_FREQ_DOMAIN_STATUS1_MAX_XCORR_Pos)/*!< BLEMODEM FREQ_DOMAIN_STATUS1: MAX_XCORR Mask */
#define BLEMODEM_FREQ_DOMAIN_STATUS1_PKT_OFFSET_COM_Pos 16                                        /*!< BLEMODEM FREQ_DOMAIN_STATUS1: PKT_OFFSET_COM Position */
#define BLEMODEM_FREQ_DOMAIN_STATUS1_PKT_OFFSET_COM_Msk (0x000001ffUL << BLEMODEM_FREQ_DOMAIN_STATUS1_PKT_OFFSET_COM_Pos)/*!< BLEMODEM FREQ_DOMAIN_STATUS1: PKT_OFFSET_COM Mask */
#define BLEMODEM_FREQ_DOMAIN_STATUS1_NIDX_Pos 28                                                  /*!< BLEMODEM FREQ_DOMAIN_STATUS1: NIDX Position */
#define BLEMODEM_FREQ_DOMAIN_STATUS1_NIDX_Msk (0x0fUL << BLEMODEM_FREQ_DOMAIN_STATUS1_NIDX_Pos)/*!< BLEMODEM FREQ_DOMAIN_STATUS1: NIDX Mask */

/* ----------------------  u_ble_dp_top_FREQ_DOMAIN_STATUS2  ---------------------- */
#define BLEMODEM_FREQ_DOMAIN_STATUS2_MAX_PAR_SPWR_Pos 0                                           /*!< BLEMODEM FREQ_DOMAIN_STATUS2: MAX_PAR_SPWR Position */
#define BLEMODEM_FREQ_DOMAIN_STATUS2_MAX_PAR_SPWR_Msk (0x000003ffUL << BLEMODEM_FREQ_DOMAIN_STATUS2_MAX_PAR_SPWR_Pos)/*!< BLEMODEM FREQ_DOMAIN_STATUS2: MAX_PAR_SPWR Mask */
#define BLEMODEM_FREQ_DOMAIN_STATUS2_MAX_PAR_XCORR_Pos 16                                         /*!< BLEMODEM FREQ_DOMAIN_STATUS2: MAX_PAR_XCORR Position */
#define BLEMODEM_FREQ_DOMAIN_STATUS2_MAX_PAR_XCORR_Msk (0x000003ffUL << BLEMODEM_FREQ_DOMAIN_STATUS2_MAX_PAR_XCORR_Pos)/*!< BLEMODEM FREQ_DOMAIN_STATUS2: MAX_PAR_XCORR Mask */

/* ------------------------  u_ble_dp_top_DP_AA_ERROR_CTRL  ----------------------- */
#define BLEMODEM_DP_AA_ERROR_CTRL_IQSWAP_SEL_Pos 0                                                /*!< BLEMODEM DP_AA_ERROR_CTRL: IQSWAP_SEL Position */
#define BLEMODEM_DP_AA_ERROR_CTRL_IQSWAP_SEL_Msk (0x01UL << BLEMODEM_DP_AA_ERROR_CTRL_IQSWAP_SEL_Pos)/*!< BLEMODEM DP_AA_ERROR_CTRL: IQSWAP_SEL Mask */
#define BLEMODEM_DP_AA_ERROR_CTRL_AA_ERROR_EN_Pos 1                                               /*!< BLEMODEM DP_AA_ERROR_CTRL: AA_ERROR_EN Position */
#define BLEMODEM_DP_AA_ERROR_CTRL_AA_ERROR_EN_Msk (0x01UL << BLEMODEM_DP_AA_ERROR_CTRL_AA_ERROR_EN_Pos)/*!< BLEMODEM DP_AA_ERROR_CTRL: AA_ERROR_EN Mask */
#define BLEMODEM_DP_AA_ERROR_CTRL_AA_ERROR_CNR_EN_Pos 2                                           /*!< BLEMODEM DP_AA_ERROR_CTRL: AA_ERROR_CNR_EN Position */
#define BLEMODEM_DP_AA_ERROR_CTRL_AA_ERROR_CNR_EN_Msk (0x01UL << BLEMODEM_DP_AA_ERROR_CTRL_AA_ERROR_CNR_EN_Pos)/*!< BLEMODEM DP_AA_ERROR_CTRL: AA_ERROR_CNR_EN Mask */
#define BLEMODEM_DP_AA_ERROR_CTRL_AA_ERROR_CNR_SEL_Pos 3                                          /*!< BLEMODEM DP_AA_ERROR_CTRL: AA_ERROR_CNR_SEL Position */
#define BLEMODEM_DP_AA_ERROR_CTRL_AA_ERROR_CNR_SEL_Msk (0x01UL << BLEMODEM_DP_AA_ERROR_CTRL_AA_ERROR_CNR_SEL_Pos)/*!< BLEMODEM DP_AA_ERROR_CTRL: AA_ERROR_CNR_SEL Mask */

/* -----------------------------  u_ble_dp_top_DP_INT  ---------------------------- */
#define BLEMODEM_DP_INT_DP_INTERRUPT0_Pos 0                                                       /*!< BLEMODEM DP_INT: DP_INTERRUPT0 Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT0_Msk (0x01UL << BLEMODEM_DP_INT_DP_INTERRUPT0_Pos)       /*!< BLEMODEM DP_INT: DP_INTERRUPT0 Mask */
#define BLEMODEM_DP_INT_DP_INTERRUPT1_Pos 1                                                       /*!< BLEMODEM DP_INT: DP_INTERRUPT1 Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT1_Msk (0x01UL << BLEMODEM_DP_INT_DP_INTERRUPT1_Pos)       /*!< BLEMODEM DP_INT: DP_INTERRUPT1 Mask */
#define BLEMODEM_DP_INT_DP_INTERRUPT2_Pos 2                                                       /*!< BLEMODEM DP_INT: DP_INTERRUPT2 Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT2_Msk (0x01UL << BLEMODEM_DP_INT_DP_INTERRUPT2_Pos)       /*!< BLEMODEM DP_INT: DP_INTERRUPT2 Mask */
#define BLEMODEM_DP_INT_DP_INTERRUPT_Pos  3                                                       /*!< BLEMODEM DP_INT: DP_INTERRUPT Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT_Msk  (0x01UL << BLEMODEM_DP_INT_DP_INTERRUPT_Pos)        /*!< BLEMODEM DP_INT: DP_INTERRUPT Mask  */
#define BLEMODEM_DP_INT_DP_INTERRUPT0_SEL_Pos 16                                                  /*!< BLEMODEM DP_INT: DP_INTERRUPT0_SEL Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT0_SEL_Msk (0x0fUL << BLEMODEM_DP_INT_DP_INTERRUPT0_SEL_Pos)/*!< BLEMODEM DP_INT: DP_INTERRUPT0_SEL Mask */
#define BLEMODEM_DP_INT_DP_INTERRUPT1_SEL_Pos 20                                                  /*!< BLEMODEM DP_INT: DP_INTERRUPT1_SEL Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT1_SEL_Msk (0x0fUL << BLEMODEM_DP_INT_DP_INTERRUPT1_SEL_Pos)/*!< BLEMODEM DP_INT: DP_INTERRUPT1_SEL Mask */
#define BLEMODEM_DP_INT_DP_INTERRUPT2_SEL_Pos 24                                                  /*!< BLEMODEM DP_INT: DP_INTERRUPT2_SEL Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT2_SEL_Msk (0x0fUL << BLEMODEM_DP_INT_DP_INTERRUPT2_SEL_Pos)/*!< BLEMODEM DP_INT: DP_INTERRUPT2_SEL Mask */
#define BLEMODEM_DP_INT_DP_INTERRUPT0_MSK_Pos 28                                                  /*!< BLEMODEM DP_INT: DP_INTERRUPT0_MSK Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT0_MSK_Msk (0x01UL << BLEMODEM_DP_INT_DP_INTERRUPT0_MSK_Pos)/*!< BLEMODEM DP_INT: DP_INTERRUPT0_MSK Mask */
#define BLEMODEM_DP_INT_DP_INTERRUPT1_MSK_Pos 29                                                  /*!< BLEMODEM DP_INT: DP_INTERRUPT1_MSK Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT1_MSK_Msk (0x01UL << BLEMODEM_DP_INT_DP_INTERRUPT1_MSK_Pos)/*!< BLEMODEM DP_INT: DP_INTERRUPT1_MSK Mask */
#define BLEMODEM_DP_INT_DP_INTERRUPT2_MSK_Pos 30                                                  /*!< BLEMODEM DP_INT: DP_INTERRUPT2_MSK Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT2_MSK_Msk (0x01UL << BLEMODEM_DP_INT_DP_INTERRUPT2_MSK_Pos)/*!< BLEMODEM DP_INT: DP_INTERRUPT2_MSK Mask */
#define BLEMODEM_DP_INT_DP_INTERRUPT_MSK_Pos 31                                                   /*!< BLEMODEM DP_INT: DP_INTERRUPT_MSK Position */
#define BLEMODEM_DP_INT_DP_INTERRUPT_MSK_Msk (0x01UL << BLEMODEM_DP_INT_DP_INTERRUPT_MSK_Pos) /*!< BLEMODEM DP_INT: DP_INTERRUPT_MSK Mask */

/* -------------------------  u_ble_dp_top_DP_AA_ERROR_TH  ------------------------ */
#define BLEMODEM_DP_AA_ERROR_TH_HP_TRAIN_POSITION_Pos 0                                           /*!< BLEMODEM DP_AA_ERROR_TH: HP_TRAIN_POSITION Position */
#define BLEMODEM_DP_AA_ERROR_TH_HP_TRAIN_POSITION_Msk (0x01UL << BLEMODEM_DP_AA_ERROR_TH_HP_TRAIN_POSITION_Pos)/*!< BLEMODEM DP_AA_ERROR_TH: HP_TRAIN_POSITION Mask */
#define BLEMODEM_DP_AA_ERROR_TH_CORDIC_IN_SCALE_Pos 1                                             /*!< BLEMODEM DP_AA_ERROR_TH: CORDIC_IN_SCALE Position */
#define BLEMODEM_DP_AA_ERROR_TH_CORDIC_IN_SCALE_Msk (0x01UL << BLEMODEM_DP_AA_ERROR_TH_CORDIC_IN_SCALE_Pos)/*!< BLEMODEM DP_AA_ERROR_TH: CORDIC_IN_SCALE Mask */
#define BLEMODEM_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_SEL_Pos 2                                         /*!< BLEMODEM DP_AA_ERROR_TH: PAR_AUTO_HIGHER_SEL Position */
#define BLEMODEM_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_SEL_Msk (0x01UL << BLEMODEM_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_SEL_Pos)/*!< BLEMODEM DP_AA_ERROR_TH: PAR_AUTO_HIGHER_SEL Mask */
#define BLEMODEM_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_EN_Pos 3                                          /*!< BLEMODEM DP_AA_ERROR_TH: PAR_AUTO_HIGHER_EN Position */
#define BLEMODEM_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_EN_Msk (0x01UL << BLEMODEM_DP_AA_ERROR_TH_PAR_AUTO_HIGHER_EN_Pos)/*!< BLEMODEM DP_AA_ERROR_TH: PAR_AUTO_HIGHER_EN Mask */
#define BLEMODEM_DP_AA_ERROR_TH_SNR_GOOD_TH_Pos 4                                                 /*!< BLEMODEM DP_AA_ERROR_TH: SNR_GOOD_TH Position */
#define BLEMODEM_DP_AA_ERROR_TH_SNR_GOOD_TH_Msk (0x07UL << BLEMODEM_DP_AA_ERROR_TH_SNR_GOOD_TH_Pos)/*!< BLEMODEM DP_AA_ERROR_TH: SNR_GOOD_TH Mask */
#define BLEMODEM_DP_AA_ERROR_TH_CNR_GOOD_TH_Pos 8                                                 /*!< BLEMODEM DP_AA_ERROR_TH: CNR_GOOD_TH Position */
#define BLEMODEM_DP_AA_ERROR_TH_CNR_GOOD_TH_Msk (0x3fUL << BLEMODEM_DP_AA_ERROR_TH_CNR_GOOD_TH_Pos)/*!< BLEMODEM DP_AA_ERROR_TH: CNR_GOOD_TH Mask */
#define BLEMODEM_DP_AA_ERROR_TH_RSSI_GOOD_TH_Pos 16                                               /*!< BLEMODEM DP_AA_ERROR_TH: RSSI_GOOD_TH Position */
#define BLEMODEM_DP_AA_ERROR_TH_RSSI_GOOD_TH_Msk (0x000000ffUL << BLEMODEM_DP_AA_ERROR_TH_RSSI_GOOD_TH_Pos)/*!< BLEMODEM DP_AA_ERROR_TH: RSSI_GOOD_TH Mask */
#define BLEMODEM_DP_AA_ERROR_TH_RSSI_GOOD_DBM_Pos 24                                              /*!< BLEMODEM DP_AA_ERROR_TH: RSSI_GOOD_DBM Position */
#define BLEMODEM_DP_AA_ERROR_TH_RSSI_GOOD_DBM_Msk (0x000000ffUL << BLEMODEM_DP_AA_ERROR_TH_RSSI_GOOD_DBM_Pos)/*!< BLEMODEM DP_AA_ERROR_TH: RSSI_GOOD_DBM Mask */

/* ------------------------  u_ble_dp_top_DP_ANTENNA_CTRL  ------------------------ */
#define BLEMODEM_DP_ANTENNA_CTRL_SWITCH_MAP_SEL_8F_Pos 0                                          /*!< BLEMODEM DP_ANTENNA_CTRL: SWITCH_MAP_SEL_8F Position */
#define BLEMODEM_DP_ANTENNA_CTRL_SWITCH_MAP_SEL_8F_Msk (0x03UL << BLEMODEM_DP_ANTENNA_CTRL_SWITCH_MAP_SEL_8F_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: SWITCH_MAP_SEL_8F Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_SWITCH_MAP_SEL_07_Pos 2                                          /*!< BLEMODEM DP_ANTENNA_CTRL: SWITCH_MAP_SEL_07 Position */
#define BLEMODEM_DP_ANTENNA_CTRL_SWITCH_MAP_SEL_07_Msk (0x03UL << BLEMODEM_DP_ANTENNA_CTRL_SWITCH_MAP_SEL_07_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: SWITCH_MAP_SEL_07 Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_EXT_ANTENNA_NUM_Pos 4                                            /*!< BLEMODEM DP_ANTENNA_CTRL: EXT_ANTENNA_NUM Position */
#define BLEMODEM_DP_ANTENNA_CTRL_EXT_ANTENNA_NUM_Msk (0x0fUL << BLEMODEM_DP_ANTENNA_CTRL_EXT_ANTENNA_NUM_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: EXT_ANTENNA_NUM Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_EXT_ANTENNA_NUM_WEN_Pos 8                                        /*!< BLEMODEM DP_ANTENNA_CTRL: EXT_ANTENNA_NUM_WEN Position */
#define BLEMODEM_DP_ANTENNA_CTRL_EXT_ANTENNA_NUM_WEN_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_EXT_ANTENNA_NUM_WEN_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: EXT_ANTENNA_NUM_WEN Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_BUFFER_BP_Pos 16                                                 /*!< BLEMODEM DP_ANTENNA_CTRL: BUFFER_BP Position */
#define BLEMODEM_DP_ANTENNA_CTRL_BUFFER_BP_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_BUFFER_BP_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: BUFFER_BP Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_TEST_TD_POWER_Pos 17                                             /*!< BLEMODEM DP_ANTENNA_CTRL: TEST_TD_POWER Position */
#define BLEMODEM_DP_ANTENNA_CTRL_TEST_TD_POWER_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_TEST_TD_POWER_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: TEST_TD_POWER Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_TEST_FD_POWER_Pos 18                                             /*!< BLEMODEM DP_ANTENNA_CTRL: TEST_FD_POWER Position */
#define BLEMODEM_DP_ANTENNA_CTRL_TEST_FD_POWER_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_TEST_FD_POWER_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: TEST_FD_POWER Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_TEST_SYNC_POWER_Pos 19                                           /*!< BLEMODEM DP_ANTENNA_CTRL: TEST_SYNC_POWER Position */
#define BLEMODEM_DP_ANTENNA_CTRL_TEST_SYNC_POWER_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_TEST_SYNC_POWER_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: TEST_SYNC_POWER Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_TEST_RFE_CORDIC_POWER_Pos 20                                     /*!< BLEMODEM DP_ANTENNA_CTRL: TEST_RFE_CORDIC_POWER Position */
#define BLEMODEM_DP_ANTENNA_CTRL_TEST_RFE_CORDIC_POWER_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_TEST_RFE_CORDIC_POWER_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: TEST_RFE_CORDIC_POWER Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_TEST_RFE_POWER_Pos 21                                            /*!< BLEMODEM DP_ANTENNA_CTRL: TEST_RFE_POWER Position */
#define BLEMODEM_DP_ANTENNA_CTRL_TEST_RFE_POWER_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_TEST_RFE_POWER_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: TEST_RFE_POWER Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_ADC01_SAMPLE_TIME_Pos 22                                         /*!< BLEMODEM DP_ANTENNA_CTRL: ADC01_SAMPLE_TIME Position */
#define BLEMODEM_DP_ANTENNA_CTRL_ADC01_SAMPLE_TIME_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_ADC01_SAMPLE_TIME_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: ADC01_SAMPLE_TIME Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_PHY_RATE_MUX_Pos 23                                              /*!< BLEMODEM DP_ANTENNA_CTRL: PHY_RATE_MUX Position */
#define BLEMODEM_DP_ANTENNA_CTRL_PHY_RATE_MUX_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_PHY_RATE_MUX_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: PHY_RATE_MUX Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_PHY_RATE_REG_Pos 24                                              /*!< BLEMODEM DP_ANTENNA_CTRL: PHY_RATE_REG Position */
#define BLEMODEM_DP_ANTENNA_CTRL_PHY_RATE_REG_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_PHY_RATE_REG_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: PHY_RATE_REG Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_PHY_RATE_WEN_Pos 25                                              /*!< BLEMODEM DP_ANTENNA_CTRL: PHY_RATE_WEN Position */
#define BLEMODEM_DP_ANTENNA_CTRL_PHY_RATE_WEN_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_PHY_RATE_WEN_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: PHY_RATE_WEN Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_PDU_RSSI_WAIT_TIME_Pos 26                                        /*!< BLEMODEM DP_ANTENNA_CTRL: PDU_RSSI_WAIT_TIME Position */
#define BLEMODEM_DP_ANTENNA_CTRL_PDU_RSSI_WAIT_TIME_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_PDU_RSSI_WAIT_TIME_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: PDU_RSSI_WAIT_TIME Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_PDU_RSSI_WIN_LEN_Pos 27                                          /*!< BLEMODEM DP_ANTENNA_CTRL: PDU_RSSI_WIN_LEN Position */
#define BLEMODEM_DP_ANTENNA_CTRL_PDU_RSSI_WIN_LEN_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_PDU_RSSI_WIN_LEN_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: PDU_RSSI_WIN_LEN Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_CAL_PDU_RSSI_EN_Pos 28                                           /*!< BLEMODEM DP_ANTENNA_CTRL: CAL_PDU_RSSI_EN Position */
#define BLEMODEM_DP_ANTENNA_CTRL_CAL_PDU_RSSI_EN_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_CAL_PDU_RSSI_EN_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: CAL_PDU_RSSI_EN Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_PROP_CRC_AA_DIS_Pos 29                                           /*!< BLEMODEM DP_ANTENNA_CTRL: PROP_CRC_AA_DIS Position */
#define BLEMODEM_DP_ANTENNA_CTRL_PROP_CRC_AA_DIS_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_PROP_CRC_AA_DIS_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: PROP_CRC_AA_DIS Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_PROP_AA_LSB_FIRST_Pos 30                                         /*!< BLEMODEM DP_ANTENNA_CTRL: PROP_AA_LSB_FIRST Position */
#define BLEMODEM_DP_ANTENNA_CTRL_PROP_AA_LSB_FIRST_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_PROP_AA_LSB_FIRST_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: PROP_AA_LSB_FIRST Mask */
#define BLEMODEM_DP_ANTENNA_CTRL_PRE_NUM_WEN_Pos 31                                               /*!< BLEMODEM DP_ANTENNA_CTRL: PRE_NUM_WEN Position */
#define BLEMODEM_DP_ANTENNA_CTRL_PRE_NUM_WEN_Msk (0x01UL << BLEMODEM_DP_ANTENNA_CTRL_PRE_NUM_WEN_Pos)/*!< BLEMODEM DP_ANTENNA_CTRL: PRE_NUM_WEN Mask */

/* -------------------------  u_ble_dp_top_ANTENNA_MAP01  ------------------------- */
#define BLEMODEM_ANTENNA_MAP01_ANTENNA_MAP01_Pos 0                                                /*!< BLEMODEM ANTENNA_MAP01: ANTENNA_MAP01 Position */
#define BLEMODEM_ANTENNA_MAP01_ANTENNA_MAP01_Msk (0xffffffffUL << BLEMODEM_ANTENNA_MAP01_ANTENNA_MAP01_Pos)/*!< BLEMODEM ANTENNA_MAP01: ANTENNA_MAP01 Mask */

/* -------------------------  u_ble_dp_top_ANTENNA_MAP23  ------------------------- */
#define BLEMODEM_ANTENNA_MAP23_ANTENNA_MAP23_Pos 0                                                /*!< BLEMODEM ANTENNA_MAP23: ANTENNA_MAP23 Position */
#define BLEMODEM_ANTENNA_MAP23_ANTENNA_MAP23_Msk (0xffffffffUL << BLEMODEM_ANTENNA_MAP23_ANTENNA_MAP23_Pos)/*!< BLEMODEM ANTENNA_MAP23: ANTENNA_MAP23 Mask */

/* -------------------------  u_ble_dp_top_ANTENNA_MAP45  ------------------------- */
#define BLEMODEM_ANTENNA_MAP45_ANTENNA_MAP45_Pos 0                                                /*!< BLEMODEM ANTENNA_MAP45: ANTENNA_MAP45 Position */
#define BLEMODEM_ANTENNA_MAP45_ANTENNA_MAP45_Msk (0xffffffffUL << BLEMODEM_ANTENNA_MAP45_ANTENNA_MAP45_Pos)/*!< BLEMODEM ANTENNA_MAP45: ANTENNA_MAP45 Mask */

/* -------------------------  u_ble_dp_top_ANTENNA_MAP67  ------------------------- */
#define BLEMODEM_ANTENNA_MAP67_ANTENNA_MAP67_Pos 0                                                /*!< BLEMODEM ANTENNA_MAP67: ANTENNA_MAP67 Position */
#define BLEMODEM_ANTENNA_MAP67_ANTENNA_MAP67_Msk (0xffffffffUL << BLEMODEM_ANTENNA_MAP67_ANTENNA_MAP67_Pos)/*!< BLEMODEM ANTENNA_MAP67: ANTENNA_MAP67 Mask */

/* -----------------------  u_ble_dp_top_LL_EM_BASE_ADDRESS  ---------------------- */
#define BLEMODEM_LL_EM_BASE_ADDRESS_LL_EM_BASE_ADDRESS_Pos 0                                      /*!< BLEMODEM LL_EM_BASE_ADDRESS: LL_EM_BASE_ADDRESS Position */
#define BLEMODEM_LL_EM_BASE_ADDRESS_LL_EM_BASE_ADDRESS_Msk (0xffffffffUL << BLEMODEM_LL_EM_BASE_ADDRESS_LL_EM_BASE_ADDRESS_Pos)/*!< BLEMODEM LL_EM_BASE_ADDRESS: LL_EM_BASE_ADDRESS Mask */

/* --------------------------  u_ble_dp_top_RX_EARLY_EOP  ------------------------- */
#define BLEMODEM_RX_EARLY_EOP_rx_early_eop_Pos 0                                                  /*!< BLEMODEM RX_EARLY_EOP: rx_early_eop Position */
#define BLEMODEM_RX_EARLY_EOP_rx_early_eop_Msk (0x000000ffUL << BLEMODEM_RX_EARLY_EOP_rx_early_eop_Pos)/*!< BLEMODEM RX_EARLY_EOP: rx_early_eop Mask */

/* -------------------------  u_ble_dp_top_ANT_DIVERSITY  ------------------------- */
#define BLEMODEM_ANT_DIVERSITY_ble_ant_selected_Pos 0                                             /*!< BLEMODEM ANT_DIVERSITY: ble_ant_selected Position */
#define BLEMODEM_ANT_DIVERSITY_ble_ant_selected_Msk (0x01UL << BLEMODEM_ANT_DIVERSITY_ble_ant_selected_Pos)/*!< BLEMODEM ANT_DIVERSITY: ble_ant_selected Mask */
#define BLEMODEM_ANT_DIVERSITY_ble_ant_mode_Pos 1                                                 /*!< BLEMODEM ANT_DIVERSITY: ble_ant_mode Position */
#define BLEMODEM_ANT_DIVERSITY_ble_ant_mode_Msk (0x01UL << BLEMODEM_ANT_DIVERSITY_ble_ant_mode_Pos)/*!< BLEMODEM ANT_DIVERSITY: ble_ant_mode Mask */

/* -------------------------  u_ble_dp_top_TX_M_TEST_CTRL  ------------------------ */
#define BLEMODEM_TX_M_TEST_CTRL_tx_test_mode_Pos 0                                                /*!< BLEMODEM TX_M_TEST_CTRL: tx_test_mode Position */
#define BLEMODEM_TX_M_TEST_CTRL_tx_test_mode_Msk (0x0fUL << BLEMODEM_TX_M_TEST_CTRL_tx_test_mode_Pos)/*!< BLEMODEM TX_M_TEST_CTRL: tx_test_mode Mask */
#define BLEMODEM_TX_M_TEST_CTRL_tx_test_speed_Pos 4                                               /*!< BLEMODEM TX_M_TEST_CTRL: tx_test_speed Position */
#define BLEMODEM_TX_M_TEST_CTRL_tx_test_speed_Msk (0x01UL << BLEMODEM_TX_M_TEST_CTRL_tx_test_speed_Pos)/*!< BLEMODEM TX_M_TEST_CTRL: tx_test_speed Mask */
#define BLEMODEM_TX_M_TEST_CTRL_tx_test_en_Pos 5                                                  /*!< BLEMODEM TX_M_TEST_CTRL: tx_test_en Position */
#define BLEMODEM_TX_M_TEST_CTRL_tx_test_en_Msk (0x01UL << BLEMODEM_TX_M_TEST_CTRL_tx_test_en_Pos)/*!< BLEMODEM TX_M_TEST_CTRL: tx_test_en Mask */


/* ================================================================================ */
/* ================         struct 'u_pvt' Position & Mask         ================ */
/* ================================================================================ */


/* ----------------------------  u_pvt_RED_DEL_CTRL_0  ---------------------------- */
#define PVT_RED_DEL_CTRL_0_RED_DEL_CTRL_0_Pos 0                                                     /*!< PVT RED_DEL_CTRL_0: RED_DEL_CTRL_0 Position */
#define PVT_RED_DEL_CTRL_0_RED_DEL_CTRL_0_Msk (0xffffffffUL << PVT_RED_DEL_CTRL_0_RED_DEL_CTRL_0_Pos)/*!< PVT RED_DEL_CTRL_0: RED_DEL_CTRL_0 Mask */

/* ---------------------------  u_pvt_RED_REGION_CNT_0  --------------------------- */
#define PVT_RED_REGION_CNT_0_RED_REGION_CNT_0_Pos 0                                                 /*!< PVT RED_REGION_CNT_0: RED_REGION_CNT_0 Position */
#define PVT_RED_REGION_CNT_0_RED_REGION_CNT_0_Msk (0xffffffffUL << PVT_RED_REGION_CNT_0_RED_REGION_CNT_0_Pos)/*!< PVT RED_REGION_CNT_0: RED_REGION_CNT_0 Mask */

/* -------------------------  u_pvt_RED_REGION_CNT_CTRL_0  ------------------------ */
#define PVT_RED_REGION_CNT_CTRL_0_RED_REGION_CNT_CTRL_0_Pos 0                                       /*!< PVT RED_REGION_CNT_CTRL_0: RED_REGION_CNT_CTRL_0 Position */
#define PVT_RED_REGION_CNT_CTRL_0_RED_REGION_CNT_CTRL_0_Msk (0xffffffffUL << PVT_RED_REGION_CNT_CTRL_0_RED_REGION_CNT_CTRL_0_Pos)/*!< PVT RED_REGION_CNT_CTRL_0: RED_REGION_CNT_CTRL_0 Mask */

/* ---------------------------  u_pvt_AMBER_DEL_CTRL_0  --------------------------- */
#define PVT_AMBER_DEL_CTRL_0_AMBER_DEL_CTRL_0_Pos 0                                                 /*!< PVT AMBER_DEL_CTRL_0: AMBER_DEL_CTRL_0 Position */
#define PVT_AMBER_DEL_CTRL_0_AMBER_DEL_CTRL_0_Msk (0xffffffffUL << PVT_AMBER_DEL_CTRL_0_AMBER_DEL_CTRL_0_Pos)/*!< PVT AMBER_DEL_CTRL_0: AMBER_DEL_CTRL_0 Mask */

/* -----------------------------  u_pvt_AMBER_RINGO_0  ---------------------------- */
#define PVT_AMBER_RINGO_0_ENABLE_Pos        0                                                       /*!< PVT AMBER_RINGO_0: ENABLE Position    */
#define PVT_AMBER_RINGO_0_ENABLE_Msk        (0x01UL << PVT_AMBER_RINGO_0_ENABLE_Pos)              /*!< PVT AMBER_RINGO_0: ENABLE Mask        */
#define PVT_AMBER_RINGO_0_CNT_ENABLE_Pos    1                                                       /*!< PVT AMBER_RINGO_0: CNT_ENABLE Position */
#define PVT_AMBER_RINGO_0_CNT_ENABLE_Msk    (0x01UL << PVT_AMBER_RINGO_0_CNT_ENABLE_Pos)          /*!< PVT AMBER_RINGO_0: CNT_ENABLE Mask    */
#define PVT_AMBER_RINGO_0_CNT_RESET_Pos     2                                                       /*!< PVT AMBER_RINGO_0: CNT_RESET Position */
#define PVT_AMBER_RINGO_0_CNT_RESET_Msk     (0x01UL << PVT_AMBER_RINGO_0_CNT_RESET_Pos)           /*!< PVT AMBER_RINGO_0: CNT_RESET Mask     */

/* ---------------------------  u_pvt_AMBER_RINGO_CNT_0  -------------------------- */
#define PVT_AMBER_RINGO_CNT_0_AMBER_RINGO_CNT_0_Pos 0                                               /*!< PVT AMBER_RINGO_CNT_0: AMBER_RINGO_CNT_0 Position */
#define PVT_AMBER_RINGO_CNT_0_AMBER_RINGO_CNT_0_Msk (0xffffffffUL << PVT_AMBER_RINGO_CNT_0_AMBER_RINGO_CNT_0_Pos)/*!< PVT AMBER_RINGO_CNT_0: AMBER_RINGO_CNT_0 Mask */

/* --------------------------  u_pvt_AMBER_REGION_CNT_0  -------------------------- */
#define PVT_AMBER_REGION_CNT_0_AMBER_REGION_CNT_0_Pos 0                                             /*!< PVT AMBER_REGION_CNT_0: AMBER_REGION_CNT_0 Position */
#define PVT_AMBER_REGION_CNT_0_AMBER_REGION_CNT_0_Msk (0xffffffffUL << PVT_AMBER_REGION_CNT_0_AMBER_REGION_CNT_0_Pos)/*!< PVT AMBER_REGION_CNT_0: AMBER_REGION_CNT_0 Mask */

/* ------------------------  u_pvt_AMBER_REGION_CNT_CTRL_0  ----------------------- */
#define PVT_AMBER_REGION_CNT_CTRL_0_AMBER_REGION_CNT_CTRL_0_Pos 0                                   /*!< PVT AMBER_REGION_CNT_CTRL_0: AMBER_REGION_CNT_CTRL_0 Position */
#define PVT_AMBER_REGION_CNT_CTRL_0_AMBER_REGION_CNT_CTRL_0_Msk (0xffffffffUL << PVT_AMBER_REGION_CNT_CTRL_0_AMBER_REGION_CNT_CTRL_0_Pos)/*!< PVT AMBER_REGION_CNT_CTRL_0: AMBER_REGION_CNT_CTRL_0 Mask */

/* ------------------------------  u_pvt_DFT_CTRL_0  ------------------------------ */
#define PVT_DFT_CTRL_0_DFT_CTRL_0_Pos       0                                                       /*!< PVT DFT_CTRL_0: DFT_CTRL_0 Position   */
#define PVT_DFT_CTRL_0_DFT_CTRL_0_Msk       (0xffffffffUL << PVT_DFT_CTRL_0_DFT_CTRL_0_Pos)       /*!< PVT DFT_CTRL_0: DFT_CTRL_0 Mask       */

/* ----------------------------  u_pvt_RED_DEL_CTRL_1  ---------------------------- */
#define PVT_RED_DEL_CTRL_1_RED_DEL_CTRL_1_Pos 0                                                     /*!< PVT RED_DEL_CTRL_1: RED_DEL_CTRL_1 Position */
#define PVT_RED_DEL_CTRL_1_RED_DEL_CTRL_1_Msk (0xffffffffUL << PVT_RED_DEL_CTRL_1_RED_DEL_CTRL_1_Pos)/*!< PVT RED_DEL_CTRL_1: RED_DEL_CTRL_1 Mask */

/* ---------------------------  u_pvt_RED_REGION_CNT_1  --------------------------- */
#define PVT_RED_REGION_CNT_1_RED_REGION_CNT_1_Pos 0                                                 /*!< PVT RED_REGION_CNT_1: RED_REGION_CNT_1 Position */
#define PVT_RED_REGION_CNT_1_RED_REGION_CNT_1_Msk (0xffffffffUL << PVT_RED_REGION_CNT_1_RED_REGION_CNT_1_Pos)/*!< PVT RED_REGION_CNT_1: RED_REGION_CNT_1 Mask */

/* -------------------------  u_pvt_RED_REGION_CNT_CTRL_1  ------------------------ */
#define PVT_RED_REGION_CNT_CTRL_1_RED_REGION_CNT_CTRL_1_Pos 0                                       /*!< PVT RED_REGION_CNT_CTRL_1: RED_REGION_CNT_CTRL_1 Position */
#define PVT_RED_REGION_CNT_CTRL_1_RED_REGION_CNT_CTRL_1_Msk (0xffffffffUL << PVT_RED_REGION_CNT_CTRL_1_RED_REGION_CNT_CTRL_1_Pos)/*!< PVT RED_REGION_CNT_CTRL_1: RED_REGION_CNT_CTRL_1 Mask */

/* ---------------------------  u_pvt_AMBER_DEL_CTRL_1  --------------------------- */
#define PVT_AMBER_DEL_CTRL_1_AMBER_DEL_CTRL_1_Pos 0                                                 /*!< PVT AMBER_DEL_CTRL_1: AMBER_DEL_CTRL_1 Position */
#define PVT_AMBER_DEL_CTRL_1_AMBER_DEL_CTRL_1_Msk (0xffffffffUL << PVT_AMBER_DEL_CTRL_1_AMBER_DEL_CTRL_1_Pos)/*!< PVT AMBER_DEL_CTRL_1: AMBER_DEL_CTRL_1 Mask */

/* -----------------------------  u_pvt_AMBER_RINGO_1  ---------------------------- */
#define PVT_AMBER_RINGO_1_ENABLE_Pos        0                                                       /*!< PVT AMBER_RINGO_1: ENABLE Position    */
#define PVT_AMBER_RINGO_1_ENABLE_Msk        (0x01UL << PVT_AMBER_RINGO_1_ENABLE_Pos)              /*!< PVT AMBER_RINGO_1: ENABLE Mask        */
#define PVT_AMBER_RINGO_1_CNT_ENABLE_Pos    1                                                       /*!< PVT AMBER_RINGO_1: CNT_ENABLE Position */
#define PVT_AMBER_RINGO_1_CNT_ENABLE_Msk    (0x01UL << PVT_AMBER_RINGO_1_CNT_ENABLE_Pos)          /*!< PVT AMBER_RINGO_1: CNT_ENABLE Mask    */
#define PVT_AMBER_RINGO_1_CNT_RESET_Pos     2                                                       /*!< PVT AMBER_RINGO_1: CNT_RESET Position */
#define PVT_AMBER_RINGO_1_CNT_RESET_Msk     (0x01UL << PVT_AMBER_RINGO_1_CNT_RESET_Pos)           /*!< PVT AMBER_RINGO_1: CNT_RESET Mask     */

/* ---------------------------  u_pvt_AMBER_RINGO_CNT_1  -------------------------- */
#define PVT_AMBER_RINGO_CNT_1_AMBER_RINGO_CNT_1_Pos 0                                               /*!< PVT AMBER_RINGO_CNT_1: AMBER_RINGO_CNT_1 Position */
#define PVT_AMBER_RINGO_CNT_1_AMBER_RINGO_CNT_1_Msk (0xffffffffUL << PVT_AMBER_RINGO_CNT_1_AMBER_RINGO_CNT_1_Pos)/*!< PVT AMBER_RINGO_CNT_1: AMBER_RINGO_CNT_1 Mask */

/* --------------------------  u_pvt_AMBER_REGION_CNT_1  -------------------------- */
#define PVT_AMBER_REGION_CNT_1_AMBER_REGION_CNT_1_Pos 0                                             /*!< PVT AMBER_REGION_CNT_1: AMBER_REGION_CNT_1 Position */
#define PVT_AMBER_REGION_CNT_1_AMBER_REGION_CNT_1_Msk (0xffffffffUL << PVT_AMBER_REGION_CNT_1_AMBER_REGION_CNT_1_Pos)/*!< PVT AMBER_REGION_CNT_1: AMBER_REGION_CNT_1 Mask */

/* ------------------------  u_pvt_AMBER_REGION_CNT_CTRL_1  ----------------------- */
#define PVT_AMBER_REGION_CNT_CTRL_1_AMBER_REGION_CNT_CTRL_1_Pos 0                                   /*!< PVT AMBER_REGION_CNT_CTRL_1: AMBER_REGION_CNT_CTRL_1 Position */
#define PVT_AMBER_REGION_CNT_CTRL_1_AMBER_REGION_CNT_CTRL_1_Msk (0xffffffffUL << PVT_AMBER_REGION_CNT_CTRL_1_AMBER_REGION_CNT_CTRL_1_Pos)/*!< PVT AMBER_REGION_CNT_CTRL_1: AMBER_REGION_CNT_CTRL_1 Mask */

/* ------------------------------  u_pvt_DFT_CTRL_1  ------------------------------ */
#define PVT_DFT_CTRL_1_DFT_CTRL_1_Pos       0                                                       /*!< PVT DFT_CTRL_1: DFT_CTRL_1 Position   */
#define PVT_DFT_CTRL_1_DFT_CTRL_1_Msk       (0xffffffffUL << PVT_DFT_CTRL_1_DFT_CTRL_1_Pos)       /*!< PVT DFT_CTRL_1: DFT_CTRL_1 Mask       */


/* ================================================================================ */
/* ================     struct 'u_async_syscon' Position & Mask    ================ */
/* ================================================================================ */


/* -----------------------  u_async_syscon_ASYNCPRESETCTRL  ----------------------- */
#define ASYSCON_ASYNCPRESETCTRL_CT32B0_Pos 1                                                   /*!< ASYSCON ASYNCPRESETCTRL: CT32B0 Position */
#define ASYSCON_ASYNCPRESETCTRL_CT32B0_Msk (0x01UL << ASYSCON_ASYNCPRESETCTRL_CT32B0_Pos)/*!< ASYSCON ASYNCPRESETCTRL: CT32B0 Mask */
#define ASYSCON_ASYNCPRESETCTRL_CT32B1_Pos 2                                                   /*!< ASYSCON ASYNCPRESETCTRL: CT32B1 Position */
#define ASYSCON_ASYNCPRESETCTRL_CT32B1_Msk (0x01UL << ASYSCON_ASYNCPRESETCTRL_CT32B1_Pos)/*!< ASYSCON ASYNCPRESETCTRL: CT32B1 Mask */

/* ----------------------  u_async_syscon_ASYNCPRESETCTRLSET  --------------------- */
#define ASYSCON_ASYNCPRESETCTRLSET_CT32B0_Pos 1                                                /*!< ASYSCON ASYNCPRESETCTRLSET: CT32B0 Position */
#define ASYSCON_ASYNCPRESETCTRLSET_CT32B0_Msk (0x01UL << ASYSCON_ASYNCPRESETCTRLSET_CT32B0_Pos)/*!< ASYSCON ASYNCPRESETCTRLSET: CT32B0 Mask */
#define ASYSCON_ASYNCPRESETCTRLSET_CT32B1_Pos 2                                                /*!< ASYSCON ASYNCPRESETCTRLSET: CT32B1 Position */
#define ASYSCON_ASYNCPRESETCTRLSET_CT32B1_Msk (0x01UL << ASYSCON_ASYNCPRESETCTRLSET_CT32B1_Pos)/*!< ASYSCON ASYNCPRESETCTRLSET: CT32B1 Mask */

/* ----------------------  u_async_syscon_ASYNCPRESETCTRLCLR  --------------------- */
#define ASYSCON_ASYNCPRESETCTRLCLR_CT32B0_Pos 1                                                /*!< ASYSCON ASYNCPRESETCTRLCLR: CT32B0 Position */
#define ASYSCON_ASYNCPRESETCTRLCLR_CT32B0_Msk (0x01UL << ASYSCON_ASYNCPRESETCTRLCLR_CT32B0_Pos)/*!< ASYSCON ASYNCPRESETCTRLCLR: CT32B0 Mask */
#define ASYSCON_ASYNCPRESETCTRLCLR_CT32B1_Pos 2                                                /*!< ASYSCON ASYNCPRESETCTRLCLR: CT32B1 Position */
#define ASYSCON_ASYNCPRESETCTRLCLR_CT32B1_Msk (0x01UL << ASYSCON_ASYNCPRESETCTRLCLR_CT32B1_Pos)/*!< ASYSCON ASYNCPRESETCTRLCLR: CT32B1 Mask */

/* -----------------------  u_async_syscon_ASYNCAPBCLKCTRL  ----------------------- */
#define ASYSCON_ASYNCAPBCLKCTRL_CT32B0_Pos 1                                                   /*!< ASYSCON ASYNCAPBCLKCTRL: CT32B0 Position */
#define ASYSCON_ASYNCAPBCLKCTRL_CT32B0_Msk (0x01UL << ASYSCON_ASYNCAPBCLKCTRL_CT32B0_Pos)/*!< ASYSCON ASYNCAPBCLKCTRL: CT32B0 Mask */
#define ASYSCON_ASYNCAPBCLKCTRL_CT32B1_Pos 2                                                   /*!< ASYSCON ASYNCAPBCLKCTRL: CT32B1 Position */
#define ASYSCON_ASYNCAPBCLKCTRL_CT32B1_Msk (0x01UL << ASYSCON_ASYNCAPBCLKCTRL_CT32B1_Pos)/*!< ASYSCON ASYNCAPBCLKCTRL: CT32B1 Mask */

/* ----------------------  u_async_syscon_ASYNCAPBCLKCTRLSET  --------------------- */
#define ASYSCON_ASYNCAPBCLKCTRLSET_CT32B0_Pos 1                                                /*!< ASYSCON ASYNCAPBCLKCTRLSET: CT32B0 Position */
#define ASYSCON_ASYNCAPBCLKCTRLSET_CT32B0_Msk (0x01UL << ASYSCON_ASYNCAPBCLKCTRLSET_CT32B0_Pos)/*!< ASYSCON ASYNCAPBCLKCTRLSET: CT32B0 Mask */
#define ASYSCON_ASYNCAPBCLKCTRLSET_CT32B1_Pos 2                                                /*!< ASYSCON ASYNCAPBCLKCTRLSET: CT32B1 Position */
#define ASYSCON_ASYNCAPBCLKCTRLSET_CT32B1_Msk (0x01UL << ASYSCON_ASYNCAPBCLKCTRLSET_CT32B1_Pos)/*!< ASYSCON ASYNCAPBCLKCTRLSET: CT32B1 Mask */

/* ----------------------  u_async_syscon_ASYNCAPBCLKCTRLCLR  --------------------- */
#define ASYSCON_ASYNCAPBCLKCTRLCLR_CT32B0_Pos 1                                                /*!< ASYSCON ASYNCAPBCLKCTRLCLR: CT32B0 Position */
#define ASYSCON_ASYNCAPBCLKCTRLCLR_CT32B0_Msk (0x01UL << ASYSCON_ASYNCAPBCLKCTRLCLR_CT32B0_Pos)/*!< ASYSCON ASYNCAPBCLKCTRLCLR: CT32B0 Mask */
#define ASYSCON_ASYNCAPBCLKCTRLCLR_CT32B1_Pos 2                                                /*!< ASYSCON ASYNCAPBCLKCTRLCLR: CT32B1 Position */
#define ASYSCON_ASYNCAPBCLKCTRLCLR_CT32B1_Msk (0x01UL << ASYSCON_ASYNCAPBCLKCTRLCLR_CT32B1_Pos)/*!< ASYSCON ASYNCAPBCLKCTRLCLR: CT32B1 Mask */

/* -----------------------  u_async_syscon_ASYNCAPBCLKSELA  ----------------------- */
#define ASYSCON_ASYNCAPBCLKSELA_SEL_Pos 0                                                      /*!< ASYSCON ASYNCAPBCLKSELA: SEL Position */
#define ASYSCON_ASYNCAPBCLKSELA_SEL_Msk (0x03UL << ASYSCON_ASYNCAPBCLKSELA_SEL_Pos)     /*!< ASYSCON ASYNCAPBCLKSELA: SEL Mask */

/* ------------------------  u_async_syscon_ASYNCAPBCLKDIV  ----------------------- */
#define ASYSCON_ASYNCAPBCLKDIV_DIV_Pos 0                                                       /*!< ASYSCON ASYNCAPBCLKDIV: DIV Position */
#define ASYSCON_ASYNCAPBCLKDIV_DIV_Msk (0x000000ffUL << ASYSCON_ASYNCAPBCLKDIV_DIV_Pos) /*!< ASYSCON ASYNCAPBCLKDIV: DIV Mask */
#define ASYSCON_ASYNCAPBCLKDIV_RESET_Pos 29                                                    /*!< ASYSCON ASYNCAPBCLKDIV: RESET Position */
#define ASYSCON_ASYNCAPBCLKDIV_RESET_Msk (0x01UL << ASYSCON_ASYNCAPBCLKDIV_RESET_Pos)   /*!< ASYSCON ASYNCAPBCLKDIV: RESET Mask */
#define ASYSCON_ASYNCAPBCLKDIV_HALT_Pos 30                                                     /*!< ASYSCON ASYNCAPBCLKDIV: HALT Position */
#define ASYSCON_ASYNCAPBCLKDIV_HALT_Msk (0x01UL << ASYSCON_ASYNCAPBCLKDIV_HALT_Pos)     /*!< ASYSCON ASYNCAPBCLKDIV: HALT Mask */
#define ASYSCON_ASYNCAPBCLKDIV_REQFLAG_Pos 31                                                  /*!< ASYSCON ASYNCAPBCLKDIV: REQFLAG Position */
#define ASYSCON_ASYNCAPBCLKDIV_REQFLAG_Msk (0x01UL << ASYSCON_ASYNCAPBCLKDIV_REQFLAG_Pos)/*!< ASYSCON ASYNCAPBCLKDIV: REQFLAG Mask */

/* -----------------------  u_async_syscon_ASYNCCLKOVERRIDE  ---------------------- */
#define ASYSCON_ASYNCCLKOVERRIDE_ASYNCSYSREGBANK_Pos 15                                        /*!< ASYSCON ASYNCCLKOVERRIDE: ASYNCSYSREGBANK Position */
#define ASYSCON_ASYNCCLKOVERRIDE_ASYNCSYSREGBANK_Msk (0x01UL << ASYSCON_ASYNCCLKOVERRIDE_ASYNCSYSREGBANK_Pos)/*!< ASYSCON ASYNCCLKOVERRIDE: ASYNCSYSREGBANK Mask */
#define ASYSCON_ASYNCCLKOVERRIDE_ENABLEUPDATE_Pos 16                                           /*!< ASYSCON ASYNCCLKOVERRIDE: ENABLEUPDATE Position */
#define ASYSCON_ASYNCCLKOVERRIDE_ENABLEUPDATE_Msk (0x0000ffffUL << ASYSCON_ASYNCCLKOVERRIDE_ENABLEUPDATE_Pos)/*!< ASYSCON ASYNCCLKOVERRIDE: ENABLEUPDATE Mask */

/* ------------------------  u_async_syscon_TEMPSENSORCTRL  ----------------------- */
#define ASYSCON_TEMPSENSORCTRL_ENABLE_Pos 0                                                    /*!< ASYSCON TEMPSENSORCTRL: ENABLE Position */
#define ASYSCON_TEMPSENSORCTRL_ENABLE_Msk (0x01UL << ASYSCON_TEMPSENSORCTRL_ENABLE_Pos) /*!< ASYSCON TEMPSENSORCTRL: ENABLE Mask */
#define ASYSCON_TEMPSENSORCTRL_SLOPE_Pos 1                                                     /*!< ASYSCON TEMPSENSORCTRL: SLOPE Position */
#define ASYSCON_TEMPSENSORCTRL_SLOPE_Msk (0x01UL << ASYSCON_TEMPSENSORCTRL_SLOPE_Pos)   /*!< ASYSCON TEMPSENSORCTRL: SLOPE Mask */
#define ASYSCON_TEMPSENSORCTRL_CM_Pos  2                                                       /*!< ASYSCON TEMPSENSORCTRL: CM Position */
#define ASYSCON_TEMPSENSORCTRL_CM_Msk  (0x03UL << ASYSCON_TEMPSENSORCTRL_CM_Pos)        /*!< ASYSCON TEMPSENSORCTRL: CM Mask  */

/* ------------------------  u_async_syscon_NFCTAGPADSCTRL  ----------------------- */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EPD_Pos 0                                               /*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_EPD Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EPD_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EPD_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_EPD Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EPUN_Pos 1                                              /*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_EPUN Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EPUN_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EPUN_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_EPUN Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EHS0_Pos 2                                              /*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_EHS0 Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EHS0_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EHS0_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_EHS0 Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_INVERT_Pos 3                                            /*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_INVERT Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_INVERT_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SDA_INVERT_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_INVERT Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_ENZI_Pos 4                                              /*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_ENZI Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_ENZI_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SDA_ENZI_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_ENZI Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_FILTEROFF_Pos 5                                         /*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_FILTEROFF Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_FILTEROFF_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SDA_FILTEROFF_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_FILTEROFF Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EHS1_Pos 6                                              /*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_EHS1 Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EHS1_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SDA_EHS1_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_EHS1 Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_OD_Pos 7                                                /*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_OD Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SDA_OD_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SDA_OD_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SDA_OD Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EPD_Pos 8                                               /*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_EPD Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EPD_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EPD_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_EPD Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EPUN_Pos 9                                              /*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_EPUN Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EPUN_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EPUN_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_EPUN Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EHS0_Pos 10                                             /*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_EHS0 Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EHS0_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EHS0_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_EHS0 Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_INVERT_Pos 11                                           /*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_INVERT Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_INVERT_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SCL_INVERT_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_INVERT Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_ENZI_Pos 12                                             /*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_ENZI Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_ENZI_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SCL_ENZI_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_ENZI Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_FILTEROFF_Pos 13                                        /*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_FILTEROFF Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_FILTEROFF_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SCL_FILTEROFF_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_FILTEROFF Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EHS1_Pos 14                                             /*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_EHS1 Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EHS1_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SCL_EHS1_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_EHS1 Mask */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_OD_Pos 15                                               /*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_OD Position */
#define ASYSCON_NFCTAGPADSCTRL_I2C_SCL_OD_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_I2C_SCL_OD_Pos)/*!< ASYSCON NFCTAGPADSCTRL: I2C_SCL_OD Mask */
#define ASYSCON_NFCTAGPADSCTRL_INT_EPD_Pos 16                                                  /*!< ASYSCON NFCTAGPADSCTRL: INT_EPD Position */
#define ASYSCON_NFCTAGPADSCTRL_INT_EPD_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_INT_EPD_Pos)/*!< ASYSCON NFCTAGPADSCTRL: INT_EPD Mask */
#define ASYSCON_NFCTAGPADSCTRL_INT_EPUN_Pos 17                                                 /*!< ASYSCON NFCTAGPADSCTRL: INT_EPUN Position */
#define ASYSCON_NFCTAGPADSCTRL_INT_EPUN_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_INT_EPUN_Pos)/*!< ASYSCON NFCTAGPADSCTRL: INT_EPUN Mask */
#define ASYSCON_NFCTAGPADSCTRL_INT_INVERT_Pos 18                                               /*!< ASYSCON NFCTAGPADSCTRL: INT_INVERT Position */
#define ASYSCON_NFCTAGPADSCTRL_INT_INVERT_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_INT_INVERT_Pos)/*!< ASYSCON NFCTAGPADSCTRL: INT_INVERT Mask */
#define ASYSCON_NFCTAGPADSCTRL_INT_ENZI_Pos 19                                                 /*!< ASYSCON NFCTAGPADSCTRL: INT_ENZI Position */
#define ASYSCON_NFCTAGPADSCTRL_INT_ENZI_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_INT_ENZI_Pos)/*!< ASYSCON NFCTAGPADSCTRL: INT_ENZI Mask */
#define ASYSCON_NFCTAGPADSCTRL_INT_FILTEROFF_Pos 20                                            /*!< ASYSCON NFCTAGPADSCTRL: INT_FILTEROFF Position */
#define ASYSCON_NFCTAGPADSCTRL_INT_FILTEROFF_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_INT_FILTEROFF_Pos)/*!< ASYSCON NFCTAGPADSCTRL: INT_FILTEROFF Mask */
#define ASYSCON_NFCTAGPADSCTRL_VDD_EPD_Pos 21                                                  /*!< ASYSCON NFCTAGPADSCTRL: VDD_EPD Position */
#define ASYSCON_NFCTAGPADSCTRL_VDD_EPD_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_VDD_EPD_Pos)/*!< ASYSCON NFCTAGPADSCTRL: VDD_EPD Mask */
#define ASYSCON_NFCTAGPADSCTRL_VDD_EPUN_Pos 22                                                 /*!< ASYSCON NFCTAGPADSCTRL: VDD_EPUN Position */
#define ASYSCON_NFCTAGPADSCTRL_VDD_EPUN_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_VDD_EPUN_Pos)/*!< ASYSCON NFCTAGPADSCTRL: VDD_EPUN Mask */
#define ASYSCON_NFCTAGPADSCTRL_VDD_EHS0_Pos 23                                                 /*!< ASYSCON NFCTAGPADSCTRL: VDD_EHS0 Position */
#define ASYSCON_NFCTAGPADSCTRL_VDD_EHS0_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_VDD_EHS0_Pos)/*!< ASYSCON NFCTAGPADSCTRL: VDD_EHS0 Mask */
#define ASYSCON_NFCTAGPADSCTRL_VDD_INVERT_Pos 24                                               /*!< ASYSCON NFCTAGPADSCTRL: VDD_INVERT Position */
#define ASYSCON_NFCTAGPADSCTRL_VDD_INVERT_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_VDD_INVERT_Pos)/*!< ASYSCON NFCTAGPADSCTRL: VDD_INVERT Mask */
#define ASYSCON_NFCTAGPADSCTRL_VDD_ENZI_Pos 25                                                 /*!< ASYSCON NFCTAGPADSCTRL: VDD_ENZI Position */
#define ASYSCON_NFCTAGPADSCTRL_VDD_ENZI_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_VDD_ENZI_Pos)/*!< ASYSCON NFCTAGPADSCTRL: VDD_ENZI Mask */
#define ASYSCON_NFCTAGPADSCTRL_VDD_FILTEROFF_Pos 26                                            /*!< ASYSCON NFCTAGPADSCTRL: VDD_FILTEROFF Position */
#define ASYSCON_NFCTAGPADSCTRL_VDD_FILTEROFF_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_VDD_FILTEROFF_Pos)/*!< ASYSCON NFCTAGPADSCTRL: VDD_FILTEROFF Mask */
#define ASYSCON_NFCTAGPADSCTRL_VDD_EHS1_Pos 27                                                 /*!< ASYSCON NFCTAGPADSCTRL: VDD_EHS1 Position */
#define ASYSCON_NFCTAGPADSCTRL_VDD_EHS1_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_VDD_EHS1_Pos)/*!< ASYSCON NFCTAGPADSCTRL: VDD_EHS1 Mask */
#define ASYSCON_NFCTAGPADSCTRL_VDD_OD_Pos 28                                                   /*!< ASYSCON NFCTAGPADSCTRL: VDD_OD Position */
#define ASYSCON_NFCTAGPADSCTRL_VDD_OD_Msk (0x01UL << ASYSCON_NFCTAGPADSCTRL_VDD_OD_Pos) /*!< ASYSCON NFCTAGPADSCTRL: VDD_OD Mask */

/* ------------------------  u_async_syscon_XTAL32MLDOCTRL  ----------------------- */
#define ASYSCON_XTAL32MLDOCTRL_BYPASS_Pos 0                                                    /*!< ASYSCON XTAL32MLDOCTRL: BYPASS Position */
#define ASYSCON_XTAL32MLDOCTRL_BYPASS_Msk (0x01UL << ASYSCON_XTAL32MLDOCTRL_BYPASS_Pos) /*!< ASYSCON XTAL32MLDOCTRL: BYPASS Mask */
#define ASYSCON_XTAL32MLDOCTRL_ENABLE_Pos 1                                                    /*!< ASYSCON XTAL32MLDOCTRL: ENABLE Position */
#define ASYSCON_XTAL32MLDOCTRL_ENABLE_Msk (0x01UL << ASYSCON_XTAL32MLDOCTRL_ENABLE_Pos) /*!< ASYSCON XTAL32MLDOCTRL: ENABLE Mask */
#define ASYSCON_XTAL32MLDOCTRL_HIGHZ_Pos 2                                                     /*!< ASYSCON XTAL32MLDOCTRL: HIGHZ Position */
#define ASYSCON_XTAL32MLDOCTRL_HIGHZ_Msk (0x01UL << ASYSCON_XTAL32MLDOCTRL_HIGHZ_Pos)   /*!< ASYSCON XTAL32MLDOCTRL: HIGHZ Mask */
#define ASYSCON_XTAL32MLDOCTRL_VOUT_Pos 3                                                      /*!< ASYSCON XTAL32MLDOCTRL: VOUT Position */
#define ASYSCON_XTAL32MLDOCTRL_VOUT_Msk (0x07UL << ASYSCON_XTAL32MLDOCTRL_VOUT_Pos)     /*!< ASYSCON XTAL32MLDOCTRL: VOUT Mask */
#define ASYSCON_XTAL32MLDOCTRL_IBIAS_Pos 6                                                     /*!< ASYSCON XTAL32MLDOCTRL: IBIAS Position */
#define ASYSCON_XTAL32MLDOCTRL_IBIAS_Msk (0x03UL << ASYSCON_XTAL32MLDOCTRL_IBIAS_Pos)   /*!< ASYSCON XTAL32MLDOCTRL: IBIAS Mask */
#define ASYSCON_XTAL32MLDOCTRL_STABMODE_Pos 8                                                  /*!< ASYSCON XTAL32MLDOCTRL: STABMODE Position */
#define ASYSCON_XTAL32MLDOCTRL_STABMODE_Msk (0x03UL << ASYSCON_XTAL32MLDOCTRL_STABMODE_Pos)/*!< ASYSCON XTAL32MLDOCTRL: STABMODE Mask */

/* -------------------------  u_async_syscon_XTAL32MCTRL  ------------------------- */
#define ASYSCON_XTAL32MCTRL_XO_ACBUF_PASS_ENABLE_Pos 0                                         /*!< ASYSCON XTAL32MCTRL: XO_ACBUF_PASS_ENABLE Position */
#define ASYSCON_XTAL32MCTRL_XO_ACBUF_PASS_ENABLE_Msk (0x01UL << ASYSCON_XTAL32MCTRL_XO_ACBUF_PASS_ENABLE_Pos)/*!< ASYSCON XTAL32MCTRL: XO_ACBUF_PASS_ENABLE Mask */
#define ASYSCON_XTAL32MCTRL_XO_AMP_Pos 1                                                       /*!< ASYSCON XTAL32MCTRL: XO_AMP Position */
#define ASYSCON_XTAL32MCTRL_XO_AMP_Msk (0x07UL << ASYSCON_XTAL32MCTRL_XO_AMP_Pos)       /*!< ASYSCON XTAL32MCTRL: XO_AMP Mask */
#define ASYSCON_XTAL32MCTRL_XO_OSC_CAP_IN_Pos 4                                                /*!< ASYSCON XTAL32MCTRL: XO_OSC_CAP_IN Position */
#define ASYSCON_XTAL32MCTRL_XO_OSC_CAP_IN_Msk (0x7fUL << ASYSCON_XTAL32MCTRL_XO_OSC_CAP_IN_Pos)/*!< ASYSCON XTAL32MCTRL: XO_OSC_CAP_IN Mask */
#define ASYSCON_XTAL32MCTRL_XO_OSC_CAP_OUT_Pos 11                                              /*!< ASYSCON XTAL32MCTRL: XO_OSC_CAP_OUT Position */
#define ASYSCON_XTAL32MCTRL_XO_OSC_CAP_OUT_Msk (0x7fUL << ASYSCON_XTAL32MCTRL_XO_OSC_CAP_OUT_Pos)/*!< ASYSCON XTAL32MCTRL: XO_OSC_CAP_OUT Mask */
#define ASYSCON_XTAL32MCTRL_XO_ENABLE_Pos 22                                                   /*!< ASYSCON XTAL32MCTRL: XO_ENABLE Position */
#define ASYSCON_XTAL32MCTRL_XO_ENABLE_Msk (0x01UL << ASYSCON_XTAL32MCTRL_XO_ENABLE_Pos) /*!< ASYSCON XTAL32MCTRL: XO_ENABLE Mask */
#define ASYSCON_XTAL32MCTRL_XO_GM_Pos  23                                                      /*!< ASYSCON XTAL32MCTRL: XO_GM Position */
#define ASYSCON_XTAL32MCTRL_XO_GM_Msk  (0x07UL << ASYSCON_XTAL32MCTRL_XO_GM_Pos)        /*!< ASYSCON XTAL32MCTRL: XO_GM Mask  */
#define ASYSCON_XTAL32MCTRL_XO_SLAVE_Pos 26                                                    /*!< ASYSCON XTAL32MCTRL: XO_SLAVE Position */
#define ASYSCON_XTAL32MCTRL_XO_SLAVE_Msk (0x01UL << ASYSCON_XTAL32MCTRL_XO_SLAVE_Pos)   /*!< ASYSCON XTAL32MCTRL: XO_SLAVE Mask */
#define ASYSCON_XTAL32MCTRL_XO_STANDALONE_ENABLE_Pos 27                                        /*!< ASYSCON XTAL32MCTRL: XO_STANDALONE_ENABLE Position */
#define ASYSCON_XTAL32MCTRL_XO_STANDALONE_ENABLE_Msk (0x01UL << ASYSCON_XTAL32MCTRL_XO_STANDALONE_ENABLE_Pos)/*!< ASYSCON XTAL32MCTRL: XO_STANDALONE_ENABLE Mask */
#define ASYSCON_XTAL32MCTRL_XO32M_TO_MCU_ENABLE_Pos 28                                         /*!< ASYSCON XTAL32MCTRL: XO32M_TO_MCU_ENABLE Position */
#define ASYSCON_XTAL32MCTRL_XO32M_TO_MCU_ENABLE_Msk (0x01UL << ASYSCON_XTAL32MCTRL_XO32M_TO_MCU_ENABLE_Pos)/*!< ASYSCON XTAL32MCTRL: XO32M_TO_MCU_ENABLE Mask */
#define ASYSCON_XTAL32MCTRL_CLK_TO_GPADC_ENABLE_Pos 29                                         /*!< ASYSCON XTAL32MCTRL: CLK_TO_GPADC_ENABLE Position */
#define ASYSCON_XTAL32MCTRL_CLK_TO_GPADC_ENABLE_Msk (0x01UL << ASYSCON_XTAL32MCTRL_CLK_TO_GPADC_ENABLE_Pos)/*!< ASYSCON XTAL32MCTRL: CLK_TO_GPADC_ENABLE Mask */

/* ---------------------------  u_async_syscon_ANALOGID  -------------------------- */
#define ASYSCON_ANALOGID_PMUID_Pos     0                                                       /*!< ASYSCON ANALOGID: PMUID Position */
#define ASYSCON_ANALOGID_PMUID_Msk     (0x3fUL << ASYSCON_ANALOGID_PMUID_Pos)           /*!< ASYSCON ANALOGID: PMUID Mask     */
#define ASYSCON_ANALOGID_RADIOID_Pos   6                                                       /*!< ASYSCON ANALOGID: RADIOID Position */
#define ASYSCON_ANALOGID_RADIOID_Msk   (0x3fUL << ASYSCON_ANALOGID_RADIOID_Pos)         /*!< ASYSCON ANALOGID: RADIOID Mask   */

/* -------------------------  u_async_syscon_RADIOSTATUS  ------------------------- */
#define ASYSCON_RADIOSTATUS_PLLXOREADY_Pos 0                                                   /*!< ASYSCON RADIOSTATUS: PLLXOREADY Position */
#define ASYSCON_RADIOSTATUS_PLLXOREADY_Msk (0x01UL << ASYSCON_RADIOSTATUS_PLLXOREADY_Pos)/*!< ASYSCON RADIOSTATUS: PLLXOREADY Mask */

/* ------------------------  u_async_syscon_DIGITALSTATUS  ------------------------ */
#define ASYSCON_DIGITALSTATUS_FLASHINITERROR_Pos 0                                             /*!< ASYSCON DIGITALSTATUS: FLASHINITERROR Position */
#define ASYSCON_DIGITALSTATUS_FLASHINITERROR_Msk (0x01UL << ASYSCON_DIGITALSTATUS_FLASHINITERROR_Pos)/*!< ASYSCON DIGITALSTATUS: FLASHINITERROR Mask */

/* --------------------------  u_async_syscon_DCBUSCTRL  -------------------------- */
#define ASYSCON_DCBUSCTRL_ADDR_Pos     0                                                       /*!< ASYSCON DCBUSCTRL: ADDR Position */
#define ASYSCON_DCBUSCTRL_ADDR_Msk     (0x000001ffUL << ASYSCON_DCBUSCTRL_ADDR_Pos)     /*!< ASYSCON DCBUSCTRL: ADDR Mask     */
#define ASYSCON_DCBUSCTRL_MUX1_Pos     9                                                       /*!< ASYSCON DCBUSCTRL: MUX1 Position */
#define ASYSCON_DCBUSCTRL_MUX1_Msk     (0x0fUL << ASYSCON_DCBUSCTRL_MUX1_Pos)           /*!< ASYSCON DCBUSCTRL: MUX1 Mask     */
#define ASYSCON_DCBUSCTRL_MUX2_Pos     13                                                      /*!< ASYSCON DCBUSCTRL: MUX2 Position */
#define ASYSCON_DCBUSCTRL_MUX2_Msk     (0x0fUL << ASYSCON_DCBUSCTRL_MUX2_Pos)           /*!< ASYSCON DCBUSCTRL: MUX2 Mask     */

/* --------------------------  u_async_syscon_FREQMECTRL  ------------------------- */
#define ASYSCON_FREQMECTRL_CAPVAL_SCALE_Pos 0                                                  /*!< ASYSCON FREQMECTRL: CAPVAL_SCALE Position */
#define ASYSCON_FREQMECTRL_CAPVAL_SCALE_Msk (0x7fffffffUL << ASYSCON_FREQMECTRL_CAPVAL_SCALE_Pos)/*!< ASYSCON FREQMECTRL: CAPVAL_SCALE Mask */
#define ASYSCON_FREQMECTRL_PROG_Pos    31                                                      /*!< ASYSCON FREQMECTRL: PROG Position */
#define ASYSCON_FREQMECTRL_PROG_Msk    (0x01UL << ASYSCON_FREQMECTRL_PROG_Pos)          /*!< ASYSCON FREQMECTRL: PROG Mask    */

/* -----------------------  u_async_syscon_NFCTAGINTSTATUS  ----------------------- */
#define ASYSCON_NFCTAGINTSTATUS_NFCTAGINT_Pos 0                                                /*!< ASYSCON NFCTAGINTSTATUS: NFCTAGINT Position */
#define ASYSCON_NFCTAGINTSTATUS_NFCTAGINT_Msk (0x01UL << ASYSCON_NFCTAGINTSTATUS_NFCTAGINT_Pos)/*!< ASYSCON NFCTAGINTSTATUS: NFCTAGINT Mask */

/* --------------------------  u_async_syscon_NFCTAG_VDD  ------------------------- */
#define ASYSCON_NFCTAG_VDD_NFCTAG_VDD_OUT_Pos 0                                                /*!< ASYSCON NFCTAG_VDD: NFCTAG_VDD_OUT Position */
#define ASYSCON_NFCTAG_VDD_NFCTAG_VDD_OUT_Msk (0x01UL << ASYSCON_NFCTAG_VDD_NFCTAG_VDD_OUT_Pos)/*!< ASYSCON NFCTAG_VDD: NFCTAG_VDD_OUT Mask */
#define ASYSCON_NFCTAG_VDD_NFCTAG_VDD_OE_Pos 1                                                 /*!< ASYSCON NFCTAG_VDD: NFCTAG_VDD_OE Position */
#define ASYSCON_NFCTAG_VDD_NFCTAG_VDD_OE_Msk (0x01UL << ASYSCON_NFCTAG_VDD_NFCTAG_VDD_OE_Pos)/*!< ASYSCON NFCTAG_VDD: NFCTAG_VDD_OE Mask */

/* -------------------------  u_async_syscon_SWRESETCTRL  ------------------------- */
#define ASYSCON_SWRESETCTRL_ICRESETREQ_Pos 0                                                   /*!< ASYSCON SWRESETCTRL: ICRESETREQ Position */
#define ASYSCON_SWRESETCTRL_ICRESETREQ_Msk (0x01UL << ASYSCON_SWRESETCTRL_ICRESETREQ_Pos)/*!< ASYSCON SWRESETCTRL: ICRESETREQ Mask */
#define ASYSCON_SWRESETCTRL_VECTKEY_Pos 16                                                     /*!< ASYSCON SWRESETCTRL: VECTKEY Position */
#define ASYSCON_SWRESETCTRL_VECTKEY_Msk (0x0000ffffUL << ASYSCON_SWRESETCTRL_VECTKEY_Pos)/*!< ASYSCON SWRESETCTRL: VECTKEY Mask */


/* ================================================================================ */
/* ================        struct 'u0_timer' Position & Mask       ================ */
/* ================================================================================ */


/* ---------------------------------  u0_timer_IR  -------------------------------- */
#define CTIMER0_IR_MR0INT_Pos                0                                                       /*!< CTIMER0 IR: MR0INT Position            */
#define CTIMER0_IR_MR0INT_Msk                (0x01UL << CTIMER0_IR_MR0INT_Pos)                      /*!< CTIMER0 IR: MR0INT Mask                */
#define CTIMER0_IR_MR1INT_Pos                1                                                       /*!< CTIMER0 IR: MR1INT Position            */
#define CTIMER0_IR_MR1INT_Msk                (0x01UL << CTIMER0_IR_MR1INT_Pos)                      /*!< CTIMER0 IR: MR1INT Mask                */
#define CTIMER0_IR_MR2INT_Pos                2                                                       /*!< CTIMER0 IR: MR2INT Position            */
#define CTIMER0_IR_MR2INT_Msk                (0x01UL << CTIMER0_IR_MR2INT_Pos)                      /*!< CTIMER0 IR: MR2INT Mask                */
#define CTIMER0_IR_MR3INT_Pos                3                                                       /*!< CTIMER0 IR: MR3INT Position            */
#define CTIMER0_IR_MR3INT_Msk                (0x01UL << CTIMER0_IR_MR3INT_Pos)                      /*!< CTIMER0 IR: MR3INT Mask                */
#define CTIMER0_IR_CR0INT_Pos                4                                                       /*!< CTIMER0 IR: CR0INT Position            */
#define CTIMER0_IR_CR0INT_Msk                (0x01UL << CTIMER0_IR_CR0INT_Pos)                      /*!< CTIMER0 IR: CR0INT Mask                */
#define CTIMER0_IR_CR1INT_Pos                5                                                       /*!< CTIMER0 IR: CR1INT Position            */
#define CTIMER0_IR_CR1INT_Msk                (0x01UL << CTIMER0_IR_CR1INT_Pos)                      /*!< CTIMER0 IR: CR1INT Mask                */
#define CTIMER0_IR_CR2INT_Pos                6                                                       /*!< CTIMER0 IR: CR2INT Position            */
#define CTIMER0_IR_CR2INT_Msk                (0x01UL << CTIMER0_IR_CR2INT_Pos)                      /*!< CTIMER0 IR: CR2INT Mask                */
#define CTIMER0_IR_CR3INT_Pos                7                                                       /*!< CTIMER0 IR: CR3INT Position            */
#define CTIMER0_IR_CR3INT_Msk                (0x01UL << CTIMER0_IR_CR3INT_Pos)                      /*!< CTIMER0 IR: CR3INT Mask                */

/* --------------------------------  u0_timer_TCR  -------------------------------- */
#define CTIMER0_TCR_CEN_Pos                  0                                                       /*!< CTIMER0 TCR: CEN Position              */
#define CTIMER0_TCR_CEN_Msk                  (0x01UL << CTIMER0_TCR_CEN_Pos)                        /*!< CTIMER0 TCR: CEN Mask                  */
#define CTIMER0_TCR_CRST_Pos                 1                                                       /*!< CTIMER0 TCR: CRST Position             */
#define CTIMER0_TCR_CRST_Msk                 (0x01UL << CTIMER0_TCR_CRST_Pos)                       /*!< CTIMER0 TCR: CRST Mask                 */

/* ---------------------------------  u0_timer_TC  -------------------------------- */
#define CTIMER0_TC_TCVAL_Pos                 0                                                       /*!< CTIMER0 TC: TCVAL Position             */
#define CTIMER0_TC_TCVAL_Msk                 (0xffffffffUL << CTIMER0_TC_TCVAL_Pos)                 /*!< CTIMER0 TC: TCVAL Mask                 */

/* ---------------------------------  u0_timer_PR  -------------------------------- */
#define CTIMER0_PR_PRVAL_Pos                 0                                                       /*!< CTIMER0 PR: PRVAL Position             */
#define CTIMER0_PR_PRVAL_Msk                 (0xffffffffUL << CTIMER0_PR_PRVAL_Pos)                 /*!< CTIMER0 PR: PRVAL Mask                 */

/* ---------------------------------  u0_timer_PC  -------------------------------- */
#define CTIMER0_PC_PCVAL_Pos                 0                                                       /*!< CTIMER0 PC: PCVAL Position             */
#define CTIMER0_PC_PCVAL_Msk                 (0xffffffffUL << CTIMER0_PC_PCVAL_Pos)                 /*!< CTIMER0 PC: PCVAL Mask                 */

/* --------------------------------  u0_timer_MCR  -------------------------------- */
#define CTIMER0_MCR_MR0I_Pos                 0                                                       /*!< CTIMER0 MCR: MR0I Position             */
#define CTIMER0_MCR_MR0I_Msk                 (0x01UL << CTIMER0_MCR_MR0I_Pos)                       /*!< CTIMER0 MCR: MR0I Mask                 */
#define CTIMER0_MCR_MR0R_Pos                 1                                                       /*!< CTIMER0 MCR: MR0R Position             */
#define CTIMER0_MCR_MR0R_Msk                 (0x01UL << CTIMER0_MCR_MR0R_Pos)                       /*!< CTIMER0 MCR: MR0R Mask                 */
#define CTIMER0_MCR_MR0S_Pos                 2                                                       /*!< CTIMER0 MCR: MR0S Position             */
#define CTIMER0_MCR_MR0S_Msk                 (0x01UL << CTIMER0_MCR_MR0S_Pos)                       /*!< CTIMER0 MCR: MR0S Mask                 */
#define CTIMER0_MCR_MR1I_Pos                 3                                                       /*!< CTIMER0 MCR: MR1I Position             */
#define CTIMER0_MCR_MR1I_Msk                 (0x01UL << CTIMER0_MCR_MR1I_Pos)                       /*!< CTIMER0 MCR: MR1I Mask                 */
#define CTIMER0_MCR_MR1R_Pos                 4                                                       /*!< CTIMER0 MCR: MR1R Position             */
#define CTIMER0_MCR_MR1R_Msk                 (0x01UL << CTIMER0_MCR_MR1R_Pos)                       /*!< CTIMER0 MCR: MR1R Mask                 */
#define CTIMER0_MCR_MR1S_Pos                 5                                                       /*!< CTIMER0 MCR: MR1S Position             */
#define CTIMER0_MCR_MR1S_Msk                 (0x01UL << CTIMER0_MCR_MR1S_Pos)                       /*!< CTIMER0 MCR: MR1S Mask                 */
#define CTIMER0_MCR_MR2I_Pos                 6                                                       /*!< CTIMER0 MCR: MR2I Position             */
#define CTIMER0_MCR_MR2I_Msk                 (0x01UL << CTIMER0_MCR_MR2I_Pos)                       /*!< CTIMER0 MCR: MR2I Mask                 */
#define CTIMER0_MCR_MR2R_Pos                 7                                                       /*!< CTIMER0 MCR: MR2R Position             */
#define CTIMER0_MCR_MR2R_Msk                 (0x01UL << CTIMER0_MCR_MR2R_Pos)                       /*!< CTIMER0 MCR: MR2R Mask                 */
#define CTIMER0_MCR_MR2S_Pos                 8                                                       /*!< CTIMER0 MCR: MR2S Position             */
#define CTIMER0_MCR_MR2S_Msk                 (0x01UL << CTIMER0_MCR_MR2S_Pos)                       /*!< CTIMER0 MCR: MR2S Mask                 */
#define CTIMER0_MCR_MR3I_Pos                 9                                                       /*!< CTIMER0 MCR: MR3I Position             */
#define CTIMER0_MCR_MR3I_Msk                 (0x01UL << CTIMER0_MCR_MR3I_Pos)                       /*!< CTIMER0 MCR: MR3I Mask                 */
#define CTIMER0_MCR_MR3R_Pos                 10                                                      /*!< CTIMER0 MCR: MR3R Position             */
#define CTIMER0_MCR_MR3R_Msk                 (0x01UL << CTIMER0_MCR_MR3R_Pos)                       /*!< CTIMER0 MCR: MR3R Mask                 */
#define CTIMER0_MCR_MR3S_Pos                 11                                                      /*!< CTIMER0 MCR: MR3S Position             */
#define CTIMER0_MCR_MR3S_Msk                 (0x01UL << CTIMER0_MCR_MR3S_Pos)                       /*!< CTIMER0 MCR: MR3S Mask                 */

/* --------------------------------  u0_timer_MR0  -------------------------------- */
#define CTIMER0_MR0_MATCH_Pos                0                                                       /*!< CTIMER0 MR0: MATCH Position            */
#define CTIMER0_MR0_MATCH_Msk                (0xffffffffUL << CTIMER0_MR0_MATCH_Pos)                /*!< CTIMER0 MR0: MATCH Mask                */

/* --------------------------------  u0_timer_MR1  -------------------------------- */
#define CTIMER0_MR1_MATCH_Pos                0                                                       /*!< CTIMER0 MR1: MATCH Position            */
#define CTIMER0_MR1_MATCH_Msk                (0xffffffffUL << CTIMER0_MR1_MATCH_Pos)                /*!< CTIMER0 MR1: MATCH Mask                */

/* --------------------------------  u0_timer_MR2  -------------------------------- */
#define CTIMER0_MR2_MATCH_Pos                0                                                       /*!< CTIMER0 MR2: MATCH Position            */
#define CTIMER0_MR2_MATCH_Msk                (0xffffffffUL << CTIMER0_MR2_MATCH_Pos)                /*!< CTIMER0 MR2: MATCH Mask                */

/* --------------------------------  u0_timer_MR3  -------------------------------- */
#define CTIMER0_MR3_MATCH_Pos                0                                                       /*!< CTIMER0 MR3: MATCH Position            */
#define CTIMER0_MR3_MATCH_Msk                (0xffffffffUL << CTIMER0_MR3_MATCH_Pos)                /*!< CTIMER0 MR3: MATCH Mask                */

/* --------------------------------  u0_timer_CCR  -------------------------------- */
#define CTIMER0_CCR_CAP0RE_Pos               0                                                       /*!< CTIMER0 CCR: CAP0RE Position           */
#define CTIMER0_CCR_CAP0RE_Msk               (0x01UL << CTIMER0_CCR_CAP0RE_Pos)                     /*!< CTIMER0 CCR: CAP0RE Mask               */
#define CTIMER0_CCR_CAP0FE_Pos               1                                                       /*!< CTIMER0 CCR: CAP0FE Position           */
#define CTIMER0_CCR_CAP0FE_Msk               (0x01UL << CTIMER0_CCR_CAP0FE_Pos)                     /*!< CTIMER0 CCR: CAP0FE Mask               */
#define CTIMER0_CCR_CAP0I_Pos                2                                                       /*!< CTIMER0 CCR: CAP0I Position            */
#define CTIMER0_CCR_CAP0I_Msk                (0x01UL << CTIMER0_CCR_CAP0I_Pos)                      /*!< CTIMER0 CCR: CAP0I Mask                */
#define CTIMER0_CCR_CAP1RE_Pos               3                                                       /*!< CTIMER0 CCR: CAP1RE Position           */
#define CTIMER0_CCR_CAP1RE_Msk               (0x01UL << CTIMER0_CCR_CAP1RE_Pos)                     /*!< CTIMER0 CCR: CAP1RE Mask               */
#define CTIMER0_CCR_CAP1FE_Pos               4                                                       /*!< CTIMER0 CCR: CAP1FE Position           */
#define CTIMER0_CCR_CAP1FE_Msk               (0x01UL << CTIMER0_CCR_CAP1FE_Pos)                     /*!< CTIMER0 CCR: CAP1FE Mask               */
#define CTIMER0_CCR_CAP1I_Pos                5                                                       /*!< CTIMER0 CCR: CAP1I Position            */
#define CTIMER0_CCR_CAP1I_Msk                (0x01UL << CTIMER0_CCR_CAP1I_Pos)                      /*!< CTIMER0 CCR: CAP1I Mask                */
#define CTIMER0_CCR_CAP2RE_Pos               6                                                       /*!< CTIMER0 CCR: CAP2RE Position           */
#define CTIMER0_CCR_CAP2RE_Msk               (0x01UL << CTIMER0_CCR_CAP2RE_Pos)                     /*!< CTIMER0 CCR: CAP2RE Mask               */
#define CTIMER0_CCR_CAP2FE_Pos               7                                                       /*!< CTIMER0 CCR: CAP2FE Position           */
#define CTIMER0_CCR_CAP2FE_Msk               (0x01UL << CTIMER0_CCR_CAP2FE_Pos)                     /*!< CTIMER0 CCR: CAP2FE Mask               */
#define CTIMER0_CCR_CAP2I_Pos                8                                                       /*!< CTIMER0 CCR: CAP2I Position            */
#define CTIMER0_CCR_CAP2I_Msk                (0x01UL << CTIMER0_CCR_CAP2I_Pos)                      /*!< CTIMER0 CCR: CAP2I Mask                */
#define CTIMER0_CCR_CAP3RE_Pos               9                                                       /*!< CTIMER0 CCR: CAP3RE Position           */
#define CTIMER0_CCR_CAP3RE_Msk               (0x01UL << CTIMER0_CCR_CAP3RE_Pos)                     /*!< CTIMER0 CCR: CAP3RE Mask               */
#define CTIMER0_CCR_CAP3FE_Pos               10                                                      /*!< CTIMER0 CCR: CAP3FE Position           */
#define CTIMER0_CCR_CAP3FE_Msk               (0x01UL << CTIMER0_CCR_CAP3FE_Pos)                     /*!< CTIMER0 CCR: CAP3FE Mask               */
#define CTIMER0_CCR_CAP3I_Pos                11                                                      /*!< CTIMER0 CCR: CAP3I Position            */
#define CTIMER0_CCR_CAP3I_Msk                (0x01UL << CTIMER0_CCR_CAP3I_Pos)                      /*!< CTIMER0 CCR: CAP3I Mask                */

/* --------------------------------  u0_timer_CR0  -------------------------------- */
#define CTIMER0_CR0_CAP_Pos                  0                                                       /*!< CTIMER0 CR0: CAP Position              */
#define CTIMER0_CR0_CAP_Msk                  (0xffffffffUL << CTIMER0_CR0_CAP_Pos)                  /*!< CTIMER0 CR0: CAP Mask                  */

/* --------------------------------  u0_timer_CR1  -------------------------------- */
#define CTIMER0_CR1_CAP_Pos                  0                                                       /*!< CTIMER0 CR1: CAP Position              */
#define CTIMER0_CR1_CAP_Msk                  (0xffffffffUL << CTIMER0_CR1_CAP_Pos)                  /*!< CTIMER0 CR1: CAP Mask                  */

/* --------------------------------  u0_timer_CR2  -------------------------------- */
#define CTIMER0_CR2_CAP_Pos                  0                                                       /*!< CTIMER0 CR2: CAP Position              */
#define CTIMER0_CR2_CAP_Msk                  (0xffffffffUL << CTIMER0_CR2_CAP_Pos)                  /*!< CTIMER0 CR2: CAP Mask                  */

/* --------------------------------  u0_timer_CR3  -------------------------------- */
#define CTIMER0_CR3_CAP_Pos                  0                                                       /*!< CTIMER0 CR3: CAP Position              */
#define CTIMER0_CR3_CAP_Msk                  (0xffffffffUL << CTIMER0_CR3_CAP_Pos)                  /*!< CTIMER0 CR3: CAP Mask                  */

/* --------------------------------  u0_timer_EMR  -------------------------------- */
#define CTIMER0_EMR_EM0_Pos                  0                                                       /*!< CTIMER0 EMR: EM0 Position              */
#define CTIMER0_EMR_EM0_Msk                  (0x01UL << CTIMER0_EMR_EM0_Pos)                        /*!< CTIMER0 EMR: EM0 Mask                  */
#define CTIMER0_EMR_EM1_Pos                  1                                                       /*!< CTIMER0 EMR: EM1 Position              */
#define CTIMER0_EMR_EM1_Msk                  (0x01UL << CTIMER0_EMR_EM1_Pos)                        /*!< CTIMER0 EMR: EM1 Mask                  */
#define CTIMER0_EMR_EM2_Pos                  2                                                       /*!< CTIMER0 EMR: EM2 Position              */
#define CTIMER0_EMR_EM2_Msk                  (0x01UL << CTIMER0_EMR_EM2_Pos)                        /*!< CTIMER0 EMR: EM2 Mask                  */
#define CTIMER0_EMR_EM3_Pos                  3                                                       /*!< CTIMER0 EMR: EM3 Position              */
#define CTIMER0_EMR_EM3_Msk                  (0x01UL << CTIMER0_EMR_EM3_Pos)                        /*!< CTIMER0 EMR: EM3 Mask                  */
#define CTIMER0_EMR_EMC0_Pos                 4                                                       /*!< CTIMER0 EMR: EMC0 Position             */
#define CTIMER0_EMR_EMC0_Msk                 (0x03UL << CTIMER0_EMR_EMC0_Pos)                       /*!< CTIMER0 EMR: EMC0 Mask                 */
#define CTIMER0_EMR_EMC1_Pos                 6                                                       /*!< CTIMER0 EMR: EMC1 Position             */
#define CTIMER0_EMR_EMC1_Msk                 (0x03UL << CTIMER0_EMR_EMC1_Pos)                       /*!< CTIMER0 EMR: EMC1 Mask                 */
#define CTIMER0_EMR_EMC2_Pos                 8                                                       /*!< CTIMER0 EMR: EMC2 Position             */
#define CTIMER0_EMR_EMC2_Msk                 (0x03UL << CTIMER0_EMR_EMC2_Pos)                       /*!< CTIMER0 EMR: EMC2 Mask                 */
#define CTIMER0_EMR_EMC3_Pos                 10                                                      /*!< CTIMER0 EMR: EMC3 Position             */
#define CTIMER0_EMR_EMC3_Msk                 (0x03UL << CTIMER0_EMR_EMC3_Pos)                       /*!< CTIMER0 EMR: EMC3 Mask                 */

/* --------------------------------  u0_timer_CTCR  ------------------------------- */
#define CTIMER0_CTCR_CTMODE_Pos              0                                                       /*!< CTIMER0 CTCR: CTMODE Position          */
#define CTIMER0_CTCR_CTMODE_Msk              (0x03UL << CTIMER0_CTCR_CTMODE_Pos)                    /*!< CTIMER0 CTCR: CTMODE Mask              */
#define CTIMER0_CTCR_CINSEL_Pos              2                                                       /*!< CTIMER0 CTCR: CINSEL Position          */
#define CTIMER0_CTCR_CINSEL_Msk              (0x03UL << CTIMER0_CTCR_CINSEL_Pos)                    /*!< CTIMER0 CTCR: CINSEL Mask              */
#define CTIMER0_CTCR_ENCC_Pos                4                                                       /*!< CTIMER0 CTCR: ENCC Position            */
#define CTIMER0_CTCR_ENCC_Msk                (0x01UL << CTIMER0_CTCR_ENCC_Pos)                      /*!< CTIMER0 CTCR: ENCC Mask                */
#define CTIMER0_CTCR_SELCC_Pos               5                                                       /*!< CTIMER0 CTCR: SELCC Position           */
#define CTIMER0_CTCR_SELCC_Msk               (0x07UL << CTIMER0_CTCR_SELCC_Pos)                     /*!< CTIMER0 CTCR: SELCC Mask               */

/* --------------------------------  u0_timer_PWMC  ------------------------------- */
#define CTIMER0_PWMC_PWMEN0_Pos              0                                                       /*!< CTIMER0 PWMC: PWMEN0 Position          */
#define CTIMER0_PWMC_PWMEN0_Msk              (0x01UL << CTIMER0_PWMC_PWMEN0_Pos)                    /*!< CTIMER0 PWMC: PWMEN0 Mask              */
#define CTIMER0_PWMC_PWMEN1_Pos              1                                                       /*!< CTIMER0 PWMC: PWMEN1 Position          */
#define CTIMER0_PWMC_PWMEN1_Msk              (0x01UL << CTIMER0_PWMC_PWMEN1_Pos)                    /*!< CTIMER0 PWMC: PWMEN1 Mask              */
#define CTIMER0_PWMC_PWMEN2_Pos              2                                                       /*!< CTIMER0 PWMC: PWMEN2 Position          */
#define CTIMER0_PWMC_PWMEN2_Msk              (0x01UL << CTIMER0_PWMC_PWMEN2_Pos)                    /*!< CTIMER0 PWMC: PWMEN2 Mask              */
#define CTIMER0_PWMC_PWMEN3_Pos              3                                                       /*!< CTIMER0 PWMC: PWMEN3 Position          */
#define CTIMER0_PWMC_PWMEN3_Msk              (0x01UL << CTIMER0_PWMC_PWMEN3_Pos)                    /*!< CTIMER0 PWMC: PWMEN3 Mask              */


/* ================================================================================ */
/* ================        struct 'u1_timer' Position & Mask       ================ */
/* ================================================================================ */


/* ---------------------------------  u1_timer_IR  -------------------------------- */
#define CTIMER1_IR_MR0INT_Pos                0                                                       /*!< CTIMER1 IR: MR0INT Position            */
#define CTIMER1_IR_MR0INT_Msk                (0x01UL << CTIMER1_IR_MR0INT_Pos)                      /*!< CTIMER1 IR: MR0INT Mask                */
#define CTIMER1_IR_MR1INT_Pos                1                                                       /*!< CTIMER1 IR: MR1INT Position            */
#define CTIMER1_IR_MR1INT_Msk                (0x01UL << CTIMER1_IR_MR1INT_Pos)                      /*!< CTIMER1 IR: MR1INT Mask                */
#define CTIMER1_IR_MR2INT_Pos                2                                                       /*!< CTIMER1 IR: MR2INT Position            */
#define CTIMER1_IR_MR2INT_Msk                (0x01UL << CTIMER1_IR_MR2INT_Pos)                      /*!< CTIMER1 IR: MR2INT Mask                */
#define CTIMER1_IR_MR3INT_Pos                3                                                       /*!< CTIMER1 IR: MR3INT Position            */
#define CTIMER1_IR_MR3INT_Msk                (0x01UL << CTIMER1_IR_MR3INT_Pos)                      /*!< CTIMER1 IR: MR3INT Mask                */
#define CTIMER1_IR_CR0INT_Pos                4                                                       /*!< CTIMER1 IR: CR0INT Position            */
#define CTIMER1_IR_CR0INT_Msk                (0x01UL << CTIMER1_IR_CR0INT_Pos)                      /*!< CTIMER1 IR: CR0INT Mask                */
#define CTIMER1_IR_CR1INT_Pos                5                                                       /*!< CTIMER1 IR: CR1INT Position            */
#define CTIMER1_IR_CR1INT_Msk                (0x01UL << CTIMER1_IR_CR1INT_Pos)                      /*!< CTIMER1 IR: CR1INT Mask                */
#define CTIMER1_IR_CR2INT_Pos                6                                                       /*!< CTIMER1 IR: CR2INT Position            */
#define CTIMER1_IR_CR2INT_Msk                (0x01UL << CTIMER1_IR_CR2INT_Pos)                      /*!< CTIMER1 IR: CR2INT Mask                */
#define CTIMER1_IR_CR3INT_Pos                7                                                       /*!< CTIMER1 IR: CR3INT Position            */
#define CTIMER1_IR_CR3INT_Msk                (0x01UL << CTIMER1_IR_CR3INT_Pos)                      /*!< CTIMER1 IR: CR3INT Mask                */

/* --------------------------------  u1_timer_TCR  -------------------------------- */
#define CTIMER1_TCR_CEN_Pos                  0                                                       /*!< CTIMER1 TCR: CEN Position              */
#define CTIMER1_TCR_CEN_Msk                  (0x01UL << CTIMER1_TCR_CEN_Pos)                        /*!< CTIMER1 TCR: CEN Mask                  */
#define CTIMER1_TCR_CRST_Pos                 1                                                       /*!< CTIMER1 TCR: CRST Position             */
#define CTIMER1_TCR_CRST_Msk                 (0x01UL << CTIMER1_TCR_CRST_Pos)                       /*!< CTIMER1 TCR: CRST Mask                 */

/* ---------------------------------  u1_timer_TC  -------------------------------- */
#define CTIMER1_TC_TCVAL_Pos                 0                                                       /*!< CTIMER1 TC: TCVAL Position             */
#define CTIMER1_TC_TCVAL_Msk                 (0xffffffffUL << CTIMER1_TC_TCVAL_Pos)                 /*!< CTIMER1 TC: TCVAL Mask                 */

/* ---------------------------------  u1_timer_PR  -------------------------------- */
#define CTIMER1_PR_PRVAL_Pos                 0                                                       /*!< CTIMER1 PR: PRVAL Position             */
#define CTIMER1_PR_PRVAL_Msk                 (0xffffffffUL << CTIMER1_PR_PRVAL_Pos)                 /*!< CTIMER1 PR: PRVAL Mask                 */

/* ---------------------------------  u1_timer_PC  -------------------------------- */
#define CTIMER1_PC_PCVAL_Pos                 0                                                       /*!< CTIMER1 PC: PCVAL Position             */
#define CTIMER1_PC_PCVAL_Msk                 (0xffffffffUL << CTIMER1_PC_PCVAL_Pos)                 /*!< CTIMER1 PC: PCVAL Mask                 */

/* --------------------------------  u1_timer_MCR  -------------------------------- */
#define CTIMER1_MCR_MR0I_Pos                 0                                                       /*!< CTIMER1 MCR: MR0I Position             */
#define CTIMER1_MCR_MR0I_Msk                 (0x01UL << CTIMER1_MCR_MR0I_Pos)                       /*!< CTIMER1 MCR: MR0I Mask                 */
#define CTIMER1_MCR_MR0R_Pos                 1                                                       /*!< CTIMER1 MCR: MR0R Position             */
#define CTIMER1_MCR_MR0R_Msk                 (0x01UL << CTIMER1_MCR_MR0R_Pos)                       /*!< CTIMER1 MCR: MR0R Mask                 */
#define CTIMER1_MCR_MR0S_Pos                 2                                                       /*!< CTIMER1 MCR: MR0S Position             */
#define CTIMER1_MCR_MR0S_Msk                 (0x01UL << CTIMER1_MCR_MR0S_Pos)                       /*!< CTIMER1 MCR: MR0S Mask                 */
#define CTIMER1_MCR_MR1I_Pos                 3                                                       /*!< CTIMER1 MCR: MR1I Position             */
#define CTIMER1_MCR_MR1I_Msk                 (0x01UL << CTIMER1_MCR_MR1I_Pos)                       /*!< CTIMER1 MCR: MR1I Mask                 */
#define CTIMER1_MCR_MR1R_Pos                 4                                                       /*!< CTIMER1 MCR: MR1R Position             */
#define CTIMER1_MCR_MR1R_Msk                 (0x01UL << CTIMER1_MCR_MR1R_Pos)                       /*!< CTIMER1 MCR: MR1R Mask                 */
#define CTIMER1_MCR_MR1S_Pos                 5                                                       /*!< CTIMER1 MCR: MR1S Position             */
#define CTIMER1_MCR_MR1S_Msk                 (0x01UL << CTIMER1_MCR_MR1S_Pos)                       /*!< CTIMER1 MCR: MR1S Mask                 */
#define CTIMER1_MCR_MR2I_Pos                 6                                                       /*!< CTIMER1 MCR: MR2I Position             */
#define CTIMER1_MCR_MR2I_Msk                 (0x01UL << CTIMER1_MCR_MR2I_Pos)                       /*!< CTIMER1 MCR: MR2I Mask                 */
#define CTIMER1_MCR_MR2R_Pos                 7                                                       /*!< CTIMER1 MCR: MR2R Position             */
#define CTIMER1_MCR_MR2R_Msk                 (0x01UL << CTIMER1_MCR_MR2R_Pos)                       /*!< CTIMER1 MCR: MR2R Mask                 */
#define CTIMER1_MCR_MR2S_Pos                 8                                                       /*!< CTIMER1 MCR: MR2S Position             */
#define CTIMER1_MCR_MR2S_Msk                 (0x01UL << CTIMER1_MCR_MR2S_Pos)                       /*!< CTIMER1 MCR: MR2S Mask                 */
#define CTIMER1_MCR_MR3I_Pos                 9                                                       /*!< CTIMER1 MCR: MR3I Position             */
#define CTIMER1_MCR_MR3I_Msk                 (0x01UL << CTIMER1_MCR_MR3I_Pos)                       /*!< CTIMER1 MCR: MR3I Mask                 */
#define CTIMER1_MCR_MR3R_Pos                 10                                                      /*!< CTIMER1 MCR: MR3R Position             */
#define CTIMER1_MCR_MR3R_Msk                 (0x01UL << CTIMER1_MCR_MR3R_Pos)                       /*!< CTIMER1 MCR: MR3R Mask                 */
#define CTIMER1_MCR_MR3S_Pos                 11                                                      /*!< CTIMER1 MCR: MR3S Position             */
#define CTIMER1_MCR_MR3S_Msk                 (0x01UL << CTIMER1_MCR_MR3S_Pos)                       /*!< CTIMER1 MCR: MR3S Mask                 */

/* --------------------------------  u1_timer_MR0  -------------------------------- */
#define CTIMER1_MR0_MATCH_Pos                0                                                       /*!< CTIMER1 MR0: MATCH Position            */
#define CTIMER1_MR0_MATCH_Msk                (0xffffffffUL << CTIMER1_MR0_MATCH_Pos)                /*!< CTIMER1 MR0: MATCH Mask                */

/* --------------------------------  u1_timer_MR1  -------------------------------- */
#define CTIMER1_MR1_MATCH_Pos                0                                                       /*!< CTIMER1 MR1: MATCH Position            */
#define CTIMER1_MR1_MATCH_Msk                (0xffffffffUL << CTIMER1_MR1_MATCH_Pos)                /*!< CTIMER1 MR1: MATCH Mask                */

/* --------------------------------  u1_timer_MR2  -------------------------------- */
#define CTIMER1_MR2_MATCH_Pos                0                                                       /*!< CTIMER1 MR2: MATCH Position            */
#define CTIMER1_MR2_MATCH_Msk                (0xffffffffUL << CTIMER1_MR2_MATCH_Pos)                /*!< CTIMER1 MR2: MATCH Mask                */

/* --------------------------------  u1_timer_MR3  -------------------------------- */
#define CTIMER1_MR3_MATCH_Pos                0                                                       /*!< CTIMER1 MR3: MATCH Position            */
#define CTIMER1_MR3_MATCH_Msk                (0xffffffffUL << CTIMER1_MR3_MATCH_Pos)                /*!< CTIMER1 MR3: MATCH Mask                */

/* --------------------------------  u1_timer_CCR  -------------------------------- */
#define CTIMER1_CCR_CAP0RE_Pos               0                                                       /*!< CTIMER1 CCR: CAP0RE Position           */
#define CTIMER1_CCR_CAP0RE_Msk               (0x01UL << CTIMER1_CCR_CAP0RE_Pos)                     /*!< CTIMER1 CCR: CAP0RE Mask               */
#define CTIMER1_CCR_CAP0FE_Pos               1                                                       /*!< CTIMER1 CCR: CAP0FE Position           */
#define CTIMER1_CCR_CAP0FE_Msk               (0x01UL << CTIMER1_CCR_CAP0FE_Pos)                     /*!< CTIMER1 CCR: CAP0FE Mask               */
#define CTIMER1_CCR_CAP0I_Pos                2                                                       /*!< CTIMER1 CCR: CAP0I Position            */
#define CTIMER1_CCR_CAP0I_Msk                (0x01UL << CTIMER1_CCR_CAP0I_Pos)                      /*!< CTIMER1 CCR: CAP0I Mask                */
#define CTIMER1_CCR_CAP1RE_Pos               3                                                       /*!< CTIMER1 CCR: CAP1RE Position           */
#define CTIMER1_CCR_CAP1RE_Msk               (0x01UL << CTIMER1_CCR_CAP1RE_Pos)                     /*!< CTIMER1 CCR: CAP1RE Mask               */
#define CTIMER1_CCR_CAP1FE_Pos               4                                                       /*!< CTIMER1 CCR: CAP1FE Position           */
#define CTIMER1_CCR_CAP1FE_Msk               (0x01UL << CTIMER1_CCR_CAP1FE_Pos)                     /*!< CTIMER1 CCR: CAP1FE Mask               */
#define CTIMER1_CCR_CAP1I_Pos                5                                                       /*!< CTIMER1 CCR: CAP1I Position            */
#define CTIMER1_CCR_CAP1I_Msk                (0x01UL << CTIMER1_CCR_CAP1I_Pos)                      /*!< CTIMER1 CCR: CAP1I Mask                */
#define CTIMER1_CCR_CAP2RE_Pos               6                                                       /*!< CTIMER1 CCR: CAP2RE Position           */
#define CTIMER1_CCR_CAP2RE_Msk               (0x01UL << CTIMER1_CCR_CAP2RE_Pos)                     /*!< CTIMER1 CCR: CAP2RE Mask               */
#define CTIMER1_CCR_CAP2FE_Pos               7                                                       /*!< CTIMER1 CCR: CAP2FE Position           */
#define CTIMER1_CCR_CAP2FE_Msk               (0x01UL << CTIMER1_CCR_CAP2FE_Pos)                     /*!< CTIMER1 CCR: CAP2FE Mask               */
#define CTIMER1_CCR_CAP2I_Pos                8                                                       /*!< CTIMER1 CCR: CAP2I Position            */
#define CTIMER1_CCR_CAP2I_Msk                (0x01UL << CTIMER1_CCR_CAP2I_Pos)                      /*!< CTIMER1 CCR: CAP2I Mask                */
#define CTIMER1_CCR_CAP3RE_Pos               9                                                       /*!< CTIMER1 CCR: CAP3RE Position           */
#define CTIMER1_CCR_CAP3RE_Msk               (0x01UL << CTIMER1_CCR_CAP3RE_Pos)                     /*!< CTIMER1 CCR: CAP3RE Mask               */
#define CTIMER1_CCR_CAP3FE_Pos               10                                                      /*!< CTIMER1 CCR: CAP3FE Position           */
#define CTIMER1_CCR_CAP3FE_Msk               (0x01UL << CTIMER1_CCR_CAP3FE_Pos)                     /*!< CTIMER1 CCR: CAP3FE Mask               */
#define CTIMER1_CCR_CAP3I_Pos                11                                                      /*!< CTIMER1 CCR: CAP3I Position            */
#define CTIMER1_CCR_CAP3I_Msk                (0x01UL << CTIMER1_CCR_CAP3I_Pos)                      /*!< CTIMER1 CCR: CAP3I Mask                */

/* --------------------------------  u1_timer_CR0  -------------------------------- */
#define CTIMER1_CR0_CAP_Pos                  0                                                       /*!< CTIMER1 CR0: CAP Position              */
#define CTIMER1_CR0_CAP_Msk                  (0xffffffffUL << CTIMER1_CR0_CAP_Pos)                  /*!< CTIMER1 CR0: CAP Mask                  */

/* --------------------------------  u1_timer_CR1  -------------------------------- */
#define CTIMER1_CR1_CAP_Pos                  0                                                       /*!< CTIMER1 CR1: CAP Position              */
#define CTIMER1_CR1_CAP_Msk                  (0xffffffffUL << CTIMER1_CR1_CAP_Pos)                  /*!< CTIMER1 CR1: CAP Mask                  */

/* --------------------------------  u1_timer_CR2  -------------------------------- */
#define CTIMER1_CR2_CAP_Pos                  0                                                       /*!< CTIMER1 CR2: CAP Position              */
#define CTIMER1_CR2_CAP_Msk                  (0xffffffffUL << CTIMER1_CR2_CAP_Pos)                  /*!< CTIMER1 CR2: CAP Mask                  */

/* --------------------------------  u1_timer_CR3  -------------------------------- */
#define CTIMER1_CR3_CAP_Pos                  0                                                       /*!< CTIMER1 CR3: CAP Position              */
#define CTIMER1_CR3_CAP_Msk                  (0xffffffffUL << CTIMER1_CR3_CAP_Pos)                  /*!< CTIMER1 CR3: CAP Mask                  */

/* --------------------------------  u1_timer_EMR  -------------------------------- */
#define CTIMER1_EMR_EM0_Pos                  0                                                       /*!< CTIMER1 EMR: EM0 Position              */
#define CTIMER1_EMR_EM0_Msk                  (0x01UL << CTIMER1_EMR_EM0_Pos)                        /*!< CTIMER1 EMR: EM0 Mask                  */
#define CTIMER1_EMR_EM1_Pos                  1                                                       /*!< CTIMER1 EMR: EM1 Position              */
#define CTIMER1_EMR_EM1_Msk                  (0x01UL << CTIMER1_EMR_EM1_Pos)                        /*!< CTIMER1 EMR: EM1 Mask                  */
#define CTIMER1_EMR_EM2_Pos                  2                                                       /*!< CTIMER1 EMR: EM2 Position              */
#define CTIMER1_EMR_EM2_Msk                  (0x01UL << CTIMER1_EMR_EM2_Pos)                        /*!< CTIMER1 EMR: EM2 Mask                  */
#define CTIMER1_EMR_EM3_Pos                  3                                                       /*!< CTIMER1 EMR: EM3 Position              */
#define CTIMER1_EMR_EM3_Msk                  (0x01UL << CTIMER1_EMR_EM3_Pos)                        /*!< CTIMER1 EMR: EM3 Mask                  */
#define CTIMER1_EMR_EMC0_Pos                 4                                                       /*!< CTIMER1 EMR: EMC0 Position             */
#define CTIMER1_EMR_EMC0_Msk                 (0x03UL << CTIMER1_EMR_EMC0_Pos)                       /*!< CTIMER1 EMR: EMC0 Mask                 */
#define CTIMER1_EMR_EMC1_Pos                 6                                                       /*!< CTIMER1 EMR: EMC1 Position             */
#define CTIMER1_EMR_EMC1_Msk                 (0x03UL << CTIMER1_EMR_EMC1_Pos)                       /*!< CTIMER1 EMR: EMC1 Mask                 */
#define CTIMER1_EMR_EMC2_Pos                 8                                                       /*!< CTIMER1 EMR: EMC2 Position             */
#define CTIMER1_EMR_EMC2_Msk                 (0x03UL << CTIMER1_EMR_EMC2_Pos)                       /*!< CTIMER1 EMR: EMC2 Mask                 */
#define CTIMER1_EMR_EMC3_Pos                 10                                                      /*!< CTIMER1 EMR: EMC3 Position             */
#define CTIMER1_EMR_EMC3_Msk                 (0x03UL << CTIMER1_EMR_EMC3_Pos)                       /*!< CTIMER1 EMR: EMC3 Mask                 */

/* --------------------------------  u1_timer_CTCR  ------------------------------- */
#define CTIMER1_CTCR_CTMODE_Pos              0                                                       /*!< CTIMER1 CTCR: CTMODE Position          */
#define CTIMER1_CTCR_CTMODE_Msk              (0x03UL << CTIMER1_CTCR_CTMODE_Pos)                    /*!< CTIMER1 CTCR: CTMODE Mask              */
#define CTIMER1_CTCR_CINSEL_Pos              2                                                       /*!< CTIMER1 CTCR: CINSEL Position          */
#define CTIMER1_CTCR_CINSEL_Msk              (0x03UL << CTIMER1_CTCR_CINSEL_Pos)                    /*!< CTIMER1 CTCR: CINSEL Mask              */
#define CTIMER1_CTCR_ENCC_Pos                4                                                       /*!< CTIMER1 CTCR: ENCC Position            */
#define CTIMER1_CTCR_ENCC_Msk                (0x01UL << CTIMER1_CTCR_ENCC_Pos)                      /*!< CTIMER1 CTCR: ENCC Mask                */
#define CTIMER1_CTCR_SELCC_Pos               5                                                       /*!< CTIMER1 CTCR: SELCC Position           */
#define CTIMER1_CTCR_SELCC_Msk               (0x07UL << CTIMER1_CTCR_SELCC_Pos)                     /*!< CTIMER1 CTCR: SELCC Mask               */

/* --------------------------------  u1_timer_PWMC  ------------------------------- */
#define CTIMER1_PWMC_PWMEN0_Pos              0                                                       /*!< CTIMER1 PWMC: PWMEN0 Position          */
#define CTIMER1_PWMC_PWMEN0_Msk              (0x01UL << CTIMER1_PWMC_PWMEN0_Pos)                    /*!< CTIMER1 PWMC: PWMEN0 Mask              */
#define CTIMER1_PWMC_PWMEN1_Pos              1                                                       /*!< CTIMER1 PWMC: PWMEN1 Position          */
#define CTIMER1_PWMC_PWMEN1_Msk              (0x01UL << CTIMER1_PWMC_PWMEN1_Pos)                    /*!< CTIMER1 PWMC: PWMEN1 Mask              */
#define CTIMER1_PWMC_PWMEN2_Pos              2                                                       /*!< CTIMER1 PWMC: PWMEN2 Position          */
#define CTIMER1_PWMC_PWMEN2_Msk              (0x01UL << CTIMER1_PWMC_PWMEN2_Pos)                    /*!< CTIMER1 PWMC: PWMEN2 Mask              */
#define CTIMER1_PWMC_PWMEN3_Pos              3                                                       /*!< CTIMER1 PWMC: PWMEN3 Position          */
#define CTIMER1_PWMC_PWMEN3_Msk              (0x01UL << CTIMER1_PWMC_PWMEN3_Pos)                    /*!< CTIMER1 PWMC: PWMEN3 Mask              */


/* ================================================================================ */
/* ================         struct 'u_gpio' Position & Mask        ================ */
/* ================================================================================ */


/* ----------------------------------  u_gpio_B  ---------------------------------- */
#define GPIO_B_B_Pos                        0                                                       /*!< GPIO B: B Position                    */
#define GPIO_B_B_Msk                        (0x000000ffUL << GPIO_B_B_Pos)                        /*!< GPIO B: B Mask                        */

/* ----------------------------------  u_gpio_W  ---------------------------------- */
#define GPIO_W_W_Pos                        0                                                       /*!< GPIO W: W Position                    */
#define GPIO_W_W_Msk                        (0xffffffffUL << GPIO_W_W_Pos)                        /*!< GPIO W: W Mask                        */

/* ---------------------------------  u_gpio_DIR  --------------------------------- */
#define GPIO_DIR_DIRP_PIO0_Pos              0                                                       /*!< GPIO DIR: DIRP_PIO0 Position          */
#define GPIO_DIR_DIRP_PIO0_Msk              (0x01UL << GPIO_DIR_DIRP_PIO0_Pos)                    /*!< GPIO DIR: DIRP_PIO0 Mask              */
#define GPIO_DIR_DIRP_PIO1_Pos              1                                                       /*!< GPIO DIR: DIRP_PIO1 Position          */
#define GPIO_DIR_DIRP_PIO1_Msk              (0x01UL << GPIO_DIR_DIRP_PIO1_Pos)                    /*!< GPIO DIR: DIRP_PIO1 Mask              */
#define GPIO_DIR_DIRP_PIO2_Pos              2                                                       /*!< GPIO DIR: DIRP_PIO2 Position          */
#define GPIO_DIR_DIRP_PIO2_Msk              (0x01UL << GPIO_DIR_DIRP_PIO2_Pos)                    /*!< GPIO DIR: DIRP_PIO2 Mask              */
#define GPIO_DIR_DIRP_PIO3_Pos              3                                                       /*!< GPIO DIR: DIRP_PIO3 Position          */
#define GPIO_DIR_DIRP_PIO3_Msk              (0x01UL << GPIO_DIR_DIRP_PIO3_Pos)                    /*!< GPIO DIR: DIRP_PIO3 Mask              */
#define GPIO_DIR_DIRP_PIO4_Pos              4                                                       /*!< GPIO DIR: DIRP_PIO4 Position          */
#define GPIO_DIR_DIRP_PIO4_Msk              (0x01UL << GPIO_DIR_DIRP_PIO4_Pos)                    /*!< GPIO DIR: DIRP_PIO4 Mask              */
#define GPIO_DIR_DIRP_PIO5_Pos              5                                                       /*!< GPIO DIR: DIRP_PIO5 Position          */
#define GPIO_DIR_DIRP_PIO5_Msk              (0x01UL << GPIO_DIR_DIRP_PIO5_Pos)                    /*!< GPIO DIR: DIRP_PIO5 Mask              */
#define GPIO_DIR_DIRP_PIO6_Pos              6                                                       /*!< GPIO DIR: DIRP_PIO6 Position          */
#define GPIO_DIR_DIRP_PIO6_Msk              (0x01UL << GPIO_DIR_DIRP_PIO6_Pos)                    /*!< GPIO DIR: DIRP_PIO6 Mask              */
#define GPIO_DIR_DIRP_PIO7_Pos              7                                                       /*!< GPIO DIR: DIRP_PIO7 Position          */
#define GPIO_DIR_DIRP_PIO7_Msk              (0x01UL << GPIO_DIR_DIRP_PIO7_Pos)                    /*!< GPIO DIR: DIRP_PIO7 Mask              */
#define GPIO_DIR_DIRP_PIO8_Pos              8                                                       /*!< GPIO DIR: DIRP_PIO8 Position          */
#define GPIO_DIR_DIRP_PIO8_Msk              (0x01UL << GPIO_DIR_DIRP_PIO8_Pos)                    /*!< GPIO DIR: DIRP_PIO8 Mask              */
#define GPIO_DIR_DIRP_PIO9_Pos              9                                                       /*!< GPIO DIR: DIRP_PIO9 Position          */
#define GPIO_DIR_DIRP_PIO9_Msk              (0x01UL << GPIO_DIR_DIRP_PIO9_Pos)                    /*!< GPIO DIR: DIRP_PIO9 Mask              */
#define GPIO_DIR_DIRP_PIO10_Pos             10                                                      /*!< GPIO DIR: DIRP_PIO10 Position         */
#define GPIO_DIR_DIRP_PIO10_Msk             (0x01UL << GPIO_DIR_DIRP_PIO10_Pos)                   /*!< GPIO DIR: DIRP_PIO10 Mask             */
#define GPIO_DIR_DIRP_PIO11_Pos             11                                                      /*!< GPIO DIR: DIRP_PIO11 Position         */
#define GPIO_DIR_DIRP_PIO11_Msk             (0x01UL << GPIO_DIR_DIRP_PIO11_Pos)                   /*!< GPIO DIR: DIRP_PIO11 Mask             */
#define GPIO_DIR_DIRP_PIO12_Pos             12                                                      /*!< GPIO DIR: DIRP_PIO12 Position         */
#define GPIO_DIR_DIRP_PIO12_Msk             (0x01UL << GPIO_DIR_DIRP_PIO12_Pos)                   /*!< GPIO DIR: DIRP_PIO12 Mask             */
#define GPIO_DIR_DIRP_PIO13_Pos             13                                                      /*!< GPIO DIR: DIRP_PIO13 Position         */
#define GPIO_DIR_DIRP_PIO13_Msk             (0x01UL << GPIO_DIR_DIRP_PIO13_Pos)                   /*!< GPIO DIR: DIRP_PIO13 Mask             */
#define GPIO_DIR_DIRP_PIO14_Pos             14                                                      /*!< GPIO DIR: DIRP_PIO14 Position         */
#define GPIO_DIR_DIRP_PIO14_Msk             (0x01UL << GPIO_DIR_DIRP_PIO14_Pos)                   /*!< GPIO DIR: DIRP_PIO14 Mask             */
#define GPIO_DIR_DIRP_PIO15_Pos             15                                                      /*!< GPIO DIR: DIRP_PIO15 Position         */
#define GPIO_DIR_DIRP_PIO15_Msk             (0x01UL << GPIO_DIR_DIRP_PIO15_Pos)                   /*!< GPIO DIR: DIRP_PIO15 Mask             */
#define GPIO_DIR_DIRP_PIO16_Pos             16                                                      /*!< GPIO DIR: DIRP_PIO16 Position         */
#define GPIO_DIR_DIRP_PIO16_Msk             (0x01UL << GPIO_DIR_DIRP_PIO16_Pos)                   /*!< GPIO DIR: DIRP_PIO16 Mask             */
#define GPIO_DIR_DIRP_PIO17_Pos             17                                                      /*!< GPIO DIR: DIRP_PIO17 Position         */
#define GPIO_DIR_DIRP_PIO17_Msk             (0x01UL << GPIO_DIR_DIRP_PIO17_Pos)                   /*!< GPIO DIR: DIRP_PIO17 Mask             */
#define GPIO_DIR_DIRP_PIO18_Pos             18                                                      /*!< GPIO DIR: DIRP_PIO18 Position         */
#define GPIO_DIR_DIRP_PIO18_Msk             (0x01UL << GPIO_DIR_DIRP_PIO18_Pos)                   /*!< GPIO DIR: DIRP_PIO18 Mask             */
#define GPIO_DIR_DIRP_PIO19_Pos             19                                                      /*!< GPIO DIR: DIRP_PIO19 Position         */
#define GPIO_DIR_DIRP_PIO19_Msk             (0x01UL << GPIO_DIR_DIRP_PIO19_Pos)                   /*!< GPIO DIR: DIRP_PIO19 Mask             */
#define GPIO_DIR_DIRP_PIO20_Pos             20                                                      /*!< GPIO DIR: DIRP_PIO20 Position         */
#define GPIO_DIR_DIRP_PIO20_Msk             (0x01UL << GPIO_DIR_DIRP_PIO20_Pos)                   /*!< GPIO DIR: DIRP_PIO20 Mask             */
#define GPIO_DIR_DIRP_PIO21_Pos             21                                                      /*!< GPIO DIR: DIRP_PIO21 Position         */
#define GPIO_DIR_DIRP_PIO21_Msk             (0x01UL << GPIO_DIR_DIRP_PIO21_Pos)                   /*!< GPIO DIR: DIRP_PIO21 Mask             */

/* ---------------------------------  u_gpio_MASK  -------------------------------- */
#define GPIO_MASK_MASKP_PIO0_Pos            0                                                       /*!< GPIO MASK: MASKP_PIO0 Position        */
#define GPIO_MASK_MASKP_PIO0_Msk            (0x01UL << GPIO_MASK_MASKP_PIO0_Pos)                  /*!< GPIO MASK: MASKP_PIO0 Mask            */
#define GPIO_MASK_MASKP_PIO1_Pos            1                                                       /*!< GPIO MASK: MASKP_PIO1 Position        */
#define GPIO_MASK_MASKP_PIO1_Msk            (0x01UL << GPIO_MASK_MASKP_PIO1_Pos)                  /*!< GPIO MASK: MASKP_PIO1 Mask            */
#define GPIO_MASK_MASKP_PIO2_Pos            2                                                       /*!< GPIO MASK: MASKP_PIO2 Position        */
#define GPIO_MASK_MASKP_PIO2_Msk            (0x01UL << GPIO_MASK_MASKP_PIO2_Pos)                  /*!< GPIO MASK: MASKP_PIO2 Mask            */
#define GPIO_MASK_MASKP_PIO3_Pos            3                                                       /*!< GPIO MASK: MASKP_PIO3 Position        */
#define GPIO_MASK_MASKP_PIO3_Msk            (0x01UL << GPIO_MASK_MASKP_PIO3_Pos)                  /*!< GPIO MASK: MASKP_PIO3 Mask            */
#define GPIO_MASK_MASKP_PIO4_Pos            4                                                       /*!< GPIO MASK: MASKP_PIO4 Position        */
#define GPIO_MASK_MASKP_PIO4_Msk            (0x01UL << GPIO_MASK_MASKP_PIO4_Pos)                  /*!< GPIO MASK: MASKP_PIO4 Mask            */
#define GPIO_MASK_MASKP_PIO5_Pos            5                                                       /*!< GPIO MASK: MASKP_PIO5 Position        */
#define GPIO_MASK_MASKP_PIO5_Msk            (0x01UL << GPIO_MASK_MASKP_PIO5_Pos)                  /*!< GPIO MASK: MASKP_PIO5 Mask            */
#define GPIO_MASK_MASKP_PIO6_Pos            6                                                       /*!< GPIO MASK: MASKP_PIO6 Position        */
#define GPIO_MASK_MASKP_PIO6_Msk            (0x01UL << GPIO_MASK_MASKP_PIO6_Pos)                  /*!< GPIO MASK: MASKP_PIO6 Mask            */
#define GPIO_MASK_MASKP_PIO7_Pos            7                                                       /*!< GPIO MASK: MASKP_PIO7 Position        */
#define GPIO_MASK_MASKP_PIO7_Msk            (0x01UL << GPIO_MASK_MASKP_PIO7_Pos)                  /*!< GPIO MASK: MASKP_PIO7 Mask            */
#define GPIO_MASK_MASKP_PIO8_Pos            8                                                       /*!< GPIO MASK: MASKP_PIO8 Position        */
#define GPIO_MASK_MASKP_PIO8_Msk            (0x01UL << GPIO_MASK_MASKP_PIO8_Pos)                  /*!< GPIO MASK: MASKP_PIO8 Mask            */
#define GPIO_MASK_MASKP_PIO9_Pos            9                                                       /*!< GPIO MASK: MASKP_PIO9 Position        */
#define GPIO_MASK_MASKP_PIO9_Msk            (0x01UL << GPIO_MASK_MASKP_PIO9_Pos)                  /*!< GPIO MASK: MASKP_PIO9 Mask            */
#define GPIO_MASK_MASKP_PIO10_Pos           10                                                      /*!< GPIO MASK: MASKP_PIO10 Position       */
#define GPIO_MASK_MASKP_PIO10_Msk           (0x01UL << GPIO_MASK_MASKP_PIO10_Pos)                 /*!< GPIO MASK: MASKP_PIO10 Mask           */
#define GPIO_MASK_MASKP_PIO11_Pos           11                                                      /*!< GPIO MASK: MASKP_PIO11 Position       */
#define GPIO_MASK_MASKP_PIO11_Msk           (0x01UL << GPIO_MASK_MASKP_PIO11_Pos)                 /*!< GPIO MASK: MASKP_PIO11 Mask           */
#define GPIO_MASK_MASKP_PIO12_Pos           12                                                      /*!< GPIO MASK: MASKP_PIO12 Position       */
#define GPIO_MASK_MASKP_PIO12_Msk           (0x01UL << GPIO_MASK_MASKP_PIO12_Pos)                 /*!< GPIO MASK: MASKP_PIO12 Mask           */
#define GPIO_MASK_MASKP_PIO13_Pos           13                                                      /*!< GPIO MASK: MASKP_PIO13 Position       */
#define GPIO_MASK_MASKP_PIO13_Msk           (0x01UL << GPIO_MASK_MASKP_PIO13_Pos)                 /*!< GPIO MASK: MASKP_PIO13 Mask           */
#define GPIO_MASK_MASKP_PIO14_Pos           14                                                      /*!< GPIO MASK: MASKP_PIO14 Position       */
#define GPIO_MASK_MASKP_PIO14_Msk           (0x01UL << GPIO_MASK_MASKP_PIO14_Pos)                 /*!< GPIO MASK: MASKP_PIO14 Mask           */
#define GPIO_MASK_MASKP_PIO15_Pos           15                                                      /*!< GPIO MASK: MASKP_PIO15 Position       */
#define GPIO_MASK_MASKP_PIO15_Msk           (0x01UL << GPIO_MASK_MASKP_PIO15_Pos)                 /*!< GPIO MASK: MASKP_PIO15 Mask           */
#define GPIO_MASK_MASKP_PIO16_Pos           16                                                      /*!< GPIO MASK: MASKP_PIO16 Position       */
#define GPIO_MASK_MASKP_PIO16_Msk           (0x01UL << GPIO_MASK_MASKP_PIO16_Pos)                 /*!< GPIO MASK: MASKP_PIO16 Mask           */
#define GPIO_MASK_MASKP_PIO17_Pos           17                                                      /*!< GPIO MASK: MASKP_PIO17 Position       */
#define GPIO_MASK_MASKP_PIO17_Msk           (0x01UL << GPIO_MASK_MASKP_PIO17_Pos)                 /*!< GPIO MASK: MASKP_PIO17 Mask           */
#define GPIO_MASK_MASKP_PIO18_Pos           18                                                      /*!< GPIO MASK: MASKP_PIO18 Position       */
#define GPIO_MASK_MASKP_PIO18_Msk           (0x01UL << GPIO_MASK_MASKP_PIO18_Pos)                 /*!< GPIO MASK: MASKP_PIO18 Mask           */
#define GPIO_MASK_MASKP_PIO19_Pos           19                                                      /*!< GPIO MASK: MASKP_PIO19 Position       */
#define GPIO_MASK_MASKP_PIO19_Msk           (0x01UL << GPIO_MASK_MASKP_PIO19_Pos)                 /*!< GPIO MASK: MASKP_PIO19 Mask           */
#define GPIO_MASK_MASKP_PIO20_Pos           20                                                      /*!< GPIO MASK: MASKP_PIO20 Position       */
#define GPIO_MASK_MASKP_PIO20_Msk           (0x01UL << GPIO_MASK_MASKP_PIO20_Pos)                 /*!< GPIO MASK: MASKP_PIO20 Mask           */
#define GPIO_MASK_MASKP_PIO21_Pos           21                                                      /*!< GPIO MASK: MASKP_PIO21 Position       */
#define GPIO_MASK_MASKP_PIO21_Msk           (0x01UL << GPIO_MASK_MASKP_PIO21_Pos)                 /*!< GPIO MASK: MASKP_PIO21 Mask           */

/* ---------------------------------  u_gpio_PIN  --------------------------------- */
#define GPIO_PIN_PORT_PIO0_Pos              0                                                       /*!< GPIO PIN: PORT_PIO0 Position          */
#define GPIO_PIN_PORT_PIO0_Msk              (0x01UL << GPIO_PIN_PORT_PIO0_Pos)                    /*!< GPIO PIN: PORT_PIO0 Mask              */
#define GPIO_PIN_PORT_PIO1_Pos              1                                                       /*!< GPIO PIN: PORT_PIO1 Position          */
#define GPIO_PIN_PORT_PIO1_Msk              (0x01UL << GPIO_PIN_PORT_PIO1_Pos)                    /*!< GPIO PIN: PORT_PIO1 Mask              */
#define GPIO_PIN_PORT_PIO2_Pos              2                                                       /*!< GPIO PIN: PORT_PIO2 Position          */
#define GPIO_PIN_PORT_PIO2_Msk              (0x01UL << GPIO_PIN_PORT_PIO2_Pos)                    /*!< GPIO PIN: PORT_PIO2 Mask              */
#define GPIO_PIN_PORT_PIO3_Pos              3                                                       /*!< GPIO PIN: PORT_PIO3 Position          */
#define GPIO_PIN_PORT_PIO3_Msk              (0x01UL << GPIO_PIN_PORT_PIO3_Pos)                    /*!< GPIO PIN: PORT_PIO3 Mask              */
#define GPIO_PIN_PORT_PIO4_Pos              4                                                       /*!< GPIO PIN: PORT_PIO4 Position          */
#define GPIO_PIN_PORT_PIO4_Msk              (0x01UL << GPIO_PIN_PORT_PIO4_Pos)                    /*!< GPIO PIN: PORT_PIO4 Mask              */
#define GPIO_PIN_PORT_PIO5_Pos              5                                                       /*!< GPIO PIN: PORT_PIO5 Position          */
#define GPIO_PIN_PORT_PIO5_Msk              (0x01UL << GPIO_PIN_PORT_PIO5_Pos)                    /*!< GPIO PIN: PORT_PIO5 Mask              */
#define GPIO_PIN_PORT_PIO6_Pos              6                                                       /*!< GPIO PIN: PORT_PIO6 Position          */
#define GPIO_PIN_PORT_PIO6_Msk              (0x01UL << GPIO_PIN_PORT_PIO6_Pos)                    /*!< GPIO PIN: PORT_PIO6 Mask              */
#define GPIO_PIN_PORT_PIO7_Pos              7                                                       /*!< GPIO PIN: PORT_PIO7 Position          */
#define GPIO_PIN_PORT_PIO7_Msk              (0x01UL << GPIO_PIN_PORT_PIO7_Pos)                    /*!< GPIO PIN: PORT_PIO7 Mask              */
#define GPIO_PIN_PORT_PIO8_Pos              8                                                       /*!< GPIO PIN: PORT_PIO8 Position          */
#define GPIO_PIN_PORT_PIO8_Msk              (0x01UL << GPIO_PIN_PORT_PIO8_Pos)                    /*!< GPIO PIN: PORT_PIO8 Mask              */
#define GPIO_PIN_PORT_PIO9_Pos              9                                                       /*!< GPIO PIN: PORT_PIO9 Position          */
#define GPIO_PIN_PORT_PIO9_Msk              (0x01UL << GPIO_PIN_PORT_PIO9_Pos)                    /*!< GPIO PIN: PORT_PIO9 Mask              */
#define GPIO_PIN_PORT_PIO10_Pos             10                                                      /*!< GPIO PIN: PORT_PIO10 Position         */
#define GPIO_PIN_PORT_PIO10_Msk             (0x01UL << GPIO_PIN_PORT_PIO10_Pos)                   /*!< GPIO PIN: PORT_PIO10 Mask             */
#define GPIO_PIN_PORT_PIO11_Pos             11                                                      /*!< GPIO PIN: PORT_PIO11 Position         */
#define GPIO_PIN_PORT_PIO11_Msk             (0x01UL << GPIO_PIN_PORT_PIO11_Pos)                   /*!< GPIO PIN: PORT_PIO11 Mask             */
#define GPIO_PIN_PORT_PIO12_Pos             12                                                      /*!< GPIO PIN: PORT_PIO12 Position         */
#define GPIO_PIN_PORT_PIO12_Msk             (0x01UL << GPIO_PIN_PORT_PIO12_Pos)                   /*!< GPIO PIN: PORT_PIO12 Mask             */
#define GPIO_PIN_PORT_PIO13_Pos             13                                                      /*!< GPIO PIN: PORT_PIO13 Position         */
#define GPIO_PIN_PORT_PIO13_Msk             (0x01UL << GPIO_PIN_PORT_PIO13_Pos)                   /*!< GPIO PIN: PORT_PIO13 Mask             */
#define GPIO_PIN_PORT_PIO14_Pos             14                                                      /*!< GPIO PIN: PORT_PIO14 Position         */
#define GPIO_PIN_PORT_PIO14_Msk             (0x01UL << GPIO_PIN_PORT_PIO14_Pos)                   /*!< GPIO PIN: PORT_PIO14 Mask             */
#define GPIO_PIN_PORT_PIO15_Pos             15                                                      /*!< GPIO PIN: PORT_PIO15 Position         */
#define GPIO_PIN_PORT_PIO15_Msk             (0x01UL << GPIO_PIN_PORT_PIO15_Pos)                   /*!< GPIO PIN: PORT_PIO15 Mask             */
#define GPIO_PIN_PORT_PIO16_Pos             16                                                      /*!< GPIO PIN: PORT_PIO16 Position         */
#define GPIO_PIN_PORT_PIO16_Msk             (0x01UL << GPIO_PIN_PORT_PIO16_Pos)                   /*!< GPIO PIN: PORT_PIO16 Mask             */
#define GPIO_PIN_PORT_PIO17_Pos             17                                                      /*!< GPIO PIN: PORT_PIO17 Position         */
#define GPIO_PIN_PORT_PIO17_Msk             (0x01UL << GPIO_PIN_PORT_PIO17_Pos)                   /*!< GPIO PIN: PORT_PIO17 Mask             */
#define GPIO_PIN_PORT_PIO18_Pos             18                                                      /*!< GPIO PIN: PORT_PIO18 Position         */
#define GPIO_PIN_PORT_PIO18_Msk             (0x01UL << GPIO_PIN_PORT_PIO18_Pos)                   /*!< GPIO PIN: PORT_PIO18 Mask             */
#define GPIO_PIN_PORT_PIO19_Pos             19                                                      /*!< GPIO PIN: PORT_PIO19 Position         */
#define GPIO_PIN_PORT_PIO19_Msk             (0x01UL << GPIO_PIN_PORT_PIO19_Pos)                   /*!< GPIO PIN: PORT_PIO19 Mask             */
#define GPIO_PIN_PORT_PIO20_Pos             20                                                      /*!< GPIO PIN: PORT_PIO20 Position         */
#define GPIO_PIN_PORT_PIO20_Msk             (0x01UL << GPIO_PIN_PORT_PIO20_Pos)                   /*!< GPIO PIN: PORT_PIO20 Mask             */
#define GPIO_PIN_PORT_PIO21_Pos             21                                                      /*!< GPIO PIN: PORT_PIO21 Position         */
#define GPIO_PIN_PORT_PIO21_Msk             (0x01UL << GPIO_PIN_PORT_PIO21_Pos)                   /*!< GPIO PIN: PORT_PIO21 Mask             */

/* ---------------------------------  u_gpio_MPIN  -------------------------------- */
#define GPIO_MPIN_MPORT_PIO0_Pos            0                                                       /*!< GPIO MPIN: MPORT_PIO0 Position        */
#define GPIO_MPIN_MPORT_PIO0_Msk            (0x01UL << GPIO_MPIN_MPORT_PIO0_Pos)                  /*!< GPIO MPIN: MPORT_PIO0 Mask            */
#define GPIO_MPIN_MPORT_PIO1_Pos            1                                                       /*!< GPIO MPIN: MPORT_PIO1 Position        */
#define GPIO_MPIN_MPORT_PIO1_Msk            (0x01UL << GPIO_MPIN_MPORT_PIO1_Pos)                  /*!< GPIO MPIN: MPORT_PIO1 Mask            */
#define GPIO_MPIN_MPORT_PIO2_Pos            2                                                       /*!< GPIO MPIN: MPORT_PIO2 Position        */
#define GPIO_MPIN_MPORT_PIO2_Msk            (0x01UL << GPIO_MPIN_MPORT_PIO2_Pos)                  /*!< GPIO MPIN: MPORT_PIO2 Mask            */
#define GPIO_MPIN_MPORT_PIO3_Pos            3                                                       /*!< GPIO MPIN: MPORT_PIO3 Position        */
#define GPIO_MPIN_MPORT_PIO3_Msk            (0x01UL << GPIO_MPIN_MPORT_PIO3_Pos)                  /*!< GPIO MPIN: MPORT_PIO3 Mask            */
#define GPIO_MPIN_MPORT_PIO4_Pos            4                                                       /*!< GPIO MPIN: MPORT_PIO4 Position        */
#define GPIO_MPIN_MPORT_PIO4_Msk            (0x01UL << GPIO_MPIN_MPORT_PIO4_Pos)                  /*!< GPIO MPIN: MPORT_PIO4 Mask            */
#define GPIO_MPIN_MPORT_PIO5_Pos            5                                                       /*!< GPIO MPIN: MPORT_PIO5 Position        */
#define GPIO_MPIN_MPORT_PIO5_Msk            (0x01UL << GPIO_MPIN_MPORT_PIO5_Pos)                  /*!< GPIO MPIN: MPORT_PIO5 Mask            */
#define GPIO_MPIN_MPORT_PIO6_Pos            6                                                       /*!< GPIO MPIN: MPORT_PIO6 Position        */
#define GPIO_MPIN_MPORT_PIO6_Msk            (0x01UL << GPIO_MPIN_MPORT_PIO6_Pos)                  /*!< GPIO MPIN: MPORT_PIO6 Mask            */
#define GPIO_MPIN_MPORT_PIO7_Pos            7                                                       /*!< GPIO MPIN: MPORT_PIO7 Position        */
#define GPIO_MPIN_MPORT_PIO7_Msk            (0x01UL << GPIO_MPIN_MPORT_PIO7_Pos)                  /*!< GPIO MPIN: MPORT_PIO7 Mask            */
#define GPIO_MPIN_MPORT_PIO8_Pos            8                                                       /*!< GPIO MPIN: MPORT_PIO8 Position        */
#define GPIO_MPIN_MPORT_PIO8_Msk            (0x01UL << GPIO_MPIN_MPORT_PIO8_Pos)                  /*!< GPIO MPIN: MPORT_PIO8 Mask            */
#define GPIO_MPIN_MPORT_PIO9_Pos            9                                                       /*!< GPIO MPIN: MPORT_PIO9 Position        */
#define GPIO_MPIN_MPORT_PIO9_Msk            (0x01UL << GPIO_MPIN_MPORT_PIO9_Pos)                  /*!< GPIO MPIN: MPORT_PIO9 Mask            */
#define GPIO_MPIN_MPORT_PIO10_Pos           10                                                      /*!< GPIO MPIN: MPORT_PIO10 Position       */
#define GPIO_MPIN_MPORT_PIO10_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO10_Pos)                 /*!< GPIO MPIN: MPORT_PIO10 Mask           */
#define GPIO_MPIN_MPORT_PIO11_Pos           11                                                      /*!< GPIO MPIN: MPORT_PIO11 Position       */
#define GPIO_MPIN_MPORT_PIO11_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO11_Pos)                 /*!< GPIO MPIN: MPORT_PIO11 Mask           */
#define GPIO_MPIN_MPORT_PIO12_Pos           12                                                      /*!< GPIO MPIN: MPORT_PIO12 Position       */
#define GPIO_MPIN_MPORT_PIO12_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO12_Pos)                 /*!< GPIO MPIN: MPORT_PIO12 Mask           */
#define GPIO_MPIN_MPORT_PIO13_Pos           13                                                      /*!< GPIO MPIN: MPORT_PIO13 Position       */
#define GPIO_MPIN_MPORT_PIO13_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO13_Pos)                 /*!< GPIO MPIN: MPORT_PIO13 Mask           */
#define GPIO_MPIN_MPORT_PIO14_Pos           14                                                      /*!< GPIO MPIN: MPORT_PIO14 Position       */
#define GPIO_MPIN_MPORT_PIO14_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO14_Pos)                 /*!< GPIO MPIN: MPORT_PIO14 Mask           */
#define GPIO_MPIN_MPORT_PIO15_Pos           15                                                      /*!< GPIO MPIN: MPORT_PIO15 Position       */
#define GPIO_MPIN_MPORT_PIO15_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO15_Pos)                 /*!< GPIO MPIN: MPORT_PIO15 Mask           */
#define GPIO_MPIN_MPORT_PIO16_Pos           16                                                      /*!< GPIO MPIN: MPORT_PIO16 Position       */
#define GPIO_MPIN_MPORT_PIO16_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO16_Pos)                 /*!< GPIO MPIN: MPORT_PIO16 Mask           */
#define GPIO_MPIN_MPORT_PIO17_Pos           17                                                      /*!< GPIO MPIN: MPORT_PIO17 Position       */
#define GPIO_MPIN_MPORT_PIO17_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO17_Pos)                 /*!< GPIO MPIN: MPORT_PIO17 Mask           */
#define GPIO_MPIN_MPORT_PIO18_Pos           18                                                      /*!< GPIO MPIN: MPORT_PIO18 Position       */
#define GPIO_MPIN_MPORT_PIO18_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO18_Pos)                 /*!< GPIO MPIN: MPORT_PIO18 Mask           */
#define GPIO_MPIN_MPORT_PIO19_Pos           19                                                      /*!< GPIO MPIN: MPORT_PIO19 Position       */
#define GPIO_MPIN_MPORT_PIO19_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO19_Pos)                 /*!< GPIO MPIN: MPORT_PIO19 Mask           */
#define GPIO_MPIN_MPORT_PIO20_Pos           20                                                      /*!< GPIO MPIN: MPORT_PIO20 Position       */
#define GPIO_MPIN_MPORT_PIO20_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO20_Pos)                 /*!< GPIO MPIN: MPORT_PIO20 Mask           */
#define GPIO_MPIN_MPORT_PIO21_Pos           21                                                      /*!< GPIO MPIN: MPORT_PIO21 Position       */
#define GPIO_MPIN_MPORT_PIO21_Msk           (0x01UL << GPIO_MPIN_MPORT_PIO21_Pos)                 /*!< GPIO MPIN: MPORT_PIO21 Mask           */

/* ---------------------------------  u_gpio_SET  --------------------------------- */
#define GPIO_SET_SETP_PIO0_Pos              0                                                       /*!< GPIO SET: SETP_PIO0 Position          */
#define GPIO_SET_SETP_PIO0_Msk              (0x01UL << GPIO_SET_SETP_PIO0_Pos)                    /*!< GPIO SET: SETP_PIO0 Mask              */
#define GPIO_SET_SETP_PIO1_Pos              1                                                       /*!< GPIO SET: SETP_PIO1 Position          */
#define GPIO_SET_SETP_PIO1_Msk              (0x01UL << GPIO_SET_SETP_PIO1_Pos)                    /*!< GPIO SET: SETP_PIO1 Mask              */
#define GPIO_SET_SETP_PIO2_Pos              2                                                       /*!< GPIO SET: SETP_PIO2 Position          */
#define GPIO_SET_SETP_PIO2_Msk              (0x01UL << GPIO_SET_SETP_PIO2_Pos)                    /*!< GPIO SET: SETP_PIO2 Mask              */
#define GPIO_SET_SETP_PIO3_Pos              3                                                       /*!< GPIO SET: SETP_PIO3 Position          */
#define GPIO_SET_SETP_PIO3_Msk              (0x01UL << GPIO_SET_SETP_PIO3_Pos)                    /*!< GPIO SET: SETP_PIO3 Mask              */
#define GPIO_SET_SETP_PIO4_Pos              4                                                       /*!< GPIO SET: SETP_PIO4 Position          */
#define GPIO_SET_SETP_PIO4_Msk              (0x01UL << GPIO_SET_SETP_PIO4_Pos)                    /*!< GPIO SET: SETP_PIO4 Mask              */
#define GPIO_SET_SETP_PIO5_Pos              5                                                       /*!< GPIO SET: SETP_PIO5 Position          */
#define GPIO_SET_SETP_PIO5_Msk              (0x01UL << GPIO_SET_SETP_PIO5_Pos)                    /*!< GPIO SET: SETP_PIO5 Mask              */
#define GPIO_SET_SETP_PIO6_Pos              6                                                       /*!< GPIO SET: SETP_PIO6 Position          */
#define GPIO_SET_SETP_PIO6_Msk              (0x01UL << GPIO_SET_SETP_PIO6_Pos)                    /*!< GPIO SET: SETP_PIO6 Mask              */
#define GPIO_SET_SETP_PIO7_Pos              7                                                       /*!< GPIO SET: SETP_PIO7 Position          */
#define GPIO_SET_SETP_PIO7_Msk              (0x01UL << GPIO_SET_SETP_PIO7_Pos)                    /*!< GPIO SET: SETP_PIO7 Mask              */
#define GPIO_SET_SETP_PIO8_Pos              8                                                       /*!< GPIO SET: SETP_PIO8 Position          */
#define GPIO_SET_SETP_PIO8_Msk              (0x01UL << GPIO_SET_SETP_PIO8_Pos)                    /*!< GPIO SET: SETP_PIO8 Mask              */
#define GPIO_SET_SETP_PIO9_Pos              9                                                       /*!< GPIO SET: SETP_PIO9 Position          */
#define GPIO_SET_SETP_PIO9_Msk              (0x01UL << GPIO_SET_SETP_PIO9_Pos)                    /*!< GPIO SET: SETP_PIO9 Mask              */
#define GPIO_SET_SETP_PIO10_Pos             10                                                      /*!< GPIO SET: SETP_PIO10 Position         */
#define GPIO_SET_SETP_PIO10_Msk             (0x01UL << GPIO_SET_SETP_PIO10_Pos)                   /*!< GPIO SET: SETP_PIO10 Mask             */
#define GPIO_SET_SETP_PIO11_Pos             11                                                      /*!< GPIO SET: SETP_PIO11 Position         */
#define GPIO_SET_SETP_PIO11_Msk             (0x01UL << GPIO_SET_SETP_PIO11_Pos)                   /*!< GPIO SET: SETP_PIO11 Mask             */
#define GPIO_SET_SETP_PIO12_Pos             12                                                      /*!< GPIO SET: SETP_PIO12 Position         */
#define GPIO_SET_SETP_PIO12_Msk             (0x01UL << GPIO_SET_SETP_PIO12_Pos)                   /*!< GPIO SET: SETP_PIO12 Mask             */
#define GPIO_SET_SETP_PIO13_Pos             13                                                      /*!< GPIO SET: SETP_PIO13 Position         */
#define GPIO_SET_SETP_PIO13_Msk             (0x01UL << GPIO_SET_SETP_PIO13_Pos)                   /*!< GPIO SET: SETP_PIO13 Mask             */
#define GPIO_SET_SETP_PIO14_Pos             14                                                      /*!< GPIO SET: SETP_PIO14 Position         */
#define GPIO_SET_SETP_PIO14_Msk             (0x01UL << GPIO_SET_SETP_PIO14_Pos)                   /*!< GPIO SET: SETP_PIO14 Mask             */
#define GPIO_SET_SETP_PIO15_Pos             15                                                      /*!< GPIO SET: SETP_PIO15 Position         */
#define GPIO_SET_SETP_PIO15_Msk             (0x01UL << GPIO_SET_SETP_PIO15_Pos)                   /*!< GPIO SET: SETP_PIO15 Mask             */
#define GPIO_SET_SETP_PIO16_Pos             16                                                      /*!< GPIO SET: SETP_PIO16 Position         */
#define GPIO_SET_SETP_PIO16_Msk             (0x01UL << GPIO_SET_SETP_PIO16_Pos)                   /*!< GPIO SET: SETP_PIO16 Mask             */
#define GPIO_SET_SETP_PIO17_Pos             17                                                      /*!< GPIO SET: SETP_PIO17 Position         */
#define GPIO_SET_SETP_PIO17_Msk             (0x01UL << GPIO_SET_SETP_PIO17_Pos)                   /*!< GPIO SET: SETP_PIO17 Mask             */
#define GPIO_SET_SETP_PIO18_Pos             18                                                      /*!< GPIO SET: SETP_PIO18 Position         */
#define GPIO_SET_SETP_PIO18_Msk             (0x01UL << GPIO_SET_SETP_PIO18_Pos)                   /*!< GPIO SET: SETP_PIO18 Mask             */
#define GPIO_SET_SETP_PIO19_Pos             19                                                      /*!< GPIO SET: SETP_PIO19 Position         */
#define GPIO_SET_SETP_PIO19_Msk             (0x01UL << GPIO_SET_SETP_PIO19_Pos)                   /*!< GPIO SET: SETP_PIO19 Mask             */
#define GPIO_SET_SETP_PIO20_Pos             20                                                      /*!< GPIO SET: SETP_PIO20 Position         */
#define GPIO_SET_SETP_PIO20_Msk             (0x01UL << GPIO_SET_SETP_PIO20_Pos)                   /*!< GPIO SET: SETP_PIO20 Mask             */
#define GPIO_SET_SETP_PIO21_Pos             21                                                      /*!< GPIO SET: SETP_PIO21 Position         */
#define GPIO_SET_SETP_PIO21_Msk             (0x01UL << GPIO_SET_SETP_PIO21_Pos)                   /*!< GPIO SET: SETP_PIO21 Mask             */

/* ---------------------------------  u_gpio_CLR  --------------------------------- */
#define GPIO_CLR_CLRP_PIO0_Pos              0                                                       /*!< GPIO CLR: CLRP_PIO0 Position          */
#define GPIO_CLR_CLRP_PIO0_Msk              (0x01UL << GPIO_CLR_CLRP_PIO0_Pos)                    /*!< GPIO CLR: CLRP_PIO0 Mask              */
#define GPIO_CLR_CLRP_PIO1_Pos              1                                                       /*!< GPIO CLR: CLRP_PIO1 Position          */
#define GPIO_CLR_CLRP_PIO1_Msk              (0x01UL << GPIO_CLR_CLRP_PIO1_Pos)                    /*!< GPIO CLR: CLRP_PIO1 Mask              */
#define GPIO_CLR_CLRP_PIO2_Pos              2                                                       /*!< GPIO CLR: CLRP_PIO2 Position          */
#define GPIO_CLR_CLRP_PIO2_Msk              (0x01UL << GPIO_CLR_CLRP_PIO2_Pos)                    /*!< GPIO CLR: CLRP_PIO2 Mask              */
#define GPIO_CLR_CLRP_PIO3_Pos              3                                                       /*!< GPIO CLR: CLRP_PIO3 Position          */
#define GPIO_CLR_CLRP_PIO3_Msk              (0x01UL << GPIO_CLR_CLRP_PIO3_Pos)                    /*!< GPIO CLR: CLRP_PIO3 Mask              */
#define GPIO_CLR_CLRP_PIO4_Pos              4                                                       /*!< GPIO CLR: CLRP_PIO4 Position          */
#define GPIO_CLR_CLRP_PIO4_Msk              (0x01UL << GPIO_CLR_CLRP_PIO4_Pos)                    /*!< GPIO CLR: CLRP_PIO4 Mask              */
#define GPIO_CLR_CLRP_PIO5_Pos              5                                                       /*!< GPIO CLR: CLRP_PIO5 Position          */
#define GPIO_CLR_CLRP_PIO5_Msk              (0x01UL << GPIO_CLR_CLRP_PIO5_Pos)                    /*!< GPIO CLR: CLRP_PIO5 Mask              */
#define GPIO_CLR_CLRP_PIO6_Pos              6                                                       /*!< GPIO CLR: CLRP_PIO6 Position          */
#define GPIO_CLR_CLRP_PIO6_Msk              (0x01UL << GPIO_CLR_CLRP_PIO6_Pos)                    /*!< GPIO CLR: CLRP_PIO6 Mask              */
#define GPIO_CLR_CLRP_PIO7_Pos              7                                                       /*!< GPIO CLR: CLRP_PIO7 Position          */
#define GPIO_CLR_CLRP_PIO7_Msk              (0x01UL << GPIO_CLR_CLRP_PIO7_Pos)                    /*!< GPIO CLR: CLRP_PIO7 Mask              */
#define GPIO_CLR_CLRP_PIO8_Pos              8                                                       /*!< GPIO CLR: CLRP_PIO8 Position          */
#define GPIO_CLR_CLRP_PIO8_Msk              (0x01UL << GPIO_CLR_CLRP_PIO8_Pos)                    /*!< GPIO CLR: CLRP_PIO8 Mask              */
#define GPIO_CLR_CLRP_PIO9_Pos              9                                                       /*!< GPIO CLR: CLRP_PIO9 Position          */
#define GPIO_CLR_CLRP_PIO9_Msk              (0x01UL << GPIO_CLR_CLRP_PIO9_Pos)                    /*!< GPIO CLR: CLRP_PIO9 Mask              */
#define GPIO_CLR_CLRP_PIO10_Pos             10                                                      /*!< GPIO CLR: CLRP_PIO10 Position         */
#define GPIO_CLR_CLRP_PIO10_Msk             (0x01UL << GPIO_CLR_CLRP_PIO10_Pos)                   /*!< GPIO CLR: CLRP_PIO10 Mask             */
#define GPIO_CLR_CLRP_PIO11_Pos             11                                                      /*!< GPIO CLR: CLRP_PIO11 Position         */
#define GPIO_CLR_CLRP_PIO11_Msk             (0x01UL << GPIO_CLR_CLRP_PIO11_Pos)                   /*!< GPIO CLR: CLRP_PIO11 Mask             */
#define GPIO_CLR_CLRP_PIO12_Pos             12                                                      /*!< GPIO CLR: CLRP_PIO12 Position         */
#define GPIO_CLR_CLRP_PIO12_Msk             (0x01UL << GPIO_CLR_CLRP_PIO12_Pos)                   /*!< GPIO CLR: CLRP_PIO12 Mask             */
#define GPIO_CLR_CLRP_PIO13_Pos             13                                                      /*!< GPIO CLR: CLRP_PIO13 Position         */
#define GPIO_CLR_CLRP_PIO13_Msk             (0x01UL << GPIO_CLR_CLRP_PIO13_Pos)                   /*!< GPIO CLR: CLRP_PIO13 Mask             */
#define GPIO_CLR_CLRP_PIO14_Pos             14                                                      /*!< GPIO CLR: CLRP_PIO14 Position         */
#define GPIO_CLR_CLRP_PIO14_Msk             (0x01UL << GPIO_CLR_CLRP_PIO14_Pos)                   /*!< GPIO CLR: CLRP_PIO14 Mask             */
#define GPIO_CLR_CLRP_PIO15_Pos             15                                                      /*!< GPIO CLR: CLRP_PIO15 Position         */
#define GPIO_CLR_CLRP_PIO15_Msk             (0x01UL << GPIO_CLR_CLRP_PIO15_Pos)                   /*!< GPIO CLR: CLRP_PIO15 Mask             */
#define GPIO_CLR_CLRP_PIO16_Pos             16                                                      /*!< GPIO CLR: CLRP_PIO16 Position         */
#define GPIO_CLR_CLRP_PIO16_Msk             (0x01UL << GPIO_CLR_CLRP_PIO16_Pos)                   /*!< GPIO CLR: CLRP_PIO16 Mask             */
#define GPIO_CLR_CLRP_PIO17_Pos             17                                                      /*!< GPIO CLR: CLRP_PIO17 Position         */
#define GPIO_CLR_CLRP_PIO17_Msk             (0x01UL << GPIO_CLR_CLRP_PIO17_Pos)                   /*!< GPIO CLR: CLRP_PIO17 Mask             */
#define GPIO_CLR_CLRP_PIO18_Pos             18                                                      /*!< GPIO CLR: CLRP_PIO18 Position         */
#define GPIO_CLR_CLRP_PIO18_Msk             (0x01UL << GPIO_CLR_CLRP_PIO18_Pos)                   /*!< GPIO CLR: CLRP_PIO18 Mask             */
#define GPIO_CLR_CLRP_PIO19_Pos             19                                                      /*!< GPIO CLR: CLRP_PIO19 Position         */
#define GPIO_CLR_CLRP_PIO19_Msk             (0x01UL << GPIO_CLR_CLRP_PIO19_Pos)                   /*!< GPIO CLR: CLRP_PIO19 Mask             */
#define GPIO_CLR_CLRP_PIO20_Pos             20                                                      /*!< GPIO CLR: CLRP_PIO20 Position         */
#define GPIO_CLR_CLRP_PIO20_Msk             (0x01UL << GPIO_CLR_CLRP_PIO20_Pos)                   /*!< GPIO CLR: CLRP_PIO20 Mask             */
#define GPIO_CLR_CLRP_PIO21_Pos             21                                                      /*!< GPIO CLR: CLRP_PIO21 Position         */
#define GPIO_CLR_CLRP_PIO21_Msk             (0x01UL << GPIO_CLR_CLRP_PIO21_Pos)                   /*!< GPIO CLR: CLRP_PIO21 Mask             */

/* ---------------------------------  u_gpio_NOT  --------------------------------- */
#define GPIO_NOT_NOTP_PIO0_Pos              0                                                       /*!< GPIO NOT: NOTP_PIO0 Position          */
#define GPIO_NOT_NOTP_PIO0_Msk              (0x01UL << GPIO_NOT_NOTP_PIO0_Pos)                    /*!< GPIO NOT: NOTP_PIO0 Mask              */
#define GPIO_NOT_NOTP_PIO1_Pos              1                                                       /*!< GPIO NOT: NOTP_PIO1 Position          */
#define GPIO_NOT_NOTP_PIO1_Msk              (0x01UL << GPIO_NOT_NOTP_PIO1_Pos)                    /*!< GPIO NOT: NOTP_PIO1 Mask              */
#define GPIO_NOT_NOTP_PIO2_Pos              2                                                       /*!< GPIO NOT: NOTP_PIO2 Position          */
#define GPIO_NOT_NOTP_PIO2_Msk              (0x01UL << GPIO_NOT_NOTP_PIO2_Pos)                    /*!< GPIO NOT: NOTP_PIO2 Mask              */
#define GPIO_NOT_NOTP_PIO3_Pos              3                                                       /*!< GPIO NOT: NOTP_PIO3 Position          */
#define GPIO_NOT_NOTP_PIO3_Msk              (0x01UL << GPIO_NOT_NOTP_PIO3_Pos)                    /*!< GPIO NOT: NOTP_PIO3 Mask              */
#define GPIO_NOT_NOTP_PIO4_Pos              4                                                       /*!< GPIO NOT: NOTP_PIO4 Position          */
#define GPIO_NOT_NOTP_PIO4_Msk              (0x01UL << GPIO_NOT_NOTP_PIO4_Pos)                    /*!< GPIO NOT: NOTP_PIO4 Mask              */
#define GPIO_NOT_NOTP_PIO5_Pos              5                                                       /*!< GPIO NOT: NOTP_PIO5 Position          */
#define GPIO_NOT_NOTP_PIO5_Msk              (0x01UL << GPIO_NOT_NOTP_PIO5_Pos)                    /*!< GPIO NOT: NOTP_PIO5 Mask              */
#define GPIO_NOT_NOTP_PIO6_Pos              6                                                       /*!< GPIO NOT: NOTP_PIO6 Position          */
#define GPIO_NOT_NOTP_PIO6_Msk              (0x01UL << GPIO_NOT_NOTP_PIO6_Pos)                    /*!< GPIO NOT: NOTP_PIO6 Mask              */
#define GPIO_NOT_NOTP_PIO7_Pos              7                                                       /*!< GPIO NOT: NOTP_PIO7 Position          */
#define GPIO_NOT_NOTP_PIO7_Msk              (0x01UL << GPIO_NOT_NOTP_PIO7_Pos)                    /*!< GPIO NOT: NOTP_PIO7 Mask              */
#define GPIO_NOT_NOTP_PIO8_Pos              8                                                       /*!< GPIO NOT: NOTP_PIO8 Position          */
#define GPIO_NOT_NOTP_PIO8_Msk              (0x01UL << GPIO_NOT_NOTP_PIO8_Pos)                    /*!< GPIO NOT: NOTP_PIO8 Mask              */
#define GPIO_NOT_NOTP_PIO9_Pos              9                                                       /*!< GPIO NOT: NOTP_PIO9 Position          */
#define GPIO_NOT_NOTP_PIO9_Msk              (0x01UL << GPIO_NOT_NOTP_PIO9_Pos)                    /*!< GPIO NOT: NOTP_PIO9 Mask              */
#define GPIO_NOT_NOTP_PIO10_Pos             10                                                      /*!< GPIO NOT: NOTP_PIO10 Position         */
#define GPIO_NOT_NOTP_PIO10_Msk             (0x01UL << GPIO_NOT_NOTP_PIO10_Pos)                   /*!< GPIO NOT: NOTP_PIO10 Mask             */
#define GPIO_NOT_NOTP_PIO11_Pos             11                                                      /*!< GPIO NOT: NOTP_PIO11 Position         */
#define GPIO_NOT_NOTP_PIO11_Msk             (0x01UL << GPIO_NOT_NOTP_PIO11_Pos)                   /*!< GPIO NOT: NOTP_PIO11 Mask             */
#define GPIO_NOT_NOTP_PIO12_Pos             12                                                      /*!< GPIO NOT: NOTP_PIO12 Position         */
#define GPIO_NOT_NOTP_PIO12_Msk             (0x01UL << GPIO_NOT_NOTP_PIO12_Pos)                   /*!< GPIO NOT: NOTP_PIO12 Mask             */
#define GPIO_NOT_NOTP_PIO13_Pos             13                                                      /*!< GPIO NOT: NOTP_PIO13 Position         */
#define GPIO_NOT_NOTP_PIO13_Msk             (0x01UL << GPIO_NOT_NOTP_PIO13_Pos)                   /*!< GPIO NOT: NOTP_PIO13 Mask             */
#define GPIO_NOT_NOTP_PIO14_Pos             14                                                      /*!< GPIO NOT: NOTP_PIO14 Position         */
#define GPIO_NOT_NOTP_PIO14_Msk             (0x01UL << GPIO_NOT_NOTP_PIO14_Pos)                   /*!< GPIO NOT: NOTP_PIO14 Mask             */
#define GPIO_NOT_NOTP_PIO15_Pos             15                                                      /*!< GPIO NOT: NOTP_PIO15 Position         */
#define GPIO_NOT_NOTP_PIO15_Msk             (0x01UL << GPIO_NOT_NOTP_PIO15_Pos)                   /*!< GPIO NOT: NOTP_PIO15 Mask             */
#define GPIO_NOT_NOTP_PIO16_Pos             16                                                      /*!< GPIO NOT: NOTP_PIO16 Position         */
#define GPIO_NOT_NOTP_PIO16_Msk             (0x01UL << GPIO_NOT_NOTP_PIO16_Pos)                   /*!< GPIO NOT: NOTP_PIO16 Mask             */
#define GPIO_NOT_NOTP_PIO17_Pos             17                                                      /*!< GPIO NOT: NOTP_PIO17 Position         */
#define GPIO_NOT_NOTP_PIO17_Msk             (0x01UL << GPIO_NOT_NOTP_PIO17_Pos)                   /*!< GPIO NOT: NOTP_PIO17 Mask             */
#define GPIO_NOT_NOTP_PIO18_Pos             18                                                      /*!< GPIO NOT: NOTP_PIO18 Position         */
#define GPIO_NOT_NOTP_PIO18_Msk             (0x01UL << GPIO_NOT_NOTP_PIO18_Pos)                   /*!< GPIO NOT: NOTP_PIO18 Mask             */
#define GPIO_NOT_NOTP_PIO19_Pos             19                                                      /*!< GPIO NOT: NOTP_PIO19 Position         */
#define GPIO_NOT_NOTP_PIO19_Msk             (0x01UL << GPIO_NOT_NOTP_PIO19_Pos)                   /*!< GPIO NOT: NOTP_PIO19 Mask             */
#define GPIO_NOT_NOTP_PIO20_Pos             20                                                      /*!< GPIO NOT: NOTP_PIO20 Position         */
#define GPIO_NOT_NOTP_PIO20_Msk             (0x01UL << GPIO_NOT_NOTP_PIO20_Pos)                   /*!< GPIO NOT: NOTP_PIO20 Mask             */
#define GPIO_NOT_NOTP_PIO21_Pos             21                                                      /*!< GPIO NOT: NOTP_PIO21 Position         */
#define GPIO_NOT_NOTP_PIO21_Msk             (0x01UL << GPIO_NOT_NOTP_PIO21_Pos)                   /*!< GPIO NOT: NOTP_PIO21 Mask             */

/* --------------------------------  u_gpio_DIRSET  ------------------------------- */
#define GPIO_DIRSET_DIRSETP_PIO0_Pos        0                                                       /*!< GPIO DIRSET: DIRSETP_PIO0 Position    */
#define GPIO_DIRSET_DIRSETP_PIO0_Msk        (0x01UL << GPIO_DIRSET_DIRSETP_PIO0_Pos)              /*!< GPIO DIRSET: DIRSETP_PIO0 Mask        */
#define GPIO_DIRSET_DIRSETP_PIO1_Pos        1                                                       /*!< GPIO DIRSET: DIRSETP_PIO1 Position    */
#define GPIO_DIRSET_DIRSETP_PIO1_Msk        (0x01UL << GPIO_DIRSET_DIRSETP_PIO1_Pos)              /*!< GPIO DIRSET: DIRSETP_PIO1 Mask        */
#define GPIO_DIRSET_DIRSETP_PIO2_Pos        2                                                       /*!< GPIO DIRSET: DIRSETP_PIO2 Position    */
#define GPIO_DIRSET_DIRSETP_PIO2_Msk        (0x01UL << GPIO_DIRSET_DIRSETP_PIO2_Pos)              /*!< GPIO DIRSET: DIRSETP_PIO2 Mask        */
#define GPIO_DIRSET_DIRSETP_PIO3_Pos        3                                                       /*!< GPIO DIRSET: DIRSETP_PIO3 Position    */
#define GPIO_DIRSET_DIRSETP_PIO3_Msk        (0x01UL << GPIO_DIRSET_DIRSETP_PIO3_Pos)              /*!< GPIO DIRSET: DIRSETP_PIO3 Mask        */
#define GPIO_DIRSET_DIRSETP_PIO4_Pos        4                                                       /*!< GPIO DIRSET: DIRSETP_PIO4 Position    */
#define GPIO_DIRSET_DIRSETP_PIO4_Msk        (0x01UL << GPIO_DIRSET_DIRSETP_PIO4_Pos)              /*!< GPIO DIRSET: DIRSETP_PIO4 Mask        */
#define GPIO_DIRSET_DIRSETP_PIO5_Pos        5                                                       /*!< GPIO DIRSET: DIRSETP_PIO5 Position    */
#define GPIO_DIRSET_DIRSETP_PIO5_Msk        (0x01UL << GPIO_DIRSET_DIRSETP_PIO5_Pos)              /*!< GPIO DIRSET: DIRSETP_PIO5 Mask        */
#define GPIO_DIRSET_DIRSETP_PIO6_Pos        6                                                       /*!< GPIO DIRSET: DIRSETP_PIO6 Position    */
#define GPIO_DIRSET_DIRSETP_PIO6_Msk        (0x01UL << GPIO_DIRSET_DIRSETP_PIO6_Pos)              /*!< GPIO DIRSET: DIRSETP_PIO6 Mask        */
#define GPIO_DIRSET_DIRSETP_PIO7_Pos        7                                                       /*!< GPIO DIRSET: DIRSETP_PIO7 Position    */
#define GPIO_DIRSET_DIRSETP_PIO7_Msk        (0x01UL << GPIO_DIRSET_DIRSETP_PIO7_Pos)              /*!< GPIO DIRSET: DIRSETP_PIO7 Mask        */
#define GPIO_DIRSET_DIRSETP_PIO8_Pos        8                                                       /*!< GPIO DIRSET: DIRSETP_PIO8 Position    */
#define GPIO_DIRSET_DIRSETP_PIO8_Msk        (0x01UL << GPIO_DIRSET_DIRSETP_PIO8_Pos)              /*!< GPIO DIRSET: DIRSETP_PIO8 Mask        */
#define GPIO_DIRSET_DIRSETP_PIO9_Pos        9                                                       /*!< GPIO DIRSET: DIRSETP_PIO9 Position    */
#define GPIO_DIRSET_DIRSETP_PIO9_Msk        (0x01UL << GPIO_DIRSET_DIRSETP_PIO9_Pos)              /*!< GPIO DIRSET: DIRSETP_PIO9 Mask        */
#define GPIO_DIRSET_DIRSETP_PIO10_Pos       10                                                      /*!< GPIO DIRSET: DIRSETP_PIO10 Position   */
#define GPIO_DIRSET_DIRSETP_PIO10_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO10_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO10 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO11_Pos       11                                                      /*!< GPIO DIRSET: DIRSETP_PIO11 Position   */
#define GPIO_DIRSET_DIRSETP_PIO11_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO11_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO11 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO12_Pos       12                                                      /*!< GPIO DIRSET: DIRSETP_PIO12 Position   */
#define GPIO_DIRSET_DIRSETP_PIO12_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO12_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO12 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO13_Pos       13                                                      /*!< GPIO DIRSET: DIRSETP_PIO13 Position   */
#define GPIO_DIRSET_DIRSETP_PIO13_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO13_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO13 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO14_Pos       14                                                      /*!< GPIO DIRSET: DIRSETP_PIO14 Position   */
#define GPIO_DIRSET_DIRSETP_PIO14_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO14_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO14 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO15_Pos       15                                                      /*!< GPIO DIRSET: DIRSETP_PIO15 Position   */
#define GPIO_DIRSET_DIRSETP_PIO15_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO15_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO15 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO16_Pos       16                                                      /*!< GPIO DIRSET: DIRSETP_PIO16 Position   */
#define GPIO_DIRSET_DIRSETP_PIO16_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO16_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO16 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO17_Pos       17                                                      /*!< GPIO DIRSET: DIRSETP_PIO17 Position   */
#define GPIO_DIRSET_DIRSETP_PIO17_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO17_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO17 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO18_Pos       18                                                      /*!< GPIO DIRSET: DIRSETP_PIO18 Position   */
#define GPIO_DIRSET_DIRSETP_PIO18_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO18_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO18 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO19_Pos       19                                                      /*!< GPIO DIRSET: DIRSETP_PIO19 Position   */
#define GPIO_DIRSET_DIRSETP_PIO19_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO19_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO19 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO20_Pos       20                                                      /*!< GPIO DIRSET: DIRSETP_PIO20 Position   */
#define GPIO_DIRSET_DIRSETP_PIO20_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO20_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO20 Mask       */
#define GPIO_DIRSET_DIRSETP_PIO21_Pos       21                                                      /*!< GPIO DIRSET: DIRSETP_PIO21 Position   */
#define GPIO_DIRSET_DIRSETP_PIO21_Msk       (0x01UL << GPIO_DIRSET_DIRSETP_PIO21_Pos)             /*!< GPIO DIRSET: DIRSETP_PIO21 Mask       */

/* --------------------------------  u_gpio_DIRCLR  ------------------------------- */
#define GPIO_DIRCLR_DIRCLRP_PIO0_Pos        0                                                       /*!< GPIO DIRCLR: DIRCLRP_PIO0 Position    */
#define GPIO_DIRCLR_DIRCLRP_PIO0_Msk        (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO0_Pos)              /*!< GPIO DIRCLR: DIRCLRP_PIO0 Mask        */
#define GPIO_DIRCLR_DIRCLRP_PIO1_Pos        1                                                       /*!< GPIO DIRCLR: DIRCLRP_PIO1 Position    */
#define GPIO_DIRCLR_DIRCLRP_PIO1_Msk        (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO1_Pos)              /*!< GPIO DIRCLR: DIRCLRP_PIO1 Mask        */
#define GPIO_DIRCLR_DIRCLRP_PIO2_Pos        2                                                       /*!< GPIO DIRCLR: DIRCLRP_PIO2 Position    */
#define GPIO_DIRCLR_DIRCLRP_PIO2_Msk        (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO2_Pos)              /*!< GPIO DIRCLR: DIRCLRP_PIO2 Mask        */
#define GPIO_DIRCLR_DIRCLRP_PIO3_Pos        3                                                       /*!< GPIO DIRCLR: DIRCLRP_PIO3 Position    */
#define GPIO_DIRCLR_DIRCLRP_PIO3_Msk        (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO3_Pos)              /*!< GPIO DIRCLR: DIRCLRP_PIO3 Mask        */
#define GPIO_DIRCLR_DIRCLRP_PIO4_Pos        4                                                       /*!< GPIO DIRCLR: DIRCLRP_PIO4 Position    */
#define GPIO_DIRCLR_DIRCLRP_PIO4_Msk        (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO4_Pos)              /*!< GPIO DIRCLR: DIRCLRP_PIO4 Mask        */
#define GPIO_DIRCLR_DIRCLRP_PIO5_Pos        5                                                       /*!< GPIO DIRCLR: DIRCLRP_PIO5 Position    */
#define GPIO_DIRCLR_DIRCLRP_PIO5_Msk        (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO5_Pos)              /*!< GPIO DIRCLR: DIRCLRP_PIO5 Mask        */
#define GPIO_DIRCLR_DIRCLRP_PIO6_Pos        6                                                       /*!< GPIO DIRCLR: DIRCLRP_PIO6 Position    */
#define GPIO_DIRCLR_DIRCLRP_PIO6_Msk        (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO6_Pos)              /*!< GPIO DIRCLR: DIRCLRP_PIO6 Mask        */
#define GPIO_DIRCLR_DIRCLRP_PIO7_Pos        7                                                       /*!< GPIO DIRCLR: DIRCLRP_PIO7 Position    */
#define GPIO_DIRCLR_DIRCLRP_PIO7_Msk        (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO7_Pos)              /*!< GPIO DIRCLR: DIRCLRP_PIO7 Mask        */
#define GPIO_DIRCLR_DIRCLRP_PIO8_Pos        8                                                       /*!< GPIO DIRCLR: DIRCLRP_PIO8 Position    */
#define GPIO_DIRCLR_DIRCLRP_PIO8_Msk        (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO8_Pos)              /*!< GPIO DIRCLR: DIRCLRP_PIO8 Mask        */
#define GPIO_DIRCLR_DIRCLRP_PIO9_Pos        9                                                       /*!< GPIO DIRCLR: DIRCLRP_PIO9 Position    */
#define GPIO_DIRCLR_DIRCLRP_PIO9_Msk        (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO9_Pos)              /*!< GPIO DIRCLR: DIRCLRP_PIO9 Mask        */
#define GPIO_DIRCLR_DIRCLRP_PIO10_Pos       10                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO10 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO10_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO10_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO10 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO11_Pos       11                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO11 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO11_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO11_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO11 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO12_Pos       12                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO12 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO12_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO12_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO12 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO13_Pos       13                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO13 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO13_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO13_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO13 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO14_Pos       14                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO14 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO14_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO14_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO14 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO15_Pos       15                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO15 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO15_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO15_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO15 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO16_Pos       16                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO16 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO16_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO16_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO16 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO17_Pos       17                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO17 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO17_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO17_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO17 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO18_Pos       18                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO18 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO18_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO18_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO18 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO19_Pos       19                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO19 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO19_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO19_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO19 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO20_Pos       20                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO20 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO20_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO20_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO20 Mask       */
#define GPIO_DIRCLR_DIRCLRP_PIO21_Pos       21                                                      /*!< GPIO DIRCLR: DIRCLRP_PIO21 Position   */
#define GPIO_DIRCLR_DIRCLRP_PIO21_Msk       (0x01UL << GPIO_DIRCLR_DIRCLRP_PIO21_Pos)             /*!< GPIO DIRCLR: DIRCLRP_PIO21 Mask       */

/* --------------------------------  u_gpio_DIRNOT  ------------------------------- */
#define GPIO_DIRNOT_DIRNOTP_PIO0_Pos        0                                                       /*!< GPIO DIRNOT: DIRNOTP_PIO0 Position    */
#define GPIO_DIRNOT_DIRNOTP_PIO0_Msk        (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO0_Pos)              /*!< GPIO DIRNOT: DIRNOTP_PIO0 Mask        */
#define GPIO_DIRNOT_DIRNOTP_PIO1_Pos        1                                                       /*!< GPIO DIRNOT: DIRNOTP_PIO1 Position    */
#define GPIO_DIRNOT_DIRNOTP_PIO1_Msk        (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO1_Pos)              /*!< GPIO DIRNOT: DIRNOTP_PIO1 Mask        */
#define GPIO_DIRNOT_DIRNOTP_PIO2_Pos        2                                                       /*!< GPIO DIRNOT: DIRNOTP_PIO2 Position    */
#define GPIO_DIRNOT_DIRNOTP_PIO2_Msk        (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO2_Pos)              /*!< GPIO DIRNOT: DIRNOTP_PIO2 Mask        */
#define GPIO_DIRNOT_DIRNOTP_PIO3_Pos        3                                                       /*!< GPIO DIRNOT: DIRNOTP_PIO3 Position    */
#define GPIO_DIRNOT_DIRNOTP_PIO3_Msk        (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO3_Pos)              /*!< GPIO DIRNOT: DIRNOTP_PIO3 Mask        */
#define GPIO_DIRNOT_DIRNOTP_PIO4_Pos        4                                                       /*!< GPIO DIRNOT: DIRNOTP_PIO4 Position    */
#define GPIO_DIRNOT_DIRNOTP_PIO4_Msk        (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO4_Pos)              /*!< GPIO DIRNOT: DIRNOTP_PIO4 Mask        */
#define GPIO_DIRNOT_DIRNOTP_PIO5_Pos        5                                                       /*!< GPIO DIRNOT: DIRNOTP_PIO5 Position    */
#define GPIO_DIRNOT_DIRNOTP_PIO5_Msk        (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO5_Pos)              /*!< GPIO DIRNOT: DIRNOTP_PIO5 Mask        */
#define GPIO_DIRNOT_DIRNOTP_PIO6_Pos        6                                                       /*!< GPIO DIRNOT: DIRNOTP_PIO6 Position    */
#define GPIO_DIRNOT_DIRNOTP_PIO6_Msk        (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO6_Pos)              /*!< GPIO DIRNOT: DIRNOTP_PIO6 Mask        */
#define GPIO_DIRNOT_DIRNOTP_PIO7_Pos        7                                                       /*!< GPIO DIRNOT: DIRNOTP_PIO7 Position    */
#define GPIO_DIRNOT_DIRNOTP_PIO7_Msk        (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO7_Pos)              /*!< GPIO DIRNOT: DIRNOTP_PIO7 Mask        */
#define GPIO_DIRNOT_DIRNOTP_PIO8_Pos        8                                                       /*!< GPIO DIRNOT: DIRNOTP_PIO8 Position    */
#define GPIO_DIRNOT_DIRNOTP_PIO8_Msk        (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO8_Pos)              /*!< GPIO DIRNOT: DIRNOTP_PIO8 Mask        */
#define GPIO_DIRNOT_DIRNOTP_PIO9_Pos        9                                                       /*!< GPIO DIRNOT: DIRNOTP_PIO9 Position    */
#define GPIO_DIRNOT_DIRNOTP_PIO9_Msk        (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO9_Pos)              /*!< GPIO DIRNOT: DIRNOTP_PIO9 Mask        */
#define GPIO_DIRNOT_DIRNOTP_PIO10_Pos       10                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO10 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO10_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO10_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO10 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO11_Pos       11                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO11 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO11_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO11_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO11 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO12_Pos       12                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO12 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO12_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO12_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO12 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO13_Pos       13                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO13 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO13_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO13_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO13 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO14_Pos       14                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO14 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO14_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO14_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO14 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO15_Pos       15                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO15 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO15_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO15_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO15 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO16_Pos       16                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO16 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO16_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO16_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO16 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO17_Pos       17                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO17 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO17_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO17_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO17 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO18_Pos       18                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO18 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO18_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO18_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO18 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO19_Pos       19                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO19 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO19_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO19_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO19 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO20_Pos       20                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO20 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO20_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO20_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO20 Mask       */
#define GPIO_DIRNOT_DIRNOTP_PIO21_Pos       21                                                      /*!< GPIO DIRNOT: DIRNOTP_PIO21 Position   */
#define GPIO_DIRNOT_DIRNOTP_PIO21_Msk       (0x01UL << GPIO_DIRNOT_DIRNOTP_PIO21_Pos)             /*!< GPIO DIRNOT: DIRNOTP_PIO21 Mask       */


/* ================================================================================ */
/* ================        struct 'u_spifi' Position & Mask        ================ */
/* ================================================================================ */


/* --------------------------------  u_spifi_CTRL  -------------------------------- */
#define SPIFI_CTRL_TIMEOUT_Pos              0                                                       /*!< SPIFI CTRL: TIMEOUT Position          */
#define SPIFI_CTRL_TIMEOUT_Msk              (0x0000ffffUL << SPIFI_CTRL_TIMEOUT_Pos)              /*!< SPIFI CTRL: TIMEOUT Mask              */
#define SPIFI_CTRL_CSHIGH_Pos               16                                                      /*!< SPIFI CTRL: CSHIGH Position           */
#define SPIFI_CTRL_CSHIGH_Msk               (0x0fUL << SPIFI_CTRL_CSHIGH_Pos)                     /*!< SPIFI CTRL: CSHIGH Mask               */
#define SPIFI_CTRL_D_PRFTCH_DIS_Pos         21                                                      /*!< SPIFI CTRL: D_PRFTCH_DIS Position     */
#define SPIFI_CTRL_D_PRFTCH_DIS_Msk         (0x01UL << SPIFI_CTRL_D_PRFTCH_DIS_Pos)               /*!< SPIFI CTRL: D_PRFTCH_DIS Mask         */
#define SPIFI_CTRL_INTEN_Pos                22                                                      /*!< SPIFI CTRL: INTEN Position            */
#define SPIFI_CTRL_INTEN_Msk                (0x01UL << SPIFI_CTRL_INTEN_Pos)                      /*!< SPIFI CTRL: INTEN Mask                */
#define SPIFI_CTRL_MODE3_Pos                23                                                      /*!< SPIFI CTRL: MODE3 Position            */
#define SPIFI_CTRL_MODE3_Msk                (0x01UL << SPIFI_CTRL_MODE3_Pos)                      /*!< SPIFI CTRL: MODE3 Mask                */
#define SPIFI_CTRL_PRFTCH_DIS_Pos           27                                                      /*!< SPIFI CTRL: PRFTCH_DIS Position       */
#define SPIFI_CTRL_PRFTCH_DIS_Msk           (0x01UL << SPIFI_CTRL_PRFTCH_DIS_Pos)                 /*!< SPIFI CTRL: PRFTCH_DIS Mask           */
#define SPIFI_CTRL_DUAL_Pos                 28                                                      /*!< SPIFI CTRL: DUAL Position             */
#define SPIFI_CTRL_DUAL_Msk                 (0x01UL << SPIFI_CTRL_DUAL_Pos)                       /*!< SPIFI CTRL: DUAL Mask                 */
#define SPIFI_CTRL_RFCLK_Pos                29                                                      /*!< SPIFI CTRL: RFCLK Position            */
#define SPIFI_CTRL_RFCLK_Msk                (0x01UL << SPIFI_CTRL_RFCLK_Pos)                      /*!< SPIFI CTRL: RFCLK Mask                */
#define SPIFI_CTRL_FBCLK_Pos                30                                                      /*!< SPIFI CTRL: FBCLK Position            */
#define SPIFI_CTRL_FBCLK_Msk                (0x01UL << SPIFI_CTRL_FBCLK_Pos)                      /*!< SPIFI CTRL: FBCLK Mask                */
#define SPIFI_CTRL_DMAEN_Pos                31                                                      /*!< SPIFI CTRL: DMAEN Position            */
#define SPIFI_CTRL_DMAEN_Msk                (0x01UL << SPIFI_CTRL_DMAEN_Pos)                      /*!< SPIFI CTRL: DMAEN Mask                */

/* ---------------------------------  u_spifi_CMD  -------------------------------- */
#define SPIFI_CMD_DATALEN_Pos               0                                                       /*!< SPIFI CMD: DATALEN Position           */
#define SPIFI_CMD_DATALEN_Msk               (0x00003fffUL << SPIFI_CMD_DATALEN_Pos)               /*!< SPIFI CMD: DATALEN Mask               */
#define SPIFI_CMD_POLL_Pos                  14                                                      /*!< SPIFI CMD: POLL Position              */
#define SPIFI_CMD_POLL_Msk                  (0x01UL << SPIFI_CMD_POLL_Pos)                        /*!< SPIFI CMD: POLL Mask                  */
#define SPIFI_CMD_DOUT_Pos                  15                                                      /*!< SPIFI CMD: DOUT Position              */
#define SPIFI_CMD_DOUT_Msk                  (0x01UL << SPIFI_CMD_DOUT_Pos)                        /*!< SPIFI CMD: DOUT Mask                  */
#define SPIFI_CMD_INTLEN_Pos                16                                                      /*!< SPIFI CMD: INTLEN Position            */
#define SPIFI_CMD_INTLEN_Msk                (0x07UL << SPIFI_CMD_INTLEN_Pos)                      /*!< SPIFI CMD: INTLEN Mask                */
#define SPIFI_CMD_FIELDFORM_Pos             19                                                      /*!< SPIFI CMD: FIELDFORM Position         */
#define SPIFI_CMD_FIELDFORM_Msk             (0x03UL << SPIFI_CMD_FIELDFORM_Pos)                   /*!< SPIFI CMD: FIELDFORM Mask             */
#define SPIFI_CMD_FRAMEFORM_Pos             21                                                      /*!< SPIFI CMD: FRAMEFORM Position         */
#define SPIFI_CMD_FRAMEFORM_Msk             (0x07UL << SPIFI_CMD_FRAMEFORM_Pos)                   /*!< SPIFI CMD: FRAMEFORM Mask             */
#define SPIFI_CMD_OPCODE_Pos                24                                                      /*!< SPIFI CMD: OPCODE Position            */
#define SPIFI_CMD_OPCODE_Msk                (0x000000ffUL << SPIFI_CMD_OPCODE_Pos)                /*!< SPIFI CMD: OPCODE Mask                */

/* --------------------------------  u_spifi_ADDR  -------------------------------- */
#define SPIFI_ADDR_ADDR_Pos                 0                                                       /*!< SPIFI ADDR: ADDR Position             */
#define SPIFI_ADDR_ADDR_Msk                 (0xffffffffUL << SPIFI_ADDR_ADDR_Pos)                 /*!< SPIFI ADDR: ADDR Mask                 */

/* --------------------------------  u_spifi_IDATA  ------------------------------- */
#define SPIFI_IDATA_IDATA_Pos               0                                                       /*!< SPIFI IDATA: IDATA Position           */
#define SPIFI_IDATA_IDATA_Msk               (0xffffffffUL << SPIFI_IDATA_IDATA_Pos)               /*!< SPIFI IDATA: IDATA Mask               */

/* -------------------------------  u_spifi_CLIMIT  ------------------------------- */
#define SPIFI_CLIMIT_CLIMIT_Pos             0                                                       /*!< SPIFI CLIMIT: CLIMIT Position         */
#define SPIFI_CLIMIT_CLIMIT_Msk             (0xffffffffUL << SPIFI_CLIMIT_CLIMIT_Pos)             /*!< SPIFI CLIMIT: CLIMIT Mask             */

/* --------------------------------  u_spifi_DATA  -------------------------------- */
#define SPIFI_DATA_DATA_Pos                 0                                                       /*!< SPIFI DATA: DATA Position             */
#define SPIFI_DATA_DATA_Msk                 (0xffffffffUL << SPIFI_DATA_DATA_Pos)                 /*!< SPIFI DATA: DATA Mask                 */

/* --------------------------------  u_spifi_MCMD  -------------------------------- */
#define SPIFI_MCMD_POLL_Pos                 14                                                      /*!< SPIFI MCMD: POLL Position             */
#define SPIFI_MCMD_POLL_Msk                 (0x01UL << SPIFI_MCMD_POLL_Pos)                       /*!< SPIFI MCMD: POLL Mask                 */
#define SPIFI_MCMD_DOUT_Pos                 15                                                      /*!< SPIFI MCMD: DOUT Position             */
#define SPIFI_MCMD_DOUT_Msk                 (0x01UL << SPIFI_MCMD_DOUT_Pos)                       /*!< SPIFI MCMD: DOUT Mask                 */
#define SPIFI_MCMD_INTLEN_Pos               16                                                      /*!< SPIFI MCMD: INTLEN Position           */
#define SPIFI_MCMD_INTLEN_Msk               (0x07UL << SPIFI_MCMD_INTLEN_Pos)                     /*!< SPIFI MCMD: INTLEN Mask               */
#define SPIFI_MCMD_FIELDFORM_Pos            19                                                      /*!< SPIFI MCMD: FIELDFORM Position        */
#define SPIFI_MCMD_FIELDFORM_Msk            (0x03UL << SPIFI_MCMD_FIELDFORM_Pos)                  /*!< SPIFI MCMD: FIELDFORM Mask            */
#define SPIFI_MCMD_FRAMEFORM_Pos            21                                                      /*!< SPIFI MCMD: FRAMEFORM Position        */
#define SPIFI_MCMD_FRAMEFORM_Msk            (0x07UL << SPIFI_MCMD_FRAMEFORM_Pos)                  /*!< SPIFI MCMD: FRAMEFORM Mask            */
#define SPIFI_MCMD_OPCODE_Pos               24                                                      /*!< SPIFI MCMD: OPCODE Position           */
#define SPIFI_MCMD_OPCODE_Msk               (0x000000ffUL << SPIFI_MCMD_OPCODE_Pos)               /*!< SPIFI MCMD: OPCODE Mask               */

/* --------------------------------  u_spifi_STAT  -------------------------------- */
#define SPIFI_STAT_MCINIT_Pos               0                                                       /*!< SPIFI STAT: MCINIT Position           */
#define SPIFI_STAT_MCINIT_Msk               (0x01UL << SPIFI_STAT_MCINIT_Pos)                     /*!< SPIFI STAT: MCINIT Mask               */
#define SPIFI_STAT_CMD_Pos                  1                                                       /*!< SPIFI STAT: CMD Position              */
#define SPIFI_STAT_CMD_Msk                  (0x01UL << SPIFI_STAT_CMD_Pos)                        /*!< SPIFI STAT: CMD Mask                  */
#define SPIFI_STAT_RESET_Pos                4                                                       /*!< SPIFI STAT: RESET Position            */
#define SPIFI_STAT_RESET_Msk                (0x01UL << SPIFI_STAT_RESET_Pos)                      /*!< SPIFI STAT: RESET Mask                */
#define SPIFI_STAT_INTRQ_Pos                5                                                       /*!< SPIFI STAT: INTRQ Position            */
#define SPIFI_STAT_INTRQ_Msk                (0x01UL << SPIFI_STAT_INTRQ_Pos)                      /*!< SPIFI STAT: INTRQ Mask                */
#define SPIFI_STAT_VERSION_Pos              24                                                      /*!< SPIFI STAT: VERSION Position          */
#define SPIFI_STAT_VERSION_Msk              (0x000000ffUL << SPIFI_STAT_VERSION_Pos)              /*!< SPIFI STAT: VERSION Mask              */


/* ================================================================================ */
/* ================         struct 'u_dma' Position & Mask         ================ */
/* ================================================================================ */


/* ---------------------------------  u_dma_CTRL  --------------------------------- */
#define DMA_CTRL_ENABLE_Pos                 0                                                       /*!< DMA CTRL: ENABLE Position             */
#define DMA_CTRL_ENABLE_Msk                 (0x01UL << DMA_CTRL_ENABLE_Pos)                       /*!< DMA CTRL: ENABLE Mask                 */

/* --------------------------------  u_dma_INTSTAT  ------------------------------- */
#define DMA_INTSTAT_ACTIVEINT_Pos           1                                                       /*!< DMA INTSTAT: ACTIVEINT Position       */
#define DMA_INTSTAT_ACTIVEINT_Msk           (0x01UL << DMA_INTSTAT_ACTIVEINT_Pos)                 /*!< DMA INTSTAT: ACTIVEINT Mask           */
#define DMA_INTSTAT_ACTIVEERRINT_Pos        2                                                       /*!< DMA INTSTAT: ACTIVEERRINT Position    */
#define DMA_INTSTAT_ACTIVEERRINT_Msk        (0x01UL << DMA_INTSTAT_ACTIVEERRINT_Pos)              /*!< DMA INTSTAT: ACTIVEERRINT Mask        */

/* -------------------------------  u_dma_SRAMBASE  ------------------------------- */
#define DMA_SRAMBASE_OFFSET_Pos             9                                                       /*!< DMA SRAMBASE: OFFSET Position         */
#define DMA_SRAMBASE_OFFSET_Msk             (0x007fffffUL << DMA_SRAMBASE_OFFSET_Pos)             /*!< DMA SRAMBASE: OFFSET Mask             */

/* ------------------------------  u_dma_ENABLESET0  ------------------------------ */
#define DMA_ENABLESET0_ENA_CH0_Pos          0                                                       /*!< DMA ENABLESET0: ENA_CH0 Position      */
#define DMA_ENABLESET0_ENA_CH0_Msk          (0x01UL << DMA_ENABLESET0_ENA_CH0_Pos)                /*!< DMA ENABLESET0: ENA_CH0 Mask          */
#define DMA_ENABLESET0_ENA_CH1_Pos          1                                                       /*!< DMA ENABLESET0: ENA_CH1 Position      */
#define DMA_ENABLESET0_ENA_CH1_Msk          (0x01UL << DMA_ENABLESET0_ENA_CH1_Pos)                /*!< DMA ENABLESET0: ENA_CH1 Mask          */
#define DMA_ENABLESET0_ENA_CH2_Pos          2                                                       /*!< DMA ENABLESET0: ENA_CH2 Position      */
#define DMA_ENABLESET0_ENA_CH2_Msk          (0x01UL << DMA_ENABLESET0_ENA_CH2_Pos)                /*!< DMA ENABLESET0: ENA_CH2 Mask          */
#define DMA_ENABLESET0_ENA_CH3_Pos          3                                                       /*!< DMA ENABLESET0: ENA_CH3 Position      */
#define DMA_ENABLESET0_ENA_CH3_Msk          (0x01UL << DMA_ENABLESET0_ENA_CH3_Pos)                /*!< DMA ENABLESET0: ENA_CH3 Mask          */
#define DMA_ENABLESET0_ENA_CH4_Pos          4                                                       /*!< DMA ENABLESET0: ENA_CH4 Position      */
#define DMA_ENABLESET0_ENA_CH4_Msk          (0x01UL << DMA_ENABLESET0_ENA_CH4_Pos)                /*!< DMA ENABLESET0: ENA_CH4 Mask          */
#define DMA_ENABLESET0_ENA_CH5_Pos          5                                                       /*!< DMA ENABLESET0: ENA_CH5 Position      */
#define DMA_ENABLESET0_ENA_CH5_Msk          (0x01UL << DMA_ENABLESET0_ENA_CH5_Pos)                /*!< DMA ENABLESET0: ENA_CH5 Mask          */
#define DMA_ENABLESET0_ENA_CH6_Pos          6                                                       /*!< DMA ENABLESET0: ENA_CH6 Position      */
#define DMA_ENABLESET0_ENA_CH6_Msk          (0x01UL << DMA_ENABLESET0_ENA_CH6_Pos)                /*!< DMA ENABLESET0: ENA_CH6 Mask          */
#define DMA_ENABLESET0_ENA_CH7_Pos          7                                                       /*!< DMA ENABLESET0: ENA_CH7 Position      */
#define DMA_ENABLESET0_ENA_CH7_Msk          (0x01UL << DMA_ENABLESET0_ENA_CH7_Pos)                /*!< DMA ENABLESET0: ENA_CH7 Mask          */
#define DMA_ENABLESET0_ENA_CH8_Pos          8                                                       /*!< DMA ENABLESET0: ENA_CH8 Position      */
#define DMA_ENABLESET0_ENA_CH8_Msk          (0x01UL << DMA_ENABLESET0_ENA_CH8_Pos)                /*!< DMA ENABLESET0: ENA_CH8 Mask          */
#define DMA_ENABLESET0_ENA_CH9_Pos          9                                                       /*!< DMA ENABLESET0: ENA_CH9 Position      */
#define DMA_ENABLESET0_ENA_CH9_Msk          (0x01UL << DMA_ENABLESET0_ENA_CH9_Pos)                /*!< DMA ENABLESET0: ENA_CH9 Mask          */
#define DMA_ENABLESET0_ENA_CH10_Pos         10                                                      /*!< DMA ENABLESET0: ENA_CH10 Position     */
#define DMA_ENABLESET0_ENA_CH10_Msk         (0x01UL << DMA_ENABLESET0_ENA_CH10_Pos)               /*!< DMA ENABLESET0: ENA_CH10 Mask         */
#define DMA_ENABLESET0_ENA_CH11_Pos         11                                                      /*!< DMA ENABLESET0: ENA_CH11 Position     */
#define DMA_ENABLESET0_ENA_CH11_Msk         (0x01UL << DMA_ENABLESET0_ENA_CH11_Pos)               /*!< DMA ENABLESET0: ENA_CH11 Mask         */
#define DMA_ENABLESET0_ENA_CH12_Pos         12                                                      /*!< DMA ENABLESET0: ENA_CH12 Position     */
#define DMA_ENABLESET0_ENA_CH12_Msk         (0x01UL << DMA_ENABLESET0_ENA_CH12_Pos)               /*!< DMA ENABLESET0: ENA_CH12 Mask         */
#define DMA_ENABLESET0_ENA_CH13_Pos         13                                                      /*!< DMA ENABLESET0: ENA_CH13 Position     */
#define DMA_ENABLESET0_ENA_CH13_Msk         (0x01UL << DMA_ENABLESET0_ENA_CH13_Pos)               /*!< DMA ENABLESET0: ENA_CH13 Mask         */
#define DMA_ENABLESET0_ENA_CH14_Pos         14                                                      /*!< DMA ENABLESET0: ENA_CH14 Position     */
#define DMA_ENABLESET0_ENA_CH14_Msk         (0x01UL << DMA_ENABLESET0_ENA_CH14_Pos)               /*!< DMA ENABLESET0: ENA_CH14 Mask         */
#define DMA_ENABLESET0_ENA_CH15_Pos         15                                                      /*!< DMA ENABLESET0: ENA_CH15 Position     */
#define DMA_ENABLESET0_ENA_CH15_Msk         (0x01UL << DMA_ENABLESET0_ENA_CH15_Pos)               /*!< DMA ENABLESET0: ENA_CH15 Mask         */
#define DMA_ENABLESET0_ENA_CH16_Pos         16                                                      /*!< DMA ENABLESET0: ENA_CH16 Position     */
#define DMA_ENABLESET0_ENA_CH16_Msk         (0x01UL << DMA_ENABLESET0_ENA_CH16_Pos)               /*!< DMA ENABLESET0: ENA_CH16 Mask         */
#define DMA_ENABLESET0_ENA_CH17_Pos         17                                                      /*!< DMA ENABLESET0: ENA_CH17 Position     */
#define DMA_ENABLESET0_ENA_CH17_Msk         (0x01UL << DMA_ENABLESET0_ENA_CH17_Pos)               /*!< DMA ENABLESET0: ENA_CH17 Mask         */
#define DMA_ENABLESET0_ENA_CH18_Pos         18                                                      /*!< DMA ENABLESET0: ENA_CH18 Position     */
#define DMA_ENABLESET0_ENA_CH18_Msk         (0x01UL << DMA_ENABLESET0_ENA_CH18_Pos)               /*!< DMA ENABLESET0: ENA_CH18 Mask         */

/* ------------------------------  u_dma_ENABLECLR0  ------------------------------ */
#define DMA_ENABLECLR0_CLR_CH0_Pos          0                                                       /*!< DMA ENABLECLR0: CLR_CH0 Position      */
#define DMA_ENABLECLR0_CLR_CH0_Msk          (0x01UL << DMA_ENABLECLR0_CLR_CH0_Pos)                /*!< DMA ENABLECLR0: CLR_CH0 Mask          */
#define DMA_ENABLECLR0_CLR_CH1_Pos          1                                                       /*!< DMA ENABLECLR0: CLR_CH1 Position      */
#define DMA_ENABLECLR0_CLR_CH1_Msk          (0x01UL << DMA_ENABLECLR0_CLR_CH1_Pos)                /*!< DMA ENABLECLR0: CLR_CH1 Mask          */
#define DMA_ENABLECLR0_CLR_CH2_Pos          2                                                       /*!< DMA ENABLECLR0: CLR_CH2 Position      */
#define DMA_ENABLECLR0_CLR_CH2_Msk          (0x01UL << DMA_ENABLECLR0_CLR_CH2_Pos)                /*!< DMA ENABLECLR0: CLR_CH2 Mask          */
#define DMA_ENABLECLR0_CLR_CH3_Pos          3                                                       /*!< DMA ENABLECLR0: CLR_CH3 Position      */
#define DMA_ENABLECLR0_CLR_CH3_Msk          (0x01UL << DMA_ENABLECLR0_CLR_CH3_Pos)                /*!< DMA ENABLECLR0: CLR_CH3 Mask          */
#define DMA_ENABLECLR0_CLR_CH4_Pos          4                                                       /*!< DMA ENABLECLR0: CLR_CH4 Position      */
#define DMA_ENABLECLR0_CLR_CH4_Msk          (0x01UL << DMA_ENABLECLR0_CLR_CH4_Pos)                /*!< DMA ENABLECLR0: CLR_CH4 Mask          */
#define DMA_ENABLECLR0_CLR_CH5_Pos          5                                                       /*!< DMA ENABLECLR0: CLR_CH5 Position      */
#define DMA_ENABLECLR0_CLR_CH5_Msk          (0x01UL << DMA_ENABLECLR0_CLR_CH5_Pos)                /*!< DMA ENABLECLR0: CLR_CH5 Mask          */
#define DMA_ENABLECLR0_CLR_CH6_Pos          6                                                       /*!< DMA ENABLECLR0: CLR_CH6 Position      */
#define DMA_ENABLECLR0_CLR_CH6_Msk          (0x01UL << DMA_ENABLECLR0_CLR_CH6_Pos)                /*!< DMA ENABLECLR0: CLR_CH6 Mask          */
#define DMA_ENABLECLR0_CLR_CH7_Pos          7                                                       /*!< DMA ENABLECLR0: CLR_CH7 Position      */
#define DMA_ENABLECLR0_CLR_CH7_Msk          (0x01UL << DMA_ENABLECLR0_CLR_CH7_Pos)                /*!< DMA ENABLECLR0: CLR_CH7 Mask          */
#define DMA_ENABLECLR0_CLR_CH8_Pos          8                                                       /*!< DMA ENABLECLR0: CLR_CH8 Position      */
#define DMA_ENABLECLR0_CLR_CH8_Msk          (0x01UL << DMA_ENABLECLR0_CLR_CH8_Pos)                /*!< DMA ENABLECLR0: CLR_CH8 Mask          */
#define DMA_ENABLECLR0_CLR_CH9_Pos          9                                                       /*!< DMA ENABLECLR0: CLR_CH9 Position      */
#define DMA_ENABLECLR0_CLR_CH9_Msk          (0x01UL << DMA_ENABLECLR0_CLR_CH9_Pos)                /*!< DMA ENABLECLR0: CLR_CH9 Mask          */
#define DMA_ENABLECLR0_CLR_CH10_Pos         10                                                      /*!< DMA ENABLECLR0: CLR_CH10 Position     */
#define DMA_ENABLECLR0_CLR_CH10_Msk         (0x01UL << DMA_ENABLECLR0_CLR_CH10_Pos)               /*!< DMA ENABLECLR0: CLR_CH10 Mask         */
#define DMA_ENABLECLR0_CLR_CH11_Pos         11                                                      /*!< DMA ENABLECLR0: CLR_CH11 Position     */
#define DMA_ENABLECLR0_CLR_CH11_Msk         (0x01UL << DMA_ENABLECLR0_CLR_CH11_Pos)               /*!< DMA ENABLECLR0: CLR_CH11 Mask         */
#define DMA_ENABLECLR0_CLR_CH12_Pos         12                                                      /*!< DMA ENABLECLR0: CLR_CH12 Position     */
#define DMA_ENABLECLR0_CLR_CH12_Msk         (0x01UL << DMA_ENABLECLR0_CLR_CH12_Pos)               /*!< DMA ENABLECLR0: CLR_CH12 Mask         */
#define DMA_ENABLECLR0_CLR_CH13_Pos         13                                                      /*!< DMA ENABLECLR0: CLR_CH13 Position     */
#define DMA_ENABLECLR0_CLR_CH13_Msk         (0x01UL << DMA_ENABLECLR0_CLR_CH13_Pos)               /*!< DMA ENABLECLR0: CLR_CH13 Mask         */
#define DMA_ENABLECLR0_CLR_CH14_Pos         14                                                      /*!< DMA ENABLECLR0: CLR_CH14 Position     */
#define DMA_ENABLECLR0_CLR_CH14_Msk         (0x01UL << DMA_ENABLECLR0_CLR_CH14_Pos)               /*!< DMA ENABLECLR0: CLR_CH14 Mask         */
#define DMA_ENABLECLR0_CLR_CH15_Pos         15                                                      /*!< DMA ENABLECLR0: CLR_CH15 Position     */
#define DMA_ENABLECLR0_CLR_CH15_Msk         (0x01UL << DMA_ENABLECLR0_CLR_CH15_Pos)               /*!< DMA ENABLECLR0: CLR_CH15 Mask         */
#define DMA_ENABLECLR0_CLR_CH16_Pos         16                                                      /*!< DMA ENABLECLR0: CLR_CH16 Position     */
#define DMA_ENABLECLR0_CLR_CH16_Msk         (0x01UL << DMA_ENABLECLR0_CLR_CH16_Pos)               /*!< DMA ENABLECLR0: CLR_CH16 Mask         */
#define DMA_ENABLECLR0_CLR_CH17_Pos         17                                                      /*!< DMA ENABLECLR0: CLR_CH17 Position     */
#define DMA_ENABLECLR0_CLR_CH17_Msk         (0x01UL << DMA_ENABLECLR0_CLR_CH17_Pos)               /*!< DMA ENABLECLR0: CLR_CH17 Mask         */
#define DMA_ENABLECLR0_CLR_CH18_Pos         18                                                      /*!< DMA ENABLECLR0: CLR_CH18 Position     */
#define DMA_ENABLECLR0_CLR_CH18_Msk         (0x01UL << DMA_ENABLECLR0_CLR_CH18_Pos)               /*!< DMA ENABLECLR0: CLR_CH18 Mask         */

/* --------------------------------  u_dma_ACTIVE0  ------------------------------- */
#define DMA_ACTIVE0_ACT_CH0_Pos             0                                                       /*!< DMA ACTIVE0: ACT_CH0 Position         */
#define DMA_ACTIVE0_ACT_CH0_Msk             (0x01UL << DMA_ACTIVE0_ACT_CH0_Pos)                   /*!< DMA ACTIVE0: ACT_CH0 Mask             */
#define DMA_ACTIVE0_ACT_CH1_Pos             1                                                       /*!< DMA ACTIVE0: ACT_CH1 Position         */
#define DMA_ACTIVE0_ACT_CH1_Msk             (0x01UL << DMA_ACTIVE0_ACT_CH1_Pos)                   /*!< DMA ACTIVE0: ACT_CH1 Mask             */
#define DMA_ACTIVE0_ACT_CH2_Pos             2                                                       /*!< DMA ACTIVE0: ACT_CH2 Position         */
#define DMA_ACTIVE0_ACT_CH2_Msk             (0x01UL << DMA_ACTIVE0_ACT_CH2_Pos)                   /*!< DMA ACTIVE0: ACT_CH2 Mask             */
#define DMA_ACTIVE0_ACT_CH3_Pos             3                                                       /*!< DMA ACTIVE0: ACT_CH3 Position         */
#define DMA_ACTIVE0_ACT_CH3_Msk             (0x01UL << DMA_ACTIVE0_ACT_CH3_Pos)                   /*!< DMA ACTIVE0: ACT_CH3 Mask             */
#define DMA_ACTIVE0_ACT_CH4_Pos             4                                                       /*!< DMA ACTIVE0: ACT_CH4 Position         */
#define DMA_ACTIVE0_ACT_CH4_Msk             (0x01UL << DMA_ACTIVE0_ACT_CH4_Pos)                   /*!< DMA ACTIVE0: ACT_CH4 Mask             */
#define DMA_ACTIVE0_ACT_CH5_Pos             5                                                       /*!< DMA ACTIVE0: ACT_CH5 Position         */
#define DMA_ACTIVE0_ACT_CH5_Msk             (0x01UL << DMA_ACTIVE0_ACT_CH5_Pos)                   /*!< DMA ACTIVE0: ACT_CH5 Mask             */
#define DMA_ACTIVE0_ACT_CH6_Pos             6                                                       /*!< DMA ACTIVE0: ACT_CH6 Position         */
#define DMA_ACTIVE0_ACT_CH6_Msk             (0x01UL << DMA_ACTIVE0_ACT_CH6_Pos)                   /*!< DMA ACTIVE0: ACT_CH6 Mask             */
#define DMA_ACTIVE0_ACT_CH7_Pos             7                                                       /*!< DMA ACTIVE0: ACT_CH7 Position         */
#define DMA_ACTIVE0_ACT_CH7_Msk             (0x01UL << DMA_ACTIVE0_ACT_CH7_Pos)                   /*!< DMA ACTIVE0: ACT_CH7 Mask             */
#define DMA_ACTIVE0_ACT_CH8_Pos             8                                                       /*!< DMA ACTIVE0: ACT_CH8 Position         */
#define DMA_ACTIVE0_ACT_CH8_Msk             (0x01UL << DMA_ACTIVE0_ACT_CH8_Pos)                   /*!< DMA ACTIVE0: ACT_CH8 Mask             */
#define DMA_ACTIVE0_ACT_CH9_Pos             9                                                       /*!< DMA ACTIVE0: ACT_CH9 Position         */
#define DMA_ACTIVE0_ACT_CH9_Msk             (0x01UL << DMA_ACTIVE0_ACT_CH9_Pos)                   /*!< DMA ACTIVE0: ACT_CH9 Mask             */
#define DMA_ACTIVE0_ACT_CH10_Pos            10                                                      /*!< DMA ACTIVE0: ACT_CH10 Position        */
#define DMA_ACTIVE0_ACT_CH10_Msk            (0x01UL << DMA_ACTIVE0_ACT_CH10_Pos)                  /*!< DMA ACTIVE0: ACT_CH10 Mask            */
#define DMA_ACTIVE0_ACT_CH11_Pos            11                                                      /*!< DMA ACTIVE0: ACT_CH11 Position        */
#define DMA_ACTIVE0_ACT_CH11_Msk            (0x01UL << DMA_ACTIVE0_ACT_CH11_Pos)                  /*!< DMA ACTIVE0: ACT_CH11 Mask            */
#define DMA_ACTIVE0_ACT_CH12_Pos            12                                                      /*!< DMA ACTIVE0: ACT_CH12 Position        */
#define DMA_ACTIVE0_ACT_CH12_Msk            (0x01UL << DMA_ACTIVE0_ACT_CH12_Pos)                  /*!< DMA ACTIVE0: ACT_CH12 Mask            */
#define DMA_ACTIVE0_ACT_CH13_Pos            13                                                      /*!< DMA ACTIVE0: ACT_CH13 Position        */
#define DMA_ACTIVE0_ACT_CH13_Msk            (0x01UL << DMA_ACTIVE0_ACT_CH13_Pos)                  /*!< DMA ACTIVE0: ACT_CH13 Mask            */
#define DMA_ACTIVE0_ACT_CH14_Pos            14                                                      /*!< DMA ACTIVE0: ACT_CH14 Position        */
#define DMA_ACTIVE0_ACT_CH14_Msk            (0x01UL << DMA_ACTIVE0_ACT_CH14_Pos)                  /*!< DMA ACTIVE0: ACT_CH14 Mask            */
#define DMA_ACTIVE0_ACT_CH15_Pos            15                                                      /*!< DMA ACTIVE0: ACT_CH15 Position        */
#define DMA_ACTIVE0_ACT_CH15_Msk            (0x01UL << DMA_ACTIVE0_ACT_CH15_Pos)                  /*!< DMA ACTIVE0: ACT_CH15 Mask            */
#define DMA_ACTIVE0_ACT_CH16_Pos            16                                                      /*!< DMA ACTIVE0: ACT_CH16 Position        */
#define DMA_ACTIVE0_ACT_CH16_Msk            (0x01UL << DMA_ACTIVE0_ACT_CH16_Pos)                  /*!< DMA ACTIVE0: ACT_CH16 Mask            */
#define DMA_ACTIVE0_ACT_CH17_Pos            17                                                      /*!< DMA ACTIVE0: ACT_CH17 Position        */
#define DMA_ACTIVE0_ACT_CH17_Msk            (0x01UL << DMA_ACTIVE0_ACT_CH17_Pos)                  /*!< DMA ACTIVE0: ACT_CH17 Mask            */
#define DMA_ACTIVE0_ACT_CH18_Pos            18                                                      /*!< DMA ACTIVE0: ACT_CH18 Position        */
#define DMA_ACTIVE0_ACT_CH18_Msk            (0x01UL << DMA_ACTIVE0_ACT_CH18_Pos)                  /*!< DMA ACTIVE0: ACT_CH18 Mask            */

/* ---------------------------------  u_dma_BUSY0  -------------------------------- */
#define DMA_BUSY0_BSY_CH0_Pos               0                                                       /*!< DMA BUSY0: BSY_CH0 Position           */
#define DMA_BUSY0_BSY_CH0_Msk               (0x01UL << DMA_BUSY0_BSY_CH0_Pos)                     /*!< DMA BUSY0: BSY_CH0 Mask               */
#define DMA_BUSY0_BSY_CH1_Pos               1                                                       /*!< DMA BUSY0: BSY_CH1 Position           */
#define DMA_BUSY0_BSY_CH1_Msk               (0x01UL << DMA_BUSY0_BSY_CH1_Pos)                     /*!< DMA BUSY0: BSY_CH1 Mask               */
#define DMA_BUSY0_BSY_CH2_Pos               2                                                       /*!< DMA BUSY0: BSY_CH2 Position           */
#define DMA_BUSY0_BSY_CH2_Msk               (0x01UL << DMA_BUSY0_BSY_CH2_Pos)                     /*!< DMA BUSY0: BSY_CH2 Mask               */
#define DMA_BUSY0_BSY_CH3_Pos               3                                                       /*!< DMA BUSY0: BSY_CH3 Position           */
#define DMA_BUSY0_BSY_CH3_Msk               (0x01UL << DMA_BUSY0_BSY_CH3_Pos)                     /*!< DMA BUSY0: BSY_CH3 Mask               */
#define DMA_BUSY0_BSY_CH4_Pos               4                                                       /*!< DMA BUSY0: BSY_CH4 Position           */
#define DMA_BUSY0_BSY_CH4_Msk               (0x01UL << DMA_BUSY0_BSY_CH4_Pos)                     /*!< DMA BUSY0: BSY_CH4 Mask               */
#define DMA_BUSY0_BSY_CH5_Pos               5                                                       /*!< DMA BUSY0: BSY_CH5 Position           */
#define DMA_BUSY0_BSY_CH5_Msk               (0x01UL << DMA_BUSY0_BSY_CH5_Pos)                     /*!< DMA BUSY0: BSY_CH5 Mask               */
#define DMA_BUSY0_BSY_CH6_Pos               6                                                       /*!< DMA BUSY0: BSY_CH6 Position           */
#define DMA_BUSY0_BSY_CH6_Msk               (0x01UL << DMA_BUSY0_BSY_CH6_Pos)                     /*!< DMA BUSY0: BSY_CH6 Mask               */
#define DMA_BUSY0_BSY_CH7_Pos               7                                                       /*!< DMA BUSY0: BSY_CH7 Position           */
#define DMA_BUSY0_BSY_CH7_Msk               (0x01UL << DMA_BUSY0_BSY_CH7_Pos)                     /*!< DMA BUSY0: BSY_CH7 Mask               */
#define DMA_BUSY0_BSY_CH8_Pos               8                                                       /*!< DMA BUSY0: BSY_CH8 Position           */
#define DMA_BUSY0_BSY_CH8_Msk               (0x01UL << DMA_BUSY0_BSY_CH8_Pos)                     /*!< DMA BUSY0: BSY_CH8 Mask               */
#define DMA_BUSY0_BSY_CH9_Pos               9                                                       /*!< DMA BUSY0: BSY_CH9 Position           */
#define DMA_BUSY0_BSY_CH9_Msk               (0x01UL << DMA_BUSY0_BSY_CH9_Pos)                     /*!< DMA BUSY0: BSY_CH9 Mask               */
#define DMA_BUSY0_BSY_CH10_Pos              10                                                      /*!< DMA BUSY0: BSY_CH10 Position          */
#define DMA_BUSY0_BSY_CH10_Msk              (0x01UL << DMA_BUSY0_BSY_CH10_Pos)                    /*!< DMA BUSY0: BSY_CH10 Mask              */
#define DMA_BUSY0_BSY_CH11_Pos              11                                                      /*!< DMA BUSY0: BSY_CH11 Position          */
#define DMA_BUSY0_BSY_CH11_Msk              (0x01UL << DMA_BUSY0_BSY_CH11_Pos)                    /*!< DMA BUSY0: BSY_CH11 Mask              */
#define DMA_BUSY0_BSY_CH12_Pos              12                                                      /*!< DMA BUSY0: BSY_CH12 Position          */
#define DMA_BUSY0_BSY_CH12_Msk              (0x01UL << DMA_BUSY0_BSY_CH12_Pos)                    /*!< DMA BUSY0: BSY_CH12 Mask              */
#define DMA_BUSY0_BSY_CH13_Pos              13                                                      /*!< DMA BUSY0: BSY_CH13 Position          */
#define DMA_BUSY0_BSY_CH13_Msk              (0x01UL << DMA_BUSY0_BSY_CH13_Pos)                    /*!< DMA BUSY0: BSY_CH13 Mask              */
#define DMA_BUSY0_BSY_CH14_Pos              14                                                      /*!< DMA BUSY0: BSY_CH14 Position          */
#define DMA_BUSY0_BSY_CH14_Msk              (0x01UL << DMA_BUSY0_BSY_CH14_Pos)                    /*!< DMA BUSY0: BSY_CH14 Mask              */
#define DMA_BUSY0_BSY_CH15_Pos              15                                                      /*!< DMA BUSY0: BSY_CH15 Position          */
#define DMA_BUSY0_BSY_CH15_Msk              (0x01UL << DMA_BUSY0_BSY_CH15_Pos)                    /*!< DMA BUSY0: BSY_CH15 Mask              */
#define DMA_BUSY0_BSY_CH16_Pos              16                                                      /*!< DMA BUSY0: BSY_CH16 Position          */
#define DMA_BUSY0_BSY_CH16_Msk              (0x01UL << DMA_BUSY0_BSY_CH16_Pos)                    /*!< DMA BUSY0: BSY_CH16 Mask              */
#define DMA_BUSY0_BSY_CH17_Pos              17                                                      /*!< DMA BUSY0: BSY_CH17 Position          */
#define DMA_BUSY0_BSY_CH17_Msk              (0x01UL << DMA_BUSY0_BSY_CH17_Pos)                    /*!< DMA BUSY0: BSY_CH17 Mask              */
#define DMA_BUSY0_BSY_CH18_Pos              18                                                      /*!< DMA BUSY0: BSY_CH18 Position          */
#define DMA_BUSY0_BSY_CH18_Msk              (0x01UL << DMA_BUSY0_BSY_CH18_Pos)                    /*!< DMA BUSY0: BSY_CH18 Mask              */

/* --------------------------------  u_dma_ERRINT0  ------------------------------- */
#define DMA_ERRINT0_ERR_CH0_Pos             0                                                       /*!< DMA ERRINT0: ERR_CH0 Position         */
#define DMA_ERRINT0_ERR_CH0_Msk             (0x01UL << DMA_ERRINT0_ERR_CH0_Pos)                   /*!< DMA ERRINT0: ERR_CH0 Mask             */
#define DMA_ERRINT0_ERR_CH1_Pos             1                                                       /*!< DMA ERRINT0: ERR_CH1 Position         */
#define DMA_ERRINT0_ERR_CH1_Msk             (0x01UL << DMA_ERRINT0_ERR_CH1_Pos)                   /*!< DMA ERRINT0: ERR_CH1 Mask             */
#define DMA_ERRINT0_ERR_CH2_Pos             2                                                       /*!< DMA ERRINT0: ERR_CH2 Position         */
#define DMA_ERRINT0_ERR_CH2_Msk             (0x01UL << DMA_ERRINT0_ERR_CH2_Pos)                   /*!< DMA ERRINT0: ERR_CH2 Mask             */
#define DMA_ERRINT0_ERR_CH3_Pos             3                                                       /*!< DMA ERRINT0: ERR_CH3 Position         */
#define DMA_ERRINT0_ERR_CH3_Msk             (0x01UL << DMA_ERRINT0_ERR_CH3_Pos)                   /*!< DMA ERRINT0: ERR_CH3 Mask             */
#define DMA_ERRINT0_ERR_CH4_Pos             4                                                       /*!< DMA ERRINT0: ERR_CH4 Position         */
#define DMA_ERRINT0_ERR_CH4_Msk             (0x01UL << DMA_ERRINT0_ERR_CH4_Pos)                   /*!< DMA ERRINT0: ERR_CH4 Mask             */
#define DMA_ERRINT0_ERR_CH5_Pos             5                                                       /*!< DMA ERRINT0: ERR_CH5 Position         */
#define DMA_ERRINT0_ERR_CH5_Msk             (0x01UL << DMA_ERRINT0_ERR_CH5_Pos)                   /*!< DMA ERRINT0: ERR_CH5 Mask             */
#define DMA_ERRINT0_ERR_CH6_Pos             6                                                       /*!< DMA ERRINT0: ERR_CH6 Position         */
#define DMA_ERRINT0_ERR_CH6_Msk             (0x01UL << DMA_ERRINT0_ERR_CH6_Pos)                   /*!< DMA ERRINT0: ERR_CH6 Mask             */
#define DMA_ERRINT0_ERR_CH7_Pos             7                                                       /*!< DMA ERRINT0: ERR_CH7 Position         */
#define DMA_ERRINT0_ERR_CH7_Msk             (0x01UL << DMA_ERRINT0_ERR_CH7_Pos)                   /*!< DMA ERRINT0: ERR_CH7 Mask             */
#define DMA_ERRINT0_ERR_CH8_Pos             8                                                       /*!< DMA ERRINT0: ERR_CH8 Position         */
#define DMA_ERRINT0_ERR_CH8_Msk             (0x01UL << DMA_ERRINT0_ERR_CH8_Pos)                   /*!< DMA ERRINT0: ERR_CH8 Mask             */
#define DMA_ERRINT0_ERR_CH9_Pos             9                                                       /*!< DMA ERRINT0: ERR_CH9 Position         */
#define DMA_ERRINT0_ERR_CH9_Msk             (0x01UL << DMA_ERRINT0_ERR_CH9_Pos)                   /*!< DMA ERRINT0: ERR_CH9 Mask             */
#define DMA_ERRINT0_ERR_CH10_Pos            10                                                      /*!< DMA ERRINT0: ERR_CH10 Position        */
#define DMA_ERRINT0_ERR_CH10_Msk            (0x01UL << DMA_ERRINT0_ERR_CH10_Pos)                  /*!< DMA ERRINT0: ERR_CH10 Mask            */
#define DMA_ERRINT0_ERR_CH11_Pos            11                                                      /*!< DMA ERRINT0: ERR_CH11 Position        */
#define DMA_ERRINT0_ERR_CH11_Msk            (0x01UL << DMA_ERRINT0_ERR_CH11_Pos)                  /*!< DMA ERRINT0: ERR_CH11 Mask            */
#define DMA_ERRINT0_ERR_CH12_Pos            12                                                      /*!< DMA ERRINT0: ERR_CH12 Position        */
#define DMA_ERRINT0_ERR_CH12_Msk            (0x01UL << DMA_ERRINT0_ERR_CH12_Pos)                  /*!< DMA ERRINT0: ERR_CH12 Mask            */
#define DMA_ERRINT0_ERR_CH13_Pos            13                                                      /*!< DMA ERRINT0: ERR_CH13 Position        */
#define DMA_ERRINT0_ERR_CH13_Msk            (0x01UL << DMA_ERRINT0_ERR_CH13_Pos)                  /*!< DMA ERRINT0: ERR_CH13 Mask            */
#define DMA_ERRINT0_ERR_CH14_Pos            14                                                      /*!< DMA ERRINT0: ERR_CH14 Position        */
#define DMA_ERRINT0_ERR_CH14_Msk            (0x01UL << DMA_ERRINT0_ERR_CH14_Pos)                  /*!< DMA ERRINT0: ERR_CH14 Mask            */
#define DMA_ERRINT0_ERR_CH15_Pos            15                                                      /*!< DMA ERRINT0: ERR_CH15 Position        */
#define DMA_ERRINT0_ERR_CH15_Msk            (0x01UL << DMA_ERRINT0_ERR_CH15_Pos)                  /*!< DMA ERRINT0: ERR_CH15 Mask            */
#define DMA_ERRINT0_ERR_CH16_Pos            16                                                      /*!< DMA ERRINT0: ERR_CH16 Position        */
#define DMA_ERRINT0_ERR_CH16_Msk            (0x01UL << DMA_ERRINT0_ERR_CH16_Pos)                  /*!< DMA ERRINT0: ERR_CH16 Mask            */
#define DMA_ERRINT0_ERR_CH17_Pos            17                                                      /*!< DMA ERRINT0: ERR_CH17 Position        */
#define DMA_ERRINT0_ERR_CH17_Msk            (0x01UL << DMA_ERRINT0_ERR_CH17_Pos)                  /*!< DMA ERRINT0: ERR_CH17 Mask            */
#define DMA_ERRINT0_ERR_CH18_Pos            18                                                      /*!< DMA ERRINT0: ERR_CH18 Position        */
#define DMA_ERRINT0_ERR_CH18_Msk            (0x01UL << DMA_ERRINT0_ERR_CH18_Pos)                  /*!< DMA ERRINT0: ERR_CH18 Mask            */

/* -------------------------------  u_dma_INTENSET0  ------------------------------ */
#define DMA_INTENSET0_INTEN_CH0_Pos         0                                                       /*!< DMA INTENSET0: INTEN_CH0 Position     */
#define DMA_INTENSET0_INTEN_CH0_Msk         (0x01UL << DMA_INTENSET0_INTEN_CH0_Pos)               /*!< DMA INTENSET0: INTEN_CH0 Mask         */
#define DMA_INTENSET0_INTEN_CH1_Pos         1                                                       /*!< DMA INTENSET0: INTEN_CH1 Position     */
#define DMA_INTENSET0_INTEN_CH1_Msk         (0x01UL << DMA_INTENSET0_INTEN_CH1_Pos)               /*!< DMA INTENSET0: INTEN_CH1 Mask         */
#define DMA_INTENSET0_INTEN_CH2_Pos         2                                                       /*!< DMA INTENSET0: INTEN_CH2 Position     */
#define DMA_INTENSET0_INTEN_CH2_Msk         (0x01UL << DMA_INTENSET0_INTEN_CH2_Pos)               /*!< DMA INTENSET0: INTEN_CH2 Mask         */
#define DMA_INTENSET0_INTEN_CH3_Pos         3                                                       /*!< DMA INTENSET0: INTEN_CH3 Position     */
#define DMA_INTENSET0_INTEN_CH3_Msk         (0x01UL << DMA_INTENSET0_INTEN_CH3_Pos)               /*!< DMA INTENSET0: INTEN_CH3 Mask         */
#define DMA_INTENSET0_INTEN_CH4_Pos         4                                                       /*!< DMA INTENSET0: INTEN_CH4 Position     */
#define DMA_INTENSET0_INTEN_CH4_Msk         (0x01UL << DMA_INTENSET0_INTEN_CH4_Pos)               /*!< DMA INTENSET0: INTEN_CH4 Mask         */
#define DMA_INTENSET0_INTEN_CH5_Pos         5                                                       /*!< DMA INTENSET0: INTEN_CH5 Position     */
#define DMA_INTENSET0_INTEN_CH5_Msk         (0x01UL << DMA_INTENSET0_INTEN_CH5_Pos)               /*!< DMA INTENSET0: INTEN_CH5 Mask         */
#define DMA_INTENSET0_INTEN_CH6_Pos         6                                                       /*!< DMA INTENSET0: INTEN_CH6 Position     */
#define DMA_INTENSET0_INTEN_CH6_Msk         (0x01UL << DMA_INTENSET0_INTEN_CH6_Pos)               /*!< DMA INTENSET0: INTEN_CH6 Mask         */
#define DMA_INTENSET0_INTEN_CH7_Pos         7                                                       /*!< DMA INTENSET0: INTEN_CH7 Position     */
#define DMA_INTENSET0_INTEN_CH7_Msk         (0x01UL << DMA_INTENSET0_INTEN_CH7_Pos)               /*!< DMA INTENSET0: INTEN_CH7 Mask         */
#define DMA_INTENSET0_INTEN_CH8_Pos         8                                                       /*!< DMA INTENSET0: INTEN_CH8 Position     */
#define DMA_INTENSET0_INTEN_CH8_Msk         (0x01UL << DMA_INTENSET0_INTEN_CH8_Pos)               /*!< DMA INTENSET0: INTEN_CH8 Mask         */
#define DMA_INTENSET0_INTEN_CH9_Pos         9                                                       /*!< DMA INTENSET0: INTEN_CH9 Position     */
#define DMA_INTENSET0_INTEN_CH9_Msk         (0x01UL << DMA_INTENSET0_INTEN_CH9_Pos)               /*!< DMA INTENSET0: INTEN_CH9 Mask         */
#define DMA_INTENSET0_INTEN_CH10_Pos        10                                                      /*!< DMA INTENSET0: INTEN_CH10 Position    */
#define DMA_INTENSET0_INTEN_CH10_Msk        (0x01UL << DMA_INTENSET0_INTEN_CH10_Pos)              /*!< DMA INTENSET0: INTEN_CH10 Mask        */
#define DMA_INTENSET0_INTEN_CH11_Pos        11                                                      /*!< DMA INTENSET0: INTEN_CH11 Position    */
#define DMA_INTENSET0_INTEN_CH11_Msk        (0x01UL << DMA_INTENSET0_INTEN_CH11_Pos)              /*!< DMA INTENSET0: INTEN_CH11 Mask        */
#define DMA_INTENSET0_INTEN_CH12_Pos        12                                                      /*!< DMA INTENSET0: INTEN_CH12 Position    */
#define DMA_INTENSET0_INTEN_CH12_Msk        (0x01UL << DMA_INTENSET0_INTEN_CH12_Pos)              /*!< DMA INTENSET0: INTEN_CH12 Mask        */
#define DMA_INTENSET0_INTEN_CH13_Pos        13                                                      /*!< DMA INTENSET0: INTEN_CH13 Position    */
#define DMA_INTENSET0_INTEN_CH13_Msk        (0x01UL << DMA_INTENSET0_INTEN_CH13_Pos)              /*!< DMA INTENSET0: INTEN_CH13 Mask        */
#define DMA_INTENSET0_INTEN_CH14_Pos        14                                                      /*!< DMA INTENSET0: INTEN_CH14 Position    */
#define DMA_INTENSET0_INTEN_CH14_Msk        (0x01UL << DMA_INTENSET0_INTEN_CH14_Pos)              /*!< DMA INTENSET0: INTEN_CH14 Mask        */
#define DMA_INTENSET0_INTEN_CH15_Pos        15                                                      /*!< DMA INTENSET0: INTEN_CH15 Position    */
#define DMA_INTENSET0_INTEN_CH15_Msk        (0x01UL << DMA_INTENSET0_INTEN_CH15_Pos)              /*!< DMA INTENSET0: INTEN_CH15 Mask        */
#define DMA_INTENSET0_INTEN_CH16_Pos        16                                                      /*!< DMA INTENSET0: INTEN_CH16 Position    */
#define DMA_INTENSET0_INTEN_CH16_Msk        (0x01UL << DMA_INTENSET0_INTEN_CH16_Pos)              /*!< DMA INTENSET0: INTEN_CH16 Mask        */
#define DMA_INTENSET0_INTEN_CH17_Pos        17                                                      /*!< DMA INTENSET0: INTEN_CH17 Position    */
#define DMA_INTENSET0_INTEN_CH17_Msk        (0x01UL << DMA_INTENSET0_INTEN_CH17_Pos)              /*!< DMA INTENSET0: INTEN_CH17 Mask        */
#define DMA_INTENSET0_INTEN_CH18_Pos        18                                                      /*!< DMA INTENSET0: INTEN_CH18 Position    */
#define DMA_INTENSET0_INTEN_CH18_Msk        (0x01UL << DMA_INTENSET0_INTEN_CH18_Pos)              /*!< DMA INTENSET0: INTEN_CH18 Mask        */

/* -------------------------------  u_dma_INTENCLR0  ------------------------------ */
#define DMA_INTENCLR0_CLR_CH0_Pos           0                                                       /*!< DMA INTENCLR0: CLR_CH0 Position       */
#define DMA_INTENCLR0_CLR_CH0_Msk           (0x01UL << DMA_INTENCLR0_CLR_CH0_Pos)                 /*!< DMA INTENCLR0: CLR_CH0 Mask           */
#define DMA_INTENCLR0_CLR_CH1_Pos           1                                                       /*!< DMA INTENCLR0: CLR_CH1 Position       */
#define DMA_INTENCLR0_CLR_CH1_Msk           (0x01UL << DMA_INTENCLR0_CLR_CH1_Pos)                 /*!< DMA INTENCLR0: CLR_CH1 Mask           */
#define DMA_INTENCLR0_CLR_CH2_Pos           2                                                       /*!< DMA INTENCLR0: CLR_CH2 Position       */
#define DMA_INTENCLR0_CLR_CH2_Msk           (0x01UL << DMA_INTENCLR0_CLR_CH2_Pos)                 /*!< DMA INTENCLR0: CLR_CH2 Mask           */
#define DMA_INTENCLR0_CLR_CH3_Pos           3                                                       /*!< DMA INTENCLR0: CLR_CH3 Position       */
#define DMA_INTENCLR0_CLR_CH3_Msk           (0x01UL << DMA_INTENCLR0_CLR_CH3_Pos)                 /*!< DMA INTENCLR0: CLR_CH3 Mask           */
#define DMA_INTENCLR0_CLR_CH4_Pos           4                                                       /*!< DMA INTENCLR0: CLR_CH4 Position       */
#define DMA_INTENCLR0_CLR_CH4_Msk           (0x01UL << DMA_INTENCLR0_CLR_CH4_Pos)                 /*!< DMA INTENCLR0: CLR_CH4 Mask           */
#define DMA_INTENCLR0_CLR_CH5_Pos           5                                                       /*!< DMA INTENCLR0: CLR_CH5 Position       */
#define DMA_INTENCLR0_CLR_CH5_Msk           (0x01UL << DMA_INTENCLR0_CLR_CH5_Pos)                 /*!< DMA INTENCLR0: CLR_CH5 Mask           */
#define DMA_INTENCLR0_CLR_CH6_Pos           6                                                       /*!< DMA INTENCLR0: CLR_CH6 Position       */
#define DMA_INTENCLR0_CLR_CH6_Msk           (0x01UL << DMA_INTENCLR0_CLR_CH6_Pos)                 /*!< DMA INTENCLR0: CLR_CH6 Mask           */
#define DMA_INTENCLR0_CLR_CH7_Pos           7                                                       /*!< DMA INTENCLR0: CLR_CH7 Position       */
#define DMA_INTENCLR0_CLR_CH7_Msk           (0x01UL << DMA_INTENCLR0_CLR_CH7_Pos)                 /*!< DMA INTENCLR0: CLR_CH7 Mask           */
#define DMA_INTENCLR0_CLR_CH8_Pos           8                                                       /*!< DMA INTENCLR0: CLR_CH8 Position       */
#define DMA_INTENCLR0_CLR_CH8_Msk           (0x01UL << DMA_INTENCLR0_CLR_CH8_Pos)                 /*!< DMA INTENCLR0: CLR_CH8 Mask           */
#define DMA_INTENCLR0_CLR_CH9_Pos           9                                                       /*!< DMA INTENCLR0: CLR_CH9 Position       */
#define DMA_INTENCLR0_CLR_CH9_Msk           (0x01UL << DMA_INTENCLR0_CLR_CH9_Pos)                 /*!< DMA INTENCLR0: CLR_CH9 Mask           */
#define DMA_INTENCLR0_CLR_CH10_Pos          10                                                      /*!< DMA INTENCLR0: CLR_CH10 Position      */
#define DMA_INTENCLR0_CLR_CH10_Msk          (0x01UL << DMA_INTENCLR0_CLR_CH10_Pos)                /*!< DMA INTENCLR0: CLR_CH10 Mask          */
#define DMA_INTENCLR0_CLR_CH11_Pos          11                                                      /*!< DMA INTENCLR0: CLR_CH11 Position      */
#define DMA_INTENCLR0_CLR_CH11_Msk          (0x01UL << DMA_INTENCLR0_CLR_CH11_Pos)                /*!< DMA INTENCLR0: CLR_CH11 Mask          */
#define DMA_INTENCLR0_CLR_CH12_Pos          12                                                      /*!< DMA INTENCLR0: CLR_CH12 Position      */
#define DMA_INTENCLR0_CLR_CH12_Msk          (0x01UL << DMA_INTENCLR0_CLR_CH12_Pos)                /*!< DMA INTENCLR0: CLR_CH12 Mask          */
#define DMA_INTENCLR0_CLR_CH13_Pos          13                                                      /*!< DMA INTENCLR0: CLR_CH13 Position      */
#define DMA_INTENCLR0_CLR_CH13_Msk          (0x01UL << DMA_INTENCLR0_CLR_CH13_Pos)                /*!< DMA INTENCLR0: CLR_CH13 Mask          */
#define DMA_INTENCLR0_CLR_CH14_Pos          14                                                      /*!< DMA INTENCLR0: CLR_CH14 Position      */
#define DMA_INTENCLR0_CLR_CH14_Msk          (0x01UL << DMA_INTENCLR0_CLR_CH14_Pos)                /*!< DMA INTENCLR0: CLR_CH14 Mask          */
#define DMA_INTENCLR0_CLR_CH15_Pos          15                                                      /*!< DMA INTENCLR0: CLR_CH15 Position      */
#define DMA_INTENCLR0_CLR_CH15_Msk          (0x01UL << DMA_INTENCLR0_CLR_CH15_Pos)                /*!< DMA INTENCLR0: CLR_CH15 Mask          */
#define DMA_INTENCLR0_CLR_CH16_Pos          16                                                      /*!< DMA INTENCLR0: CLR_CH16 Position      */
#define DMA_INTENCLR0_CLR_CH16_Msk          (0x01UL << DMA_INTENCLR0_CLR_CH16_Pos)                /*!< DMA INTENCLR0: CLR_CH16 Mask          */
#define DMA_INTENCLR0_CLR_CH17_Pos          17                                                      /*!< DMA INTENCLR0: CLR_CH17 Position      */
#define DMA_INTENCLR0_CLR_CH17_Msk          (0x01UL << DMA_INTENCLR0_CLR_CH17_Pos)                /*!< DMA INTENCLR0: CLR_CH17 Mask          */
#define DMA_INTENCLR0_CLR_CH18_Pos          18                                                      /*!< DMA INTENCLR0: CLR_CH18 Position      */
#define DMA_INTENCLR0_CLR_CH18_Msk          (0x01UL << DMA_INTENCLR0_CLR_CH18_Pos)                /*!< DMA INTENCLR0: CLR_CH18 Mask          */

/* ---------------------------------  u_dma_INTA0  -------------------------------- */
#define DMA_INTA0_IA_CH0_Pos                0                                                       /*!< DMA INTA0: IA_CH0 Position            */
#define DMA_INTA0_IA_CH0_Msk                (0x01UL << DMA_INTA0_IA_CH0_Pos)                      /*!< DMA INTA0: IA_CH0 Mask                */
#define DMA_INTA0_IA_CH1_Pos                1                                                       /*!< DMA INTA0: IA_CH1 Position            */
#define DMA_INTA0_IA_CH1_Msk                (0x01UL << DMA_INTA0_IA_CH1_Pos)                      /*!< DMA INTA0: IA_CH1 Mask                */
#define DMA_INTA0_IA_CH2_Pos                2                                                       /*!< DMA INTA0: IA_CH2 Position            */
#define DMA_INTA0_IA_CH2_Msk                (0x01UL << DMA_INTA0_IA_CH2_Pos)                      /*!< DMA INTA0: IA_CH2 Mask                */
#define DMA_INTA0_IA_CH3_Pos                3                                                       /*!< DMA INTA0: IA_CH3 Position            */
#define DMA_INTA0_IA_CH3_Msk                (0x01UL << DMA_INTA0_IA_CH3_Pos)                      /*!< DMA INTA0: IA_CH3 Mask                */
#define DMA_INTA0_IA_CH4_Pos                4                                                       /*!< DMA INTA0: IA_CH4 Position            */
#define DMA_INTA0_IA_CH4_Msk                (0x01UL << DMA_INTA0_IA_CH4_Pos)                      /*!< DMA INTA0: IA_CH4 Mask                */
#define DMA_INTA0_IA_CH5_Pos                5                                                       /*!< DMA INTA0: IA_CH5 Position            */
#define DMA_INTA0_IA_CH5_Msk                (0x01UL << DMA_INTA0_IA_CH5_Pos)                      /*!< DMA INTA0: IA_CH5 Mask                */
#define DMA_INTA0_IA_CH6_Pos                6                                                       /*!< DMA INTA0: IA_CH6 Position            */
#define DMA_INTA0_IA_CH6_Msk                (0x01UL << DMA_INTA0_IA_CH6_Pos)                      /*!< DMA INTA0: IA_CH6 Mask                */
#define DMA_INTA0_IA_CH7_Pos                7                                                       /*!< DMA INTA0: IA_CH7 Position            */
#define DMA_INTA0_IA_CH7_Msk                (0x01UL << DMA_INTA0_IA_CH7_Pos)                      /*!< DMA INTA0: IA_CH7 Mask                */
#define DMA_INTA0_IA_CH8_Pos                8                                                       /*!< DMA INTA0: IA_CH8 Position            */
#define DMA_INTA0_IA_CH8_Msk                (0x01UL << DMA_INTA0_IA_CH8_Pos)                      /*!< DMA INTA0: IA_CH8 Mask                */
#define DMA_INTA0_IA_CH9_Pos                9                                                       /*!< DMA INTA0: IA_CH9 Position            */
#define DMA_INTA0_IA_CH9_Msk                (0x01UL << DMA_INTA0_IA_CH9_Pos)                      /*!< DMA INTA0: IA_CH9 Mask                */
#define DMA_INTA0_IA_CH10_Pos               10                                                      /*!< DMA INTA0: IA_CH10 Position           */
#define DMA_INTA0_IA_CH10_Msk               (0x01UL << DMA_INTA0_IA_CH10_Pos)                     /*!< DMA INTA0: IA_CH10 Mask               */
#define DMA_INTA0_IA_CH11_Pos               11                                                      /*!< DMA INTA0: IA_CH11 Position           */
#define DMA_INTA0_IA_CH11_Msk               (0x01UL << DMA_INTA0_IA_CH11_Pos)                     /*!< DMA INTA0: IA_CH11 Mask               */
#define DMA_INTA0_IA_CH12_Pos               12                                                      /*!< DMA INTA0: IA_CH12 Position           */
#define DMA_INTA0_IA_CH12_Msk               (0x01UL << DMA_INTA0_IA_CH12_Pos)                     /*!< DMA INTA0: IA_CH12 Mask               */
#define DMA_INTA0_IA_CH13_Pos               13                                                      /*!< DMA INTA0: IA_CH13 Position           */
#define DMA_INTA0_IA_CH13_Msk               (0x01UL << DMA_INTA0_IA_CH13_Pos)                     /*!< DMA INTA0: IA_CH13 Mask               */
#define DMA_INTA0_IA_CH14_Pos               14                                                      /*!< DMA INTA0: IA_CH14 Position           */
#define DMA_INTA0_IA_CH14_Msk               (0x01UL << DMA_INTA0_IA_CH14_Pos)                     /*!< DMA INTA0: IA_CH14 Mask               */
#define DMA_INTA0_IA_CH15_Pos               15                                                      /*!< DMA INTA0: IA_CH15 Position           */
#define DMA_INTA0_IA_CH15_Msk               (0x01UL << DMA_INTA0_IA_CH15_Pos)                     /*!< DMA INTA0: IA_CH15 Mask               */
#define DMA_INTA0_IA_CH16_Pos               16                                                      /*!< DMA INTA0: IA_CH16 Position           */
#define DMA_INTA0_IA_CH16_Msk               (0x01UL << DMA_INTA0_IA_CH16_Pos)                     /*!< DMA INTA0: IA_CH16 Mask               */
#define DMA_INTA0_IA_CH17_Pos               17                                                      /*!< DMA INTA0: IA_CH17 Position           */
#define DMA_INTA0_IA_CH17_Msk               (0x01UL << DMA_INTA0_IA_CH17_Pos)                     /*!< DMA INTA0: IA_CH17 Mask               */
#define DMA_INTA0_IA_CH18_Pos               18                                                      /*!< DMA INTA0: IA_CH18 Position           */
#define DMA_INTA0_IA_CH18_Msk               (0x01UL << DMA_INTA0_IA_CH18_Pos)                     /*!< DMA INTA0: IA_CH18 Mask               */

/* ---------------------------------  u_dma_INTB0  -------------------------------- */
#define DMA_INTB0_IB_CH0_Pos                0                                                       /*!< DMA INTB0: IB_CH0 Position            */
#define DMA_INTB0_IB_CH0_Msk                (0x01UL << DMA_INTB0_IB_CH0_Pos)                      /*!< DMA INTB0: IB_CH0 Mask                */
#define DMA_INTB0_IB_CH1_Pos                1                                                       /*!< DMA INTB0: IB_CH1 Position            */
#define DMA_INTB0_IB_CH1_Msk                (0x01UL << DMA_INTB0_IB_CH1_Pos)                      /*!< DMA INTB0: IB_CH1 Mask                */
#define DMA_INTB0_IB_CH2_Pos                2                                                       /*!< DMA INTB0: IB_CH2 Position            */
#define DMA_INTB0_IB_CH2_Msk                (0x01UL << DMA_INTB0_IB_CH2_Pos)                      /*!< DMA INTB0: IB_CH2 Mask                */
#define DMA_INTB0_IB_CH3_Pos                3                                                       /*!< DMA INTB0: IB_CH3 Position            */
#define DMA_INTB0_IB_CH3_Msk                (0x01UL << DMA_INTB0_IB_CH3_Pos)                      /*!< DMA INTB0: IB_CH3 Mask                */
#define DMA_INTB0_IB_CH4_Pos                4                                                       /*!< DMA INTB0: IB_CH4 Position            */
#define DMA_INTB0_IB_CH4_Msk                (0x01UL << DMA_INTB0_IB_CH4_Pos)                      /*!< DMA INTB0: IB_CH4 Mask                */
#define DMA_INTB0_IB_CH5_Pos                5                                                       /*!< DMA INTB0: IB_CH5 Position            */
#define DMA_INTB0_IB_CH5_Msk                (0x01UL << DMA_INTB0_IB_CH5_Pos)                      /*!< DMA INTB0: IB_CH5 Mask                */
#define DMA_INTB0_IB_CH6_Pos                6                                                       /*!< DMA INTB0: IB_CH6 Position            */
#define DMA_INTB0_IB_CH6_Msk                (0x01UL << DMA_INTB0_IB_CH6_Pos)                      /*!< DMA INTB0: IB_CH6 Mask                */
#define DMA_INTB0_IB_CH7_Pos                7                                                       /*!< DMA INTB0: IB_CH7 Position            */
#define DMA_INTB0_IB_CH7_Msk                (0x01UL << DMA_INTB0_IB_CH7_Pos)                      /*!< DMA INTB0: IB_CH7 Mask                */
#define DMA_INTB0_IB_CH8_Pos                8                                                       /*!< DMA INTB0: IB_CH8 Position            */
#define DMA_INTB0_IB_CH8_Msk                (0x01UL << DMA_INTB0_IB_CH8_Pos)                      /*!< DMA INTB0: IB_CH8 Mask                */
#define DMA_INTB0_IB_CH9_Pos                9                                                       /*!< DMA INTB0: IB_CH9 Position            */
#define DMA_INTB0_IB_CH9_Msk                (0x01UL << DMA_INTB0_IB_CH9_Pos)                      /*!< DMA INTB0: IB_CH9 Mask                */
#define DMA_INTB0_IB_CH10_Pos               10                                                      /*!< DMA INTB0: IB_CH10 Position           */
#define DMA_INTB0_IB_CH10_Msk               (0x01UL << DMA_INTB0_IB_CH10_Pos)                     /*!< DMA INTB0: IB_CH10 Mask               */
#define DMA_INTB0_IB_CH11_Pos               11                                                      /*!< DMA INTB0: IB_CH11 Position           */
#define DMA_INTB0_IB_CH11_Msk               (0x01UL << DMA_INTB0_IB_CH11_Pos)                     /*!< DMA INTB0: IB_CH11 Mask               */
#define DMA_INTB0_IB_CH12_Pos               12                                                      /*!< DMA INTB0: IB_CH12 Position           */
#define DMA_INTB0_IB_CH12_Msk               (0x01UL << DMA_INTB0_IB_CH12_Pos)                     /*!< DMA INTB0: IB_CH12 Mask               */
#define DMA_INTB0_IB_CH13_Pos               13                                                      /*!< DMA INTB0: IB_CH13 Position           */
#define DMA_INTB0_IB_CH13_Msk               (0x01UL << DMA_INTB0_IB_CH13_Pos)                     /*!< DMA INTB0: IB_CH13 Mask               */
#define DMA_INTB0_IB_CH14_Pos               14                                                      /*!< DMA INTB0: IB_CH14 Position           */
#define DMA_INTB0_IB_CH14_Msk               (0x01UL << DMA_INTB0_IB_CH14_Pos)                     /*!< DMA INTB0: IB_CH14 Mask               */
#define DMA_INTB0_IB_CH15_Pos               15                                                      /*!< DMA INTB0: IB_CH15 Position           */
#define DMA_INTB0_IB_CH15_Msk               (0x01UL << DMA_INTB0_IB_CH15_Pos)                     /*!< DMA INTB0: IB_CH15 Mask               */
#define DMA_INTB0_IB_CH16_Pos               16                                                      /*!< DMA INTB0: IB_CH16 Position           */
#define DMA_INTB0_IB_CH16_Msk               (0x01UL << DMA_INTB0_IB_CH16_Pos)                     /*!< DMA INTB0: IB_CH16 Mask               */
#define DMA_INTB0_IB_CH17_Pos               17                                                      /*!< DMA INTB0: IB_CH17 Position           */
#define DMA_INTB0_IB_CH17_Msk               (0x01UL << DMA_INTB0_IB_CH17_Pos)                     /*!< DMA INTB0: IB_CH17 Mask               */
#define DMA_INTB0_IB_CH18_Pos               18                                                      /*!< DMA INTB0: IB_CH18 Position           */
#define DMA_INTB0_IB_CH18_Msk               (0x01UL << DMA_INTB0_IB_CH18_Pos)                     /*!< DMA INTB0: IB_CH18 Mask               */

/* -------------------------------  u_dma_SETVALID0  ------------------------------ */
#define DMA_SETVALID0_SV_CH0_Pos            0                                                       /*!< DMA SETVALID0: SV_CH0 Position        */
#define DMA_SETVALID0_SV_CH0_Msk            (0x01UL << DMA_SETVALID0_SV_CH0_Pos)                  /*!< DMA SETVALID0: SV_CH0 Mask            */
#define DMA_SETVALID0_SV_CH1_Pos            1                                                       /*!< DMA SETVALID0: SV_CH1 Position        */
#define DMA_SETVALID0_SV_CH1_Msk            (0x01UL << DMA_SETVALID0_SV_CH1_Pos)                  /*!< DMA SETVALID0: SV_CH1 Mask            */
#define DMA_SETVALID0_SV_CH2_Pos            2                                                       /*!< DMA SETVALID0: SV_CH2 Position        */
#define DMA_SETVALID0_SV_CH2_Msk            (0x01UL << DMA_SETVALID0_SV_CH2_Pos)                  /*!< DMA SETVALID0: SV_CH2 Mask            */
#define DMA_SETVALID0_SV_CH3_Pos            3                                                       /*!< DMA SETVALID0: SV_CH3 Position        */
#define DMA_SETVALID0_SV_CH3_Msk            (0x01UL << DMA_SETVALID0_SV_CH3_Pos)                  /*!< DMA SETVALID0: SV_CH3 Mask            */
#define DMA_SETVALID0_SV_CH4_Pos            4                                                       /*!< DMA SETVALID0: SV_CH4 Position        */
#define DMA_SETVALID0_SV_CH4_Msk            (0x01UL << DMA_SETVALID0_SV_CH4_Pos)                  /*!< DMA SETVALID0: SV_CH4 Mask            */
#define DMA_SETVALID0_SV_CH5_Pos            5                                                       /*!< DMA SETVALID0: SV_CH5 Position        */
#define DMA_SETVALID0_SV_CH5_Msk            (0x01UL << DMA_SETVALID0_SV_CH5_Pos)                  /*!< DMA SETVALID0: SV_CH5 Mask            */
#define DMA_SETVALID0_SV_CH6_Pos            6                                                       /*!< DMA SETVALID0: SV_CH6 Position        */
#define DMA_SETVALID0_SV_CH6_Msk            (0x01UL << DMA_SETVALID0_SV_CH6_Pos)                  /*!< DMA SETVALID0: SV_CH6 Mask            */
#define DMA_SETVALID0_SV_CH7_Pos            7                                                       /*!< DMA SETVALID0: SV_CH7 Position        */
#define DMA_SETVALID0_SV_CH7_Msk            (0x01UL << DMA_SETVALID0_SV_CH7_Pos)                  /*!< DMA SETVALID0: SV_CH7 Mask            */
#define DMA_SETVALID0_SV_CH8_Pos            8                                                       /*!< DMA SETVALID0: SV_CH8 Position        */
#define DMA_SETVALID0_SV_CH8_Msk            (0x01UL << DMA_SETVALID0_SV_CH8_Pos)                  /*!< DMA SETVALID0: SV_CH8 Mask            */
#define DMA_SETVALID0_SV_CH9_Pos            9                                                       /*!< DMA SETVALID0: SV_CH9 Position        */
#define DMA_SETVALID0_SV_CH9_Msk            (0x01UL << DMA_SETVALID0_SV_CH9_Pos)                  /*!< DMA SETVALID0: SV_CH9 Mask            */
#define DMA_SETVALID0_SV_CH10_Pos           10                                                      /*!< DMA SETVALID0: SV_CH10 Position       */
#define DMA_SETVALID0_SV_CH10_Msk           (0x01UL << DMA_SETVALID0_SV_CH10_Pos)                 /*!< DMA SETVALID0: SV_CH10 Mask           */
#define DMA_SETVALID0_SV_CH11_Pos           11                                                      /*!< DMA SETVALID0: SV_CH11 Position       */
#define DMA_SETVALID0_SV_CH11_Msk           (0x01UL << DMA_SETVALID0_SV_CH11_Pos)                 /*!< DMA SETVALID0: SV_CH11 Mask           */
#define DMA_SETVALID0_SV_CH12_Pos           12                                                      /*!< DMA SETVALID0: SV_CH12 Position       */
#define DMA_SETVALID0_SV_CH12_Msk           (0x01UL << DMA_SETVALID0_SV_CH12_Pos)                 /*!< DMA SETVALID0: SV_CH12 Mask           */
#define DMA_SETVALID0_SV_CH13_Pos           13                                                      /*!< DMA SETVALID0: SV_CH13 Position       */
#define DMA_SETVALID0_SV_CH13_Msk           (0x01UL << DMA_SETVALID0_SV_CH13_Pos)                 /*!< DMA SETVALID0: SV_CH13 Mask           */
#define DMA_SETVALID0_SV_CH14_Pos           14                                                      /*!< DMA SETVALID0: SV_CH14 Position       */
#define DMA_SETVALID0_SV_CH14_Msk           (0x01UL << DMA_SETVALID0_SV_CH14_Pos)                 /*!< DMA SETVALID0: SV_CH14 Mask           */
#define DMA_SETVALID0_SV_CH15_Pos           15                                                      /*!< DMA SETVALID0: SV_CH15 Position       */
#define DMA_SETVALID0_SV_CH15_Msk           (0x01UL << DMA_SETVALID0_SV_CH15_Pos)                 /*!< DMA SETVALID0: SV_CH15 Mask           */
#define DMA_SETVALID0_SV_CH16_Pos           16                                                      /*!< DMA SETVALID0: SV_CH16 Position       */
#define DMA_SETVALID0_SV_CH16_Msk           (0x01UL << DMA_SETVALID0_SV_CH16_Pos)                 /*!< DMA SETVALID0: SV_CH16 Mask           */
#define DMA_SETVALID0_SV_CH17_Pos           17                                                      /*!< DMA SETVALID0: SV_CH17 Position       */
#define DMA_SETVALID0_SV_CH17_Msk           (0x01UL << DMA_SETVALID0_SV_CH17_Pos)                 /*!< DMA SETVALID0: SV_CH17 Mask           */
#define DMA_SETVALID0_SV_CH18_Pos           18                                                      /*!< DMA SETVALID0: SV_CH18 Position       */
#define DMA_SETVALID0_SV_CH18_Msk           (0x01UL << DMA_SETVALID0_SV_CH18_Pos)                 /*!< DMA SETVALID0: SV_CH18 Mask           */

/* -------------------------------  u_dma_SETTRIG0  ------------------------------- */
#define DMA_SETTRIG0_TRIG_CH0_Pos           0                                                       /*!< DMA SETTRIG0: TRIG_CH0 Position       */
#define DMA_SETTRIG0_TRIG_CH0_Msk           (0x01UL << DMA_SETTRIG0_TRIG_CH0_Pos)                 /*!< DMA SETTRIG0: TRIG_CH0 Mask           */
#define DMA_SETTRIG0_TRIG_CH1_Pos           1                                                       /*!< DMA SETTRIG0: TRIG_CH1 Position       */
#define DMA_SETTRIG0_TRIG_CH1_Msk           (0x01UL << DMA_SETTRIG0_TRIG_CH1_Pos)                 /*!< DMA SETTRIG0: TRIG_CH1 Mask           */
#define DMA_SETTRIG0_TRIG_CH2_Pos           2                                                       /*!< DMA SETTRIG0: TRIG_CH2 Position       */
#define DMA_SETTRIG0_TRIG_CH2_Msk           (0x01UL << DMA_SETTRIG0_TRIG_CH2_Pos)                 /*!< DMA SETTRIG0: TRIG_CH2 Mask           */
#define DMA_SETTRIG0_TRIG_CH3_Pos           3                                                       /*!< DMA SETTRIG0: TRIG_CH3 Position       */
#define DMA_SETTRIG0_TRIG_CH3_Msk           (0x01UL << DMA_SETTRIG0_TRIG_CH3_Pos)                 /*!< DMA SETTRIG0: TRIG_CH3 Mask           */
#define DMA_SETTRIG0_TRIG_CH4_Pos           4                                                       /*!< DMA SETTRIG0: TRIG_CH4 Position       */
#define DMA_SETTRIG0_TRIG_CH4_Msk           (0x01UL << DMA_SETTRIG0_TRIG_CH4_Pos)                 /*!< DMA SETTRIG0: TRIG_CH4 Mask           */
#define DMA_SETTRIG0_TRIG_CH5_Pos           5                                                       /*!< DMA SETTRIG0: TRIG_CH5 Position       */
#define DMA_SETTRIG0_TRIG_CH5_Msk           (0x01UL << DMA_SETTRIG0_TRIG_CH5_Pos)                 /*!< DMA SETTRIG0: TRIG_CH5 Mask           */
#define DMA_SETTRIG0_TRIG_CH6_Pos           6                                                       /*!< DMA SETTRIG0: TRIG_CH6 Position       */
#define DMA_SETTRIG0_TRIG_CH6_Msk           (0x01UL << DMA_SETTRIG0_TRIG_CH6_Pos)                 /*!< DMA SETTRIG0: TRIG_CH6 Mask           */
#define DMA_SETTRIG0_TRIG_CH7_Pos           7                                                       /*!< DMA SETTRIG0: TRIG_CH7 Position       */
#define DMA_SETTRIG0_TRIG_CH7_Msk           (0x01UL << DMA_SETTRIG0_TRIG_CH7_Pos)                 /*!< DMA SETTRIG0: TRIG_CH7 Mask           */
#define DMA_SETTRIG0_TRIG_CH8_Pos           8                                                       /*!< DMA SETTRIG0: TRIG_CH8 Position       */
#define DMA_SETTRIG0_TRIG_CH8_Msk           (0x01UL << DMA_SETTRIG0_TRIG_CH8_Pos)                 /*!< DMA SETTRIG0: TRIG_CH8 Mask           */
#define DMA_SETTRIG0_TRIG_CH9_Pos           9                                                       /*!< DMA SETTRIG0: TRIG_CH9 Position       */
#define DMA_SETTRIG0_TRIG_CH9_Msk           (0x01UL << DMA_SETTRIG0_TRIG_CH9_Pos)                 /*!< DMA SETTRIG0: TRIG_CH9 Mask           */
#define DMA_SETTRIG0_TRIG_CH10_Pos          10                                                      /*!< DMA SETTRIG0: TRIG_CH10 Position      */
#define DMA_SETTRIG0_TRIG_CH10_Msk          (0x01UL << DMA_SETTRIG0_TRIG_CH10_Pos)                /*!< DMA SETTRIG0: TRIG_CH10 Mask          */
#define DMA_SETTRIG0_TRIG_CH11_Pos          11                                                      /*!< DMA SETTRIG0: TRIG_CH11 Position      */
#define DMA_SETTRIG0_TRIG_CH11_Msk          (0x01UL << DMA_SETTRIG0_TRIG_CH11_Pos)                /*!< DMA SETTRIG0: TRIG_CH11 Mask          */
#define DMA_SETTRIG0_TRIG_CH12_Pos          12                                                      /*!< DMA SETTRIG0: TRIG_CH12 Position      */
#define DMA_SETTRIG0_TRIG_CH12_Msk          (0x01UL << DMA_SETTRIG0_TRIG_CH12_Pos)                /*!< DMA SETTRIG0: TRIG_CH12 Mask          */
#define DMA_SETTRIG0_TRIG_CH13_Pos          13                                                      /*!< DMA SETTRIG0: TRIG_CH13 Position      */
#define DMA_SETTRIG0_TRIG_CH13_Msk          (0x01UL << DMA_SETTRIG0_TRIG_CH13_Pos)                /*!< DMA SETTRIG0: TRIG_CH13 Mask          */
#define DMA_SETTRIG0_TRIG_CH14_Pos          14                                                      /*!< DMA SETTRIG0: TRIG_CH14 Position      */
#define DMA_SETTRIG0_TRIG_CH14_Msk          (0x01UL << DMA_SETTRIG0_TRIG_CH14_Pos)                /*!< DMA SETTRIG0: TRIG_CH14 Mask          */
#define DMA_SETTRIG0_TRIG_CH15_Pos          15                                                      /*!< DMA SETTRIG0: TRIG_CH15 Position      */
#define DMA_SETTRIG0_TRIG_CH15_Msk          (0x01UL << DMA_SETTRIG0_TRIG_CH15_Pos)                /*!< DMA SETTRIG0: TRIG_CH15 Mask          */
#define DMA_SETTRIG0_TRIG_CH16_Pos          16                                                      /*!< DMA SETTRIG0: TRIG_CH16 Position      */
#define DMA_SETTRIG0_TRIG_CH16_Msk          (0x01UL << DMA_SETTRIG0_TRIG_CH16_Pos)                /*!< DMA SETTRIG0: TRIG_CH16 Mask          */
#define DMA_SETTRIG0_TRIG_CH17_Pos          17                                                      /*!< DMA SETTRIG0: TRIG_CH17 Position      */
#define DMA_SETTRIG0_TRIG_CH17_Msk          (0x01UL << DMA_SETTRIG0_TRIG_CH17_Pos)                /*!< DMA SETTRIG0: TRIG_CH17 Mask          */
#define DMA_SETTRIG0_TRIG_CH18_Pos          18                                                      /*!< DMA SETTRIG0: TRIG_CH18 Position      */
#define DMA_SETTRIG0_TRIG_CH18_Msk          (0x01UL << DMA_SETTRIG0_TRIG_CH18_Pos)                /*!< DMA SETTRIG0: TRIG_CH18 Mask          */

/* --------------------------------  u_dma_ABORT0  -------------------------------- */
#define DMA_ABORT0_ABORTCTRL_CH0_Pos        0                                                       /*!< DMA ABORT0: ABORTCTRL_CH0 Position    */
#define DMA_ABORT0_ABORTCTRL_CH0_Msk        (0x01UL << DMA_ABORT0_ABORTCTRL_CH0_Pos)              /*!< DMA ABORT0: ABORTCTRL_CH0 Mask        */
#define DMA_ABORT0_ABORTCTRL_CH1_Pos        1                                                       /*!< DMA ABORT0: ABORTCTRL_CH1 Position    */
#define DMA_ABORT0_ABORTCTRL_CH1_Msk        (0x01UL << DMA_ABORT0_ABORTCTRL_CH1_Pos)              /*!< DMA ABORT0: ABORTCTRL_CH1 Mask        */
#define DMA_ABORT0_ABORTCTRL_CH2_Pos        2                                                       /*!< DMA ABORT0: ABORTCTRL_CH2 Position    */
#define DMA_ABORT0_ABORTCTRL_CH2_Msk        (0x01UL << DMA_ABORT0_ABORTCTRL_CH2_Pos)              /*!< DMA ABORT0: ABORTCTRL_CH2 Mask        */
#define DMA_ABORT0_ABORTCTRL_CH3_Pos        3                                                       /*!< DMA ABORT0: ABORTCTRL_CH3 Position    */
#define DMA_ABORT0_ABORTCTRL_CH3_Msk        (0x01UL << DMA_ABORT0_ABORTCTRL_CH3_Pos)              /*!< DMA ABORT0: ABORTCTRL_CH3 Mask        */
#define DMA_ABORT0_ABORTCTRL_CH4_Pos        4                                                       /*!< DMA ABORT0: ABORTCTRL_CH4 Position    */
#define DMA_ABORT0_ABORTCTRL_CH4_Msk        (0x01UL << DMA_ABORT0_ABORTCTRL_CH4_Pos)              /*!< DMA ABORT0: ABORTCTRL_CH4 Mask        */
#define DMA_ABORT0_ABORTCTRL_CH5_Pos        5                                                       /*!< DMA ABORT0: ABORTCTRL_CH5 Position    */
#define DMA_ABORT0_ABORTCTRL_CH5_Msk        (0x01UL << DMA_ABORT0_ABORTCTRL_CH5_Pos)              /*!< DMA ABORT0: ABORTCTRL_CH5 Mask        */
#define DMA_ABORT0_ABORTCTRL_CH6_Pos        6                                                       /*!< DMA ABORT0: ABORTCTRL_CH6 Position    */
#define DMA_ABORT0_ABORTCTRL_CH6_Msk        (0x01UL << DMA_ABORT0_ABORTCTRL_CH6_Pos)              /*!< DMA ABORT0: ABORTCTRL_CH6 Mask        */
#define DMA_ABORT0_ABORTCTRL_CH7_Pos        7                                                       /*!< DMA ABORT0: ABORTCTRL_CH7 Position    */
#define DMA_ABORT0_ABORTCTRL_CH7_Msk        (0x01UL << DMA_ABORT0_ABORTCTRL_CH7_Pos)              /*!< DMA ABORT0: ABORTCTRL_CH7 Mask        */
#define DMA_ABORT0_ABORTCTRL_CH8_Pos        8                                                       /*!< DMA ABORT0: ABORTCTRL_CH8 Position    */
#define DMA_ABORT0_ABORTCTRL_CH8_Msk        (0x01UL << DMA_ABORT0_ABORTCTRL_CH8_Pos)              /*!< DMA ABORT0: ABORTCTRL_CH8 Mask        */
#define DMA_ABORT0_ABORTCTRL_CH9_Pos        9                                                       /*!< DMA ABORT0: ABORTCTRL_CH9 Position    */
#define DMA_ABORT0_ABORTCTRL_CH9_Msk        (0x01UL << DMA_ABORT0_ABORTCTRL_CH9_Pos)              /*!< DMA ABORT0: ABORTCTRL_CH9 Mask        */
#define DMA_ABORT0_ABORTCTRL_CH10_Pos       10                                                      /*!< DMA ABORT0: ABORTCTRL_CH10 Position   */
#define DMA_ABORT0_ABORTCTRL_CH10_Msk       (0x01UL << DMA_ABORT0_ABORTCTRL_CH10_Pos)             /*!< DMA ABORT0: ABORTCTRL_CH10 Mask       */
#define DMA_ABORT0_ABORTCTRL_CH11_Pos       11                                                      /*!< DMA ABORT0: ABORTCTRL_CH11 Position   */
#define DMA_ABORT0_ABORTCTRL_CH11_Msk       (0x01UL << DMA_ABORT0_ABORTCTRL_CH11_Pos)             /*!< DMA ABORT0: ABORTCTRL_CH11 Mask       */
#define DMA_ABORT0_ABORTCTRL_CH12_Pos       12                                                      /*!< DMA ABORT0: ABORTCTRL_CH12 Position   */
#define DMA_ABORT0_ABORTCTRL_CH12_Msk       (0x01UL << DMA_ABORT0_ABORTCTRL_CH12_Pos)             /*!< DMA ABORT0: ABORTCTRL_CH12 Mask       */
#define DMA_ABORT0_ABORTCTRL_CH13_Pos       13                                                      /*!< DMA ABORT0: ABORTCTRL_CH13 Position   */
#define DMA_ABORT0_ABORTCTRL_CH13_Msk       (0x01UL << DMA_ABORT0_ABORTCTRL_CH13_Pos)             /*!< DMA ABORT0: ABORTCTRL_CH13 Mask       */
#define DMA_ABORT0_ABORTCTRL_CH14_Pos       14                                                      /*!< DMA ABORT0: ABORTCTRL_CH14 Position   */
#define DMA_ABORT0_ABORTCTRL_CH14_Msk       (0x01UL << DMA_ABORT0_ABORTCTRL_CH14_Pos)             /*!< DMA ABORT0: ABORTCTRL_CH14 Mask       */
#define DMA_ABORT0_ABORTCTRL_CH15_Pos       15                                                      /*!< DMA ABORT0: ABORTCTRL_CH15 Position   */
#define DMA_ABORT0_ABORTCTRL_CH15_Msk       (0x01UL << DMA_ABORT0_ABORTCTRL_CH15_Pos)             /*!< DMA ABORT0: ABORTCTRL_CH15 Mask       */
#define DMA_ABORT0_ABORTCTRL_CH16_Pos       16                                                      /*!< DMA ABORT0: ABORTCTRL_CH16 Position   */
#define DMA_ABORT0_ABORTCTRL_CH16_Msk       (0x01UL << DMA_ABORT0_ABORTCTRL_CH16_Pos)             /*!< DMA ABORT0: ABORTCTRL_CH16 Mask       */
#define DMA_ABORT0_ABORTCTRL_CH17_Pos       17                                                      /*!< DMA ABORT0: ABORTCTRL_CH17 Position   */
#define DMA_ABORT0_ABORTCTRL_CH17_Msk       (0x01UL << DMA_ABORT0_ABORTCTRL_CH17_Pos)             /*!< DMA ABORT0: ABORTCTRL_CH17 Mask       */
#define DMA_ABORT0_ABORTCTRL_CH18_Pos       18                                                      /*!< DMA ABORT0: ABORTCTRL_CH18 Position   */
#define DMA_ABORT0_ABORTCTRL_CH18_Msk       (0x01UL << DMA_ABORT0_ABORTCTRL_CH18_Pos)             /*!< DMA ABORT0: ABORTCTRL_CH18 Mask       */


/* ================================================================================ */
/* ================        struct 'Channel' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  Channel_CFG  -------------------------------- */
#define Channel_CFG_PERIPHREQEN_Pos           0                                                       /*!< Channel CFG: PERIPHREQEN Position       */
#define Channel_CFG_PERIPHREQEN_Msk           (0x01UL << Channel_CFG_PERIPHREQEN_Pos)                 /*!< Channel CFG: PERIPHREQEN Mask           */
#define Channel_CFG_HWTRIGEN_Pos              1                                                       /*!< Channel CFG: HWTRIGEN Position          */
#define Channel_CFG_HWTRIGEN_Msk              (0x01UL << Channel_CFG_HWTRIGEN_Pos)                    /*!< Channel CFG: HWTRIGEN Mask              */
#define Channel_CFG_TRIGPOL_Pos               4                                                       /*!< Channel CFG: TRIGPOL Position           */
#define Channel_CFG_TRIGPOL_Msk               (0x01UL << Channel_CFG_TRIGPOL_Pos)                     /*!< Channel CFG: TRIGPOL Mask               */
#define Channel_CFG_TRIGTYPE_Pos              5                                                       /*!< Channel CFG: TRIGTYPE Position          */
#define Channel_CFG_TRIGTYPE_Msk              (0x01UL << Channel_CFG_TRIGTYPE_Pos)                    /*!< Channel CFG: TRIGTYPE Mask              */
#define Channel_CFG_TRIGBURST_Pos             6                                                       /*!< Channel CFG: TRIGBURST Position         */
#define Channel_CFG_TRIGBURST_Msk             (0x01UL << Channel_CFG_TRIGBURST_Pos)                   /*!< Channel CFG: TRIGBURST Mask             */
#define Channel_CFG_BURSTPOWER_Pos            8                                                       /*!< Channel CFG: BURSTPOWER Position        */
#define Channel_CFG_BURSTPOWER_Msk            (0x0fUL << Channel_CFG_BURSTPOWER_Pos)                  /*!< Channel CFG: BURSTPOWER Mask            */
#define Channel_CFG_SRCBURSTWRAP_Pos          14                                                      /*!< Channel CFG: SRCBURSTWRAP Position      */
#define Channel_CFG_SRCBURSTWRAP_Msk          (0x01UL << Channel_CFG_SRCBURSTWRAP_Pos)                /*!< Channel CFG: SRCBURSTWRAP Mask          */
#define Channel_CFG_DSTBURSTWRAP_Pos          15                                                      /*!< Channel CFG: DSTBURSTWRAP Position      */
#define Channel_CFG_DSTBURSTWRAP_Msk          (0x01UL << Channel_CFG_DSTBURSTWRAP_Pos)                /*!< Channel CFG: DSTBURSTWRAP Mask          */
#define Channel_CFG_CHPRIORITY_Pos            16                                                      /*!< Channel CFG: CHPRIORITY Position        */
#define Channel_CFG_CHPRIORITY_Msk            (0x07UL << Channel_CFG_CHPRIORITY_Pos)                  /*!< Channel CFG: CHPRIORITY Mask            */

/* -------------------------------  Channel_CTLSTAT  ------------------------------ */
#define Channel_CTLSTAT_VALIDPENDING_Pos      0                                                       /*!< Channel CTLSTAT: VALIDPENDING Position  */
#define Channel_CTLSTAT_VALIDPENDING_Msk      (0x01UL << Channel_CTLSTAT_VALIDPENDING_Pos)            /*!< Channel CTLSTAT: VALIDPENDING Mask      */
#define Channel_CTLSTAT_TRIG_Pos              2                                                       /*!< Channel CTLSTAT: TRIG Position          */
#define Channel_CTLSTAT_TRIG_Msk              (0x01UL << Channel_CTLSTAT_TRIG_Pos)                    /*!< Channel CTLSTAT: TRIG Mask              */

/* -------------------------------  Channel_XFERCFG  ------------------------------ */
#define Channel_XFERCFG_CFGVALID_Pos          0                                                       /*!< Channel XFERCFG: CFGVALID Position      */
#define Channel_XFERCFG_CFGVALID_Msk          (0x01UL << Channel_XFERCFG_CFGVALID_Pos)                /*!< Channel XFERCFG: CFGVALID Mask          */
#define Channel_XFERCFG_RELOAD_Pos            1                                                       /*!< Channel XFERCFG: RELOAD Position        */
#define Channel_XFERCFG_RELOAD_Msk            (0x01UL << Channel_XFERCFG_RELOAD_Pos)                  /*!< Channel XFERCFG: RELOAD Mask            */
#define Channel_XFERCFG_SWTRIG_Pos            2                                                       /*!< Channel XFERCFG: SWTRIG Position        */
#define Channel_XFERCFG_SWTRIG_Msk            (0x01UL << Channel_XFERCFG_SWTRIG_Pos)                  /*!< Channel XFERCFG: SWTRIG Mask            */
#define Channel_XFERCFG_CLRTRIG_Pos           3                                                       /*!< Channel XFERCFG: CLRTRIG Position       */
#define Channel_XFERCFG_CLRTRIG_Msk           (0x01UL << Channel_XFERCFG_CLRTRIG_Pos)                 /*!< Channel XFERCFG: CLRTRIG Mask           */
#define Channel_XFERCFG_SETINTA_Pos           4                                                       /*!< Channel XFERCFG: SETINTA Position       */
#define Channel_XFERCFG_SETINTA_Msk           (0x01UL << Channel_XFERCFG_SETINTA_Pos)                 /*!< Channel XFERCFG: SETINTA Mask           */
#define Channel_XFERCFG_SETINTB_Pos           5                                                       /*!< Channel XFERCFG: SETINTB Position       */
#define Channel_XFERCFG_SETINTB_Msk           (0x01UL << Channel_XFERCFG_SETINTB_Pos)                 /*!< Channel XFERCFG: SETINTB Mask           */
#define Channel_XFERCFG_WIDTH_Pos             8                                                       /*!< Channel XFERCFG: WIDTH Position         */
#define Channel_XFERCFG_WIDTH_Msk             (0x03UL << Channel_XFERCFG_WIDTH_Pos)                   /*!< Channel XFERCFG: WIDTH Mask             */
#define Channel_XFERCFG_SRCINC_Pos            12                                                      /*!< Channel XFERCFG: SRCINC Position        */
#define Channel_XFERCFG_SRCINC_Msk            (0x03UL << Channel_XFERCFG_SRCINC_Pos)                  /*!< Channel XFERCFG: SRCINC Mask            */
#define Channel_XFERCFG_DSTINC_Pos            14                                                      /*!< Channel XFERCFG: DSTINC Position        */
#define Channel_XFERCFG_DSTINC_Msk            (0x03UL << Channel_XFERCFG_DSTINC_Pos)                  /*!< Channel XFERCFG: DSTINC Mask            */
#define Channel_XFERCFG_XFERCOUNT_Pos         16                                                      /*!< Channel XFERCFG: XFERCOUNT Position     */
#define Channel_XFERCFG_XFERCOUNT_Msk         (0x000003ffUL << Channel_XFERCFG_XFERCOUNT_Pos)         /*!< Channel XFERCFG: XFERCOUNT Mask         */

/* ------------------------------  Channel_RESERVED0  ----------------------------- */
#define Channel_RESERVED0_DUMMYWORD_Pos       0                                                       /*!< Channel RESERVED0: DUMMYWORD Position   */
#define Channel_RESERVED0_DUMMYWORD_Msk       (0xffffffffUL << Channel_RESERVED0_DUMMYWORD_Pos)       /*!< Channel RESERVED0: DUMMYWORD Mask       */


/* ================================================================================ */
/* ================        struct 'u_aes256' Position & Mask       ================ */
/* ================================================================================ */


/* --------------------------------  u_aes256_CFG  -------------------------------- */
#define AES256_CFG_PROC_EN_Pos              0                                                       /*!< AES256 CFG: PROC_EN Position          */
#define AES256_CFG_PROC_EN_Msk              (0x03UL << AES256_CFG_PROC_EN_Pos)                    /*!< AES256 CFG: PROC_EN Mask              */
#define AES256_CFG_GF128_SEL_Pos            2                                                       /*!< AES256 CFG: GF128_SEL Position        */
#define AES256_CFG_GF128_SEL_Msk            (0x01UL << AES256_CFG_GF128_SEL_Pos)                  /*!< AES256 CFG: GF128_SEL Mask            */
#define AES256_CFG_INT_BSWAP_Pos            4                                                       /*!< AES256 CFG: INT_BSWAP Position        */
#define AES256_CFG_INT_BSWAP_Msk            (0x01UL << AES256_CFG_INT_BSWAP_Pos)                  /*!< AES256 CFG: INT_BSWAP Mask            */
#define AES256_CFG_INT_WSWAP_Pos            5                                                       /*!< AES256 CFG: INT_WSWAP Position        */
#define AES256_CFG_INT_WSWAP_Msk            (0x01UL << AES256_CFG_INT_WSWAP_Pos)                  /*!< AES256 CFG: INT_WSWAP Mask            */
#define AES256_CFG_OUTT_BSWAP_Pos           6                                                       /*!< AES256 CFG: OUTT_BSWAP Position       */
#define AES256_CFG_OUTT_BSWAP_Msk           (0x01UL << AES256_CFG_OUTT_BSWAP_Pos)                 /*!< AES256 CFG: OUTT_BSWAP Mask           */
#define AES256_CFG_OUTT_WSWAP_Pos           7                                                       /*!< AES256 CFG: OUTT_WSWAP Position       */
#define AES256_CFG_OUTT_WSWAP_Msk           (0x01UL << AES256_CFG_OUTT_WSWAP_Pos)                 /*!< AES256 CFG: OUTT_WSWAP Mask           */
#define AES256_CFG_KEY_CFG_Pos              8                                                       /*!< AES256 CFG: KEY_CFG Position          */
#define AES256_CFG_KEY_CFG_Msk              (0x03UL << AES256_CFG_KEY_CFG_Pos)                    /*!< AES256 CFG: KEY_CFG Mask              */
#define AES256_CFG_INB_FSEL_Pos             16                                                      /*!< AES256 CFG: INB_FSEL Position         */
#define AES256_CFG_INB_FSEL_Msk             (0x03UL << AES256_CFG_INB_FSEL_Pos)                   /*!< AES256 CFG: INB_FSEL Mask             */
#define AES256_CFG_HOLD_FSEL_Pos            20                                                      /*!< AES256 CFG: HOLD_FSEL Position        */
#define AES256_CFG_HOLD_FSEL_Msk            (0x03UL << AES256_CFG_HOLD_FSEL_Pos)                  /*!< AES256 CFG: HOLD_FSEL Mask            */
#define AES256_CFG_OUTT_FSEL_Pos            24                                                      /*!< AES256 CFG: OUTT_FSEL Position        */
#define AES256_CFG_OUTT_FSEL_Msk            (0x03UL << AES256_CFG_OUTT_FSEL_Pos)                  /*!< AES256 CFG: OUTT_FSEL Mask            */

/* --------------------------------  u_aes256_CMD  -------------------------------- */
#define AES256_CMD_COPY_SKEY_Pos            0                                                       /*!< AES256 CMD: COPY_SKEY Position        */
#define AES256_CMD_COPY_SKEY_Msk            (0x01UL << AES256_CMD_COPY_SKEY_Pos)                  /*!< AES256 CMD: COPY_SKEY Mask            */
#define AES256_CMD_COPY_TO_Y_Pos            1                                                       /*!< AES256 CMD: COPY_TO_Y Position        */
#define AES256_CMD_COPY_TO_Y_Msk            (0x01UL << AES256_CMD_COPY_TO_Y_Pos)                  /*!< AES256 CMD: COPY_TO_Y Mask            */
#define AES256_CMD_SWITCH_MODE_Pos          4                                                       /*!< AES256 CMD: SWITCH_MODE Position      */
#define AES256_CMD_SWITCH_MODE_Msk          (0x01UL << AES256_CMD_SWITCH_MODE_Pos)                /*!< AES256 CMD: SWITCH_MODE Mask          */
#define AES256_CMD_ABORT_Pos                8                                                       /*!< AES256 CMD: ABORT Position            */
#define AES256_CMD_ABORT_Msk                (0x01UL << AES256_CMD_ABORT_Pos)                      /*!< AES256 CMD: ABORT Mask                */
#define AES256_CMD_WIPE_Pos                 9                                                       /*!< AES256 CMD: WIPE Position             */
#define AES256_CMD_WIPE_Msk                 (0x01UL << AES256_CMD_WIPE_Pos)                       /*!< AES256 CMD: WIPE Mask                 */

/* --------------------------------  u_aes256_STAT  ------------------------------- */
#define AES256_STAT_IDLE_Pos                0                                                       /*!< AES256 STAT: IDLE Position            */
#define AES256_STAT_IDLE_Msk                (0x01UL << AES256_STAT_IDLE_Pos)                      /*!< AES256 STAT: IDLE Mask                */
#define AES256_STAT_IN_READY_Pos            1                                                       /*!< AES256 STAT: IN_READY Position        */
#define AES256_STAT_IN_READY_Msk            (0x01UL << AES256_STAT_IN_READY_Pos)                  /*!< AES256 STAT: IN_READY Mask            */
#define AES256_STAT_OUT_READY_Pos           2                                                       /*!< AES256 STAT: OUT_READY Position       */
#define AES256_STAT_OUT_READY_Msk           (0x01UL << AES256_STAT_OUT_READY_Pos)                 /*!< AES256 STAT: OUT_READY Mask           */
#define AES256_STAT_REVERSE_Pos             4                                                       /*!< AES256 STAT: REVERSE Position         */
#define AES256_STAT_REVERSE_Msk             (0x01UL << AES256_STAT_REVERSE_Pos)                   /*!< AES256 STAT: REVERSE Mask             */
#define AES256_STAT_KEY_VALID_Pos           5                                                       /*!< AES256 STAT: KEY_VALID Position       */
#define AES256_STAT_KEY_VALID_Msk           (0x01UL << AES256_STAT_KEY_VALID_Pos)                 /*!< AES256 STAT: KEY_VALID Mask           */

/* ------------------------------  u_aes256_CTR_INCR  ----------------------------- */
#define AES256_CTR_INCR_CTR_INCR_Pos        0                                                       /*!< AES256 CTR_INCR: CTR_INCR Position    */
#define AES256_CTR_INCR_CTR_INCR_Msk        (0xffffffffUL << AES256_CTR_INCR_CTR_INCR_Pos)        /*!< AES256 CTR_INCR: CTR_INCR Mask        */

/* --------------------------------  u_aes256_KEY0  ------------------------------- */
#define AES256_KEY0_KEY0_Pos                0                                                       /*!< AES256 KEY0: KEY0 Position            */
#define AES256_KEY0_KEY0_Msk                (0xffffffffUL << AES256_KEY0_KEY0_Pos)                /*!< AES256 KEY0: KEY0 Mask                */

/* --------------------------------  u_aes256_KEY1  ------------------------------- */
#define AES256_KEY1_KEY1_Pos                0                                                       /*!< AES256 KEY1: KEY1 Position            */
#define AES256_KEY1_KEY1_Msk                (0xffffffffUL << AES256_KEY1_KEY1_Pos)                /*!< AES256 KEY1: KEY1 Mask                */

/* --------------------------------  u_aes256_KEY2  ------------------------------- */
#define AES256_KEY2_KEY2_Pos                0                                                       /*!< AES256 KEY2: KEY2 Position            */
#define AES256_KEY2_KEY2_Msk                (0xffffffffUL << AES256_KEY2_KEY2_Pos)                /*!< AES256 KEY2: KEY2 Mask                */

/* --------------------------------  u_aes256_KEY3  ------------------------------- */
#define AES256_KEY3_KEY3_Pos                0                                                       /*!< AES256 KEY3: KEY3 Position            */
#define AES256_KEY3_KEY3_Msk                (0xffffffffUL << AES256_KEY3_KEY3_Pos)                /*!< AES256 KEY3: KEY3 Mask                */

/* --------------------------------  u_aes256_KEY4  ------------------------------- */
#define AES256_KEY4_KEY4_Pos                0                                                       /*!< AES256 KEY4: KEY4 Position            */
#define AES256_KEY4_KEY4_Msk                (0xffffffffUL << AES256_KEY4_KEY4_Pos)                /*!< AES256 KEY4: KEY4 Mask                */

/* --------------------------------  u_aes256_KEY5  ------------------------------- */
#define AES256_KEY5_KEY5_Pos                0                                                       /*!< AES256 KEY5: KEY5 Position            */
#define AES256_KEY5_KEY5_Msk                (0xffffffffUL << AES256_KEY5_KEY5_Pos)                /*!< AES256 KEY5: KEY5 Mask                */

/* --------------------------------  u_aes256_KEY6  ------------------------------- */
#define AES256_KEY6_KEY6_Pos                0                                                       /*!< AES256 KEY6: KEY6 Position            */
#define AES256_KEY6_KEY6_Msk                (0xffffffffUL << AES256_KEY6_KEY6_Pos)                /*!< AES256 KEY6: KEY6 Mask                */

/* --------------------------------  u_aes256_KEY7  ------------------------------- */
#define AES256_KEY7_KEY7_Pos                0                                                       /*!< AES256 KEY7: KEY7 Position            */
#define AES256_KEY7_KEY7_Msk                (0xffffffffUL << AES256_KEY7_KEY7_Pos)                /*!< AES256 KEY7: KEY7 Mask                */

/* --------------------------------  u_aes256_IN0  -------------------------------- */
#define AES256_IN0_IN0_Pos                  0                                                       /*!< AES256 IN0: IN0 Position              */
#define AES256_IN0_IN0_Msk                  (0xffffffffUL << AES256_IN0_IN0_Pos)                  /*!< AES256 IN0: IN0 Mask                  */

/* --------------------------------  u_aes256_IN1  -------------------------------- */
#define AES256_IN1_IN1_Pos                  0                                                       /*!< AES256 IN1: IN1 Position              */
#define AES256_IN1_IN1_Msk                  (0xffffffffUL << AES256_IN1_IN1_Pos)                  /*!< AES256 IN1: IN1 Mask                  */

/* --------------------------------  u_aes256_IN2  -------------------------------- */
#define AES256_IN2_IN2_Pos                  0                                                       /*!< AES256 IN2: IN2 Position              */
#define AES256_IN2_IN2_Msk                  (0xffffffffUL << AES256_IN2_IN2_Pos)                  /*!< AES256 IN2: IN2 Mask                  */

/* --------------------------------  u_aes256_IN3  -------------------------------- */
#define AES256_IN3_IN3_Pos                  0                                                       /*!< AES256 IN3: IN3 Position              */
#define AES256_IN3_IN3_Msk                  (0xffffffffUL << AES256_IN3_IN3_Pos)                  /*!< AES256 IN3: IN3 Mask                  */

/* ------------------------------  u_aes256_HOLDING0  ----------------------------- */
#define AES256_HOLDING0_HOLDING0_Pos        0                                                       /*!< AES256 HOLDING0: HOLDING0 Position    */
#define AES256_HOLDING0_HOLDING0_Msk        (0xffffffffUL << AES256_HOLDING0_HOLDING0_Pos)        /*!< AES256 HOLDING0: HOLDING0 Mask        */

/* ------------------------------  u_aes256_HOLDING1  ----------------------------- */
#define AES256_HOLDING1_HOLDING1_Pos        0                                                       /*!< AES256 HOLDING1: HOLDING1 Position    */
#define AES256_HOLDING1_HOLDING1_Msk        (0xffffffffUL << AES256_HOLDING1_HOLDING1_Pos)        /*!< AES256 HOLDING1: HOLDING1 Mask        */

/* ------------------------------  u_aes256_HOLDING2  ----------------------------- */
#define AES256_HOLDING2_HOLDING2_Pos        0                                                       /*!< AES256 HOLDING2: HOLDING2 Position    */
#define AES256_HOLDING2_HOLDING2_Msk        (0xffffffffUL << AES256_HOLDING2_HOLDING2_Pos)        /*!< AES256 HOLDING2: HOLDING2 Mask        */

/* ------------------------------  u_aes256_HOLDING3  ----------------------------- */
#define AES256_HOLDING3_HOLDING3_Pos        0                                                       /*!< AES256 HOLDING3: HOLDING3 Position    */
#define AES256_HOLDING3_HOLDING3_Msk        (0xffffffffUL << AES256_HOLDING3_HOLDING3_Pos)        /*!< AES256 HOLDING3: HOLDING3 Mask        */

/* --------------------------------  u_aes256_OUT0  ------------------------------- */
#define AES256_OUT0_OUT0_Pos                0                                                       /*!< AES256 OUT0: OUT0 Position            */
#define AES256_OUT0_OUT0_Msk                (0xffffffffUL << AES256_OUT0_OUT0_Pos)                /*!< AES256 OUT0: OUT0 Mask                */

/* --------------------------------  u_aes256_OUT1  ------------------------------- */
#define AES256_OUT1_OUT1_Pos                0                                                       /*!< AES256 OUT1: OUT1 Position            */
#define AES256_OUT1_OUT1_Msk                (0xffffffffUL << AES256_OUT1_OUT1_Pos)                /*!< AES256 OUT1: OUT1 Mask                */

/* --------------------------------  u_aes256_OUT2  ------------------------------- */
#define AES256_OUT2_OUT2_Pos                0                                                       /*!< AES256 OUT2: OUT2 Position            */
#define AES256_OUT2_OUT2_Msk                (0xffffffffUL << AES256_OUT2_OUT2_Pos)                /*!< AES256 OUT2: OUT2 Mask                */

/* --------------------------------  u_aes256_OUT3  ------------------------------- */
#define AES256_OUT3_OUT3_Pos                0                                                       /*!< AES256 OUT3: OUT3 Position            */
#define AES256_OUT3_OUT3_Msk                (0xffffffffUL << AES256_OUT3_OUT3_Pos)                /*!< AES256 OUT3: OUT3 Mask                */

/* ------------------------------  u_aes256_GF128_Y0  ----------------------------- */
#define AES256_GF128_Y0_GF128_Y0_Pos        0                                                       /*!< AES256 GF128_Y0: GF128_Y0 Position    */
#define AES256_GF128_Y0_GF128_Y0_Msk        (0xffffffffUL << AES256_GF128_Y0_GF128_Y0_Pos)        /*!< AES256 GF128_Y0: GF128_Y0 Mask        */

/* ------------------------------  u_aes256_GF128_Y1  ----------------------------- */
#define AES256_GF128_Y1_GF128_Y1_Pos        0                                                       /*!< AES256 GF128_Y1: GF128_Y1 Position    */
#define AES256_GF128_Y1_GF128_Y1_Msk        (0xffffffffUL << AES256_GF128_Y1_GF128_Y1_Pos)        /*!< AES256 GF128_Y1: GF128_Y1 Mask        */

/* ------------------------------  u_aes256_GF128_Y2  ----------------------------- */
#define AES256_GF128_Y2_GF128_Y2_Pos        0                                                       /*!< AES256 GF128_Y2: GF128_Y2 Position    */
#define AES256_GF128_Y2_GF128_Y2_Msk        (0xffffffffUL << AES256_GF128_Y2_GF128_Y2_Pos)        /*!< AES256 GF128_Y2: GF128_Y2 Mask        */

/* ------------------------------  u_aes256_GF128_Y3  ----------------------------- */
#define AES256_GF128_Y3_GF128_Y3_Pos        0                                                       /*!< AES256 GF128_Y3: GF128_Y3 Position    */
#define AES256_GF128_Y3_GF128_Y3_Msk        (0xffffffffUL << AES256_GF128_Y3_GF128_Y3_Pos)        /*!< AES256 GF128_Y3: GF128_Y3 Mask        */

/* ------------------------------  u_aes256_GF128_Z0  ----------------------------- */
#define AES256_GF128_Z0_GF128_Z0_Pos        0                                                       /*!< AES256 GF128_Z0: GF128_Z0 Position    */
#define AES256_GF128_Z0_GF128_Z0_Msk        (0xffffffffUL << AES256_GF128_Z0_GF128_Z0_Pos)        /*!< AES256 GF128_Z0: GF128_Z0 Mask        */

/* ------------------------------  u_aes256_GF128_Z1  ----------------------------- */
#define AES256_GF128_Z1_GF128_Z1_Pos        0                                                       /*!< AES256 GF128_Z1: GF128_Z1 Position    */
#define AES256_GF128_Z1_GF128_Z1_Msk        (0xffffffffUL << AES256_GF128_Z1_GF128_Z1_Pos)        /*!< AES256 GF128_Z1: GF128_Z1 Mask        */

/* ------------------------------  u_aes256_GF128_Z2  ----------------------------- */
#define AES256_GF128_Z2_GF128_Z2_Pos        0                                                       /*!< AES256 GF128_Z2: GF128_Z2 Position    */
#define AES256_GF128_Z2_GF128_Z2_Msk        (0xffffffffUL << AES256_GF128_Z2_GF128_Z2_Pos)        /*!< AES256 GF128_Z2: GF128_Z2 Mask        */

/* ------------------------------  u_aes256_GF128_Z3  ----------------------------- */
#define AES256_GF128_Z3_GF128_Z3_Pos        0                                                       /*!< AES256 GF128_Z3: GF128_Z3 Position    */
#define AES256_GF128_Z3_GF128_Z3_Msk        (0xffffffffUL << AES256_GF128_Z3_GF128_Z3_Pos)        /*!< AES256 GF128_Z3: GF128_Z3 Mask        */

/* ------------------------------  u_aes256_GCM_TAG0  ----------------------------- */
#define AES256_GCM_TAG0_GCM_TAG0_Pos        0                                                       /*!< AES256 GCM_TAG0: GCM_TAG0 Position    */
#define AES256_GCM_TAG0_GCM_TAG0_Msk        (0xffffffffUL << AES256_GCM_TAG0_GCM_TAG0_Pos)        /*!< AES256 GCM_TAG0: GCM_TAG0 Mask        */

/* ------------------------------  u_aes256_GCM_TAG1  ----------------------------- */
#define AES256_GCM_TAG1_GCM_TAG1_Pos        0                                                       /*!< AES256 GCM_TAG1: GCM_TAG1 Position    */
#define AES256_GCM_TAG1_GCM_TAG1_Msk        (0xffffffffUL << AES256_GCM_TAG1_GCM_TAG1_Pos)        /*!< AES256 GCM_TAG1: GCM_TAG1 Mask        */

/* ------------------------------  u_aes256_GCM_TAG2  ----------------------------- */
#define AES256_GCM_TAG2_GCM_TAG2_Pos        0                                                       /*!< AES256 GCM_TAG2: GCM_TAG2 Position    */
#define AES256_GCM_TAG2_GCM_TAG2_Msk        (0xffffffffUL << AES256_GCM_TAG2_GCM_TAG2_Pos)        /*!< AES256 GCM_TAG2: GCM_TAG2 Mask        */

/* ------------------------------  u_aes256_GCM_TAG3  ----------------------------- */
#define AES256_GCM_TAG3_GCM_TAG3_Pos        0                                                       /*!< AES256 GCM_TAG3: GCM_TAG3 Position    */
#define AES256_GCM_TAG3_GCM_TAG3_Msk        (0xffffffffUL << AES256_GCM_TAG3_GCM_TAG3_Pos)        /*!< AES256 GCM_TAG3: GCM_TAG3 Mask        */


/* ================================================================================ */
/* ================       struct 'u_mailbox' Position & Mask       ================ */
/* ================================================================================ */


/* -------------------------------  u_mailbox_IRQ0  ------------------------------- */
#define MAILBOX_IRQ0_INTREQ0_Pos            0                                                       /*!< MAILBOX IRQ0: INTREQ0 Position        */
#define MAILBOX_IRQ0_INTREQ0_Msk            (0x01UL << MAILBOX_IRQ0_INTREQ0_Pos)                  /*!< MAILBOX IRQ0: INTREQ0 Mask            */
#define MAILBOX_IRQ0_INTREQ1_Pos            1                                                       /*!< MAILBOX IRQ0: INTREQ1 Position        */
#define MAILBOX_IRQ0_INTREQ1_Msk            (0x01UL << MAILBOX_IRQ0_INTREQ1_Pos)                  /*!< MAILBOX IRQ0: INTREQ1 Mask            */
#define MAILBOX_IRQ0_INTREQ2_Pos            2                                                       /*!< MAILBOX IRQ0: INTREQ2 Position        */
#define MAILBOX_IRQ0_INTREQ2_Msk            (0x01UL << MAILBOX_IRQ0_INTREQ2_Pos)                  /*!< MAILBOX IRQ0: INTREQ2 Mask            */
#define MAILBOX_IRQ0_INTREQ3_Pos            3                                                       /*!< MAILBOX IRQ0: INTREQ3 Position        */
#define MAILBOX_IRQ0_INTREQ3_Msk            (0x01UL << MAILBOX_IRQ0_INTREQ3_Pos)                  /*!< MAILBOX IRQ0: INTREQ3 Mask            */
#define MAILBOX_IRQ0_INTREQ4_Pos            4                                                       /*!< MAILBOX IRQ0: INTREQ4 Position        */
#define MAILBOX_IRQ0_INTREQ4_Msk            (0x01UL << MAILBOX_IRQ0_INTREQ4_Pos)                  /*!< MAILBOX IRQ0: INTREQ4 Mask            */
#define MAILBOX_IRQ0_INTREQ5_Pos            5                                                       /*!< MAILBOX IRQ0: INTREQ5 Position        */
#define MAILBOX_IRQ0_INTREQ5_Msk            (0x01UL << MAILBOX_IRQ0_INTREQ5_Pos)                  /*!< MAILBOX IRQ0: INTREQ5 Mask            */
#define MAILBOX_IRQ0_INTREQ6_Pos            6                                                       /*!< MAILBOX IRQ0: INTREQ6 Position        */
#define MAILBOX_IRQ0_INTREQ6_Msk            (0x01UL << MAILBOX_IRQ0_INTREQ6_Pos)                  /*!< MAILBOX IRQ0: INTREQ6 Mask            */
#define MAILBOX_IRQ0_INTREQ7_Pos            7                                                       /*!< MAILBOX IRQ0: INTREQ7 Position        */
#define MAILBOX_IRQ0_INTREQ7_Msk            (0x01UL << MAILBOX_IRQ0_INTREQ7_Pos)                  /*!< MAILBOX IRQ0: INTREQ7 Mask            */
#define MAILBOX_IRQ0_INTREQ8_Pos            8                                                       /*!< MAILBOX IRQ0: INTREQ8 Position        */
#define MAILBOX_IRQ0_INTREQ8_Msk            (0x01UL << MAILBOX_IRQ0_INTREQ8_Pos)                  /*!< MAILBOX IRQ0: INTREQ8 Mask            */
#define MAILBOX_IRQ0_INTREQ9_Pos            9                                                       /*!< MAILBOX IRQ0: INTREQ9 Position        */
#define MAILBOX_IRQ0_INTREQ9_Msk            (0x01UL << MAILBOX_IRQ0_INTREQ9_Pos)                  /*!< MAILBOX IRQ0: INTREQ9 Mask            */
#define MAILBOX_IRQ0_INTREQ10_Pos           10                                                      /*!< MAILBOX IRQ0: INTREQ10 Position       */
#define MAILBOX_IRQ0_INTREQ10_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ10_Pos)                 /*!< MAILBOX IRQ0: INTREQ10 Mask           */
#define MAILBOX_IRQ0_INTREQ11_Pos           11                                                      /*!< MAILBOX IRQ0: INTREQ11 Position       */
#define MAILBOX_IRQ0_INTREQ11_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ11_Pos)                 /*!< MAILBOX IRQ0: INTREQ11 Mask           */
#define MAILBOX_IRQ0_INTREQ12_Pos           12                                                      /*!< MAILBOX IRQ0: INTREQ12 Position       */
#define MAILBOX_IRQ0_INTREQ12_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ12_Pos)                 /*!< MAILBOX IRQ0: INTREQ12 Mask           */
#define MAILBOX_IRQ0_INTREQ13_Pos           13                                                      /*!< MAILBOX IRQ0: INTREQ13 Position       */
#define MAILBOX_IRQ0_INTREQ13_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ13_Pos)                 /*!< MAILBOX IRQ0: INTREQ13 Mask           */
#define MAILBOX_IRQ0_INTREQ14_Pos           14                                                      /*!< MAILBOX IRQ0: INTREQ14 Position       */
#define MAILBOX_IRQ0_INTREQ14_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ14_Pos)                 /*!< MAILBOX IRQ0: INTREQ14 Mask           */
#define MAILBOX_IRQ0_INTREQ15_Pos           15                                                      /*!< MAILBOX IRQ0: INTREQ15 Position       */
#define MAILBOX_IRQ0_INTREQ15_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ15_Pos)                 /*!< MAILBOX IRQ0: INTREQ15 Mask           */
#define MAILBOX_IRQ0_INTREQ16_Pos           16                                                      /*!< MAILBOX IRQ0: INTREQ16 Position       */
#define MAILBOX_IRQ0_INTREQ16_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ16_Pos)                 /*!< MAILBOX IRQ0: INTREQ16 Mask           */
#define MAILBOX_IRQ0_INTREQ17_Pos           17                                                      /*!< MAILBOX IRQ0: INTREQ17 Position       */
#define MAILBOX_IRQ0_INTREQ17_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ17_Pos)                 /*!< MAILBOX IRQ0: INTREQ17 Mask           */
#define MAILBOX_IRQ0_INTREQ18_Pos           18                                                      /*!< MAILBOX IRQ0: INTREQ18 Position       */
#define MAILBOX_IRQ0_INTREQ18_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ18_Pos)                 /*!< MAILBOX IRQ0: INTREQ18 Mask           */
#define MAILBOX_IRQ0_INTREQ19_Pos           19                                                      /*!< MAILBOX IRQ0: INTREQ19 Position       */
#define MAILBOX_IRQ0_INTREQ19_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ19_Pos)                 /*!< MAILBOX IRQ0: INTREQ19 Mask           */
#define MAILBOX_IRQ0_INTREQ20_Pos           20                                                      /*!< MAILBOX IRQ0: INTREQ20 Position       */
#define MAILBOX_IRQ0_INTREQ20_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ20_Pos)                 /*!< MAILBOX IRQ0: INTREQ20 Mask           */
#define MAILBOX_IRQ0_INTREQ21_Pos           21                                                      /*!< MAILBOX IRQ0: INTREQ21 Position       */
#define MAILBOX_IRQ0_INTREQ21_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ21_Pos)                 /*!< MAILBOX IRQ0: INTREQ21 Mask           */
#define MAILBOX_IRQ0_INTREQ22_Pos           22                                                      /*!< MAILBOX IRQ0: INTREQ22 Position       */
#define MAILBOX_IRQ0_INTREQ22_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ22_Pos)                 /*!< MAILBOX IRQ0: INTREQ22 Mask           */
#define MAILBOX_IRQ0_INTREQ23_Pos           23                                                      /*!< MAILBOX IRQ0: INTREQ23 Position       */
#define MAILBOX_IRQ0_INTREQ23_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ23_Pos)                 /*!< MAILBOX IRQ0: INTREQ23 Mask           */
#define MAILBOX_IRQ0_INTREQ24_Pos           24                                                      /*!< MAILBOX IRQ0: INTREQ24 Position       */
#define MAILBOX_IRQ0_INTREQ24_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ24_Pos)                 /*!< MAILBOX IRQ0: INTREQ24 Mask           */
#define MAILBOX_IRQ0_INTREQ25_Pos           25                                                      /*!< MAILBOX IRQ0: INTREQ25 Position       */
#define MAILBOX_IRQ0_INTREQ25_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ25_Pos)                 /*!< MAILBOX IRQ0: INTREQ25 Mask           */
#define MAILBOX_IRQ0_INTREQ26_Pos           26                                                      /*!< MAILBOX IRQ0: INTREQ26 Position       */
#define MAILBOX_IRQ0_INTREQ26_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ26_Pos)                 /*!< MAILBOX IRQ0: INTREQ26 Mask           */
#define MAILBOX_IRQ0_INTREQ27_Pos           27                                                      /*!< MAILBOX IRQ0: INTREQ27 Position       */
#define MAILBOX_IRQ0_INTREQ27_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ27_Pos)                 /*!< MAILBOX IRQ0: INTREQ27 Mask           */
#define MAILBOX_IRQ0_INTREQ28_Pos           28                                                      /*!< MAILBOX IRQ0: INTREQ28 Position       */
#define MAILBOX_IRQ0_INTREQ28_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ28_Pos)                 /*!< MAILBOX IRQ0: INTREQ28 Mask           */
#define MAILBOX_IRQ0_INTREQ29_Pos           29                                                      /*!< MAILBOX IRQ0: INTREQ29 Position       */
#define MAILBOX_IRQ0_INTREQ29_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ29_Pos)                 /*!< MAILBOX IRQ0: INTREQ29 Mask           */
#define MAILBOX_IRQ0_INTREQ30_Pos           30                                                      /*!< MAILBOX IRQ0: INTREQ30 Position       */
#define MAILBOX_IRQ0_INTREQ30_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ30_Pos)                 /*!< MAILBOX IRQ0: INTREQ30 Mask           */
#define MAILBOX_IRQ0_INTREQ31_Pos           31                                                      /*!< MAILBOX IRQ0: INTREQ31 Position       */
#define MAILBOX_IRQ0_INTREQ31_Msk           (0x01UL << MAILBOX_IRQ0_INTREQ31_Pos)                 /*!< MAILBOX IRQ0: INTREQ31 Mask           */

/* ------------------------------  u_mailbox_IRQ0SET  ----------------------------- */
#define MAILBOX_IRQ0SET_INTREQSET0_Pos      0                                                       /*!< MAILBOX IRQ0SET: INTREQSET0 Position  */
#define MAILBOX_IRQ0SET_INTREQSET0_Msk      (0x01UL << MAILBOX_IRQ0SET_INTREQSET0_Pos)            /*!< MAILBOX IRQ0SET: INTREQSET0 Mask      */
#define MAILBOX_IRQ0SET_INTREQSET1_Pos      1                                                       /*!< MAILBOX IRQ0SET: INTREQSET1 Position  */
#define MAILBOX_IRQ0SET_INTREQSET1_Msk      (0x01UL << MAILBOX_IRQ0SET_INTREQSET1_Pos)            /*!< MAILBOX IRQ0SET: INTREQSET1 Mask      */
#define MAILBOX_IRQ0SET_INTREQSET2_Pos      2                                                       /*!< MAILBOX IRQ0SET: INTREQSET2 Position  */
#define MAILBOX_IRQ0SET_INTREQSET2_Msk      (0x01UL << MAILBOX_IRQ0SET_INTREQSET2_Pos)            /*!< MAILBOX IRQ0SET: INTREQSET2 Mask      */
#define MAILBOX_IRQ0SET_INTREQSET3_Pos      3                                                       /*!< MAILBOX IRQ0SET: INTREQSET3 Position  */
#define MAILBOX_IRQ0SET_INTREQSET3_Msk      (0x01UL << MAILBOX_IRQ0SET_INTREQSET3_Pos)            /*!< MAILBOX IRQ0SET: INTREQSET3 Mask      */
#define MAILBOX_IRQ0SET_INTREQSET4_Pos      4                                                       /*!< MAILBOX IRQ0SET: INTREQSET4 Position  */
#define MAILBOX_IRQ0SET_INTREQSET4_Msk      (0x01UL << MAILBOX_IRQ0SET_INTREQSET4_Pos)            /*!< MAILBOX IRQ0SET: INTREQSET4 Mask      */
#define MAILBOX_IRQ0SET_INTREQSET5_Pos      5                                                       /*!< MAILBOX IRQ0SET: INTREQSET5 Position  */
#define MAILBOX_IRQ0SET_INTREQSET5_Msk      (0x01UL << MAILBOX_IRQ0SET_INTREQSET5_Pos)            /*!< MAILBOX IRQ0SET: INTREQSET5 Mask      */
#define MAILBOX_IRQ0SET_INTREQSET6_Pos      6                                                       /*!< MAILBOX IRQ0SET: INTREQSET6 Position  */
#define MAILBOX_IRQ0SET_INTREQSET6_Msk      (0x01UL << MAILBOX_IRQ0SET_INTREQSET6_Pos)            /*!< MAILBOX IRQ0SET: INTREQSET6 Mask      */
#define MAILBOX_IRQ0SET_INTREQSET7_Pos      7                                                       /*!< MAILBOX IRQ0SET: INTREQSET7 Position  */
#define MAILBOX_IRQ0SET_INTREQSET7_Msk      (0x01UL << MAILBOX_IRQ0SET_INTREQSET7_Pos)            /*!< MAILBOX IRQ0SET: INTREQSET7 Mask      */
#define MAILBOX_IRQ0SET_INTREQSET8_Pos      8                                                       /*!< MAILBOX IRQ0SET: INTREQSET8 Position  */
#define MAILBOX_IRQ0SET_INTREQSET8_Msk      (0x01UL << MAILBOX_IRQ0SET_INTREQSET8_Pos)            /*!< MAILBOX IRQ0SET: INTREQSET8 Mask      */
#define MAILBOX_IRQ0SET_INTREQSET9_Pos      9                                                       /*!< MAILBOX IRQ0SET: INTREQSET9 Position  */
#define MAILBOX_IRQ0SET_INTREQSET9_Msk      (0x01UL << MAILBOX_IRQ0SET_INTREQSET9_Pos)            /*!< MAILBOX IRQ0SET: INTREQSET9 Mask      */
#define MAILBOX_IRQ0SET_INTREQSET10_Pos     10                                                      /*!< MAILBOX IRQ0SET: INTREQSET10 Position */
#define MAILBOX_IRQ0SET_INTREQSET10_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET10_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET10 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET11_Pos     11                                                      /*!< MAILBOX IRQ0SET: INTREQSET11 Position */
#define MAILBOX_IRQ0SET_INTREQSET11_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET11_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET11 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET12_Pos     12                                                      /*!< MAILBOX IRQ0SET: INTREQSET12 Position */
#define MAILBOX_IRQ0SET_INTREQSET12_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET12_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET12 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET13_Pos     13                                                      /*!< MAILBOX IRQ0SET: INTREQSET13 Position */
#define MAILBOX_IRQ0SET_INTREQSET13_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET13_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET13 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET14_Pos     14                                                      /*!< MAILBOX IRQ0SET: INTREQSET14 Position */
#define MAILBOX_IRQ0SET_INTREQSET14_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET14_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET14 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET15_Pos     15                                                      /*!< MAILBOX IRQ0SET: INTREQSET15 Position */
#define MAILBOX_IRQ0SET_INTREQSET15_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET15_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET15 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET16_Pos     16                                                      /*!< MAILBOX IRQ0SET: INTREQSET16 Position */
#define MAILBOX_IRQ0SET_INTREQSET16_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET16_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET16 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET17_Pos     17                                                      /*!< MAILBOX IRQ0SET: INTREQSET17 Position */
#define MAILBOX_IRQ0SET_INTREQSET17_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET17_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET17 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET18_Pos     18                                                      /*!< MAILBOX IRQ0SET: INTREQSET18 Position */
#define MAILBOX_IRQ0SET_INTREQSET18_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET18_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET18 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET19_Pos     19                                                      /*!< MAILBOX IRQ0SET: INTREQSET19 Position */
#define MAILBOX_IRQ0SET_INTREQSET19_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET19_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET19 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET20_Pos     20                                                      /*!< MAILBOX IRQ0SET: INTREQSET20 Position */
#define MAILBOX_IRQ0SET_INTREQSET20_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET20_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET20 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET21_Pos     21                                                      /*!< MAILBOX IRQ0SET: INTREQSET21 Position */
#define MAILBOX_IRQ0SET_INTREQSET21_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET21_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET21 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET22_Pos     22                                                      /*!< MAILBOX IRQ0SET: INTREQSET22 Position */
#define MAILBOX_IRQ0SET_INTREQSET22_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET22_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET22 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET23_Pos     23                                                      /*!< MAILBOX IRQ0SET: INTREQSET23 Position */
#define MAILBOX_IRQ0SET_INTREQSET23_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET23_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET23 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET24_Pos     24                                                      /*!< MAILBOX IRQ0SET: INTREQSET24 Position */
#define MAILBOX_IRQ0SET_INTREQSET24_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET24_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET24 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET25_Pos     25                                                      /*!< MAILBOX IRQ0SET: INTREQSET25 Position */
#define MAILBOX_IRQ0SET_INTREQSET25_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET25_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET25 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET26_Pos     26                                                      /*!< MAILBOX IRQ0SET: INTREQSET26 Position */
#define MAILBOX_IRQ0SET_INTREQSET26_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET26_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET26 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET27_Pos     27                                                      /*!< MAILBOX IRQ0SET: INTREQSET27 Position */
#define MAILBOX_IRQ0SET_INTREQSET27_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET27_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET27 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET28_Pos     28                                                      /*!< MAILBOX IRQ0SET: INTREQSET28 Position */
#define MAILBOX_IRQ0SET_INTREQSET28_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET28_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET28 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET29_Pos     29                                                      /*!< MAILBOX IRQ0SET: INTREQSET29 Position */
#define MAILBOX_IRQ0SET_INTREQSET29_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET29_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET29 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET30_Pos     30                                                      /*!< MAILBOX IRQ0SET: INTREQSET30 Position */
#define MAILBOX_IRQ0SET_INTREQSET30_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET30_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET30 Mask     */
#define MAILBOX_IRQ0SET_INTREQSET31_Pos     31                                                      /*!< MAILBOX IRQ0SET: INTREQSET31 Position */
#define MAILBOX_IRQ0SET_INTREQSET31_Msk     (0x01UL << MAILBOX_IRQ0SET_INTREQSET31_Pos)           /*!< MAILBOX IRQ0SET: INTREQSET31 Mask     */

/* ------------------------------  u_mailbox_IRQ0CLR  ----------------------------- */
#define MAILBOX_IRQ0CLR_INTREQCLR0_Pos      0                                                       /*!< MAILBOX IRQ0CLR: INTREQCLR0 Position  */
#define MAILBOX_IRQ0CLR_INTREQCLR0_Msk      (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR0_Pos)            /*!< MAILBOX IRQ0CLR: INTREQCLR0 Mask      */
#define MAILBOX_IRQ0CLR_INTREQCLR1_Pos      1                                                       /*!< MAILBOX IRQ0CLR: INTREQCLR1 Position  */
#define MAILBOX_IRQ0CLR_INTREQCLR1_Msk      (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR1_Pos)            /*!< MAILBOX IRQ0CLR: INTREQCLR1 Mask      */
#define MAILBOX_IRQ0CLR_INTREQCLR2_Pos      2                                                       /*!< MAILBOX IRQ0CLR: INTREQCLR2 Position  */
#define MAILBOX_IRQ0CLR_INTREQCLR2_Msk      (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR2_Pos)            /*!< MAILBOX IRQ0CLR: INTREQCLR2 Mask      */
#define MAILBOX_IRQ0CLR_INTREQCLR3_Pos      3                                                       /*!< MAILBOX IRQ0CLR: INTREQCLR3 Position  */
#define MAILBOX_IRQ0CLR_INTREQCLR3_Msk      (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR3_Pos)            /*!< MAILBOX IRQ0CLR: INTREQCLR3 Mask      */
#define MAILBOX_IRQ0CLR_INTREQCLR4_Pos      4                                                       /*!< MAILBOX IRQ0CLR: INTREQCLR4 Position  */
#define MAILBOX_IRQ0CLR_INTREQCLR4_Msk      (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR4_Pos)            /*!< MAILBOX IRQ0CLR: INTREQCLR4 Mask      */
#define MAILBOX_IRQ0CLR_INTREQCLR5_Pos      5                                                       /*!< MAILBOX IRQ0CLR: INTREQCLR5 Position  */
#define MAILBOX_IRQ0CLR_INTREQCLR5_Msk      (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR5_Pos)            /*!< MAILBOX IRQ0CLR: INTREQCLR5 Mask      */
#define MAILBOX_IRQ0CLR_INTREQCLR6_Pos      6                                                       /*!< MAILBOX IRQ0CLR: INTREQCLR6 Position  */
#define MAILBOX_IRQ0CLR_INTREQCLR6_Msk      (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR6_Pos)            /*!< MAILBOX IRQ0CLR: INTREQCLR6 Mask      */
#define MAILBOX_IRQ0CLR_INTREQCLR7_Pos      7                                                       /*!< MAILBOX IRQ0CLR: INTREQCLR7 Position  */
#define MAILBOX_IRQ0CLR_INTREQCLR7_Msk      (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR7_Pos)            /*!< MAILBOX IRQ0CLR: INTREQCLR7 Mask      */
#define MAILBOX_IRQ0CLR_INTREQCLR8_Pos      8                                                       /*!< MAILBOX IRQ0CLR: INTREQCLR8 Position  */
#define MAILBOX_IRQ0CLR_INTREQCLR8_Msk      (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR8_Pos)            /*!< MAILBOX IRQ0CLR: INTREQCLR8 Mask      */
#define MAILBOX_IRQ0CLR_INTREQCLR9_Pos      9                                                       /*!< MAILBOX IRQ0CLR: INTREQCLR9 Position  */
#define MAILBOX_IRQ0CLR_INTREQCLR9_Msk      (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR9_Pos)            /*!< MAILBOX IRQ0CLR: INTREQCLR9 Mask      */
#define MAILBOX_IRQ0CLR_INTREQCLR10_Pos     10                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR10 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR10_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR10_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR10 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR11_Pos     11                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR11 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR11_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR11_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR11 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR12_Pos     12                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR12 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR12_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR12_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR12 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR13_Pos     13                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR13 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR13_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR13_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR13 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR14_Pos     14                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR14 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR14_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR14_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR14 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR15_Pos     15                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR15 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR15_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR15_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR15 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR16_Pos     16                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR16 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR16_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR16_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR16 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR17_Pos     17                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR17 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR17_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR17_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR17 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR18_Pos     18                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR18 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR18_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR18_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR18 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR19_Pos     19                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR19 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR19_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR19_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR19 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR20_Pos     20                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR20 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR20_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR20_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR20 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR21_Pos     21                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR21 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR21_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR21_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR21 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR22_Pos     22                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR22 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR22_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR22_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR22 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR23_Pos     23                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR23 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR23_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR23_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR23 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR24_Pos     24                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR24 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR24_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR24_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR24 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR25_Pos     25                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR25 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR25_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR25_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR25 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR26_Pos     26                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR26 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR26_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR26_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR26 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR27_Pos     27                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR27 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR27_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR27_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR27 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR28_Pos     28                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR28 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR28_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR28_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR28 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR29_Pos     29                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR29 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR29_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR29_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR29 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR30_Pos     30                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR30 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR30_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR30_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR30 Mask     */
#define MAILBOX_IRQ0CLR_INTREQCLR31_Pos     31                                                      /*!< MAILBOX IRQ0CLR: INTREQCLR31 Position */
#define MAILBOX_IRQ0CLR_INTREQCLR31_Msk     (0x01UL << MAILBOX_IRQ0CLR_INTREQCLR31_Pos)           /*!< MAILBOX IRQ0CLR: INTREQCLR31 Mask     */

/* -------------------------------  u_mailbox_IRQ1  ------------------------------- */
#define MAILBOX_IRQ1_INTREQ0_Pos            0                                                       /*!< MAILBOX IRQ1: INTREQ0 Position        */
#define MAILBOX_IRQ1_INTREQ0_Msk            (0x01UL << MAILBOX_IRQ1_INTREQ0_Pos)                  /*!< MAILBOX IRQ1: INTREQ0 Mask            */
#define MAILBOX_IRQ1_INTREQ1_Pos            1                                                       /*!< MAILBOX IRQ1: INTREQ1 Position        */
#define MAILBOX_IRQ1_INTREQ1_Msk            (0x01UL << MAILBOX_IRQ1_INTREQ1_Pos)                  /*!< MAILBOX IRQ1: INTREQ1 Mask            */
#define MAILBOX_IRQ1_INTREQ2_Pos            2                                                       /*!< MAILBOX IRQ1: INTREQ2 Position        */
#define MAILBOX_IRQ1_INTREQ2_Msk            (0x01UL << MAILBOX_IRQ1_INTREQ2_Pos)                  /*!< MAILBOX IRQ1: INTREQ2 Mask            */
#define MAILBOX_IRQ1_INTREQ3_Pos            3                                                       /*!< MAILBOX IRQ1: INTREQ3 Position        */
#define MAILBOX_IRQ1_INTREQ3_Msk            (0x01UL << MAILBOX_IRQ1_INTREQ3_Pos)                  /*!< MAILBOX IRQ1: INTREQ3 Mask            */
#define MAILBOX_IRQ1_INTREQ4_Pos            4                                                       /*!< MAILBOX IRQ1: INTREQ4 Position        */
#define MAILBOX_IRQ1_INTREQ4_Msk            (0x01UL << MAILBOX_IRQ1_INTREQ4_Pos)                  /*!< MAILBOX IRQ1: INTREQ4 Mask            */
#define MAILBOX_IRQ1_INTREQ5_Pos            5                                                       /*!< MAILBOX IRQ1: INTREQ5 Position        */
#define MAILBOX_IRQ1_INTREQ5_Msk            (0x01UL << MAILBOX_IRQ1_INTREQ5_Pos)                  /*!< MAILBOX IRQ1: INTREQ5 Mask            */
#define MAILBOX_IRQ1_INTREQ6_Pos            6                                                       /*!< MAILBOX IRQ1: INTREQ6 Position        */
#define MAILBOX_IRQ1_INTREQ6_Msk            (0x01UL << MAILBOX_IRQ1_INTREQ6_Pos)                  /*!< MAILBOX IRQ1: INTREQ6 Mask            */
#define MAILBOX_IRQ1_INTREQ7_Pos            7                                                       /*!< MAILBOX IRQ1: INTREQ7 Position        */
#define MAILBOX_IRQ1_INTREQ7_Msk            (0x01UL << MAILBOX_IRQ1_INTREQ7_Pos)                  /*!< MAILBOX IRQ1: INTREQ7 Mask            */
#define MAILBOX_IRQ1_INTREQ8_Pos            8                                                       /*!< MAILBOX IRQ1: INTREQ8 Position        */
#define MAILBOX_IRQ1_INTREQ8_Msk            (0x01UL << MAILBOX_IRQ1_INTREQ8_Pos)                  /*!< MAILBOX IRQ1: INTREQ8 Mask            */
#define MAILBOX_IRQ1_INTREQ9_Pos            9                                                       /*!< MAILBOX IRQ1: INTREQ9 Position        */
#define MAILBOX_IRQ1_INTREQ9_Msk            (0x01UL << MAILBOX_IRQ1_INTREQ9_Pos)                  /*!< MAILBOX IRQ1: INTREQ9 Mask            */
#define MAILBOX_IRQ1_INTREQ10_Pos           10                                                      /*!< MAILBOX IRQ1: INTREQ10 Position       */
#define MAILBOX_IRQ1_INTREQ10_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ10_Pos)                 /*!< MAILBOX IRQ1: INTREQ10 Mask           */
#define MAILBOX_IRQ1_INTREQ11_Pos           11                                                      /*!< MAILBOX IRQ1: INTREQ11 Position       */
#define MAILBOX_IRQ1_INTREQ11_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ11_Pos)                 /*!< MAILBOX IRQ1: INTREQ11 Mask           */
#define MAILBOX_IRQ1_INTREQ12_Pos           12                                                      /*!< MAILBOX IRQ1: INTREQ12 Position       */
#define MAILBOX_IRQ1_INTREQ12_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ12_Pos)                 /*!< MAILBOX IRQ1: INTREQ12 Mask           */
#define MAILBOX_IRQ1_INTREQ13_Pos           13                                                      /*!< MAILBOX IRQ1: INTREQ13 Position       */
#define MAILBOX_IRQ1_INTREQ13_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ13_Pos)                 /*!< MAILBOX IRQ1: INTREQ13 Mask           */
#define MAILBOX_IRQ1_INTREQ14_Pos           14                                                      /*!< MAILBOX IRQ1: INTREQ14 Position       */
#define MAILBOX_IRQ1_INTREQ14_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ14_Pos)                 /*!< MAILBOX IRQ1: INTREQ14 Mask           */
#define MAILBOX_IRQ1_INTREQ15_Pos           15                                                      /*!< MAILBOX IRQ1: INTREQ15 Position       */
#define MAILBOX_IRQ1_INTREQ15_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ15_Pos)                 /*!< MAILBOX IRQ1: INTREQ15 Mask           */
#define MAILBOX_IRQ1_INTREQ16_Pos           16                                                      /*!< MAILBOX IRQ1: INTREQ16 Position       */
#define MAILBOX_IRQ1_INTREQ16_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ16_Pos)                 /*!< MAILBOX IRQ1: INTREQ16 Mask           */
#define MAILBOX_IRQ1_INTREQ17_Pos           17                                                      /*!< MAILBOX IRQ1: INTREQ17 Position       */
#define MAILBOX_IRQ1_INTREQ17_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ17_Pos)                 /*!< MAILBOX IRQ1: INTREQ17 Mask           */
#define MAILBOX_IRQ1_INTREQ18_Pos           18                                                      /*!< MAILBOX IRQ1: INTREQ18 Position       */
#define MAILBOX_IRQ1_INTREQ18_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ18_Pos)                 /*!< MAILBOX IRQ1: INTREQ18 Mask           */
#define MAILBOX_IRQ1_INTREQ19_Pos           19                                                      /*!< MAILBOX IRQ1: INTREQ19 Position       */
#define MAILBOX_IRQ1_INTREQ19_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ19_Pos)                 /*!< MAILBOX IRQ1: INTREQ19 Mask           */
#define MAILBOX_IRQ1_INTREQ20_Pos           20                                                      /*!< MAILBOX IRQ1: INTREQ20 Position       */
#define MAILBOX_IRQ1_INTREQ20_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ20_Pos)                 /*!< MAILBOX IRQ1: INTREQ20 Mask           */
#define MAILBOX_IRQ1_INTREQ21_Pos           21                                                      /*!< MAILBOX IRQ1: INTREQ21 Position       */
#define MAILBOX_IRQ1_INTREQ21_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ21_Pos)                 /*!< MAILBOX IRQ1: INTREQ21 Mask           */
#define MAILBOX_IRQ1_INTREQ22_Pos           22                                                      /*!< MAILBOX IRQ1: INTREQ22 Position       */
#define MAILBOX_IRQ1_INTREQ22_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ22_Pos)                 /*!< MAILBOX IRQ1: INTREQ22 Mask           */
#define MAILBOX_IRQ1_INTREQ23_Pos           23                                                      /*!< MAILBOX IRQ1: INTREQ23 Position       */
#define MAILBOX_IRQ1_INTREQ23_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ23_Pos)                 /*!< MAILBOX IRQ1: INTREQ23 Mask           */
#define MAILBOX_IRQ1_INTREQ24_Pos           24                                                      /*!< MAILBOX IRQ1: INTREQ24 Position       */
#define MAILBOX_IRQ1_INTREQ24_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ24_Pos)                 /*!< MAILBOX IRQ1: INTREQ24 Mask           */
#define MAILBOX_IRQ1_INTREQ25_Pos           25                                                      /*!< MAILBOX IRQ1: INTREQ25 Position       */
#define MAILBOX_IRQ1_INTREQ25_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ25_Pos)                 /*!< MAILBOX IRQ1: INTREQ25 Mask           */
#define MAILBOX_IRQ1_INTREQ26_Pos           26                                                      /*!< MAILBOX IRQ1: INTREQ26 Position       */
#define MAILBOX_IRQ1_INTREQ26_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ26_Pos)                 /*!< MAILBOX IRQ1: INTREQ26 Mask           */
#define MAILBOX_IRQ1_INTREQ27_Pos           27                                                      /*!< MAILBOX IRQ1: INTREQ27 Position       */
#define MAILBOX_IRQ1_INTREQ27_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ27_Pos)                 /*!< MAILBOX IRQ1: INTREQ27 Mask           */
#define MAILBOX_IRQ1_INTREQ28_Pos           28                                                      /*!< MAILBOX IRQ1: INTREQ28 Position       */
#define MAILBOX_IRQ1_INTREQ28_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ28_Pos)                 /*!< MAILBOX IRQ1: INTREQ28 Mask           */
#define MAILBOX_IRQ1_INTREQ29_Pos           29                                                      /*!< MAILBOX IRQ1: INTREQ29 Position       */
#define MAILBOX_IRQ1_INTREQ29_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ29_Pos)                 /*!< MAILBOX IRQ1: INTREQ29 Mask           */
#define MAILBOX_IRQ1_INTREQ30_Pos           30                                                      /*!< MAILBOX IRQ1: INTREQ30 Position       */
#define MAILBOX_IRQ1_INTREQ30_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ30_Pos)                 /*!< MAILBOX IRQ1: INTREQ30 Mask           */
#define MAILBOX_IRQ1_INTREQ31_Pos           31                                                      /*!< MAILBOX IRQ1: INTREQ31 Position       */
#define MAILBOX_IRQ1_INTREQ31_Msk           (0x01UL << MAILBOX_IRQ1_INTREQ31_Pos)                 /*!< MAILBOX IRQ1: INTREQ31 Mask           */

/* ------------------------------  u_mailbox_IRQ1SET  ----------------------------- */
#define MAILBOX_IRQ1SET_INTREQSET0_Pos      0                                                       /*!< MAILBOX IRQ1SET: INTREQSET0 Position  */
#define MAILBOX_IRQ1SET_INTREQSET0_Msk      (0x01UL << MAILBOX_IRQ1SET_INTREQSET0_Pos)            /*!< MAILBOX IRQ1SET: INTREQSET0 Mask      */
#define MAILBOX_IRQ1SET_INTREQSET1_Pos      1                                                       /*!< MAILBOX IRQ1SET: INTREQSET1 Position  */
#define MAILBOX_IRQ1SET_INTREQSET1_Msk      (0x01UL << MAILBOX_IRQ1SET_INTREQSET1_Pos)            /*!< MAILBOX IRQ1SET: INTREQSET1 Mask      */
#define MAILBOX_IRQ1SET_INTREQSET2_Pos      2                                                       /*!< MAILBOX IRQ1SET: INTREQSET2 Position  */
#define MAILBOX_IRQ1SET_INTREQSET2_Msk      (0x01UL << MAILBOX_IRQ1SET_INTREQSET2_Pos)            /*!< MAILBOX IRQ1SET: INTREQSET2 Mask      */
#define MAILBOX_IRQ1SET_INTREQSET3_Pos      3                                                       /*!< MAILBOX IRQ1SET: INTREQSET3 Position  */
#define MAILBOX_IRQ1SET_INTREQSET3_Msk      (0x01UL << MAILBOX_IRQ1SET_INTREQSET3_Pos)            /*!< MAILBOX IRQ1SET: INTREQSET3 Mask      */
#define MAILBOX_IRQ1SET_INTREQSET4_Pos      4                                                       /*!< MAILBOX IRQ1SET: INTREQSET4 Position  */
#define MAILBOX_IRQ1SET_INTREQSET4_Msk      (0x01UL << MAILBOX_IRQ1SET_INTREQSET4_Pos)            /*!< MAILBOX IRQ1SET: INTREQSET4 Mask      */
#define MAILBOX_IRQ1SET_INTREQSET5_Pos      5                                                       /*!< MAILBOX IRQ1SET: INTREQSET5 Position  */
#define MAILBOX_IRQ1SET_INTREQSET5_Msk      (0x01UL << MAILBOX_IRQ1SET_INTREQSET5_Pos)            /*!< MAILBOX IRQ1SET: INTREQSET5 Mask      */
#define MAILBOX_IRQ1SET_INTREQSET6_Pos      6                                                       /*!< MAILBOX IRQ1SET: INTREQSET6 Position  */
#define MAILBOX_IRQ1SET_INTREQSET6_Msk      (0x01UL << MAILBOX_IRQ1SET_INTREQSET6_Pos)            /*!< MAILBOX IRQ1SET: INTREQSET6 Mask      */
#define MAILBOX_IRQ1SET_INTREQSET7_Pos      7                                                       /*!< MAILBOX IRQ1SET: INTREQSET7 Position  */
#define MAILBOX_IRQ1SET_INTREQSET7_Msk      (0x01UL << MAILBOX_IRQ1SET_INTREQSET7_Pos)            /*!< MAILBOX IRQ1SET: INTREQSET7 Mask      */
#define MAILBOX_IRQ1SET_INTREQSET8_Pos      8                                                       /*!< MAILBOX IRQ1SET: INTREQSET8 Position  */
#define MAILBOX_IRQ1SET_INTREQSET8_Msk      (0x01UL << MAILBOX_IRQ1SET_INTREQSET8_Pos)            /*!< MAILBOX IRQ1SET: INTREQSET8 Mask      */
#define MAILBOX_IRQ1SET_INTREQSET9_Pos      9                                                       /*!< MAILBOX IRQ1SET: INTREQSET9 Position  */
#define MAILBOX_IRQ1SET_INTREQSET9_Msk      (0x01UL << MAILBOX_IRQ1SET_INTREQSET9_Pos)            /*!< MAILBOX IRQ1SET: INTREQSET9 Mask      */
#define MAILBOX_IRQ1SET_INTREQSET10_Pos     10                                                      /*!< MAILBOX IRQ1SET: INTREQSET10 Position */
#define MAILBOX_IRQ1SET_INTREQSET10_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET10_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET10 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET11_Pos     11                                                      /*!< MAILBOX IRQ1SET: INTREQSET11 Position */
#define MAILBOX_IRQ1SET_INTREQSET11_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET11_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET11 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET12_Pos     12                                                      /*!< MAILBOX IRQ1SET: INTREQSET12 Position */
#define MAILBOX_IRQ1SET_INTREQSET12_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET12_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET12 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET13_Pos     13                                                      /*!< MAILBOX IRQ1SET: INTREQSET13 Position */
#define MAILBOX_IRQ1SET_INTREQSET13_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET13_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET13 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET14_Pos     14                                                      /*!< MAILBOX IRQ1SET: INTREQSET14 Position */
#define MAILBOX_IRQ1SET_INTREQSET14_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET14_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET14 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET15_Pos     15                                                      /*!< MAILBOX IRQ1SET: INTREQSET15 Position */
#define MAILBOX_IRQ1SET_INTREQSET15_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET15_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET15 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET16_Pos     16                                                      /*!< MAILBOX IRQ1SET: INTREQSET16 Position */
#define MAILBOX_IRQ1SET_INTREQSET16_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET16_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET16 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET17_Pos     17                                                      /*!< MAILBOX IRQ1SET: INTREQSET17 Position */
#define MAILBOX_IRQ1SET_INTREQSET17_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET17_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET17 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET18_Pos     18                                                      /*!< MAILBOX IRQ1SET: INTREQSET18 Position */
#define MAILBOX_IRQ1SET_INTREQSET18_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET18_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET18 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET19_Pos     19                                                      /*!< MAILBOX IRQ1SET: INTREQSET19 Position */
#define MAILBOX_IRQ1SET_INTREQSET19_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET19_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET19 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET20_Pos     20                                                      /*!< MAILBOX IRQ1SET: INTREQSET20 Position */
#define MAILBOX_IRQ1SET_INTREQSET20_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET20_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET20 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET21_Pos     21                                                      /*!< MAILBOX IRQ1SET: INTREQSET21 Position */
#define MAILBOX_IRQ1SET_INTREQSET21_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET21_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET21 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET22_Pos     22                                                      /*!< MAILBOX IRQ1SET: INTREQSET22 Position */
#define MAILBOX_IRQ1SET_INTREQSET22_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET22_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET22 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET23_Pos     23                                                      /*!< MAILBOX IRQ1SET: INTREQSET23 Position */
#define MAILBOX_IRQ1SET_INTREQSET23_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET23_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET23 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET24_Pos     24                                                      /*!< MAILBOX IRQ1SET: INTREQSET24 Position */
#define MAILBOX_IRQ1SET_INTREQSET24_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET24_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET24 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET25_Pos     25                                                      /*!< MAILBOX IRQ1SET: INTREQSET25 Position */
#define MAILBOX_IRQ1SET_INTREQSET25_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET25_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET25 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET26_Pos     26                                                      /*!< MAILBOX IRQ1SET: INTREQSET26 Position */
#define MAILBOX_IRQ1SET_INTREQSET26_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET26_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET26 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET27_Pos     27                                                      /*!< MAILBOX IRQ1SET: INTREQSET27 Position */
#define MAILBOX_IRQ1SET_INTREQSET27_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET27_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET27 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET28_Pos     28                                                      /*!< MAILBOX IRQ1SET: INTREQSET28 Position */
#define MAILBOX_IRQ1SET_INTREQSET28_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET28_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET28 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET29_Pos     29                                                      /*!< MAILBOX IRQ1SET: INTREQSET29 Position */
#define MAILBOX_IRQ1SET_INTREQSET29_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET29_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET29 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET30_Pos     30                                                      /*!< MAILBOX IRQ1SET: INTREQSET30 Position */
#define MAILBOX_IRQ1SET_INTREQSET30_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET30_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET30 Mask     */
#define MAILBOX_IRQ1SET_INTREQSET31_Pos     31                                                      /*!< MAILBOX IRQ1SET: INTREQSET31 Position */
#define MAILBOX_IRQ1SET_INTREQSET31_Msk     (0x01UL << MAILBOX_IRQ1SET_INTREQSET31_Pos)           /*!< MAILBOX IRQ1SET: INTREQSET31 Mask     */

/* ------------------------------  u_mailbox_IRQ1CLR  ----------------------------- */
#define MAILBOX_IRQ1CLR_INTREQCLR0_Pos      0                                                       /*!< MAILBOX IRQ1CLR: INTREQCLR0 Position  */
#define MAILBOX_IRQ1CLR_INTREQCLR0_Msk      (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR0_Pos)            /*!< MAILBOX IRQ1CLR: INTREQCLR0 Mask      */
#define MAILBOX_IRQ1CLR_INTREQCLR1_Pos      1                                                       /*!< MAILBOX IRQ1CLR: INTREQCLR1 Position  */
#define MAILBOX_IRQ1CLR_INTREQCLR1_Msk      (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR1_Pos)            /*!< MAILBOX IRQ1CLR: INTREQCLR1 Mask      */
#define MAILBOX_IRQ1CLR_INTREQCLR2_Pos      2                                                       /*!< MAILBOX IRQ1CLR: INTREQCLR2 Position  */
#define MAILBOX_IRQ1CLR_INTREQCLR2_Msk      (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR2_Pos)            /*!< MAILBOX IRQ1CLR: INTREQCLR2 Mask      */
#define MAILBOX_IRQ1CLR_INTREQCLR3_Pos      3                                                       /*!< MAILBOX IRQ1CLR: INTREQCLR3 Position  */
#define MAILBOX_IRQ1CLR_INTREQCLR3_Msk      (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR3_Pos)            /*!< MAILBOX IRQ1CLR: INTREQCLR3 Mask      */
#define MAILBOX_IRQ1CLR_INTREQCLR4_Pos      4                                                       /*!< MAILBOX IRQ1CLR: INTREQCLR4 Position  */
#define MAILBOX_IRQ1CLR_INTREQCLR4_Msk      (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR4_Pos)            /*!< MAILBOX IRQ1CLR: INTREQCLR4 Mask      */
#define MAILBOX_IRQ1CLR_INTREQCLR5_Pos      5                                                       /*!< MAILBOX IRQ1CLR: INTREQCLR5 Position  */
#define MAILBOX_IRQ1CLR_INTREQCLR5_Msk      (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR5_Pos)            /*!< MAILBOX IRQ1CLR: INTREQCLR5 Mask      */
#define MAILBOX_IRQ1CLR_INTREQCLR6_Pos      6                                                       /*!< MAILBOX IRQ1CLR: INTREQCLR6 Position  */
#define MAILBOX_IRQ1CLR_INTREQCLR6_Msk      (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR6_Pos)            /*!< MAILBOX IRQ1CLR: INTREQCLR6 Mask      */
#define MAILBOX_IRQ1CLR_INTREQCLR7_Pos      7                                                       /*!< MAILBOX IRQ1CLR: INTREQCLR7 Position  */
#define MAILBOX_IRQ1CLR_INTREQCLR7_Msk      (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR7_Pos)            /*!< MAILBOX IRQ1CLR: INTREQCLR7 Mask      */
#define MAILBOX_IRQ1CLR_INTREQCLR8_Pos      8                                                       /*!< MAILBOX IRQ1CLR: INTREQCLR8 Position  */
#define MAILBOX_IRQ1CLR_INTREQCLR8_Msk      (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR8_Pos)            /*!< MAILBOX IRQ1CLR: INTREQCLR8 Mask      */
#define MAILBOX_IRQ1CLR_INTREQCLR9_Pos      9                                                       /*!< MAILBOX IRQ1CLR: INTREQCLR9 Position  */
#define MAILBOX_IRQ1CLR_INTREQCLR9_Msk      (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR9_Pos)            /*!< MAILBOX IRQ1CLR: INTREQCLR9 Mask      */
#define MAILBOX_IRQ1CLR_INTREQCLR10_Pos     10                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR10 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR10_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR10_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR10 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR11_Pos     11                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR11 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR11_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR11_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR11 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR12_Pos     12                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR12 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR12_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR12_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR12 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR13_Pos     13                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR13 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR13_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR13_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR13 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR14_Pos     14                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR14 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR14_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR14_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR14 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR15_Pos     15                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR15 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR15_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR15_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR15 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR16_Pos     16                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR16 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR16_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR16_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR16 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR17_Pos     17                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR17 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR17_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR17_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR17 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR18_Pos     18                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR18 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR18_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR18_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR18 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR19_Pos     19                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR19 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR19_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR19_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR19 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR20_Pos     20                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR20 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR20_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR20_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR20 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR21_Pos     21                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR21 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR21_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR21_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR21 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR22_Pos     22                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR22 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR22_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR22_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR22 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR23_Pos     23                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR23 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR23_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR23_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR23 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR24_Pos     24                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR24 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR24_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR24_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR24 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR25_Pos     25                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR25 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR25_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR25_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR25 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR26_Pos     26                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR26 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR26_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR26_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR26 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR27_Pos     27                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR27 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR27_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR27_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR27 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR28_Pos     28                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR28 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR28_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR28_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR28 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR29_Pos     29                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR29 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR29_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR29_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR29 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR30_Pos     30                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR30 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR30_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR30_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR30 Mask     */
#define MAILBOX_IRQ1CLR_INTREQCLR31_Pos     31                                                      /*!< MAILBOX IRQ1CLR: INTREQCLR31 Position */
#define MAILBOX_IRQ1CLR_INTREQCLR31_Msk     (0x01UL << MAILBOX_IRQ1CLR_INTREQCLR31_Pos)           /*!< MAILBOX IRQ1CLR: INTREQCLR31 Mask     */

/* -------------------------------  u_mailbox_MUTEX  ------------------------------ */
#define MAILBOX_MUTEX_EX_Pos                0                                                       /*!< MAILBOX MUTEX: EX Position            */
#define MAILBOX_MUTEX_EX_Msk                (0x01UL << MAILBOX_MUTEX_EX_Pos)                      /*!< MAILBOX MUTEX: EX Mask                */


/* ================================================================================ */
/* ================         struct 'u_adc' Position & Mask         ================ */
/* ================================================================================ */


/* ---------------------------------  u_adc_CTRL  --------------------------------- */
#define ADC_CTRL_CLKDIV_Pos                 0                                                       /*!< ADC CTRL: CLKDIV Position             */
#define ADC_CTRL_CLKDIV_Msk                 (0x000000ffUL << ADC_CTRL_CLKDIV_Pos)                 /*!< ADC CTRL: CLKDIV Mask                 */
#define ADC_CTRL_ASYNMODE_Pos               8                                                       /*!< ADC CTRL: ASYNMODE Position           */
#define ADC_CTRL_ASYNMODE_Msk               (0x01UL << ADC_CTRL_ASYNMODE_Pos)                     /*!< ADC CTRL: ASYNMODE Mask               */
#define ADC_CTRL_RESOL_Pos                  9                                                       /*!< ADC CTRL: RESOL Position              */
#define ADC_CTRL_RESOL_Msk                  (0x03UL << ADC_CTRL_RESOL_Pos)                        /*!< ADC CTRL: RESOL Mask                  */
#define ADC_CTRL_RESOL_MASK_DIS_Pos         11                                                      /*!< ADC CTRL: RESOL_MASK_DIS Position     */
#define ADC_CTRL_RESOL_MASK_DIS_Msk         (0x01UL << ADC_CTRL_RESOL_MASK_DIS_Pos)               /*!< ADC CTRL: RESOL_MASK_DIS Mask         */
#define ADC_CTRL_TSAMP_Pos                  12                                                      /*!< ADC CTRL: TSAMP Position              */
#define ADC_CTRL_TSAMP_Msk                  (0x07UL << ADC_CTRL_TSAMP_Pos)                        /*!< ADC CTRL: TSAMP Mask                  */

/* ---------------------------------  u_adc_INSEL  -------------------------------- */
#define ADC_INSEL_INSEL_Pos                 0                                                       /*!< ADC INSEL: INSEL Position             */
#define ADC_INSEL_INSEL_Msk                 (0xffffffffUL << ADC_INSEL_INSEL_Pos)                 /*!< ADC INSEL: INSEL Mask                 */

/* -------------------------------  u_adc_SEQA_CTRL  ------------------------------ */
#define ADC_SEQA_CTRL_CHANNELS_Pos          0                                                       /*!< ADC SEQA_CTRL: CHANNELS Position      */
#define ADC_SEQA_CTRL_CHANNELS_Msk          (0x000000ffUL << ADC_SEQA_CTRL_CHANNELS_Pos)          /*!< ADC SEQA_CTRL: CHANNELS Mask          */
#define ADC_SEQA_CTRL_TRIGGER_Pos           12                                                      /*!< ADC SEQA_CTRL: TRIGGER Position       */
#define ADC_SEQA_CTRL_TRIGGER_Msk           (0x3fUL << ADC_SEQA_CTRL_TRIGGER_Pos)                 /*!< ADC SEQA_CTRL: TRIGGER Mask           */
#define ADC_SEQA_CTRL_TRIGPOL_Pos           18                                                      /*!< ADC SEQA_CTRL: TRIGPOL Position       */
#define ADC_SEQA_CTRL_TRIGPOL_Msk           (0x01UL << ADC_SEQA_CTRL_TRIGPOL_Pos)                 /*!< ADC SEQA_CTRL: TRIGPOL Mask           */
#define ADC_SEQA_CTRL_SYNCBYPASS_Pos        19                                                      /*!< ADC SEQA_CTRL: SYNCBYPASS Position    */
#define ADC_SEQA_CTRL_SYNCBYPASS_Msk        (0x01UL << ADC_SEQA_CTRL_SYNCBYPASS_Pos)              /*!< ADC SEQA_CTRL: SYNCBYPASS Mask        */
#define ADC_SEQA_CTRL_START_BEHAVIOUR_Pos   25                                                      /*!< ADC SEQA_CTRL: START_BEHAVIOUR Position */
#define ADC_SEQA_CTRL_START_BEHAVIOUR_Msk   (0x01UL << ADC_SEQA_CTRL_START_BEHAVIOUR_Pos)         /*!< ADC SEQA_CTRL: START_BEHAVIOUR Mask   */
#define ADC_SEQA_CTRL_START_Pos             26                                                      /*!< ADC SEQA_CTRL: START Position         */
#define ADC_SEQA_CTRL_START_Msk             (0x01UL << ADC_SEQA_CTRL_START_Pos)                   /*!< ADC SEQA_CTRL: START Mask             */
#define ADC_SEQA_CTRL_BURST_Pos             27                                                      /*!< ADC SEQA_CTRL: BURST Position         */
#define ADC_SEQA_CTRL_BURST_Msk             (0x01UL << ADC_SEQA_CTRL_BURST_Pos)                   /*!< ADC SEQA_CTRL: BURST Mask             */
#define ADC_SEQA_CTRL_SINGLESTEP_Pos        28                                                      /*!< ADC SEQA_CTRL: SINGLESTEP Position    */
#define ADC_SEQA_CTRL_SINGLESTEP_Msk        (0x01UL << ADC_SEQA_CTRL_SINGLESTEP_Pos)              /*!< ADC SEQA_CTRL: SINGLESTEP Mask        */
#define ADC_SEQA_CTRL_LOWPRIO_Pos           29                                                      /*!< ADC SEQA_CTRL: LOWPRIO Position       */
#define ADC_SEQA_CTRL_LOWPRIO_Msk           (0x01UL << ADC_SEQA_CTRL_LOWPRIO_Pos)                 /*!< ADC SEQA_CTRL: LOWPRIO Mask           */
#define ADC_SEQA_CTRL_MODE_Pos              30                                                      /*!< ADC SEQA_CTRL: MODE Position          */
#define ADC_SEQA_CTRL_MODE_Msk              (0x01UL << ADC_SEQA_CTRL_MODE_Pos)                    /*!< ADC SEQA_CTRL: MODE Mask              */
#define ADC_SEQA_CTRL_SEQA_ENA_Pos          31                                                      /*!< ADC SEQA_CTRL: SEQA_ENA Position      */
#define ADC_SEQA_CTRL_SEQA_ENA_Msk          (0x01UL << ADC_SEQA_CTRL_SEQA_ENA_Pos)                /*!< ADC SEQA_CTRL: SEQA_ENA Mask          */

/* -------------------------------  u_adc_SEQB_CTRL  ------------------------------ */
#define ADC_SEQB_CTRL_CHANNELS_Pos          0                                                       /*!< ADC SEQB_CTRL: CHANNELS Position      */
#define ADC_SEQB_CTRL_CHANNELS_Msk          (0x000000ffUL << ADC_SEQB_CTRL_CHANNELS_Pos)          /*!< ADC SEQB_CTRL: CHANNELS Mask          */
#define ADC_SEQB_CTRL_TRIGGER_Pos           12                                                      /*!< ADC SEQB_CTRL: TRIGGER Position       */
#define ADC_SEQB_CTRL_TRIGGER_Msk           (0x3fUL << ADC_SEQB_CTRL_TRIGGER_Pos)                 /*!< ADC SEQB_CTRL: TRIGGER Mask           */
#define ADC_SEQB_CTRL_TRIGPOL_Pos           18                                                      /*!< ADC SEQB_CTRL: TRIGPOL Position       */
#define ADC_SEQB_CTRL_TRIGPOL_Msk           (0x01UL << ADC_SEQB_CTRL_TRIGPOL_Pos)                 /*!< ADC SEQB_CTRL: TRIGPOL Mask           */
#define ADC_SEQB_CTRL_SYNCBYPASS_Pos        19                                                      /*!< ADC SEQB_CTRL: SYNCBYPASS Position    */
#define ADC_SEQB_CTRL_SYNCBYPASS_Msk        (0x01UL << ADC_SEQB_CTRL_SYNCBYPASS_Pos)              /*!< ADC SEQB_CTRL: SYNCBYPASS Mask        */
#define ADC_SEQB_CTRL_START_BEHAVIOUR_Pos   25                                                      /*!< ADC SEQB_CTRL: START_BEHAVIOUR Position */
#define ADC_SEQB_CTRL_START_BEHAVIOUR_Msk   (0x01UL << ADC_SEQB_CTRL_START_BEHAVIOUR_Pos)         /*!< ADC SEQB_CTRL: START_BEHAVIOUR Mask   */
#define ADC_SEQB_CTRL_START_Pos             26                                                      /*!< ADC SEQB_CTRL: START Position         */
#define ADC_SEQB_CTRL_START_Msk             (0x01UL << ADC_SEQB_CTRL_START_Pos)                   /*!< ADC SEQB_CTRL: START Mask             */
#define ADC_SEQB_CTRL_BURST_Pos             27                                                      /*!< ADC SEQB_CTRL: BURST Position         */
#define ADC_SEQB_CTRL_BURST_Msk             (0x01UL << ADC_SEQB_CTRL_BURST_Pos)                   /*!< ADC SEQB_CTRL: BURST Mask             */
#define ADC_SEQB_CTRL_SINGLESTEP_Pos        28                                                      /*!< ADC SEQB_CTRL: SINGLESTEP Position    */
#define ADC_SEQB_CTRL_SINGLESTEP_Msk        (0x01UL << ADC_SEQB_CTRL_SINGLESTEP_Pos)              /*!< ADC SEQB_CTRL: SINGLESTEP Mask        */
#define ADC_SEQB_CTRL_MODE_Pos              30                                                      /*!< ADC SEQB_CTRL: MODE Position          */
#define ADC_SEQB_CTRL_MODE_Msk              (0x01UL << ADC_SEQB_CTRL_MODE_Pos)                    /*!< ADC SEQB_CTRL: MODE Mask              */
#define ADC_SEQB_CTRL_SEQB_ENA_Pos          31                                                      /*!< ADC SEQB_CTRL: SEQB_ENA Position      */
#define ADC_SEQB_CTRL_SEQB_ENA_Msk          (0x01UL << ADC_SEQB_CTRL_SEQB_ENA_Pos)                /*!< ADC SEQB_CTRL: SEQB_ENA Mask          */

/* -------------------------------  u_adc_SEQA_GDAT  ------------------------------ */
#define ADC_SEQA_GDAT_RESULT_Pos            4                                                       /*!< ADC SEQA_GDAT: RESULT Position        */
#define ADC_SEQA_GDAT_RESULT_Msk            (0x00000fffUL << ADC_SEQA_GDAT_RESULT_Pos)            /*!< ADC SEQA_GDAT: RESULT Mask            */
#define ADC_SEQA_GDAT_THCMPRANGE_Pos        16                                                      /*!< ADC SEQA_GDAT: THCMPRANGE Position    */
#define ADC_SEQA_GDAT_THCMPRANGE_Msk        (0x03UL << ADC_SEQA_GDAT_THCMPRANGE_Pos)              /*!< ADC SEQA_GDAT: THCMPRANGE Mask        */
#define ADC_SEQA_GDAT_THCMPCROSS_Pos        18                                                      /*!< ADC SEQA_GDAT: THCMPCROSS Position    */
#define ADC_SEQA_GDAT_THCMPCROSS_Msk        (0x03UL << ADC_SEQA_GDAT_THCMPCROSS_Pos)              /*!< ADC SEQA_GDAT: THCMPCROSS Mask        */
#define ADC_SEQA_GDAT_CHN_Pos               26                                                      /*!< ADC SEQA_GDAT: CHN Position           */
#define ADC_SEQA_GDAT_CHN_Msk               (0x0fUL << ADC_SEQA_GDAT_CHN_Pos)                     /*!< ADC SEQA_GDAT: CHN Mask               */
#define ADC_SEQA_GDAT_OVERRUN_Pos           30                                                      /*!< ADC SEQA_GDAT: OVERRUN Position       */
#define ADC_SEQA_GDAT_OVERRUN_Msk           (0x01UL << ADC_SEQA_GDAT_OVERRUN_Pos)                 /*!< ADC SEQA_GDAT: OVERRUN Mask           */
#define ADC_SEQA_GDAT_DATAVALID_Pos         31                                                      /*!< ADC SEQA_GDAT: DATAVALID Position     */
#define ADC_SEQA_GDAT_DATAVALID_Msk         (0x01UL << ADC_SEQA_GDAT_DATAVALID_Pos)               /*!< ADC SEQA_GDAT: DATAVALID Mask         */

/* -------------------------------  u_adc_SEQB_GDAT  ------------------------------ */
#define ADC_SEQB_GDAT_RESULT_Pos            4                                                       /*!< ADC SEQB_GDAT: RESULT Position        */
#define ADC_SEQB_GDAT_RESULT_Msk            (0x00000fffUL << ADC_SEQB_GDAT_RESULT_Pos)            /*!< ADC SEQB_GDAT: RESULT Mask            */
#define ADC_SEQB_GDAT_THCMPRANGE_Pos        16                                                      /*!< ADC SEQB_GDAT: THCMPRANGE Position    */
#define ADC_SEQB_GDAT_THCMPRANGE_Msk        (0x03UL << ADC_SEQB_GDAT_THCMPRANGE_Pos)              /*!< ADC SEQB_GDAT: THCMPRANGE Mask        */
#define ADC_SEQB_GDAT_THCMPCROSS_Pos        18                                                      /*!< ADC SEQB_GDAT: THCMPCROSS Position    */
#define ADC_SEQB_GDAT_THCMPCROSS_Msk        (0x03UL << ADC_SEQB_GDAT_THCMPCROSS_Pos)              /*!< ADC SEQB_GDAT: THCMPCROSS Mask        */
#define ADC_SEQB_GDAT_CHN_Pos               26                                                      /*!< ADC SEQB_GDAT: CHN Position           */
#define ADC_SEQB_GDAT_CHN_Msk               (0x0fUL << ADC_SEQB_GDAT_CHN_Pos)                     /*!< ADC SEQB_GDAT: CHN Mask               */
#define ADC_SEQB_GDAT_OVERRUN_Pos           30                                                      /*!< ADC SEQB_GDAT: OVERRUN Position       */
#define ADC_SEQB_GDAT_OVERRUN_Msk           (0x01UL << ADC_SEQB_GDAT_OVERRUN_Pos)                 /*!< ADC SEQB_GDAT: OVERRUN Mask           */
#define ADC_SEQB_GDAT_DATAVALID_Pos         31                                                      /*!< ADC SEQB_GDAT: DATAVALID Position     */
#define ADC_SEQB_GDAT_DATAVALID_Msk         (0x01UL << ADC_SEQB_GDAT_DATAVALID_Pos)               /*!< ADC SEQB_GDAT: DATAVALID Mask         */

/* ----------------------------------  u_adc_DAT  --------------------------------- */
#define ADC_DAT_RESULT_Pos                  4                                                       /*!< ADC DAT: RESULT Position              */
#define ADC_DAT_RESULT_Msk                  (0x00000fffUL << ADC_DAT_RESULT_Pos)                  /*!< ADC DAT: RESULT Mask                  */
#define ADC_DAT_THCMPRANGE_Pos              16                                                      /*!< ADC DAT: THCMPRANGE Position          */
#define ADC_DAT_THCMPRANGE_Msk              (0x03UL << ADC_DAT_THCMPRANGE_Pos)                    /*!< ADC DAT: THCMPRANGE Mask              */
#define ADC_DAT_THCMPCROSS_Pos              18                                                      /*!< ADC DAT: THCMPCROSS Position          */
#define ADC_DAT_THCMPCROSS_Msk              (0x03UL << ADC_DAT_THCMPCROSS_Pos)                    /*!< ADC DAT: THCMPCROSS Mask              */
#define ADC_DAT_CHN_Pos                     26                                                      /*!< ADC DAT: CHN Position                 */
#define ADC_DAT_CHN_Msk                     (0x0fUL << ADC_DAT_CHN_Pos)                           /*!< ADC DAT: CHN Mask                     */
#define ADC_DAT_OVERRUN_Pos                 30                                                      /*!< ADC DAT: OVERRUN Position             */
#define ADC_DAT_OVERRUN_Msk                 (0x01UL << ADC_DAT_OVERRUN_Pos)                       /*!< ADC DAT: OVERRUN Mask                 */
#define ADC_DAT_DATAVALID_Pos               31                                                      /*!< ADC DAT: DATAVALID Position           */
#define ADC_DAT_DATAVALID_Msk               (0x01UL << ADC_DAT_DATAVALID_Pos)                     /*!< ADC DAT: DATAVALID Mask               */

/* -------------------------------  u_adc_THR0_LOW  ------------------------------- */
#define ADC_THR0_LOW_THRLOW_Pos             4                                                       /*!< ADC THR0_LOW: THRLOW Position         */
#define ADC_THR0_LOW_THRLOW_Msk             (0x00000fffUL << ADC_THR0_LOW_THRLOW_Pos)             /*!< ADC THR0_LOW: THRLOW Mask             */

/* -------------------------------  u_adc_THR1_LOW  ------------------------------- */
#define ADC_THR1_LOW_THRLOW_Pos             4                                                       /*!< ADC THR1_LOW: THRLOW Position         */
#define ADC_THR1_LOW_THRLOW_Msk             (0x00000fffUL << ADC_THR1_LOW_THRLOW_Pos)             /*!< ADC THR1_LOW: THRLOW Mask             */

/* -------------------------------  u_adc_THR0_HIGH  ------------------------------ */
#define ADC_THR0_HIGH_THRHIGH_Pos           4                                                       /*!< ADC THR0_HIGH: THRHIGH Position       */
#define ADC_THR0_HIGH_THRHIGH_Msk           (0x00000fffUL << ADC_THR0_HIGH_THRHIGH_Pos)           /*!< ADC THR0_HIGH: THRHIGH Mask           */

/* -------------------------------  u_adc_THR1_HIGH  ------------------------------ */
#define ADC_THR1_HIGH_THRHIGH_Pos           4                                                       /*!< ADC THR1_HIGH: THRHIGH Position       */
#define ADC_THR1_HIGH_THRHIGH_Msk           (0x00000fffUL << ADC_THR1_HIGH_THRHIGH_Pos)           /*!< ADC THR1_HIGH: THRHIGH Mask           */

/* ------------------------------  u_adc_CHAN_THRSEL  ----------------------------- */
#define ADC_CHAN_THRSEL_CH0_THRSEL_Pos      0                                                       /*!< ADC CHAN_THRSEL: CH0_THRSEL Position  */
#define ADC_CHAN_THRSEL_CH0_THRSEL_Msk      (0x01UL << ADC_CHAN_THRSEL_CH0_THRSEL_Pos)            /*!< ADC CHAN_THRSEL: CH0_THRSEL Mask      */
#define ADC_CHAN_THRSEL_CH1_THRSEL_Pos      1                                                       /*!< ADC CHAN_THRSEL: CH1_THRSEL Position  */
#define ADC_CHAN_THRSEL_CH1_THRSEL_Msk      (0x01UL << ADC_CHAN_THRSEL_CH1_THRSEL_Pos)            /*!< ADC CHAN_THRSEL: CH1_THRSEL Mask      */
#define ADC_CHAN_THRSEL_CH2_THRSEL_Pos      2                                                       /*!< ADC CHAN_THRSEL: CH2_THRSEL Position  */
#define ADC_CHAN_THRSEL_CH2_THRSEL_Msk      (0x01UL << ADC_CHAN_THRSEL_CH2_THRSEL_Pos)            /*!< ADC CHAN_THRSEL: CH2_THRSEL Mask      */
#define ADC_CHAN_THRSEL_CH3_THRSEL_Pos      3                                                       /*!< ADC CHAN_THRSEL: CH3_THRSEL Position  */
#define ADC_CHAN_THRSEL_CH3_THRSEL_Msk      (0x01UL << ADC_CHAN_THRSEL_CH3_THRSEL_Pos)            /*!< ADC CHAN_THRSEL: CH3_THRSEL Mask      */
#define ADC_CHAN_THRSEL_CH4_THRSEL_Pos      4                                                       /*!< ADC CHAN_THRSEL: CH4_THRSEL Position  */
#define ADC_CHAN_THRSEL_CH4_THRSEL_Msk      (0x01UL << ADC_CHAN_THRSEL_CH4_THRSEL_Pos)            /*!< ADC CHAN_THRSEL: CH4_THRSEL Mask      */
#define ADC_CHAN_THRSEL_CH5_THRSEL_Pos      5                                                       /*!< ADC CHAN_THRSEL: CH5_THRSEL Position  */
#define ADC_CHAN_THRSEL_CH5_THRSEL_Msk      (0x01UL << ADC_CHAN_THRSEL_CH5_THRSEL_Pos)            /*!< ADC CHAN_THRSEL: CH5_THRSEL Mask      */
#define ADC_CHAN_THRSEL_CH6_THRSEL_Pos      6                                                       /*!< ADC CHAN_THRSEL: CH6_THRSEL Position  */
#define ADC_CHAN_THRSEL_CH6_THRSEL_Msk      (0x01UL << ADC_CHAN_THRSEL_CH6_THRSEL_Pos)            /*!< ADC CHAN_THRSEL: CH6_THRSEL Mask      */
#define ADC_CHAN_THRSEL_CH7_THRSEL_Pos      7                                                       /*!< ADC CHAN_THRSEL: CH7_THRSEL Position  */
#define ADC_CHAN_THRSEL_CH7_THRSEL_Msk      (0x01UL << ADC_CHAN_THRSEL_CH7_THRSEL_Pos)            /*!< ADC CHAN_THRSEL: CH7_THRSEL Mask      */

/* ---------------------------------  u_adc_INTEN  -------------------------------- */
#define ADC_INTEN_SEQA_INTEN_Pos            0                                                       /*!< ADC INTEN: SEQA_INTEN Position        */
#define ADC_INTEN_SEQA_INTEN_Msk            (0x01UL << ADC_INTEN_SEQA_INTEN_Pos)                  /*!< ADC INTEN: SEQA_INTEN Mask            */
#define ADC_INTEN_SEQB_INTEN_Pos            1                                                       /*!< ADC INTEN: SEQB_INTEN Position        */
#define ADC_INTEN_SEQB_INTEN_Msk            (0x01UL << ADC_INTEN_SEQB_INTEN_Pos)                  /*!< ADC INTEN: SEQB_INTEN Mask            */
#define ADC_INTEN_OVR_INTEN_Pos             2                                                       /*!< ADC INTEN: OVR_INTEN Position         */
#define ADC_INTEN_OVR_INTEN_Msk             (0x01UL << ADC_INTEN_OVR_INTEN_Pos)                   /*!< ADC INTEN: OVR_INTEN Mask             */
#define ADC_INTEN_ADCMPINTEN0_Pos           3                                                       /*!< ADC INTEN: ADCMPINTEN0 Position       */
#define ADC_INTEN_ADCMPINTEN0_Msk           (0x03UL << ADC_INTEN_ADCMPINTEN0_Pos)                 /*!< ADC INTEN: ADCMPINTEN0 Mask           */
#define ADC_INTEN_ADCMPINTEN1_Pos           5                                                       /*!< ADC INTEN: ADCMPINTEN1 Position       */
#define ADC_INTEN_ADCMPINTEN1_Msk           (0x03UL << ADC_INTEN_ADCMPINTEN1_Pos)                 /*!< ADC INTEN: ADCMPINTEN1 Mask           */
#define ADC_INTEN_ADCMPINTEN2_Pos           7                                                       /*!< ADC INTEN: ADCMPINTEN2 Position       */
#define ADC_INTEN_ADCMPINTEN2_Msk           (0x03UL << ADC_INTEN_ADCMPINTEN2_Pos)                 /*!< ADC INTEN: ADCMPINTEN2 Mask           */
#define ADC_INTEN_ADCMPINTEN3_Pos           9                                                       /*!< ADC INTEN: ADCMPINTEN3 Position       */
#define ADC_INTEN_ADCMPINTEN3_Msk           (0x03UL << ADC_INTEN_ADCMPINTEN3_Pos)                 /*!< ADC INTEN: ADCMPINTEN3 Mask           */
#define ADC_INTEN_ADCMPINTEN4_Pos           11                                                      /*!< ADC INTEN: ADCMPINTEN4 Position       */
#define ADC_INTEN_ADCMPINTEN4_Msk           (0x03UL << ADC_INTEN_ADCMPINTEN4_Pos)                 /*!< ADC INTEN: ADCMPINTEN4 Mask           */
#define ADC_INTEN_ADCMPINTEN5_Pos           13                                                      /*!< ADC INTEN: ADCMPINTEN5 Position       */
#define ADC_INTEN_ADCMPINTEN5_Msk           (0x03UL << ADC_INTEN_ADCMPINTEN5_Pos)                 /*!< ADC INTEN: ADCMPINTEN5 Mask           */
#define ADC_INTEN_ADCMPINTEN6_Pos           15                                                      /*!< ADC INTEN: ADCMPINTEN6 Position       */
#define ADC_INTEN_ADCMPINTEN6_Msk           (0x03UL << ADC_INTEN_ADCMPINTEN6_Pos)                 /*!< ADC INTEN: ADCMPINTEN6 Mask           */
#define ADC_INTEN_ADCMPINTEN7_Pos           17                                                      /*!< ADC INTEN: ADCMPINTEN7 Position       */
#define ADC_INTEN_ADCMPINTEN7_Msk           (0x03UL << ADC_INTEN_ADCMPINTEN7_Pos)                 /*!< ADC INTEN: ADCMPINTEN7 Mask           */

/* ---------------------------------  u_adc_FLAGS  -------------------------------- */
#define ADC_FLAGS_THCMP0_Pos                0                                                       /*!< ADC FLAGS: THCMP0 Position            */
#define ADC_FLAGS_THCMP0_Msk                (0x01UL << ADC_FLAGS_THCMP0_Pos)                      /*!< ADC FLAGS: THCMP0 Mask                */
#define ADC_FLAGS_THCMP1_Pos                1                                                       /*!< ADC FLAGS: THCMP1 Position            */
#define ADC_FLAGS_THCMP1_Msk                (0x01UL << ADC_FLAGS_THCMP1_Pos)                      /*!< ADC FLAGS: THCMP1 Mask                */
#define ADC_FLAGS_THCMP2_Pos                2                                                       /*!< ADC FLAGS: THCMP2 Position            */
#define ADC_FLAGS_THCMP2_Msk                (0x01UL << ADC_FLAGS_THCMP2_Pos)                      /*!< ADC FLAGS: THCMP2 Mask                */
#define ADC_FLAGS_THCMP3_Pos                3                                                       /*!< ADC FLAGS: THCMP3 Position            */
#define ADC_FLAGS_THCMP3_Msk                (0x01UL << ADC_FLAGS_THCMP3_Pos)                      /*!< ADC FLAGS: THCMP3 Mask                */
#define ADC_FLAGS_THCMP4_Pos                4                                                       /*!< ADC FLAGS: THCMP4 Position            */
#define ADC_FLAGS_THCMP4_Msk                (0x01UL << ADC_FLAGS_THCMP4_Pos)                      /*!< ADC FLAGS: THCMP4 Mask                */
#define ADC_FLAGS_THCMP5_Pos                5                                                       /*!< ADC FLAGS: THCMP5 Position            */
#define ADC_FLAGS_THCMP5_Msk                (0x01UL << ADC_FLAGS_THCMP5_Pos)                      /*!< ADC FLAGS: THCMP5 Mask                */
#define ADC_FLAGS_THCMP6_Pos                6                                                       /*!< ADC FLAGS: THCMP6 Position            */
#define ADC_FLAGS_THCMP6_Msk                (0x01UL << ADC_FLAGS_THCMP6_Pos)                      /*!< ADC FLAGS: THCMP6 Mask                */
#define ADC_FLAGS_THCMP7_Pos                7                                                       /*!< ADC FLAGS: THCMP7 Position            */
#define ADC_FLAGS_THCMP7_Msk                (0x01UL << ADC_FLAGS_THCMP7_Pos)                      /*!< ADC FLAGS: THCMP7 Mask                */
#define ADC_FLAGS_OVERRUN0_Pos              12                                                      /*!< ADC FLAGS: OVERRUN0 Position          */
#define ADC_FLAGS_OVERRUN0_Msk              (0x01UL << ADC_FLAGS_OVERRUN0_Pos)                    /*!< ADC FLAGS: OVERRUN0 Mask              */
#define ADC_FLAGS_OVERRUN1_Pos              13                                                      /*!< ADC FLAGS: OVERRUN1 Position          */
#define ADC_FLAGS_OVERRUN1_Msk              (0x01UL << ADC_FLAGS_OVERRUN1_Pos)                    /*!< ADC FLAGS: OVERRUN1 Mask              */
#define ADC_FLAGS_OVERRUN2_Pos              14                                                      /*!< ADC FLAGS: OVERRUN2 Position          */
#define ADC_FLAGS_OVERRUN2_Msk              (0x01UL << ADC_FLAGS_OVERRUN2_Pos)                    /*!< ADC FLAGS: OVERRUN2 Mask              */
#define ADC_FLAGS_OVERRUN3_Pos              15                                                      /*!< ADC FLAGS: OVERRUN3 Position          */
#define ADC_FLAGS_OVERRUN3_Msk              (0x01UL << ADC_FLAGS_OVERRUN3_Pos)                    /*!< ADC FLAGS: OVERRUN3 Mask              */
#define ADC_FLAGS_OVERRUN4_Pos              16                                                      /*!< ADC FLAGS: OVERRUN4 Position          */
#define ADC_FLAGS_OVERRUN4_Msk              (0x01UL << ADC_FLAGS_OVERRUN4_Pos)                    /*!< ADC FLAGS: OVERRUN4 Mask              */
#define ADC_FLAGS_OVERRUN5_Pos              17                                                      /*!< ADC FLAGS: OVERRUN5 Position          */
#define ADC_FLAGS_OVERRUN5_Msk              (0x01UL << ADC_FLAGS_OVERRUN5_Pos)                    /*!< ADC FLAGS: OVERRUN5 Mask              */
#define ADC_FLAGS_OVERRUN6_Pos              18                                                      /*!< ADC FLAGS: OVERRUN6 Position          */
#define ADC_FLAGS_OVERRUN6_Msk              (0x01UL << ADC_FLAGS_OVERRUN6_Pos)                    /*!< ADC FLAGS: OVERRUN6 Mask              */
#define ADC_FLAGS_OVERRUN7_Pos              19                                                      /*!< ADC FLAGS: OVERRUN7 Position          */
#define ADC_FLAGS_OVERRUN7_Msk              (0x01UL << ADC_FLAGS_OVERRUN7_Pos)                    /*!< ADC FLAGS: OVERRUN7 Mask              */
#define ADC_FLAGS_SEQA_OVR_Pos              24                                                      /*!< ADC FLAGS: SEQA_OVR Position          */
#define ADC_FLAGS_SEQA_OVR_Msk              (0x01UL << ADC_FLAGS_SEQA_OVR_Pos)                    /*!< ADC FLAGS: SEQA_OVR Mask              */
#define ADC_FLAGS_SEQB_OVR_Pos              25                                                      /*!< ADC FLAGS: SEQB_OVR Position          */
#define ADC_FLAGS_SEQB_OVR_Msk              (0x01UL << ADC_FLAGS_SEQB_OVR_Pos)                    /*!< ADC FLAGS: SEQB_OVR Mask              */
#define ADC_FLAGS_SEQA_INT_Pos              28                                                      /*!< ADC FLAGS: SEQA_INT Position          */
#define ADC_FLAGS_SEQA_INT_Msk              (0x01UL << ADC_FLAGS_SEQA_INT_Pos)                    /*!< ADC FLAGS: SEQA_INT Mask              */
#define ADC_FLAGS_SEQB_INT_Pos              29                                                      /*!< ADC FLAGS: SEQB_INT Position          */
#define ADC_FLAGS_SEQB_INT_Msk              (0x01UL << ADC_FLAGS_SEQB_INT_Pos)                    /*!< ADC FLAGS: SEQB_INT Mask              */
#define ADC_FLAGS_THCMP_INT_Pos             30                                                      /*!< ADC FLAGS: THCMP_INT Position         */
#define ADC_FLAGS_THCMP_INT_Msk             (0x01UL << ADC_FLAGS_THCMP_INT_Pos)                   /*!< ADC FLAGS: THCMP_INT Mask             */
#define ADC_FLAGS_OVR_INT_Pos               31                                                      /*!< ADC FLAGS: OVR_INT Position           */
#define ADC_FLAGS_OVR_INT_Msk               (0x01UL << ADC_FLAGS_OVR_INT_Pos)                     /*!< ADC FLAGS: OVR_INT Mask               */

/* --------------------------------  u_adc_STARTUP  ------------------------------- */
#define ADC_STARTUP_ADC_ENA_Pos             0                                                       /*!< ADC STARTUP: ADC_ENA Position         */
#define ADC_STARTUP_ADC_ENA_Msk             (0x01UL << ADC_STARTUP_ADC_ENA_Pos)                   /*!< ADC STARTUP: ADC_ENA Mask             */

/* ------------------------------  u_adc_GPADC_CTRL0  ----------------------------- */
#define ADC_GPADC_CTRL0_LDO_POWER_EN_Pos    0                                                       /*!< ADC GPADC_CTRL0: LDO_POWER_EN Position */
#define ADC_GPADC_CTRL0_LDO_POWER_EN_Msk    (0x01UL << ADC_GPADC_CTRL0_LDO_POWER_EN_Pos)          /*!< ADC GPADC_CTRL0: LDO_POWER_EN Mask    */
#define ADC_GPADC_CTRL0_LDO_SEL_OUT_Pos     3                                                       /*!< ADC GPADC_CTRL0: LDO_SEL_OUT Position */
#define ADC_GPADC_CTRL0_LDO_SEL_OUT_Msk     (0x1fUL << ADC_GPADC_CTRL0_LDO_SEL_OUT_Pos)           /*!< ADC GPADC_CTRL0: LDO_SEL_OUT Mask     */
#define ADC_GPADC_CTRL0_PASS_ENABLE_Pos     8                                                       /*!< ADC GPADC_CTRL0: PASS_ENABLE Position */
#define ADC_GPADC_CTRL0_PASS_ENABLE_Msk     (0x01UL << ADC_GPADC_CTRL0_PASS_ENABLE_Pos)           /*!< ADC GPADC_CTRL0: PASS_ENABLE Mask     */
#define ADC_GPADC_CTRL0_GPADC_TSAMP_Pos     9                                                       /*!< ADC GPADC_CTRL0: GPADC_TSAMP Position */
#define ADC_GPADC_CTRL0_GPADC_TSAMP_Msk     (0x1fUL << ADC_GPADC_CTRL0_GPADC_TSAMP_Pos)           /*!< ADC GPADC_CTRL0: GPADC_TSAMP Mask     */
#define ADC_GPADC_CTRL0_TEST_Pos            14                                                      /*!< ADC GPADC_CTRL0: TEST Position        */
#define ADC_GPADC_CTRL0_TEST_Msk            (0x03UL << ADC_GPADC_CTRL0_TEST_Pos)                  /*!< ADC GPADC_CTRL0: TEST Mask            */
#define ADC_GPADC_CTRL0_SEL_ATB_Pos         16                                                      /*!< ADC GPADC_CTRL0: SEL_ATB Position     */
#define ADC_GPADC_CTRL0_SEL_ATB_Msk         (0x03UL << ADC_GPADC_CTRL0_SEL_ATB_Pos)               /*!< ADC GPADC_CTRL0: SEL_ATB Mask         */

/* ------------------------------  u_adc_GPADC_CTRL1  ----------------------------- */
#define ADC_GPADC_CTRL1_OFFSET_CAL_Pos      0                                                       /*!< ADC GPADC_CTRL1: OFFSET_CAL Position  */
#define ADC_GPADC_CTRL1_OFFSET_CAL_Msk      (0x000003ffUL << ADC_GPADC_CTRL1_OFFSET_CAL_Pos)      /*!< ADC GPADC_CTRL1: OFFSET_CAL Mask      */
#define ADC_GPADC_CTRL1_GAIN_CAL_Pos        10                                                      /*!< ADC GPADC_CTRL1: GAIN_CAL Position    */
#define ADC_GPADC_CTRL1_GAIN_CAL_Msk        (0x000003ffUL << ADC_GPADC_CTRL1_GAIN_CAL_Pos)        /*!< ADC GPADC_CTRL1: GAIN_CAL Mask        */


/* ================================================================================ */
/* ================         struct 'u_dmic' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u_dmic_OSR0  -------------------------------- */
#define DMIC_OSR0_OSR_Pos                   0                                                       /*!< DMIC OSR0: OSR Position               */
#define DMIC_OSR0_OSR_Msk                   (0x000000ffUL << DMIC_OSR0_OSR_Pos)                   /*!< DMIC OSR0: OSR Mask                   */

/* ------------------------------  u_dmic_DIVHFCLK0  ------------------------------ */
#define DMIC_DIVHFCLK0_PDMDIV_Pos           0                                                       /*!< DMIC DIVHFCLK0: PDMDIV Position       */
#define DMIC_DIVHFCLK0_PDMDIV_Msk           (0x0fUL << DMIC_DIVHFCLK0_PDMDIV_Pos)                 /*!< DMIC DIVHFCLK0: PDMDIV Mask           */

/* ----------------------------  u_dmic_PREAC2FSCOEF0  ---------------------------- */
#define DMIC_PREAC2FSCOEF0_COMP_Pos         0                                                       /*!< DMIC PREAC2FSCOEF0: COMP Position     */
#define DMIC_PREAC2FSCOEF0_COMP_Msk         (0x03UL << DMIC_PREAC2FSCOEF0_COMP_Pos)               /*!< DMIC PREAC2FSCOEF0: COMP Mask         */

/* ----------------------------  u_dmic_PREAC4FSCOEF0  ---------------------------- */
#define DMIC_PREAC4FSCOEF0_COMP_Pos         0                                                       /*!< DMIC PREAC4FSCOEF0: COMP Position     */
#define DMIC_PREAC4FSCOEF0_COMP_Msk         (0x03UL << DMIC_PREAC4FSCOEF0_COMP_Pos)               /*!< DMIC PREAC4FSCOEF0: COMP Mask         */

/* ------------------------------  u_dmic_GAINSHIFT0  ----------------------------- */
#define DMIC_GAINSHIFT0_GAIN_Pos            0                                                       /*!< DMIC GAINSHIFT0: GAIN Position        */
#define DMIC_GAINSHIFT0_GAIN_Msk            (0x3fUL << DMIC_GAINSHIFT0_GAIN_Pos)                  /*!< DMIC GAINSHIFT0: GAIN Mask            */

/* ------------------------------  u_dmic_FIFOCTRL0  ------------------------------ */
#define DMIC_FIFOCTRL0_ENABLE_Pos           0                                                       /*!< DMIC FIFOCTRL0: ENABLE Position       */
#define DMIC_FIFOCTRL0_ENABLE_Msk           (0x01UL << DMIC_FIFOCTRL0_ENABLE_Pos)                 /*!< DMIC FIFOCTRL0: ENABLE Mask           */
#define DMIC_FIFOCTRL0_RESET_Pos            1                                                       /*!< DMIC FIFOCTRL0: RESET Position        */
#define DMIC_FIFOCTRL0_RESET_Msk            (0x01UL << DMIC_FIFOCTRL0_RESET_Pos)                  /*!< DMIC FIFOCTRL0: RESET Mask            */
#define DMIC_FIFOCTRL0_INTEN_Pos            2                                                       /*!< DMIC FIFOCTRL0: INTEN Position        */
#define DMIC_FIFOCTRL0_INTEN_Msk            (0x01UL << DMIC_FIFOCTRL0_INTEN_Pos)                  /*!< DMIC FIFOCTRL0: INTEN Mask            */
#define DMIC_FIFOCTRL0_DMAEN_Pos            3                                                       /*!< DMIC FIFOCTRL0: DMAEN Position        */
#define DMIC_FIFOCTRL0_DMAEN_Msk            (0x01UL << DMIC_FIFOCTRL0_DMAEN_Pos)                  /*!< DMIC FIFOCTRL0: DMAEN Mask            */
#define DMIC_FIFOCTRL0_TRIGLVL_Pos          16                                                      /*!< DMIC FIFOCTRL0: TRIGLVL Position      */
#define DMIC_FIFOCTRL0_TRIGLVL_Msk          (0x1fUL << DMIC_FIFOCTRL0_TRIGLVL_Pos)                /*!< DMIC FIFOCTRL0: TRIGLVL Mask          */

/* ------------------------------  u_dmic_FIFOSTAT0  ------------------------------ */
#define DMIC_FIFOSTAT0_INT_Pos              0                                                       /*!< DMIC FIFOSTAT0: INT Position          */
#define DMIC_FIFOSTAT0_INT_Msk              (0x01UL << DMIC_FIFOSTAT0_INT_Pos)                    /*!< DMIC FIFOSTAT0: INT Mask              */
#define DMIC_FIFOSTAT0_OVERRUN_Pos          1                                                       /*!< DMIC FIFOSTAT0: OVERRUN Position      */
#define DMIC_FIFOSTAT0_OVERRUN_Msk          (0x01UL << DMIC_FIFOSTAT0_OVERRUN_Pos)                /*!< DMIC FIFOSTAT0: OVERRUN Mask          */
#define DMIC_FIFOSTAT0_UNDERRUN_Pos         2                                                       /*!< DMIC FIFOSTAT0: UNDERRUN Position     */
#define DMIC_FIFOSTAT0_UNDERRUN_Msk         (0x01UL << DMIC_FIFOSTAT0_UNDERRUN_Pos)               /*!< DMIC FIFOSTAT0: UNDERRUN Mask         */

/* ------------------------------  u_dmic_FIFODATA0  ------------------------------ */
#define DMIC_FIFODATA0_DATA_Pos             0                                                       /*!< DMIC FIFODATA0: DATA Position         */
#define DMIC_FIFODATA0_DATA_Msk             (0x00ffffffUL << DMIC_FIFODATA0_DATA_Pos)             /*!< DMIC FIFODATA0: DATA Mask             */

/* ------------------------------  u_dmic_PDMSRCCFG0  ----------------------------- */
#define DMIC_PDMSRCCFG0_PHY_FALL_Pos        0                                                       /*!< DMIC PDMSRCCFG0: PHY_FALL Position    */
#define DMIC_PDMSRCCFG0_PHY_FALL_Msk        (0x01UL << DMIC_PDMSRCCFG0_PHY_FALL_Pos)              /*!< DMIC PDMSRCCFG0: PHY_FALL Mask        */
#define DMIC_PDMSRCCFG0_PHY_HALF_Pos        1                                                       /*!< DMIC PDMSRCCFG0: PHY_HALF Position    */
#define DMIC_PDMSRCCFG0_PHY_HALF_Msk        (0x01UL << DMIC_PDMSRCCFG0_PHY_HALF_Pos)              /*!< DMIC PDMSRCCFG0: PHY_HALF Mask        */

/* -------------------------------  u_dmic_DCCTRL0  ------------------------------- */
#define DMIC_DCCTRL0_DCPOLE_Pos             0                                                       /*!< DMIC DCCTRL0: DCPOLE Position         */
#define DMIC_DCCTRL0_DCPOLE_Msk             (0x03UL << DMIC_DCCTRL0_DCPOLE_Pos)                   /*!< DMIC DCCTRL0: DCPOLE Mask             */
#define DMIC_DCCTRL0_DCGAIN_Pos             4                                                       /*!< DMIC DCCTRL0: DCGAIN Position         */
#define DMIC_DCCTRL0_DCGAIN_Msk             (0x0fUL << DMIC_DCCTRL0_DCGAIN_Pos)                   /*!< DMIC DCCTRL0: DCGAIN Mask             */
#define DMIC_DCCTRL0_SATURATEAT16BIT_Pos    8                                                       /*!< DMIC DCCTRL0: SATURATEAT16BIT Position */
#define DMIC_DCCTRL0_SATURATEAT16BIT_Msk    (0x01UL << DMIC_DCCTRL0_SATURATEAT16BIT_Pos)          /*!< DMIC DCCTRL0: SATURATEAT16BIT Mask    */

/* ---------------------------------  u_dmic_OSR1  -------------------------------- */
#define DMIC_OSR1_OSR_Pos                   0                                                       /*!< DMIC OSR1: OSR Position               */
#define DMIC_OSR1_OSR_Msk                   (0x000000ffUL << DMIC_OSR1_OSR_Pos)                   /*!< DMIC OSR1: OSR Mask                   */

/* ------------------------------  u_dmic_DIVHFCLK1  ------------------------------ */
#define DMIC_DIVHFCLK1_PDMDIV_Pos           0                                                       /*!< DMIC DIVHFCLK1: PDMDIV Position       */
#define DMIC_DIVHFCLK1_PDMDIV_Msk           (0x0fUL << DMIC_DIVHFCLK1_PDMDIV_Pos)                 /*!< DMIC DIVHFCLK1: PDMDIV Mask           */

/* ----------------------------  u_dmic_PREAC2FSCOEF1  ---------------------------- */
#define DMIC_PREAC2FSCOEF1_COMP_Pos         0                                                       /*!< DMIC PREAC2FSCOEF1: COMP Position     */
#define DMIC_PREAC2FSCOEF1_COMP_Msk         (0x03UL << DMIC_PREAC2FSCOEF1_COMP_Pos)               /*!< DMIC PREAC2FSCOEF1: COMP Mask         */

/* ----------------------------  u_dmic_PREAC4FSCOEF1  ---------------------------- */
#define DMIC_PREAC4FSCOEF1_COMP_Pos         0                                                       /*!< DMIC PREAC4FSCOEF1: COMP Position     */
#define DMIC_PREAC4FSCOEF1_COMP_Msk         (0x03UL << DMIC_PREAC4FSCOEF1_COMP_Pos)               /*!< DMIC PREAC4FSCOEF1: COMP Mask         */

/* ------------------------------  u_dmic_GAINSHIFT1  ----------------------------- */
#define DMIC_GAINSHIFT1_GAIN_Pos            0                                                       /*!< DMIC GAINSHIFT1: GAIN Position        */
#define DMIC_GAINSHIFT1_GAIN_Msk            (0x3fUL << DMIC_GAINSHIFT1_GAIN_Pos)                  /*!< DMIC GAINSHIFT1: GAIN Mask            */

/* ------------------------------  u_dmic_FIFOCTRL1  ------------------------------ */
#define DMIC_FIFOCTRL1_ENABLE_Pos           0                                                       /*!< DMIC FIFOCTRL1: ENABLE Position       */
#define DMIC_FIFOCTRL1_ENABLE_Msk           (0x01UL << DMIC_FIFOCTRL1_ENABLE_Pos)                 /*!< DMIC FIFOCTRL1: ENABLE Mask           */
#define DMIC_FIFOCTRL1_RESET_Pos            1                                                       /*!< DMIC FIFOCTRL1: RESET Position        */
#define DMIC_FIFOCTRL1_RESET_Msk            (0x01UL << DMIC_FIFOCTRL1_RESET_Pos)                  /*!< DMIC FIFOCTRL1: RESET Mask            */
#define DMIC_FIFOCTRL1_INTEN_Pos            2                                                       /*!< DMIC FIFOCTRL1: INTEN Position        */
#define DMIC_FIFOCTRL1_INTEN_Msk            (0x01UL << DMIC_FIFOCTRL1_INTEN_Pos)                  /*!< DMIC FIFOCTRL1: INTEN Mask            */
#define DMIC_FIFOCTRL1_DMAEN_Pos            3                                                       /*!< DMIC FIFOCTRL1: DMAEN Position        */
#define DMIC_FIFOCTRL1_DMAEN_Msk            (0x01UL << DMIC_FIFOCTRL1_DMAEN_Pos)                  /*!< DMIC FIFOCTRL1: DMAEN Mask            */
#define DMIC_FIFOCTRL1_TRIGLVL_Pos          16                                                      /*!< DMIC FIFOCTRL1: TRIGLVL Position      */
#define DMIC_FIFOCTRL1_TRIGLVL_Msk          (0x1fUL << DMIC_FIFOCTRL1_TRIGLVL_Pos)                /*!< DMIC FIFOCTRL1: TRIGLVL Mask          */

/* ------------------------------  u_dmic_FIFOSTAT1  ------------------------------ */
#define DMIC_FIFOSTAT1_INT_Pos              0                                                       /*!< DMIC FIFOSTAT1: INT Position          */
#define DMIC_FIFOSTAT1_INT_Msk              (0x01UL << DMIC_FIFOSTAT1_INT_Pos)                    /*!< DMIC FIFOSTAT1: INT Mask              */
#define DMIC_FIFOSTAT1_OVERRUN_Pos          1                                                       /*!< DMIC FIFOSTAT1: OVERRUN Position      */
#define DMIC_FIFOSTAT1_OVERRUN_Msk          (0x01UL << DMIC_FIFOSTAT1_OVERRUN_Pos)                /*!< DMIC FIFOSTAT1: OVERRUN Mask          */
#define DMIC_FIFOSTAT1_UNDERRUN_Pos         2                                                       /*!< DMIC FIFOSTAT1: UNDERRUN Position     */
#define DMIC_FIFOSTAT1_UNDERRUN_Msk         (0x01UL << DMIC_FIFOSTAT1_UNDERRUN_Pos)               /*!< DMIC FIFOSTAT1: UNDERRUN Mask         */

/* ------------------------------  u_dmic_FIFODATA1  ------------------------------ */
#define DMIC_FIFODATA1_DATA_Pos             0                                                       /*!< DMIC FIFODATA1: DATA Position         */
#define DMIC_FIFODATA1_DATA_Msk             (0x00ffffffUL << DMIC_FIFODATA1_DATA_Pos)             /*!< DMIC FIFODATA1: DATA Mask             */

/* ------------------------------  u_dmic_PDMSRCCFG1  ----------------------------- */
#define DMIC_PDMSRCCFG1_PHY_FALL_Pos        0                                                       /*!< DMIC PDMSRCCFG1: PHY_FALL Position    */
#define DMIC_PDMSRCCFG1_PHY_FALL_Msk        (0x01UL << DMIC_PDMSRCCFG1_PHY_FALL_Pos)              /*!< DMIC PDMSRCCFG1: PHY_FALL Mask        */
#define DMIC_PDMSRCCFG1_PHY_HALF_Pos        1                                                       /*!< DMIC PDMSRCCFG1: PHY_HALF Position    */
#define DMIC_PDMSRCCFG1_PHY_HALF_Msk        (0x01UL << DMIC_PDMSRCCFG1_PHY_HALF_Pos)              /*!< DMIC PDMSRCCFG1: PHY_HALF Mask        */

/* -------------------------------  u_dmic_DCCTRL1  ------------------------------- */
#define DMIC_DCCTRL1_DCPOLE_Pos             0                                                       /*!< DMIC DCCTRL1: DCPOLE Position         */
#define DMIC_DCCTRL1_DCPOLE_Msk             (0x03UL << DMIC_DCCTRL1_DCPOLE_Pos)                   /*!< DMIC DCCTRL1: DCPOLE Mask             */
#define DMIC_DCCTRL1_DCGAIN_Pos             4                                                       /*!< DMIC DCCTRL1: DCGAIN Position         */
#define DMIC_DCCTRL1_DCGAIN_Msk             (0x0fUL << DMIC_DCCTRL1_DCGAIN_Pos)                   /*!< DMIC DCCTRL1: DCGAIN Mask             */
#define DMIC_DCCTRL1_SATURATEAT16BIT_Pos    8                                                       /*!< DMIC DCCTRL1: SATURATEAT16BIT Position */
#define DMIC_DCCTRL1_SATURATEAT16BIT_Msk    (0x01UL << DMIC_DCCTRL1_SATURATEAT16BIT_Pos)          /*!< DMIC DCCTRL1: SATURATEAT16BIT Mask    */

/* --------------------------------  u_dmic_CHANEN  ------------------------------- */
#define DMIC_CHANEN_EN_CH0_Pos              0                                                       /*!< DMIC CHANEN: EN_CH0 Position          */
#define DMIC_CHANEN_EN_CH0_Msk              (0x01UL << DMIC_CHANEN_EN_CH0_Pos)                    /*!< DMIC CHANEN: EN_CH0 Mask              */
#define DMIC_CHANEN_EN_CH1_Pos              1                                                       /*!< DMIC CHANEN: EN_CH1 Position          */
#define DMIC_CHANEN_EN_CH1_Msk              (0x01UL << DMIC_CHANEN_EN_CH1_Pos)                    /*!< DMIC CHANEN: EN_CH1 Mask              */

/* --------------------------------  u_dmic_IOCFG  -------------------------------- */
#define DMIC_IOCFG_CLK_BYPASS0_Pos          0                                                       /*!< DMIC IOCFG: CLK_BYPASS0 Position      */
#define DMIC_IOCFG_CLK_BYPASS0_Msk          (0x01UL << DMIC_IOCFG_CLK_BYPASS0_Pos)                /*!< DMIC IOCFG: CLK_BYPASS0 Mask          */
#define DMIC_IOCFG_CLK_BYPASS1_Pos          1                                                       /*!< DMIC IOCFG: CLK_BYPASS1 Position      */
#define DMIC_IOCFG_CLK_BYPASS1_Msk          (0x01UL << DMIC_IOCFG_CLK_BYPASS1_Pos)                /*!< DMIC IOCFG: CLK_BYPASS1 Mask          */
#define DMIC_IOCFG_STEREO_DATA0_Pos         2                                                       /*!< DMIC IOCFG: STEREO_DATA0 Position     */
#define DMIC_IOCFG_STEREO_DATA0_Msk         (0x01UL << DMIC_IOCFG_STEREO_DATA0_Pos)               /*!< DMIC IOCFG: STEREO_DATA0 Mask         */

/* --------------------------------  u_dmic_USE2FS  ------------------------------- */
#define DMIC_USE2FS_USE2FS_Pos              0                                                       /*!< DMIC USE2FS: USE2FS Position          */
#define DMIC_USE2FS_USE2FS_Msk              (0x01UL << DMIC_USE2FS_USE2FS_Pos)                    /*!< DMIC USE2FS: USE2FS Mask              */

/* ------------------------------  u_dmic_HWVADGAIN  ------------------------------ */
#define DMIC_HWVADGAIN_INPUTGAIN_Pos        0                                                       /*!< DMIC HWVADGAIN: INPUTGAIN Position    */
#define DMIC_HWVADGAIN_INPUTGAIN_Msk        (0x0fUL << DMIC_HWVADGAIN_INPUTGAIN_Pos)              /*!< DMIC HWVADGAIN: INPUTGAIN Mask        */

/* ------------------------------  u_dmic_HWVADHPFS  ------------------------------ */
#define DMIC_HWVADHPFS_HPFS_Pos             0                                                       /*!< DMIC HWVADHPFS: HPFS Position         */
#define DMIC_HWVADHPFS_HPFS_Msk             (0x03UL << DMIC_HWVADHPFS_HPFS_Pos)                   /*!< DMIC HWVADHPFS: HPFS Mask             */

/* ------------------------------  u_dmic_HWVADST10  ------------------------------ */
#define DMIC_HWVADST10_ST10_Pos             0                                                       /*!< DMIC HWVADST10: ST10 Position         */
#define DMIC_HWVADST10_ST10_Msk             (0x01UL << DMIC_HWVADST10_ST10_Pos)                   /*!< DMIC HWVADST10: ST10 Mask             */

/* ------------------------------  u_dmic_HWVADRSTT  ------------------------------ */
#define DMIC_HWVADRSTT_RSTT_Pos             0                                                       /*!< DMIC HWVADRSTT: RSTT Position         */
#define DMIC_HWVADRSTT_RSTT_Msk             (0x01UL << DMIC_HWVADRSTT_RSTT_Pos)                   /*!< DMIC HWVADRSTT: RSTT Mask             */

/* ------------------------------  u_dmic_HWVADTHGN  ------------------------------ */
#define DMIC_HWVADTHGN_THGN_Pos             0                                                       /*!< DMIC HWVADTHGN: THGN Position         */
#define DMIC_HWVADTHGN_THGN_Msk             (0x0fUL << DMIC_HWVADTHGN_THGN_Pos)                   /*!< DMIC HWVADTHGN: THGN Mask             */

/* ------------------------------  u_dmic_HWVADTHGS  ------------------------------ */
#define DMIC_HWVADTHGS_THGS_Pos             0                                                       /*!< DMIC HWVADTHGS: THGS Position         */
#define DMIC_HWVADTHGS_THGS_Msk             (0x0fUL << DMIC_HWVADTHGS_THGS_Pos)                   /*!< DMIC HWVADTHGS: THGS Mask             */

/* ------------------------------  u_dmic_HWVADLOWZ  ------------------------------ */
#define DMIC_HWVADLOWZ_LOWZ_Pos             0                                                       /*!< DMIC HWVADLOWZ: LOWZ Position         */
#define DMIC_HWVADLOWZ_LOWZ_Msk             (0x0000ffffUL << DMIC_HWVADLOWZ_LOWZ_Pos)             /*!< DMIC HWVADLOWZ: LOWZ Mask             */

/* ----------------------------------  u_dmic_ID  --------------------------------- */
#define DMIC_ID_ID_Pos                      0                                                       /*!< DMIC ID: ID Position                  */
#define DMIC_ID_ID_Msk                      (0xffffffffUL << DMIC_ID_ID_Pos)                      /*!< DMIC ID: ID Mask                      */


/* ================================================================================ */
/* ================        struct 'u0_usart' Position & Mask       ================ */
/* ================================================================================ */


/* --------------------------------  u0_usart_CFG  -------------------------------- */
#define USART0_CFG_ENABLE_Pos               0                                                       /*!< USART0 CFG: ENABLE Position           */
#define USART0_CFG_ENABLE_Msk               (0x01UL << USART0_CFG_ENABLE_Pos)                     /*!< USART0 CFG: ENABLE Mask               */
#define USART0_CFG_DATALEN_Pos              2                                                       /*!< USART0 CFG: DATALEN Position          */
#define USART0_CFG_DATALEN_Msk              (0x03UL << USART0_CFG_DATALEN_Pos)                    /*!< USART0 CFG: DATALEN Mask              */
#define USART0_CFG_PARITYSEL_Pos            4                                                       /*!< USART0 CFG: PARITYSEL Position        */
#define USART0_CFG_PARITYSEL_Msk            (0x03UL << USART0_CFG_PARITYSEL_Pos)                  /*!< USART0 CFG: PARITYSEL Mask            */
#define USART0_CFG_STOPLEN_Pos              6                                                       /*!< USART0 CFG: STOPLEN Position          */
#define USART0_CFG_STOPLEN_Msk              (0x01UL << USART0_CFG_STOPLEN_Pos)                    /*!< USART0 CFG: STOPLEN Mask              */
#define USART0_CFG_MODE32K_Pos              7                                                       /*!< USART0 CFG: MODE32K Position          */
#define USART0_CFG_MODE32K_Msk              (0x01UL << USART0_CFG_MODE32K_Pos)                    /*!< USART0 CFG: MODE32K Mask              */
#define USART0_CFG_LINMODE_Pos              8                                                       /*!< USART0 CFG: LINMODE Position          */
#define USART0_CFG_LINMODE_Msk              (0x01UL << USART0_CFG_LINMODE_Pos)                    /*!< USART0 CFG: LINMODE Mask              */
#define USART0_CFG_CTSEN_Pos                9                                                       /*!< USART0 CFG: CTSEN Position            */
#define USART0_CFG_CTSEN_Msk                (0x01UL << USART0_CFG_CTSEN_Pos)                      /*!< USART0 CFG: CTSEN Mask                */
#define USART0_CFG_SYNCEN_Pos               11                                                      /*!< USART0 CFG: SYNCEN Position           */
#define USART0_CFG_SYNCEN_Msk               (0x01UL << USART0_CFG_SYNCEN_Pos)                     /*!< USART0 CFG: SYNCEN Mask               */
#define USART0_CFG_CLKPOL_Pos               12                                                      /*!< USART0 CFG: CLKPOL Position           */
#define USART0_CFG_CLKPOL_Msk               (0x01UL << USART0_CFG_CLKPOL_Pos)                     /*!< USART0 CFG: CLKPOL Mask               */
#define USART0_CFG_SYNCMST_Pos              14                                                      /*!< USART0 CFG: SYNCMST Position          */
#define USART0_CFG_SYNCMST_Msk              (0x01UL << USART0_CFG_SYNCMST_Pos)                    /*!< USART0 CFG: SYNCMST Mask              */
#define USART0_CFG_LOOP_Pos                 15                                                      /*!< USART0 CFG: LOOP Position             */
#define USART0_CFG_LOOP_Msk                 (0x01UL << USART0_CFG_LOOP_Pos)                       /*!< USART0 CFG: LOOP Mask                 */
#define USART0_CFG_IOMODE_Pos               16                                                      /*!< USART0 CFG: IOMODE Position           */
#define USART0_CFG_IOMODE_Msk               (0x01UL << USART0_CFG_IOMODE_Pos)                     /*!< USART0 CFG: IOMODE Mask               */
#define USART0_CFG_OETA_Pos                 18                                                      /*!< USART0 CFG: OETA Position             */
#define USART0_CFG_OETA_Msk                 (0x01UL << USART0_CFG_OETA_Pos)                       /*!< USART0 CFG: OETA Mask                 */
#define USART0_CFG_AUTOADDR_Pos             19                                                      /*!< USART0 CFG: AUTOADDR Position         */
#define USART0_CFG_AUTOADDR_Msk             (0x01UL << USART0_CFG_AUTOADDR_Pos)                   /*!< USART0 CFG: AUTOADDR Mask             */
#define USART0_CFG_OESEL_Pos                20                                                      /*!< USART0 CFG: OESEL Position            */
#define USART0_CFG_OESEL_Msk                (0x01UL << USART0_CFG_OESEL_Pos)                      /*!< USART0 CFG: OESEL Mask                */
#define USART0_CFG_OEPOL_Pos                21                                                      /*!< USART0 CFG: OEPOL Position            */
#define USART0_CFG_OEPOL_Msk                (0x01UL << USART0_CFG_OEPOL_Pos)                      /*!< USART0 CFG: OEPOL Mask                */
#define USART0_CFG_RXPOL_Pos                22                                                      /*!< USART0 CFG: RXPOL Position            */
#define USART0_CFG_RXPOL_Msk                (0x01UL << USART0_CFG_RXPOL_Pos)                      /*!< USART0 CFG: RXPOL Mask                */
#define USART0_CFG_TXPOL_Pos                23                                                      /*!< USART0 CFG: TXPOL Position            */
#define USART0_CFG_TXPOL_Msk                (0x01UL << USART0_CFG_TXPOL_Pos)                      /*!< USART0 CFG: TXPOL Mask                */

/* --------------------------------  u0_usart_CTL  -------------------------------- */
#define USART0_CTL_TXBRKEN_Pos              1                                                       /*!< USART0 CTL: TXBRKEN Position          */
#define USART0_CTL_TXBRKEN_Msk              (0x01UL << USART0_CTL_TXBRKEN_Pos)                    /*!< USART0 CTL: TXBRKEN Mask              */
#define USART0_CTL_ADDRDET_Pos              2                                                       /*!< USART0 CTL: ADDRDET Position          */
#define USART0_CTL_ADDRDET_Msk              (0x01UL << USART0_CTL_ADDRDET_Pos)                    /*!< USART0 CTL: ADDRDET Mask              */
#define USART0_CTL_TXDIS_Pos                6                                                       /*!< USART0 CTL: TXDIS Position            */
#define USART0_CTL_TXDIS_Msk                (0x01UL << USART0_CTL_TXDIS_Pos)                      /*!< USART0 CTL: TXDIS Mask                */
#define USART0_CTL_CC_Pos                   8                                                       /*!< USART0 CTL: CC Position               */
#define USART0_CTL_CC_Msk                   (0x01UL << USART0_CTL_CC_Pos)                         /*!< USART0 CTL: CC Mask                   */
#define USART0_CTL_CLRCCONRX_Pos            9                                                       /*!< USART0 CTL: CLRCCONRX Position        */
#define USART0_CTL_CLRCCONRX_Msk            (0x01UL << USART0_CTL_CLRCCONRX_Pos)                  /*!< USART0 CTL: CLRCCONRX Mask            */
#define USART0_CTL_AUTOBAUD_Pos             16                                                      /*!< USART0 CTL: AUTOBAUD Position         */
#define USART0_CTL_AUTOBAUD_Msk             (0x01UL << USART0_CTL_AUTOBAUD_Pos)                   /*!< USART0 CTL: AUTOBAUD Mask             */

/* --------------------------------  u0_usart_STAT  ------------------------------- */
#define USART0_STAT_RXIDLE_Pos              1                                                       /*!< USART0 STAT: RXIDLE Position          */
#define USART0_STAT_RXIDLE_Msk              (0x01UL << USART0_STAT_RXIDLE_Pos)                    /*!< USART0 STAT: RXIDLE Mask              */
#define USART0_STAT_TXIDLE_Pos              3                                                       /*!< USART0 STAT: TXIDLE Position          */
#define USART0_STAT_TXIDLE_Msk              (0x01UL << USART0_STAT_TXIDLE_Pos)                    /*!< USART0 STAT: TXIDLE Mask              */
#define USART0_STAT_CTS_Pos                 4                                                       /*!< USART0 STAT: CTS Position             */
#define USART0_STAT_CTS_Msk                 (0x01UL << USART0_STAT_CTS_Pos)                       /*!< USART0 STAT: CTS Mask                 */
#define USART0_STAT_DELTACTS_Pos            5                                                       /*!< USART0 STAT: DELTACTS Position        */
#define USART0_STAT_DELTACTS_Msk            (0x01UL << USART0_STAT_DELTACTS_Pos)                  /*!< USART0 STAT: DELTACTS Mask            */
#define USART0_STAT_TXDISSTAT_Pos           6                                                       /*!< USART0 STAT: TXDISSTAT Position       */
#define USART0_STAT_TXDISSTAT_Msk           (0x01UL << USART0_STAT_TXDISSTAT_Pos)                 /*!< USART0 STAT: TXDISSTAT Mask           */
#define USART0_STAT_OVERRUNINT_Pos          8                                                       /*!< USART0 STAT: OVERRUNINT Position      */
#define USART0_STAT_OVERRUNINT_Msk          (0x01UL << USART0_STAT_OVERRUNINT_Pos)                /*!< USART0 STAT: OVERRUNINT Mask          */
#define USART0_STAT_RXBRK_Pos               10                                                      /*!< USART0 STAT: RXBRK Position           */
#define USART0_STAT_RXBRK_Msk               (0x01UL << USART0_STAT_RXBRK_Pos)                     /*!< USART0 STAT: RXBRK Mask               */
#define USART0_STAT_DELTARXBRK_Pos          11                                                      /*!< USART0 STAT: DELTARXBRK Position      */
#define USART0_STAT_DELTARXBRK_Msk          (0x01UL << USART0_STAT_DELTARXBRK_Pos)                /*!< USART0 STAT: DELTARXBRK Mask          */
#define USART0_STAT_START_Pos               12                                                      /*!< USART0 STAT: START Position           */
#define USART0_STAT_START_Msk               (0x01UL << USART0_STAT_START_Pos)                     /*!< USART0 STAT: START Mask               */
#define USART0_STAT_FRAMERRINT_Pos          13                                                      /*!< USART0 STAT: FRAMERRINT Position      */
#define USART0_STAT_FRAMERRINT_Msk          (0x01UL << USART0_STAT_FRAMERRINT_Pos)                /*!< USART0 STAT: FRAMERRINT Mask          */
#define USART0_STAT_PARITYERRINT_Pos        14                                                      /*!< USART0 STAT: PARITYERRINT Position    */
#define USART0_STAT_PARITYERRINT_Msk        (0x01UL << USART0_STAT_PARITYERRINT_Pos)              /*!< USART0 STAT: PARITYERRINT Mask        */
#define USART0_STAT_RXNOISEINT_Pos          15                                                      /*!< USART0 STAT: RXNOISEINT Position      */
#define USART0_STAT_RXNOISEINT_Msk          (0x01UL << USART0_STAT_RXNOISEINT_Pos)                /*!< USART0 STAT: RXNOISEINT Mask          */
#define USART0_STAT_ABERR_Pos               16                                                      /*!< USART0 STAT: ABERR Position           */
#define USART0_STAT_ABERR_Msk               (0x01UL << USART0_STAT_ABERR_Pos)                     /*!< USART0 STAT: ABERR Mask               */

/* ------------------------------  u0_usart_INTENSET  ----------------------------- */
#define USART0_INTENSET_RXRDYEN_Pos         0                                                       /*!< USART0 INTENSET: RXRDYEN Position     */
#define USART0_INTENSET_RXRDYEN_Msk         (0x01UL << USART0_INTENSET_RXRDYEN_Pos)               /*!< USART0 INTENSET: RXRDYEN Mask         */
#define USART0_INTENSET_TXRDTEN_Pos         2                                                       /*!< USART0 INTENSET: TXRDTEN Position     */
#define USART0_INTENSET_TXRDTEN_Msk         (0x01UL << USART0_INTENSET_TXRDTEN_Pos)               /*!< USART0 INTENSET: TXRDTEN Mask         */
#define USART0_INTENSET_TXIDLEEN_Pos        3                                                       /*!< USART0 INTENSET: TXIDLEEN Position    */
#define USART0_INTENSET_TXIDLEEN_Msk        (0x01UL << USART0_INTENSET_TXIDLEEN_Pos)              /*!< USART0 INTENSET: TXIDLEEN Mask        */
#define USART0_INTENSET_DELTACTSEN_Pos      5                                                       /*!< USART0 INTENSET: DELTACTSEN Position  */
#define USART0_INTENSET_DELTACTSEN_Msk      (0x01UL << USART0_INTENSET_DELTACTSEN_Pos)            /*!< USART0 INTENSET: DELTACTSEN Mask      */
#define USART0_INTENSET_TXDISEN_Pos         6                                                       /*!< USART0 INTENSET: TXDISEN Position     */
#define USART0_INTENSET_TXDISEN_Msk         (0x01UL << USART0_INTENSET_TXDISEN_Pos)               /*!< USART0 INTENSET: TXDISEN Mask         */
#define USART0_INTENSET_OVERRUNEN_Pos       8                                                       /*!< USART0 INTENSET: OVERRUNEN Position   */
#define USART0_INTENSET_OVERRUNEN_Msk       (0x01UL << USART0_INTENSET_OVERRUNEN_Pos)             /*!< USART0 INTENSET: OVERRUNEN Mask       */
#define USART0_INTENSET_DELTARXBRKEN_Pos    11                                                      /*!< USART0 INTENSET: DELTARXBRKEN Position */
#define USART0_INTENSET_DELTARXBRKEN_Msk    (0x01UL << USART0_INTENSET_DELTARXBRKEN_Pos)          /*!< USART0 INTENSET: DELTARXBRKEN Mask    */
#define USART0_INTENSET_STARTEN_Pos         12                                                      /*!< USART0 INTENSET: STARTEN Position     */
#define USART0_INTENSET_STARTEN_Msk         (0x01UL << USART0_INTENSET_STARTEN_Pos)               /*!< USART0 INTENSET: STARTEN Mask         */
#define USART0_INTENSET_FRAMERREN_Pos       13                                                      /*!< USART0 INTENSET: FRAMERREN Position   */
#define USART0_INTENSET_FRAMERREN_Msk       (0x01UL << USART0_INTENSET_FRAMERREN_Pos)             /*!< USART0 INTENSET: FRAMERREN Mask       */
#define USART0_INTENSET_PARITYERREN_Pos     14                                                      /*!< USART0 INTENSET: PARITYERREN Position */
#define USART0_INTENSET_PARITYERREN_Msk     (0x01UL << USART0_INTENSET_PARITYERREN_Pos)           /*!< USART0 INTENSET: PARITYERREN Mask     */
#define USART0_INTENSET_RXNOISEEN_Pos       15                                                      /*!< USART0 INTENSET: RXNOISEEN Position   */
#define USART0_INTENSET_RXNOISEEN_Msk       (0x01UL << USART0_INTENSET_RXNOISEEN_Pos)             /*!< USART0 INTENSET: RXNOISEEN Mask       */
#define USART0_INTENSET_ABERREN_Pos         16                                                      /*!< USART0 INTENSET: ABERREN Position     */
#define USART0_INTENSET_ABERREN_Msk         (0x01UL << USART0_INTENSET_ABERREN_Pos)               /*!< USART0 INTENSET: ABERREN Mask         */

/* ------------------------------  u0_usart_INTENCLR  ----------------------------- */
#define USART0_INTENCLR_RXRDYCLR_Pos        0                                                       /*!< USART0 INTENCLR: RXRDYCLR Position    */
#define USART0_INTENCLR_RXRDYCLR_Msk        (0x01UL << USART0_INTENCLR_RXRDYCLR_Pos)              /*!< USART0 INTENCLR: RXRDYCLR Mask        */
#define USART0_INTENCLR_TXRDYCLR_Pos        2                                                       /*!< USART0 INTENCLR: TXRDYCLR Position    */
#define USART0_INTENCLR_TXRDYCLR_Msk        (0x01UL << USART0_INTENCLR_TXRDYCLR_Pos)              /*!< USART0 INTENCLR: TXRDYCLR Mask        */
#define USART0_INTENCLR_TXIDLECLR_Pos       3                                                       /*!< USART0 INTENCLR: TXIDLECLR Position   */
#define USART0_INTENCLR_TXIDLECLR_Msk       (0x01UL << USART0_INTENCLR_TXIDLECLR_Pos)             /*!< USART0 INTENCLR: TXIDLECLR Mask       */
#define USART0_INTENCLR_DELTACTSCLR_Pos     5                                                       /*!< USART0 INTENCLR: DELTACTSCLR Position */
#define USART0_INTENCLR_DELTACTSCLR_Msk     (0x01UL << USART0_INTENCLR_DELTACTSCLR_Pos)           /*!< USART0 INTENCLR: DELTACTSCLR Mask     */
#define USART0_INTENCLR_TXDISCLR_Pos        6                                                       /*!< USART0 INTENCLR: TXDISCLR Position    */
#define USART0_INTENCLR_TXDISCLR_Msk        (0x01UL << USART0_INTENCLR_TXDISCLR_Pos)              /*!< USART0 INTENCLR: TXDISCLR Mask        */
#define USART0_INTENCLR_OVERRUNCLR_Pos      8                                                       /*!< USART0 INTENCLR: OVERRUNCLR Position  */
#define USART0_INTENCLR_OVERRUNCLR_Msk      (0x01UL << USART0_INTENCLR_OVERRUNCLR_Pos)            /*!< USART0 INTENCLR: OVERRUNCLR Mask      */
#define USART0_INTENCLR_DELTARXBRKCLR_Pos   11                                                      /*!< USART0 INTENCLR: DELTARXBRKCLR Position */
#define USART0_INTENCLR_DELTARXBRKCLR_Msk   (0x01UL << USART0_INTENCLR_DELTARXBRKCLR_Pos)         /*!< USART0 INTENCLR: DELTARXBRKCLR Mask   */
#define USART0_INTENCLR_STARTCLR_Pos        12                                                      /*!< USART0 INTENCLR: STARTCLR Position    */
#define USART0_INTENCLR_STARTCLR_Msk        (0x01UL << USART0_INTENCLR_STARTCLR_Pos)              /*!< USART0 INTENCLR: STARTCLR Mask        */
#define USART0_INTENCLR_FRAMERRCLR_Pos      13                                                      /*!< USART0 INTENCLR: FRAMERRCLR Position  */
#define USART0_INTENCLR_FRAMERRCLR_Msk      (0x01UL << USART0_INTENCLR_FRAMERRCLR_Pos)            /*!< USART0 INTENCLR: FRAMERRCLR Mask      */
#define USART0_INTENCLR_PARITYERRCLR_Pos    14                                                      /*!< USART0 INTENCLR: PARITYERRCLR Position */
#define USART0_INTENCLR_PARITYERRCLR_Msk    (0x01UL << USART0_INTENCLR_PARITYERRCLR_Pos)          /*!< USART0 INTENCLR: PARITYERRCLR Mask    */
#define USART0_INTENCLR_RXNOISECLR_Pos      15                                                      /*!< USART0 INTENCLR: RXNOISECLR Position  */
#define USART0_INTENCLR_RXNOISECLR_Msk      (0x01UL << USART0_INTENCLR_RXNOISECLR_Pos)            /*!< USART0 INTENCLR: RXNOISECLR Mask      */
#define USART0_INTENCLR_ABERRCLR_Pos        16                                                      /*!< USART0 INTENCLR: ABERRCLR Position    */
#define USART0_INTENCLR_ABERRCLR_Msk        (0x01UL << USART0_INTENCLR_ABERRCLR_Pos)              /*!< USART0 INTENCLR: ABERRCLR Mask        */

/* --------------------------------  u0_usart_BRG  -------------------------------- */
#define USART0_BRG_BRGVAL_Pos               0                                                       /*!< USART0 BRG: BRGVAL Position           */
#define USART0_BRG_BRGVAL_Msk               (0x0000ffffUL << USART0_BRG_BRGVAL_Pos)               /*!< USART0 BRG: BRGVAL Mask               */

/* ------------------------------  u0_usart_INTSTAT  ------------------------------ */
#define USART0_INTSTAT_RX_RDY_Pos           0                                                       /*!< USART0 INTSTAT: RX_RDY Position       */
#define USART0_INTSTAT_RX_RDY_Msk           (0x01UL << USART0_INTSTAT_RX_RDY_Pos)                 /*!< USART0 INTSTAT: RX_RDY Mask           */
#define USART0_INTSTAT_RXIDLE_Pos           1                                                       /*!< USART0 INTSTAT: RXIDLE Position       */
#define USART0_INTSTAT_RXIDLE_Msk           (0x01UL << USART0_INTSTAT_RXIDLE_Pos)                 /*!< USART0 INTSTAT: RXIDLE Mask           */
#define USART0_INTSTAT_TX_RDY_Pos           2                                                       /*!< USART0 INTSTAT: TX_RDY Position       */
#define USART0_INTSTAT_TX_RDY_Msk           (0x01UL << USART0_INTSTAT_TX_RDY_Pos)                 /*!< USART0 INTSTAT: TX_RDY Mask           */
#define USART0_INTSTAT_TXIDLE_Pos           3                                                       /*!< USART0 INTSTAT: TXIDLE Position       */
#define USART0_INTSTAT_TXIDLE_Msk           (0x01UL << USART0_INTSTAT_TXIDLE_Pos)                 /*!< USART0 INTSTAT: TXIDLE Mask           */
#define USART0_INTSTAT_DELTACTS_Pos         5                                                       /*!< USART0 INTSTAT: DELTACTS Position     */
#define USART0_INTSTAT_DELTACTS_Msk         (0x01UL << USART0_INTSTAT_DELTACTS_Pos)               /*!< USART0 INTSTAT: DELTACTS Mask         */
#define USART0_INTSTAT_TXDIS_Pos            6                                                       /*!< USART0 INTSTAT: TXDIS Position        */
#define USART0_INTSTAT_TXDIS_Msk            (0x01UL << USART0_INTSTAT_TXDIS_Pos)                  /*!< USART0 INTSTAT: TXDIS Mask            */
#define USART0_INTSTAT_OVERRUN_Pos          8                                                       /*!< USART0 INTSTAT: OVERRUN Position      */
#define USART0_INTSTAT_OVERRUN_Msk          (0x01UL << USART0_INTSTAT_OVERRUN_Pos)                /*!< USART0 INTSTAT: OVERRUN Mask          */
#define USART0_INTSTAT_DELTARXBRK_Pos       11                                                      /*!< USART0 INTSTAT: DELTARXBRK Position   */
#define USART0_INTSTAT_DELTARXBRK_Msk       (0x01UL << USART0_INTSTAT_DELTARXBRK_Pos)             /*!< USART0 INTSTAT: DELTARXBRK Mask       */
#define USART0_INTSTAT_START_Pos            12                                                      /*!< USART0 INTSTAT: START Position        */
#define USART0_INTSTAT_START_Msk            (0x01UL << USART0_INTSTAT_START_Pos)                  /*!< USART0 INTSTAT: START Mask            */
#define USART0_INTSTAT_FRAMERR_Pos          13                                                      /*!< USART0 INTSTAT: FRAMERR Position      */
#define USART0_INTSTAT_FRAMERR_Msk          (0x01UL << USART0_INTSTAT_FRAMERR_Pos)                /*!< USART0 INTSTAT: FRAMERR Mask          */
#define USART0_INTSTAT_PARITYERR_Pos        14                                                      /*!< USART0 INTSTAT: PARITYERR Position    */
#define USART0_INTSTAT_PARITYERR_Msk        (0x01UL << USART0_INTSTAT_PARITYERR_Pos)              /*!< USART0 INTSTAT: PARITYERR Mask        */
#define USART0_INTSTAT_RXNOISE_Pos          15                                                      /*!< USART0 INTSTAT: RXNOISE Position      */
#define USART0_INTSTAT_RXNOISE_Msk          (0x01UL << USART0_INTSTAT_RXNOISE_Pos)                /*!< USART0 INTSTAT: RXNOISE Mask          */
#define USART0_INTSTAT_ABERR_Pos            16                                                      /*!< USART0 INTSTAT: ABERR Position        */
#define USART0_INTSTAT_ABERR_Msk            (0x01UL << USART0_INTSTAT_ABERR_Pos)                  /*!< USART0 INTSTAT: ABERR Mask            */

/* --------------------------------  u0_usart_OSR  -------------------------------- */
#define USART0_OSR_OSRVAL_Pos               0                                                       /*!< USART0 OSR: OSRVAL Position           */
#define USART0_OSR_OSRVAL_Msk               (0x0fUL << USART0_OSR_OSRVAL_Pos)                     /*!< USART0 OSR: OSRVAL Mask               */

/* --------------------------------  u0_usart_ADDR  ------------------------------- */
#define USART0_ADDR_ADDRESS_Pos             0                                                       /*!< USART0 ADDR: ADDRESS Position         */
#define USART0_ADDR_ADDRESS_Msk             (0x000000ffUL << USART0_ADDR_ADDRESS_Pos)             /*!< USART0 ADDR: ADDRESS Mask             */

/* ------------------------------  u0_usart_FIFOCFG  ------------------------------ */
#define USART0_FIFOCFG_ENABLETX_Pos         0                                                       /*!< USART0 FIFOCFG: ENABLETX Position     */
#define USART0_FIFOCFG_ENABLETX_Msk         (0x01UL << USART0_FIFOCFG_ENABLETX_Pos)               /*!< USART0 FIFOCFG: ENABLETX Mask         */
#define USART0_FIFOCFG_ENABLERX_Pos         1                                                       /*!< USART0 FIFOCFG: ENABLERX Position     */
#define USART0_FIFOCFG_ENABLERX_Msk         (0x01UL << USART0_FIFOCFG_ENABLERX_Pos)               /*!< USART0 FIFOCFG: ENABLERX Mask         */
#define USART0_FIFOCFG_SIZE_Pos             4                                                       /*!< USART0 FIFOCFG: SIZE Position         */
#define USART0_FIFOCFG_SIZE_Msk             (0x03UL << USART0_FIFOCFG_SIZE_Pos)                   /*!< USART0 FIFOCFG: SIZE Mask             */
#define USART0_FIFOCFG_DMATX_Pos            12                                                      /*!< USART0 FIFOCFG: DMATX Position        */
#define USART0_FIFOCFG_DMATX_Msk            (0x01UL << USART0_FIFOCFG_DMATX_Pos)                  /*!< USART0 FIFOCFG: DMATX Mask            */
#define USART0_FIFOCFG_DMARX_Pos            13                                                      /*!< USART0 FIFOCFG: DMARX Position        */
#define USART0_FIFOCFG_DMARX_Msk            (0x01UL << USART0_FIFOCFG_DMARX_Pos)                  /*!< USART0 FIFOCFG: DMARX Mask            */
#define USART0_FIFOCFG_WAKETX_Pos           14                                                      /*!< USART0 FIFOCFG: WAKETX Position       */
#define USART0_FIFOCFG_WAKETX_Msk           (0x01UL << USART0_FIFOCFG_WAKETX_Pos)                 /*!< USART0 FIFOCFG: WAKETX Mask           */
#define USART0_FIFOCFG_WAKERX_Pos           15                                                      /*!< USART0 FIFOCFG: WAKERX Position       */
#define USART0_FIFOCFG_WAKERX_Msk           (0x01UL << USART0_FIFOCFG_WAKERX_Pos)                 /*!< USART0 FIFOCFG: WAKERX Mask           */
#define USART0_FIFOCFG_EMPTYTX_Pos          16                                                      /*!< USART0 FIFOCFG: EMPTYTX Position      */
#define USART0_FIFOCFG_EMPTYTX_Msk          (0x01UL << USART0_FIFOCFG_EMPTYTX_Pos)                /*!< USART0 FIFOCFG: EMPTYTX Mask          */
#define USART0_FIFOCFG_EMPTYRX_Pos          17                                                      /*!< USART0 FIFOCFG: EMPTYRX Position      */
#define USART0_FIFOCFG_EMPTYRX_Msk          (0x01UL << USART0_FIFOCFG_EMPTYRX_Pos)                /*!< USART0 FIFOCFG: EMPTYRX Mask          */
#define USART0_FIFOCFG_POPDBG_Pos           18                                                      /*!< USART0 FIFOCFG: POPDBG Position       */
#define USART0_FIFOCFG_POPDBG_Msk           (0x01UL << USART0_FIFOCFG_POPDBG_Pos)                 /*!< USART0 FIFOCFG: POPDBG Mask           */

/* ------------------------------  u0_usart_FIFOSTAT  ----------------------------- */
#define USART0_FIFOSTAT_TXERR_Pos           0                                                       /*!< USART0 FIFOSTAT: TXERR Position       */
#define USART0_FIFOSTAT_TXERR_Msk           (0x01UL << USART0_FIFOSTAT_TXERR_Pos)                 /*!< USART0 FIFOSTAT: TXERR Mask           */
#define USART0_FIFOSTAT_RXERR_Pos           1                                                       /*!< USART0 FIFOSTAT: RXERR Position       */
#define USART0_FIFOSTAT_RXERR_Msk           (0x01UL << USART0_FIFOSTAT_RXERR_Pos)                 /*!< USART0 FIFOSTAT: RXERR Mask           */
#define USART0_FIFOSTAT_PERINT_Pos          3                                                       /*!< USART0 FIFOSTAT: PERINT Position      */
#define USART0_FIFOSTAT_PERINT_Msk          (0x01UL << USART0_FIFOSTAT_PERINT_Pos)                /*!< USART0 FIFOSTAT: PERINT Mask          */
#define USART0_FIFOSTAT_TXEMPTY_Pos         4                                                       /*!< USART0 FIFOSTAT: TXEMPTY Position     */
#define USART0_FIFOSTAT_TXEMPTY_Msk         (0x01UL << USART0_FIFOSTAT_TXEMPTY_Pos)               /*!< USART0 FIFOSTAT: TXEMPTY Mask         */
#define USART0_FIFOSTAT_TXNOTFULL_Pos       5                                                       /*!< USART0 FIFOSTAT: TXNOTFULL Position   */
#define USART0_FIFOSTAT_TXNOTFULL_Msk       (0x01UL << USART0_FIFOSTAT_TXNOTFULL_Pos)             /*!< USART0 FIFOSTAT: TXNOTFULL Mask       */
#define USART0_FIFOSTAT_RXNOTEMPTY_Pos      6                                                       /*!< USART0 FIFOSTAT: RXNOTEMPTY Position  */
#define USART0_FIFOSTAT_RXNOTEMPTY_Msk      (0x01UL << USART0_FIFOSTAT_RXNOTEMPTY_Pos)            /*!< USART0 FIFOSTAT: RXNOTEMPTY Mask      */
#define USART0_FIFOSTAT_RXFULL_Pos          7                                                       /*!< USART0 FIFOSTAT: RXFULL Position      */
#define USART0_FIFOSTAT_RXFULL_Msk          (0x01UL << USART0_FIFOSTAT_RXFULL_Pos)                /*!< USART0 FIFOSTAT: RXFULL Mask          */
#define USART0_FIFOSTAT_TXLVL_Pos           8                                                       /*!< USART0 FIFOSTAT: TXLVL Position       */
#define USART0_FIFOSTAT_TXLVL_Msk           (0x1fUL << USART0_FIFOSTAT_TXLVL_Pos)                 /*!< USART0 FIFOSTAT: TXLVL Mask           */
#define USART0_FIFOSTAT_RXLVL_Pos           16                                                      /*!< USART0 FIFOSTAT: RXLVL Position       */
#define USART0_FIFOSTAT_RXLVL_Msk           (0x1fUL << USART0_FIFOSTAT_RXLVL_Pos)                 /*!< USART0 FIFOSTAT: RXLVL Mask           */

/* ------------------------------  u0_usart_FIFOTRIG  ----------------------------- */
#define USART0_FIFOTRIG_TXLVLENA_Pos        0                                                       /*!< USART0 FIFOTRIG: TXLVLENA Position    */
#define USART0_FIFOTRIG_TXLVLENA_Msk        (0x01UL << USART0_FIFOTRIG_TXLVLENA_Pos)              /*!< USART0 FIFOTRIG: TXLVLENA Mask        */
#define USART0_FIFOTRIG_RXLVLENA_Pos        1                                                       /*!< USART0 FIFOTRIG: RXLVLENA Position    */
#define USART0_FIFOTRIG_RXLVLENA_Msk        (0x01UL << USART0_FIFOTRIG_RXLVLENA_Pos)              /*!< USART0 FIFOTRIG: RXLVLENA Mask        */
#define USART0_FIFOTRIG_TXLVL_Pos           8                                                       /*!< USART0 FIFOTRIG: TXLVL Position       */
#define USART0_FIFOTRIG_TXLVL_Msk           (0x0fUL << USART0_FIFOTRIG_TXLVL_Pos)                 /*!< USART0 FIFOTRIG: TXLVL Mask           */
#define USART0_FIFOTRIG_RXLVL_Pos           16                                                      /*!< USART0 FIFOTRIG: RXLVL Position       */
#define USART0_FIFOTRIG_RXLVL_Msk           (0x0fUL << USART0_FIFOTRIG_RXLVL_Pos)                 /*!< USART0 FIFOTRIG: RXLVL Mask           */

/* ----------------------------  u0_usart_FIFOINTENSET  --------------------------- */
#define USART0_FIFOINTENSET_TXERR_Pos       0                                                       /*!< USART0 FIFOINTENSET: TXERR Position   */
#define USART0_FIFOINTENSET_TXERR_Msk       (0x01UL << USART0_FIFOINTENSET_TXERR_Pos)             /*!< USART0 FIFOINTENSET: TXERR Mask       */
#define USART0_FIFOINTENSET_RXERR_Pos       1                                                       /*!< USART0 FIFOINTENSET: RXERR Position   */
#define USART0_FIFOINTENSET_RXERR_Msk       (0x01UL << USART0_FIFOINTENSET_RXERR_Pos)             /*!< USART0 FIFOINTENSET: RXERR Mask       */
#define USART0_FIFOINTENSET_TXLVL_Pos       2                                                       /*!< USART0 FIFOINTENSET: TXLVL Position   */
#define USART0_FIFOINTENSET_TXLVL_Msk       (0x01UL << USART0_FIFOINTENSET_TXLVL_Pos)             /*!< USART0 FIFOINTENSET: TXLVL Mask       */
#define USART0_FIFOINTENSET_RXLVL_Pos       3                                                       /*!< USART0 FIFOINTENSET: RXLVL Position   */
#define USART0_FIFOINTENSET_RXLVL_Msk       (0x01UL << USART0_FIFOINTENSET_RXLVL_Pos)             /*!< USART0 FIFOINTENSET: RXLVL Mask       */

/* ----------------------------  u0_usart_FIFOINTENCLR  --------------------------- */
#define USART0_FIFOINTENCLR_TXERR_Pos       0                                                       /*!< USART0 FIFOINTENCLR: TXERR Position   */
#define USART0_FIFOINTENCLR_TXERR_Msk       (0x01UL << USART0_FIFOINTENCLR_TXERR_Pos)             /*!< USART0 FIFOINTENCLR: TXERR Mask       */
#define USART0_FIFOINTENCLR_RXERR_Pos       1                                                       /*!< USART0 FIFOINTENCLR: RXERR Position   */
#define USART0_FIFOINTENCLR_RXERR_Msk       (0x01UL << USART0_FIFOINTENCLR_RXERR_Pos)             /*!< USART0 FIFOINTENCLR: RXERR Mask       */
#define USART0_FIFOINTENCLR_TXLVL_Pos       2                                                       /*!< USART0 FIFOINTENCLR: TXLVL Position   */
#define USART0_FIFOINTENCLR_TXLVL_Msk       (0x01UL << USART0_FIFOINTENCLR_TXLVL_Pos)             /*!< USART0 FIFOINTENCLR: TXLVL Mask       */
#define USART0_FIFOINTENCLR_RXLVL_Pos       3                                                       /*!< USART0 FIFOINTENCLR: RXLVL Position   */
#define USART0_FIFOINTENCLR_RXLVL_Msk       (0x01UL << USART0_FIFOINTENCLR_RXLVL_Pos)             /*!< USART0 FIFOINTENCLR: RXLVL Mask       */

/* ----------------------------  u0_usart_FIFOINTSTAT  ---------------------------- */
#define USART0_FIFOINTSTAT_TXERR_Pos        0                                                       /*!< USART0 FIFOINTSTAT: TXERR Position    */
#define USART0_FIFOINTSTAT_TXERR_Msk        (0x01UL << USART0_FIFOINTSTAT_TXERR_Pos)              /*!< USART0 FIFOINTSTAT: TXERR Mask        */
#define USART0_FIFOINTSTAT_RXERR_Pos        1                                                       /*!< USART0 FIFOINTSTAT: RXERR Position    */
#define USART0_FIFOINTSTAT_RXERR_Msk        (0x01UL << USART0_FIFOINTSTAT_RXERR_Pos)              /*!< USART0 FIFOINTSTAT: RXERR Mask        */
#define USART0_FIFOINTSTAT_TXLVL_Pos        2                                                       /*!< USART0 FIFOINTSTAT: TXLVL Position    */
#define USART0_FIFOINTSTAT_TXLVL_Msk        (0x01UL << USART0_FIFOINTSTAT_TXLVL_Pos)              /*!< USART0 FIFOINTSTAT: TXLVL Mask        */
#define USART0_FIFOINTSTAT_RXLVL_Pos        3                                                       /*!< USART0 FIFOINTSTAT: RXLVL Position    */
#define USART0_FIFOINTSTAT_RXLVL_Msk        (0x01UL << USART0_FIFOINTSTAT_RXLVL_Pos)              /*!< USART0 FIFOINTSTAT: RXLVL Mask        */
#define USART0_FIFOINTSTAT_PERINT_Pos       4                                                       /*!< USART0 FIFOINTSTAT: PERINT Position   */
#define USART0_FIFOINTSTAT_PERINT_Msk       (0x01UL << USART0_FIFOINTSTAT_PERINT_Pos)             /*!< USART0 FIFOINTSTAT: PERINT Mask       */

/* -------------------------------  u0_usart_FIFOWR  ------------------------------ */
#define USART0_FIFOWR_TXDATA_Pos            0                                                       /*!< USART0 FIFOWR: TXDATA Position        */
#define USART0_FIFOWR_TXDATA_Msk            (0x000000ffUL << USART0_FIFOWR_TXDATA_Pos)            /*!< USART0 FIFOWR: TXDATA Mask            */

/* -------------------------------  u0_usart_FIFORD  ------------------------------ */
#define USART0_FIFORD_RXDATA_Pos            0                                                       /*!< USART0 FIFORD: RXDATA Position        */
#define USART0_FIFORD_RXDATA_Msk            (0x000001ffUL << USART0_FIFORD_RXDATA_Pos)            /*!< USART0 FIFORD: RXDATA Mask            */
#define USART0_FIFORD_FRAMERR_Pos           13                                                      /*!< USART0 FIFORD: FRAMERR Position       */
#define USART0_FIFORD_FRAMERR_Msk           (0x01UL << USART0_FIFORD_FRAMERR_Pos)                 /*!< USART0 FIFORD: FRAMERR Mask           */
#define USART0_FIFORD_PARITYERR_Pos         14                                                      /*!< USART0 FIFORD: PARITYERR Position     */
#define USART0_FIFORD_PARITYERR_Msk         (0x01UL << USART0_FIFORD_PARITYERR_Pos)               /*!< USART0 FIFORD: PARITYERR Mask         */
#define USART0_FIFORD_RXNOISE_Pos           15                                                      /*!< USART0 FIFORD: RXNOISE Position       */
#define USART0_FIFORD_RXNOISE_Msk           (0x01UL << USART0_FIFORD_RXNOISE_Pos)                 /*!< USART0 FIFORD: RXNOISE Mask           */

/* ----------------------------  u0_usart_FIFORDNOPOP  ---------------------------- */
#define USART0_FIFORDNOPOP_RXDATA_Pos       0                                                       /*!< USART0 FIFORDNOPOP: RXDATA Position   */
#define USART0_FIFORDNOPOP_RXDATA_Msk       (0x000001ffUL << USART0_FIFORDNOPOP_RXDATA_Pos)       /*!< USART0 FIFORDNOPOP: RXDATA Mask       */
#define USART0_FIFORDNOPOP_FRAMERR_Pos      13                                                      /*!< USART0 FIFORDNOPOP: FRAMERR Position  */
#define USART0_FIFORDNOPOP_FRAMERR_Msk      (0x01UL << USART0_FIFORDNOPOP_FRAMERR_Pos)            /*!< USART0 FIFORDNOPOP: FRAMERR Mask      */
#define USART0_FIFORDNOPOP_PARITYERR_Pos    14                                                      /*!< USART0 FIFORDNOPOP: PARITYERR Position */
#define USART0_FIFORDNOPOP_PARITYERR_Msk    (0x01UL << USART0_FIFORDNOPOP_PARITYERR_Pos)          /*!< USART0 FIFORDNOPOP: PARITYERR Mask    */
#define USART0_FIFORDNOPOP_RXNOISE_Pos      15                                                      /*!< USART0 FIFORDNOPOP: RXNOISE Position  */
#define USART0_FIFORDNOPOP_RXNOISE_Msk      (0x01UL << USART0_FIFORDNOPOP_RXNOISE_Pos)            /*!< USART0 FIFORDNOPOP: RXNOISE Mask      */

/* -------------------------------  u0_usart_PSELID  ------------------------------ */
#define USART0_PSELID_PERSEL_Pos            0                                                       /*!< USART0 PSELID: PERSEL Position        */
#define USART0_PSELID_PERSEL_Msk            (0x07UL << USART0_PSELID_PERSEL_Pos)                  /*!< USART0 PSELID: PERSEL Mask            */
#define USART0_PSELID_LOCK_Pos              3                                                       /*!< USART0 PSELID: LOCK Position          */
#define USART0_PSELID_LOCK_Msk              (0x01UL << USART0_PSELID_LOCK_Pos)                    /*!< USART0 PSELID: LOCK Mask              */
#define USART0_PSELID_USARTPRESENT_Pos      4                                                       /*!< USART0 PSELID: USARTPRESENT Position  */
#define USART0_PSELID_USARTPRESENT_Msk      (0x01UL << USART0_PSELID_USARTPRESENT_Pos)            /*!< USART0 PSELID: USARTPRESENT Mask      */
#define USART0_PSELID_ID_Pos                12                                                      /*!< USART0 PSELID: ID Position            */
#define USART0_PSELID_ID_Msk                (0x000fffffUL << USART0_PSELID_ID_Pos)                /*!< USART0 PSELID: ID Mask                */

/* ---------------------------------  u0_usart_ID  -------------------------------- */
#define USART0_ID_APERTURE_Pos              0                                                       /*!< USART0 ID: APERTURE Position          */
#define USART0_ID_APERTURE_Msk              (0x000000ffUL << USART0_ID_APERTURE_Pos)              /*!< USART0 ID: APERTURE Mask              */
#define USART0_ID_MIN_REV_Pos               8                                                       /*!< USART0 ID: MIN_REV Position           */
#define USART0_ID_MIN_REV_Msk               (0x0fUL << USART0_ID_MIN_REV_Pos)                     /*!< USART0 ID: MIN_REV Mask               */
#define USART0_ID_MAJ_REV_Pos               12                                                      /*!< USART0 ID: MAJ_REV Position           */
#define USART0_ID_MAJ_REV_Msk               (0x0fUL << USART0_ID_MAJ_REV_Pos)                     /*!< USART0 ID: MAJ_REV Mask               */
#define USART0_ID_ID_Pos                    16                                                      /*!< USART0 ID: ID Position                */
#define USART0_ID_ID_Msk                    (0x0000ffffUL << USART0_ID_ID_Pos)                    /*!< USART0 ID: ID Mask                    */


/* ================================================================================ */
/* ================        struct 'u1_usart' Position & Mask       ================ */
/* ================================================================================ */


/* --------------------------------  u1_usart_CFG  -------------------------------- */
#define USART1_CFG_ENABLE_Pos               0                                                       /*!< USART1 CFG: ENABLE Position           */
#define USART1_CFG_ENABLE_Msk               (0x01UL << USART1_CFG_ENABLE_Pos)                     /*!< USART1 CFG: ENABLE Mask               */
#define USART1_CFG_DATALEN_Pos              2                                                       /*!< USART1 CFG: DATALEN Position          */
#define USART1_CFG_DATALEN_Msk              (0x03UL << USART1_CFG_DATALEN_Pos)                    /*!< USART1 CFG: DATALEN Mask              */
#define USART1_CFG_PARITYSEL_Pos            4                                                       /*!< USART1 CFG: PARITYSEL Position        */
#define USART1_CFG_PARITYSEL_Msk            (0x03UL << USART1_CFG_PARITYSEL_Pos)                  /*!< USART1 CFG: PARITYSEL Mask            */
#define USART1_CFG_STOPLEN_Pos              6                                                       /*!< USART1 CFG: STOPLEN Position          */
#define USART1_CFG_STOPLEN_Msk              (0x01UL << USART1_CFG_STOPLEN_Pos)                    /*!< USART1 CFG: STOPLEN Mask              */
#define USART1_CFG_MODE32K_Pos              7                                                       /*!< USART1 CFG: MODE32K Position          */
#define USART1_CFG_MODE32K_Msk              (0x01UL << USART1_CFG_MODE32K_Pos)                    /*!< USART1 CFG: MODE32K Mask              */
#define USART1_CFG_LINMODE_Pos              8                                                       /*!< USART1 CFG: LINMODE Position          */
#define USART1_CFG_LINMODE_Msk              (0x01UL << USART1_CFG_LINMODE_Pos)                    /*!< USART1 CFG: LINMODE Mask              */
#define USART1_CFG_CTSEN_Pos                9                                                       /*!< USART1 CFG: CTSEN Position            */
#define USART1_CFG_CTSEN_Msk                (0x01UL << USART1_CFG_CTSEN_Pos)                      /*!< USART1 CFG: CTSEN Mask                */
#define USART1_CFG_SYNCEN_Pos               11                                                      /*!< USART1 CFG: SYNCEN Position           */
#define USART1_CFG_SYNCEN_Msk               (0x01UL << USART1_CFG_SYNCEN_Pos)                     /*!< USART1 CFG: SYNCEN Mask               */
#define USART1_CFG_CLKPOL_Pos               12                                                      /*!< USART1 CFG: CLKPOL Position           */
#define USART1_CFG_CLKPOL_Msk               (0x01UL << USART1_CFG_CLKPOL_Pos)                     /*!< USART1 CFG: CLKPOL Mask               */
#define USART1_CFG_SYNCMST_Pos              14                                                      /*!< USART1 CFG: SYNCMST Position          */
#define USART1_CFG_SYNCMST_Msk              (0x01UL << USART1_CFG_SYNCMST_Pos)                    /*!< USART1 CFG: SYNCMST Mask              */
#define USART1_CFG_LOOP_Pos                 15                                                      /*!< USART1 CFG: LOOP Position             */
#define USART1_CFG_LOOP_Msk                 (0x01UL << USART1_CFG_LOOP_Pos)                       /*!< USART1 CFG: LOOP Mask                 */
#define USART1_CFG_IOMODE_Pos               16                                                      /*!< USART1 CFG: IOMODE Position           */
#define USART1_CFG_IOMODE_Msk               (0x01UL << USART1_CFG_IOMODE_Pos)                     /*!< USART1 CFG: IOMODE Mask               */
#define USART1_CFG_OETA_Pos                 18                                                      /*!< USART1 CFG: OETA Position             */
#define USART1_CFG_OETA_Msk                 (0x01UL << USART1_CFG_OETA_Pos)                       /*!< USART1 CFG: OETA Mask                 */
#define USART1_CFG_AUTOADDR_Pos             19                                                      /*!< USART1 CFG: AUTOADDR Position         */
#define USART1_CFG_AUTOADDR_Msk             (0x01UL << USART1_CFG_AUTOADDR_Pos)                   /*!< USART1 CFG: AUTOADDR Mask             */
#define USART1_CFG_OESEL_Pos                20                                                      /*!< USART1 CFG: OESEL Position            */
#define USART1_CFG_OESEL_Msk                (0x01UL << USART1_CFG_OESEL_Pos)                      /*!< USART1 CFG: OESEL Mask                */
#define USART1_CFG_OEPOL_Pos                21                                                      /*!< USART1 CFG: OEPOL Position            */
#define USART1_CFG_OEPOL_Msk                (0x01UL << USART1_CFG_OEPOL_Pos)                      /*!< USART1 CFG: OEPOL Mask                */
#define USART1_CFG_RXPOL_Pos                22                                                      /*!< USART1 CFG: RXPOL Position            */
#define USART1_CFG_RXPOL_Msk                (0x01UL << USART1_CFG_RXPOL_Pos)                      /*!< USART1 CFG: RXPOL Mask                */
#define USART1_CFG_TXPOL_Pos                23                                                      /*!< USART1 CFG: TXPOL Position            */
#define USART1_CFG_TXPOL_Msk                (0x01UL << USART1_CFG_TXPOL_Pos)                      /*!< USART1 CFG: TXPOL Mask                */

/* --------------------------------  u1_usart_CTL  -------------------------------- */
#define USART1_CTL_TXBRKEN_Pos              1                                                       /*!< USART1 CTL: TXBRKEN Position          */
#define USART1_CTL_TXBRKEN_Msk              (0x01UL << USART1_CTL_TXBRKEN_Pos)                    /*!< USART1 CTL: TXBRKEN Mask              */
#define USART1_CTL_ADDRDET_Pos              2                                                       /*!< USART1 CTL: ADDRDET Position          */
#define USART1_CTL_ADDRDET_Msk              (0x01UL << USART1_CTL_ADDRDET_Pos)                    /*!< USART1 CTL: ADDRDET Mask              */
#define USART1_CTL_TXDIS_Pos                6                                                       /*!< USART1 CTL: TXDIS Position            */
#define USART1_CTL_TXDIS_Msk                (0x01UL << USART1_CTL_TXDIS_Pos)                      /*!< USART1 CTL: TXDIS Mask                */
#define USART1_CTL_CC_Pos                   8                                                       /*!< USART1 CTL: CC Position               */
#define USART1_CTL_CC_Msk                   (0x01UL << USART1_CTL_CC_Pos)                         /*!< USART1 CTL: CC Mask                   */
#define USART1_CTL_CLRCCONRX_Pos            9                                                       /*!< USART1 CTL: CLRCCONRX Position        */
#define USART1_CTL_CLRCCONRX_Msk            (0x01UL << USART1_CTL_CLRCCONRX_Pos)                  /*!< USART1 CTL: CLRCCONRX Mask            */
#define USART1_CTL_AUTOBAUD_Pos             16                                                      /*!< USART1 CTL: AUTOBAUD Position         */
#define USART1_CTL_AUTOBAUD_Msk             (0x01UL << USART1_CTL_AUTOBAUD_Pos)                   /*!< USART1 CTL: AUTOBAUD Mask             */

/* --------------------------------  u1_usart_STAT  ------------------------------- */
#define USART1_STAT_RXIDLE_Pos              1                                                       /*!< USART1 STAT: RXIDLE Position          */
#define USART1_STAT_RXIDLE_Msk              (0x01UL << USART1_STAT_RXIDLE_Pos)                    /*!< USART1 STAT: RXIDLE Mask              */
#define USART1_STAT_TXIDLE_Pos              3                                                       /*!< USART1 STAT: TXIDLE Position          */
#define USART1_STAT_TXIDLE_Msk              (0x01UL << USART1_STAT_TXIDLE_Pos)                    /*!< USART1 STAT: TXIDLE Mask              */
#define USART1_STAT_CTS_Pos                 4                                                       /*!< USART1 STAT: CTS Position             */
#define USART1_STAT_CTS_Msk                 (0x01UL << USART1_STAT_CTS_Pos)                       /*!< USART1 STAT: CTS Mask                 */
#define USART1_STAT_DELTACTS_Pos            5                                                       /*!< USART1 STAT: DELTACTS Position        */
#define USART1_STAT_DELTACTS_Msk            (0x01UL << USART1_STAT_DELTACTS_Pos)                  /*!< USART1 STAT: DELTACTS Mask            */
#define USART1_STAT_TXDISSTAT_Pos           6                                                       /*!< USART1 STAT: TXDISSTAT Position       */
#define USART1_STAT_TXDISSTAT_Msk           (0x01UL << USART1_STAT_TXDISSTAT_Pos)                 /*!< USART1 STAT: TXDISSTAT Mask           */
#define USART1_STAT_OVERRUNINT_Pos          8                                                       /*!< USART1 STAT: OVERRUNINT Position      */
#define USART1_STAT_OVERRUNINT_Msk          (0x01UL << USART1_STAT_OVERRUNINT_Pos)                /*!< USART1 STAT: OVERRUNINT Mask          */
#define USART1_STAT_RXBRK_Pos               10                                                      /*!< USART1 STAT: RXBRK Position           */
#define USART1_STAT_RXBRK_Msk               (0x01UL << USART1_STAT_RXBRK_Pos)                     /*!< USART1 STAT: RXBRK Mask               */
#define USART1_STAT_DELTARXBRK_Pos          11                                                      /*!< USART1 STAT: DELTARXBRK Position      */
#define USART1_STAT_DELTARXBRK_Msk          (0x01UL << USART1_STAT_DELTARXBRK_Pos)                /*!< USART1 STAT: DELTARXBRK Mask          */
#define USART1_STAT_START_Pos               12                                                      /*!< USART1 STAT: START Position           */
#define USART1_STAT_START_Msk               (0x01UL << USART1_STAT_START_Pos)                     /*!< USART1 STAT: START Mask               */
#define USART1_STAT_FRAMERRINT_Pos          13                                                      /*!< USART1 STAT: FRAMERRINT Position      */
#define USART1_STAT_FRAMERRINT_Msk          (0x01UL << USART1_STAT_FRAMERRINT_Pos)                /*!< USART1 STAT: FRAMERRINT Mask          */
#define USART1_STAT_PARITYERRINT_Pos        14                                                      /*!< USART1 STAT: PARITYERRINT Position    */
#define USART1_STAT_PARITYERRINT_Msk        (0x01UL << USART1_STAT_PARITYERRINT_Pos)              /*!< USART1 STAT: PARITYERRINT Mask        */
#define USART1_STAT_RXNOISEINT_Pos          15                                                      /*!< USART1 STAT: RXNOISEINT Position      */
#define USART1_STAT_RXNOISEINT_Msk          (0x01UL << USART1_STAT_RXNOISEINT_Pos)                /*!< USART1 STAT: RXNOISEINT Mask          */
#define USART1_STAT_ABERR_Pos               16                                                      /*!< USART1 STAT: ABERR Position           */
#define USART1_STAT_ABERR_Msk               (0x01UL << USART1_STAT_ABERR_Pos)                     /*!< USART1 STAT: ABERR Mask               */

/* ------------------------------  u1_usart_INTENSET  ----------------------------- */
#define USART1_INTENSET_RXRDYEN_Pos         0                                                       /*!< USART1 INTENSET: RXRDYEN Position     */
#define USART1_INTENSET_RXRDYEN_Msk         (0x01UL << USART1_INTENSET_RXRDYEN_Pos)               /*!< USART1 INTENSET: RXRDYEN Mask         */
#define USART1_INTENSET_TXRDTEN_Pos         2                                                       /*!< USART1 INTENSET: TXRDTEN Position     */
#define USART1_INTENSET_TXRDTEN_Msk         (0x01UL << USART1_INTENSET_TXRDTEN_Pos)               /*!< USART1 INTENSET: TXRDTEN Mask         */
#define USART1_INTENSET_TXIDLEEN_Pos        3                                                       /*!< USART1 INTENSET: TXIDLEEN Position    */
#define USART1_INTENSET_TXIDLEEN_Msk        (0x01UL << USART1_INTENSET_TXIDLEEN_Pos)              /*!< USART1 INTENSET: TXIDLEEN Mask        */
#define USART1_INTENSET_DELTACTSEN_Pos      5                                                       /*!< USART1 INTENSET: DELTACTSEN Position  */
#define USART1_INTENSET_DELTACTSEN_Msk      (0x01UL << USART1_INTENSET_DELTACTSEN_Pos)            /*!< USART1 INTENSET: DELTACTSEN Mask      */
#define USART1_INTENSET_TXDISEN_Pos         6                                                       /*!< USART1 INTENSET: TXDISEN Position     */
#define USART1_INTENSET_TXDISEN_Msk         (0x01UL << USART1_INTENSET_TXDISEN_Pos)               /*!< USART1 INTENSET: TXDISEN Mask         */
#define USART1_INTENSET_OVERRUNEN_Pos       8                                                       /*!< USART1 INTENSET: OVERRUNEN Position   */
#define USART1_INTENSET_OVERRUNEN_Msk       (0x01UL << USART1_INTENSET_OVERRUNEN_Pos)             /*!< USART1 INTENSET: OVERRUNEN Mask       */
#define USART1_INTENSET_DELTARXBRKEN_Pos    11                                                      /*!< USART1 INTENSET: DELTARXBRKEN Position */
#define USART1_INTENSET_DELTARXBRKEN_Msk    (0x01UL << USART1_INTENSET_DELTARXBRKEN_Pos)          /*!< USART1 INTENSET: DELTARXBRKEN Mask    */
#define USART1_INTENSET_STARTEN_Pos         12                                                      /*!< USART1 INTENSET: STARTEN Position     */
#define USART1_INTENSET_STARTEN_Msk         (0x01UL << USART1_INTENSET_STARTEN_Pos)               /*!< USART1 INTENSET: STARTEN Mask         */
#define USART1_INTENSET_FRAMERREN_Pos       13                                                      /*!< USART1 INTENSET: FRAMERREN Position   */
#define USART1_INTENSET_FRAMERREN_Msk       (0x01UL << USART1_INTENSET_FRAMERREN_Pos)             /*!< USART1 INTENSET: FRAMERREN Mask       */
#define USART1_INTENSET_PARITYERREN_Pos     14                                                      /*!< USART1 INTENSET: PARITYERREN Position */
#define USART1_INTENSET_PARITYERREN_Msk     (0x01UL << USART1_INTENSET_PARITYERREN_Pos)           /*!< USART1 INTENSET: PARITYERREN Mask     */
#define USART1_INTENSET_RXNOISEEN_Pos       15                                                      /*!< USART1 INTENSET: RXNOISEEN Position   */
#define USART1_INTENSET_RXNOISEEN_Msk       (0x01UL << USART1_INTENSET_RXNOISEEN_Pos)             /*!< USART1 INTENSET: RXNOISEEN Mask       */
#define USART1_INTENSET_ABERREN_Pos         16                                                      /*!< USART1 INTENSET: ABERREN Position     */
#define USART1_INTENSET_ABERREN_Msk         (0x01UL << USART1_INTENSET_ABERREN_Pos)               /*!< USART1 INTENSET: ABERREN Mask         */

/* ------------------------------  u1_usart_INTENCLR  ----------------------------- */
#define USART1_INTENCLR_RXRDYCLR_Pos        0                                                       /*!< USART1 INTENCLR: RXRDYCLR Position    */
#define USART1_INTENCLR_RXRDYCLR_Msk        (0x01UL << USART1_INTENCLR_RXRDYCLR_Pos)              /*!< USART1 INTENCLR: RXRDYCLR Mask        */
#define USART1_INTENCLR_TXRDYCLR_Pos        2                                                       /*!< USART1 INTENCLR: TXRDYCLR Position    */
#define USART1_INTENCLR_TXRDYCLR_Msk        (0x01UL << USART1_INTENCLR_TXRDYCLR_Pos)              /*!< USART1 INTENCLR: TXRDYCLR Mask        */
#define USART1_INTENCLR_TXIDLECLR_Pos       3                                                       /*!< USART1 INTENCLR: TXIDLECLR Position   */
#define USART1_INTENCLR_TXIDLECLR_Msk       (0x01UL << USART1_INTENCLR_TXIDLECLR_Pos)             /*!< USART1 INTENCLR: TXIDLECLR Mask       */
#define USART1_INTENCLR_DELTACTSCLR_Pos     5                                                       /*!< USART1 INTENCLR: DELTACTSCLR Position */
#define USART1_INTENCLR_DELTACTSCLR_Msk     (0x01UL << USART1_INTENCLR_DELTACTSCLR_Pos)           /*!< USART1 INTENCLR: DELTACTSCLR Mask     */
#define USART1_INTENCLR_TXDISCLR_Pos        6                                                       /*!< USART1 INTENCLR: TXDISCLR Position    */
#define USART1_INTENCLR_TXDISCLR_Msk        (0x01UL << USART1_INTENCLR_TXDISCLR_Pos)              /*!< USART1 INTENCLR: TXDISCLR Mask        */
#define USART1_INTENCLR_OVERRUNCLR_Pos      8                                                       /*!< USART1 INTENCLR: OVERRUNCLR Position  */
#define USART1_INTENCLR_OVERRUNCLR_Msk      (0x01UL << USART1_INTENCLR_OVERRUNCLR_Pos)            /*!< USART1 INTENCLR: OVERRUNCLR Mask      */
#define USART1_INTENCLR_DELTARXBRKCLR_Pos   11                                                      /*!< USART1 INTENCLR: DELTARXBRKCLR Position */
#define USART1_INTENCLR_DELTARXBRKCLR_Msk   (0x01UL << USART1_INTENCLR_DELTARXBRKCLR_Pos)         /*!< USART1 INTENCLR: DELTARXBRKCLR Mask   */
#define USART1_INTENCLR_STARTCLR_Pos        12                                                      /*!< USART1 INTENCLR: STARTCLR Position    */
#define USART1_INTENCLR_STARTCLR_Msk        (0x01UL << USART1_INTENCLR_STARTCLR_Pos)              /*!< USART1 INTENCLR: STARTCLR Mask        */
#define USART1_INTENCLR_FRAMERRCLR_Pos      13                                                      /*!< USART1 INTENCLR: FRAMERRCLR Position  */
#define USART1_INTENCLR_FRAMERRCLR_Msk      (0x01UL << USART1_INTENCLR_FRAMERRCLR_Pos)            /*!< USART1 INTENCLR: FRAMERRCLR Mask      */
#define USART1_INTENCLR_PARITYERRCLR_Pos    14                                                      /*!< USART1 INTENCLR: PARITYERRCLR Position */
#define USART1_INTENCLR_PARITYERRCLR_Msk    (0x01UL << USART1_INTENCLR_PARITYERRCLR_Pos)          /*!< USART1 INTENCLR: PARITYERRCLR Mask    */
#define USART1_INTENCLR_RXNOISECLR_Pos      15                                                      /*!< USART1 INTENCLR: RXNOISECLR Position  */
#define USART1_INTENCLR_RXNOISECLR_Msk      (0x01UL << USART1_INTENCLR_RXNOISECLR_Pos)            /*!< USART1 INTENCLR: RXNOISECLR Mask      */
#define USART1_INTENCLR_ABERRCLR_Pos        16                                                      /*!< USART1 INTENCLR: ABERRCLR Position    */
#define USART1_INTENCLR_ABERRCLR_Msk        (0x01UL << USART1_INTENCLR_ABERRCLR_Pos)              /*!< USART1 INTENCLR: ABERRCLR Mask        */

/* --------------------------------  u1_usart_BRG  -------------------------------- */
#define USART1_BRG_BRGVAL_Pos               0                                                       /*!< USART1 BRG: BRGVAL Position           */
#define USART1_BRG_BRGVAL_Msk               (0x0000ffffUL << USART1_BRG_BRGVAL_Pos)               /*!< USART1 BRG: BRGVAL Mask               */

/* ------------------------------  u1_usart_INTSTAT  ------------------------------ */
#define USART1_INTSTAT_RX_RDY_Pos           0                                                       /*!< USART1 INTSTAT: RX_RDY Position       */
#define USART1_INTSTAT_RX_RDY_Msk           (0x01UL << USART1_INTSTAT_RX_RDY_Pos)                 /*!< USART1 INTSTAT: RX_RDY Mask           */
#define USART1_INTSTAT_RXIDLE_Pos           1                                                       /*!< USART1 INTSTAT: RXIDLE Position       */
#define USART1_INTSTAT_RXIDLE_Msk           (0x01UL << USART1_INTSTAT_RXIDLE_Pos)                 /*!< USART1 INTSTAT: RXIDLE Mask           */
#define USART1_INTSTAT_TX_RDY_Pos           2                                                       /*!< USART1 INTSTAT: TX_RDY Position       */
#define USART1_INTSTAT_TX_RDY_Msk           (0x01UL << USART1_INTSTAT_TX_RDY_Pos)                 /*!< USART1 INTSTAT: TX_RDY Mask           */
#define USART1_INTSTAT_TXIDLE_Pos           3                                                       /*!< USART1 INTSTAT: TXIDLE Position       */
#define USART1_INTSTAT_TXIDLE_Msk           (0x01UL << USART1_INTSTAT_TXIDLE_Pos)                 /*!< USART1 INTSTAT: TXIDLE Mask           */
#define USART1_INTSTAT_DELTACTS_Pos         5                                                       /*!< USART1 INTSTAT: DELTACTS Position     */
#define USART1_INTSTAT_DELTACTS_Msk         (0x01UL << USART1_INTSTAT_DELTACTS_Pos)               /*!< USART1 INTSTAT: DELTACTS Mask         */
#define USART1_INTSTAT_TXDIS_Pos            6                                                       /*!< USART1 INTSTAT: TXDIS Position        */
#define USART1_INTSTAT_TXDIS_Msk            (0x01UL << USART1_INTSTAT_TXDIS_Pos)                  /*!< USART1 INTSTAT: TXDIS Mask            */
#define USART1_INTSTAT_OVERRUN_Pos          8                                                       /*!< USART1 INTSTAT: OVERRUN Position      */
#define USART1_INTSTAT_OVERRUN_Msk          (0x01UL << USART1_INTSTAT_OVERRUN_Pos)                /*!< USART1 INTSTAT: OVERRUN Mask          */
#define USART1_INTSTAT_DELTARXBRK_Pos       11                                                      /*!< USART1 INTSTAT: DELTARXBRK Position   */
#define USART1_INTSTAT_DELTARXBRK_Msk       (0x01UL << USART1_INTSTAT_DELTARXBRK_Pos)             /*!< USART1 INTSTAT: DELTARXBRK Mask       */
#define USART1_INTSTAT_START_Pos            12                                                      /*!< USART1 INTSTAT: START Position        */
#define USART1_INTSTAT_START_Msk            (0x01UL << USART1_INTSTAT_START_Pos)                  /*!< USART1 INTSTAT: START Mask            */
#define USART1_INTSTAT_FRAMERR_Pos          13                                                      /*!< USART1 INTSTAT: FRAMERR Position      */
#define USART1_INTSTAT_FRAMERR_Msk          (0x01UL << USART1_INTSTAT_FRAMERR_Pos)                /*!< USART1 INTSTAT: FRAMERR Mask          */
#define USART1_INTSTAT_PARITYERR_Pos        14                                                      /*!< USART1 INTSTAT: PARITYERR Position    */
#define USART1_INTSTAT_PARITYERR_Msk        (0x01UL << USART1_INTSTAT_PARITYERR_Pos)              /*!< USART1 INTSTAT: PARITYERR Mask        */
#define USART1_INTSTAT_RXNOISE_Pos          15                                                      /*!< USART1 INTSTAT: RXNOISE Position      */
#define USART1_INTSTAT_RXNOISE_Msk          (0x01UL << USART1_INTSTAT_RXNOISE_Pos)                /*!< USART1 INTSTAT: RXNOISE Mask          */
#define USART1_INTSTAT_ABERR_Pos            16                                                      /*!< USART1 INTSTAT: ABERR Position        */
#define USART1_INTSTAT_ABERR_Msk            (0x01UL << USART1_INTSTAT_ABERR_Pos)                  /*!< USART1 INTSTAT: ABERR Mask            */

/* --------------------------------  u1_usart_OSR  -------------------------------- */
#define USART1_OSR_OSRVAL_Pos               0                                                       /*!< USART1 OSR: OSRVAL Position           */
#define USART1_OSR_OSRVAL_Msk               (0x0fUL << USART1_OSR_OSRVAL_Pos)                     /*!< USART1 OSR: OSRVAL Mask               */

/* --------------------------------  u1_usart_ADDR  ------------------------------- */
#define USART1_ADDR_ADDRESS_Pos             0                                                       /*!< USART1 ADDR: ADDRESS Position         */
#define USART1_ADDR_ADDRESS_Msk             (0x000000ffUL << USART1_ADDR_ADDRESS_Pos)             /*!< USART1 ADDR: ADDRESS Mask             */

/* ------------------------------  u1_usart_FIFOCFG  ------------------------------ */
#define USART1_FIFOCFG_ENABLETX_Pos         0                                                       /*!< USART1 FIFOCFG: ENABLETX Position     */
#define USART1_FIFOCFG_ENABLETX_Msk         (0x01UL << USART1_FIFOCFG_ENABLETX_Pos)               /*!< USART1 FIFOCFG: ENABLETX Mask         */
#define USART1_FIFOCFG_ENABLERX_Pos         1                                                       /*!< USART1 FIFOCFG: ENABLERX Position     */
#define USART1_FIFOCFG_ENABLERX_Msk         (0x01UL << USART1_FIFOCFG_ENABLERX_Pos)               /*!< USART1 FIFOCFG: ENABLERX Mask         */
#define USART1_FIFOCFG_SIZE_Pos             4                                                       /*!< USART1 FIFOCFG: SIZE Position         */
#define USART1_FIFOCFG_SIZE_Msk             (0x03UL << USART1_FIFOCFG_SIZE_Pos)                   /*!< USART1 FIFOCFG: SIZE Mask             */
#define USART1_FIFOCFG_DMATX_Pos            12                                                      /*!< USART1 FIFOCFG: DMATX Position        */
#define USART1_FIFOCFG_DMATX_Msk            (0x01UL << USART1_FIFOCFG_DMATX_Pos)                  /*!< USART1 FIFOCFG: DMATX Mask            */
#define USART1_FIFOCFG_DMARX_Pos            13                                                      /*!< USART1 FIFOCFG: DMARX Position        */
#define USART1_FIFOCFG_DMARX_Msk            (0x01UL << USART1_FIFOCFG_DMARX_Pos)                  /*!< USART1 FIFOCFG: DMARX Mask            */
#define USART1_FIFOCFG_WAKETX_Pos           14                                                      /*!< USART1 FIFOCFG: WAKETX Position       */
#define USART1_FIFOCFG_WAKETX_Msk           (0x01UL << USART1_FIFOCFG_WAKETX_Pos)                 /*!< USART1 FIFOCFG: WAKETX Mask           */
#define USART1_FIFOCFG_WAKERX_Pos           15                                                      /*!< USART1 FIFOCFG: WAKERX Position       */
#define USART1_FIFOCFG_WAKERX_Msk           (0x01UL << USART1_FIFOCFG_WAKERX_Pos)                 /*!< USART1 FIFOCFG: WAKERX Mask           */
#define USART1_FIFOCFG_EMPTYTX_Pos          16                                                      /*!< USART1 FIFOCFG: EMPTYTX Position      */
#define USART1_FIFOCFG_EMPTYTX_Msk          (0x01UL << USART1_FIFOCFG_EMPTYTX_Pos)                /*!< USART1 FIFOCFG: EMPTYTX Mask          */
#define USART1_FIFOCFG_EMPTYRX_Pos          17                                                      /*!< USART1 FIFOCFG: EMPTYRX Position      */
#define USART1_FIFOCFG_EMPTYRX_Msk          (0x01UL << USART1_FIFOCFG_EMPTYRX_Pos)                /*!< USART1 FIFOCFG: EMPTYRX Mask          */
#define USART1_FIFOCFG_POPDBG_Pos           18                                                      /*!< USART1 FIFOCFG: POPDBG Position       */
#define USART1_FIFOCFG_POPDBG_Msk           (0x01UL << USART1_FIFOCFG_POPDBG_Pos)                 /*!< USART1 FIFOCFG: POPDBG Mask           */

/* ------------------------------  u1_usart_FIFOSTAT  ----------------------------- */
#define USART1_FIFOSTAT_TXERR_Pos           0                                                       /*!< USART1 FIFOSTAT: TXERR Position       */
#define USART1_FIFOSTAT_TXERR_Msk           (0x01UL << USART1_FIFOSTAT_TXERR_Pos)                 /*!< USART1 FIFOSTAT: TXERR Mask           */
#define USART1_FIFOSTAT_RXERR_Pos           1                                                       /*!< USART1 FIFOSTAT: RXERR Position       */
#define USART1_FIFOSTAT_RXERR_Msk           (0x01UL << USART1_FIFOSTAT_RXERR_Pos)                 /*!< USART1 FIFOSTAT: RXERR Mask           */
#define USART1_FIFOSTAT_PERINT_Pos          3                                                       /*!< USART1 FIFOSTAT: PERINT Position      */
#define USART1_FIFOSTAT_PERINT_Msk          (0x01UL << USART1_FIFOSTAT_PERINT_Pos)                /*!< USART1 FIFOSTAT: PERINT Mask          */
#define USART1_FIFOSTAT_TXEMPTY_Pos         4                                                       /*!< USART1 FIFOSTAT: TXEMPTY Position     */
#define USART1_FIFOSTAT_TXEMPTY_Msk         (0x01UL << USART1_FIFOSTAT_TXEMPTY_Pos)               /*!< USART1 FIFOSTAT: TXEMPTY Mask         */
#define USART1_FIFOSTAT_TXNOTFULL_Pos       5                                                       /*!< USART1 FIFOSTAT: TXNOTFULL Position   */
#define USART1_FIFOSTAT_TXNOTFULL_Msk       (0x01UL << USART1_FIFOSTAT_TXNOTFULL_Pos)             /*!< USART1 FIFOSTAT: TXNOTFULL Mask       */
#define USART1_FIFOSTAT_RXNOTEMPTY_Pos      6                                                       /*!< USART1 FIFOSTAT: RXNOTEMPTY Position  */
#define USART1_FIFOSTAT_RXNOTEMPTY_Msk      (0x01UL << USART1_FIFOSTAT_RXNOTEMPTY_Pos)            /*!< USART1 FIFOSTAT: RXNOTEMPTY Mask      */
#define USART1_FIFOSTAT_RXFULL_Pos          7                                                       /*!< USART1 FIFOSTAT: RXFULL Position      */
#define USART1_FIFOSTAT_RXFULL_Msk          (0x01UL << USART1_FIFOSTAT_RXFULL_Pos)                /*!< USART1 FIFOSTAT: RXFULL Mask          */
#define USART1_FIFOSTAT_TXLVL_Pos           8                                                       /*!< USART1 FIFOSTAT: TXLVL Position       */
#define USART1_FIFOSTAT_TXLVL_Msk           (0x1fUL << USART1_FIFOSTAT_TXLVL_Pos)                 /*!< USART1 FIFOSTAT: TXLVL Mask           */
#define USART1_FIFOSTAT_RXLVL_Pos           16                                                      /*!< USART1 FIFOSTAT: RXLVL Position       */
#define USART1_FIFOSTAT_RXLVL_Msk           (0x1fUL << USART1_FIFOSTAT_RXLVL_Pos)                 /*!< USART1 FIFOSTAT: RXLVL Mask           */

/* ------------------------------  u1_usart_FIFOTRIG  ----------------------------- */
#define USART1_FIFOTRIG_TXLVLENA_Pos        0                                                       /*!< USART1 FIFOTRIG: TXLVLENA Position    */
#define USART1_FIFOTRIG_TXLVLENA_Msk        (0x01UL << USART1_FIFOTRIG_TXLVLENA_Pos)              /*!< USART1 FIFOTRIG: TXLVLENA Mask        */
#define USART1_FIFOTRIG_RXLVLENA_Pos        1                                                       /*!< USART1 FIFOTRIG: RXLVLENA Position    */
#define USART1_FIFOTRIG_RXLVLENA_Msk        (0x01UL << USART1_FIFOTRIG_RXLVLENA_Pos)              /*!< USART1 FIFOTRIG: RXLVLENA Mask        */
#define USART1_FIFOTRIG_TXLVL_Pos           8                                                       /*!< USART1 FIFOTRIG: TXLVL Position       */
#define USART1_FIFOTRIG_TXLVL_Msk           (0x0fUL << USART1_FIFOTRIG_TXLVL_Pos)                 /*!< USART1 FIFOTRIG: TXLVL Mask           */
#define USART1_FIFOTRIG_RXLVL_Pos           16                                                      /*!< USART1 FIFOTRIG: RXLVL Position       */
#define USART1_FIFOTRIG_RXLVL_Msk           (0x0fUL << USART1_FIFOTRIG_RXLVL_Pos)                 /*!< USART1 FIFOTRIG: RXLVL Mask           */

/* ----------------------------  u1_usart_FIFOINTENSET  --------------------------- */
#define USART1_FIFOINTENSET_TXERR_Pos       0                                                       /*!< USART1 FIFOINTENSET: TXERR Position   */
#define USART1_FIFOINTENSET_TXERR_Msk       (0x01UL << USART1_FIFOINTENSET_TXERR_Pos)             /*!< USART1 FIFOINTENSET: TXERR Mask       */
#define USART1_FIFOINTENSET_RXERR_Pos       1                                                       /*!< USART1 FIFOINTENSET: RXERR Position   */
#define USART1_FIFOINTENSET_RXERR_Msk       (0x01UL << USART1_FIFOINTENSET_RXERR_Pos)             /*!< USART1 FIFOINTENSET: RXERR Mask       */
#define USART1_FIFOINTENSET_TXLVL_Pos       2                                                       /*!< USART1 FIFOINTENSET: TXLVL Position   */
#define USART1_FIFOINTENSET_TXLVL_Msk       (0x01UL << USART1_FIFOINTENSET_TXLVL_Pos)             /*!< USART1 FIFOINTENSET: TXLVL Mask       */
#define USART1_FIFOINTENSET_RXLVL_Pos       3                                                       /*!< USART1 FIFOINTENSET: RXLVL Position   */
#define USART1_FIFOINTENSET_RXLVL_Msk       (0x01UL << USART1_FIFOINTENSET_RXLVL_Pos)             /*!< USART1 FIFOINTENSET: RXLVL Mask       */

/* ----------------------------  u1_usart_FIFOINTENCLR  --------------------------- */
#define USART1_FIFOINTENCLR_TXERR_Pos       0                                                       /*!< USART1 FIFOINTENCLR: TXERR Position   */
#define USART1_FIFOINTENCLR_TXERR_Msk       (0x01UL << USART1_FIFOINTENCLR_TXERR_Pos)             /*!< USART1 FIFOINTENCLR: TXERR Mask       */
#define USART1_FIFOINTENCLR_RXERR_Pos       1                                                       /*!< USART1 FIFOINTENCLR: RXERR Position   */
#define USART1_FIFOINTENCLR_RXERR_Msk       (0x01UL << USART1_FIFOINTENCLR_RXERR_Pos)             /*!< USART1 FIFOINTENCLR: RXERR Mask       */
#define USART1_FIFOINTENCLR_TXLVL_Pos       2                                                       /*!< USART1 FIFOINTENCLR: TXLVL Position   */
#define USART1_FIFOINTENCLR_TXLVL_Msk       (0x01UL << USART1_FIFOINTENCLR_TXLVL_Pos)             /*!< USART1 FIFOINTENCLR: TXLVL Mask       */
#define USART1_FIFOINTENCLR_RXLVL_Pos       3                                                       /*!< USART1 FIFOINTENCLR: RXLVL Position   */
#define USART1_FIFOINTENCLR_RXLVL_Msk       (0x01UL << USART1_FIFOINTENCLR_RXLVL_Pos)             /*!< USART1 FIFOINTENCLR: RXLVL Mask       */

/* ----------------------------  u1_usart_FIFOINTSTAT  ---------------------------- */
#define USART1_FIFOINTSTAT_TXERR_Pos        0                                                       /*!< USART1 FIFOINTSTAT: TXERR Position    */
#define USART1_FIFOINTSTAT_TXERR_Msk        (0x01UL << USART1_FIFOINTSTAT_TXERR_Pos)              /*!< USART1 FIFOINTSTAT: TXERR Mask        */
#define USART1_FIFOINTSTAT_RXERR_Pos        1                                                       /*!< USART1 FIFOINTSTAT: RXERR Position    */
#define USART1_FIFOINTSTAT_RXERR_Msk        (0x01UL << USART1_FIFOINTSTAT_RXERR_Pos)              /*!< USART1 FIFOINTSTAT: RXERR Mask        */
#define USART1_FIFOINTSTAT_TXLVL_Pos        2                                                       /*!< USART1 FIFOINTSTAT: TXLVL Position    */
#define USART1_FIFOINTSTAT_TXLVL_Msk        (0x01UL << USART1_FIFOINTSTAT_TXLVL_Pos)              /*!< USART1 FIFOINTSTAT: TXLVL Mask        */
#define USART1_FIFOINTSTAT_RXLVL_Pos        3                                                       /*!< USART1 FIFOINTSTAT: RXLVL Position    */
#define USART1_FIFOINTSTAT_RXLVL_Msk        (0x01UL << USART1_FIFOINTSTAT_RXLVL_Pos)              /*!< USART1 FIFOINTSTAT: RXLVL Mask        */
#define USART1_FIFOINTSTAT_PERINT_Pos       4                                                       /*!< USART1 FIFOINTSTAT: PERINT Position   */
#define USART1_FIFOINTSTAT_PERINT_Msk       (0x01UL << USART1_FIFOINTSTAT_PERINT_Pos)             /*!< USART1 FIFOINTSTAT: PERINT Mask       */

/* -------------------------------  u1_usart_FIFOWR  ------------------------------ */
#define USART1_FIFOWR_TXDATA_Pos            0                                                       /*!< USART1 FIFOWR: TXDATA Position        */
#define USART1_FIFOWR_TXDATA_Msk            (0x000000ffUL << USART1_FIFOWR_TXDATA_Pos)            /*!< USART1 FIFOWR: TXDATA Mask            */

/* -------------------------------  u1_usart_FIFORD  ------------------------------ */
#define USART1_FIFORD_RXDATA_Pos            0                                                       /*!< USART1 FIFORD: RXDATA Position        */
#define USART1_FIFORD_RXDATA_Msk            (0x000001ffUL << USART1_FIFORD_RXDATA_Pos)            /*!< USART1 FIFORD: RXDATA Mask            */
#define USART1_FIFORD_FRAMERR_Pos           13                                                      /*!< USART1 FIFORD: FRAMERR Position       */
#define USART1_FIFORD_FRAMERR_Msk           (0x01UL << USART1_FIFORD_FRAMERR_Pos)                 /*!< USART1 FIFORD: FRAMERR Mask           */
#define USART1_FIFORD_PARITYERR_Pos         14                                                      /*!< USART1 FIFORD: PARITYERR Position     */
#define USART1_FIFORD_PARITYERR_Msk         (0x01UL << USART1_FIFORD_PARITYERR_Pos)               /*!< USART1 FIFORD: PARITYERR Mask         */
#define USART1_FIFORD_RXNOISE_Pos           15                                                      /*!< USART1 FIFORD: RXNOISE Position       */
#define USART1_FIFORD_RXNOISE_Msk           (0x01UL << USART1_FIFORD_RXNOISE_Pos)                 /*!< USART1 FIFORD: RXNOISE Mask           */

/* ----------------------------  u1_usart_FIFORDNOPOP  ---------------------------- */
#define USART1_FIFORDNOPOP_RXDATA_Pos       0                                                       /*!< USART1 FIFORDNOPOP: RXDATA Position   */
#define USART1_FIFORDNOPOP_RXDATA_Msk       (0x000001ffUL << USART1_FIFORDNOPOP_RXDATA_Pos)       /*!< USART1 FIFORDNOPOP: RXDATA Mask       */
#define USART1_FIFORDNOPOP_FRAMERR_Pos      13                                                      /*!< USART1 FIFORDNOPOP: FRAMERR Position  */
#define USART1_FIFORDNOPOP_FRAMERR_Msk      (0x01UL << USART1_FIFORDNOPOP_FRAMERR_Pos)            /*!< USART1 FIFORDNOPOP: FRAMERR Mask      */
#define USART1_FIFORDNOPOP_PARITYERR_Pos    14                                                      /*!< USART1 FIFORDNOPOP: PARITYERR Position */
#define USART1_FIFORDNOPOP_PARITYERR_Msk    (0x01UL << USART1_FIFORDNOPOP_PARITYERR_Pos)          /*!< USART1 FIFORDNOPOP: PARITYERR Mask    */
#define USART1_FIFORDNOPOP_RXNOISE_Pos      15                                                      /*!< USART1 FIFORDNOPOP: RXNOISE Position  */
#define USART1_FIFORDNOPOP_RXNOISE_Msk      (0x01UL << USART1_FIFORDNOPOP_RXNOISE_Pos)            /*!< USART1 FIFORDNOPOP: RXNOISE Mask      */

/* -------------------------------  u1_usart_PSELID  ------------------------------ */
#define USART1_PSELID_PERSEL_Pos            0                                                       /*!< USART1 PSELID: PERSEL Position        */
#define USART1_PSELID_PERSEL_Msk            (0x07UL << USART1_PSELID_PERSEL_Pos)                  /*!< USART1 PSELID: PERSEL Mask            */
#define USART1_PSELID_LOCK_Pos              3                                                       /*!< USART1 PSELID: LOCK Position          */
#define USART1_PSELID_LOCK_Msk              (0x01UL << USART1_PSELID_LOCK_Pos)                    /*!< USART1 PSELID: LOCK Mask              */
#define USART1_PSELID_USARTPRESENT_Pos      4                                                       /*!< USART1 PSELID: USARTPRESENT Position  */
#define USART1_PSELID_USARTPRESENT_Msk      (0x01UL << USART1_PSELID_USARTPRESENT_Pos)            /*!< USART1 PSELID: USARTPRESENT Mask      */
#define USART1_PSELID_ID_Pos                12                                                      /*!< USART1 PSELID: ID Position            */
#define USART1_PSELID_ID_Msk                (0x000fffffUL << USART1_PSELID_ID_Pos)                /*!< USART1 PSELID: ID Mask                */

/* ---------------------------------  u1_usart_ID  -------------------------------- */
#define USART1_ID_APERTURE_Pos              0                                                       /*!< USART1 ID: APERTURE Position          */
#define USART1_ID_APERTURE_Msk              (0x000000ffUL << USART1_ID_APERTURE_Pos)              /*!< USART1 ID: APERTURE Mask              */
#define USART1_ID_MIN_REV_Pos               8                                                       /*!< USART1 ID: MIN_REV Position           */
#define USART1_ID_MIN_REV_Msk               (0x0fUL << USART1_ID_MIN_REV_Pos)                     /*!< USART1 ID: MIN_REV Mask               */
#define USART1_ID_MAJ_REV_Pos               12                                                      /*!< USART1 ID: MAJ_REV Position           */
#define USART1_ID_MAJ_REV_Msk               (0x0fUL << USART1_ID_MAJ_REV_Pos)                     /*!< USART1 ID: MAJ_REV Mask               */
#define USART1_ID_ID_Pos                    16                                                      /*!< USART1 ID: ID Position                */
#define USART1_ID_ID_Msk                    (0x0000ffffUL << USART1_ID_ID_Pos)                    /*!< USART1 ID: ID Mask                    */


/* ================================================================================ */
/* ================         struct 'u0_spi' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u0_spi_CFG  --------------------------------- */
#define SPI0_CFG_ENABLE_Pos                 0                                                       /*!< SPI0 CFG: ENABLE Position             */
#define SPI0_CFG_ENABLE_Msk                 (0x01UL << SPI0_CFG_ENABLE_Pos)                       /*!< SPI0 CFG: ENABLE Mask                 */
#define SPI0_CFG_MASTER_Pos                 2                                                       /*!< SPI0 CFG: MASTER Position             */
#define SPI0_CFG_MASTER_Msk                 (0x01UL << SPI0_CFG_MASTER_Pos)                       /*!< SPI0 CFG: MASTER Mask                 */
#define SPI0_CFG_LSBF_Pos                   3                                                       /*!< SPI0 CFG: LSBF Position               */
#define SPI0_CFG_LSBF_Msk                   (0x01UL << SPI0_CFG_LSBF_Pos)                         /*!< SPI0 CFG: LSBF Mask                   */
#define SPI0_CFG_CPHA_Pos                   4                                                       /*!< SPI0 CFG: CPHA Position               */
#define SPI0_CFG_CPHA_Msk                   (0x01UL << SPI0_CFG_CPHA_Pos)                         /*!< SPI0 CFG: CPHA Mask                   */
#define SPI0_CFG_CPOL_Pos                   5                                                       /*!< SPI0 CFG: CPOL Position               */
#define SPI0_CFG_CPOL_Msk                   (0x01UL << SPI0_CFG_CPOL_Pos)                         /*!< SPI0 CFG: CPOL Mask                   */
#define SPI0_CFG_LOOP_Pos                   7                                                       /*!< SPI0 CFG: LOOP Position               */
#define SPI0_CFG_LOOP_Msk                   (0x01UL << SPI0_CFG_LOOP_Pos)                         /*!< SPI0 CFG: LOOP Mask                   */
#define SPI0_CFG_SPOL0_Pos                  8                                                       /*!< SPI0 CFG: SPOL0 Position              */
#define SPI0_CFG_SPOL0_Msk                  (0x01UL << SPI0_CFG_SPOL0_Pos)                        /*!< SPI0 CFG: SPOL0 Mask                  */
#define SPI0_CFG_SPOL1_Pos                  9                                                       /*!< SPI0 CFG: SPOL1 Position              */
#define SPI0_CFG_SPOL1_Msk                  (0x01UL << SPI0_CFG_SPOL1_Pos)                        /*!< SPI0 CFG: SPOL1 Mask                  */
#define SPI0_CFG_SPOL2_Pos                  10                                                      /*!< SPI0 CFG: SPOL2 Position              */
#define SPI0_CFG_SPOL2_Msk                  (0x01UL << SPI0_CFG_SPOL2_Pos)                        /*!< SPI0 CFG: SPOL2 Mask                  */
#define SPI0_CFG_SPOL3_Pos                  11                                                      /*!< SPI0 CFG: SPOL3 Position              */
#define SPI0_CFG_SPOL3_Msk                  (0x01UL << SPI0_CFG_SPOL3_Pos)                        /*!< SPI0 CFG: SPOL3 Mask                  */

/* ---------------------------------  u0_spi_DLY  --------------------------------- */
#define SPI0_DLY_PRE_DELAY_Pos              0                                                       /*!< SPI0 DLY: PRE_DELAY Position          */
#define SPI0_DLY_PRE_DELAY_Msk              (0x0fUL << SPI0_DLY_PRE_DELAY_Pos)                    /*!< SPI0 DLY: PRE_DELAY Mask              */
#define SPI0_DLY_POST_DELAY_Pos             4                                                       /*!< SPI0 DLY: POST_DELAY Position         */
#define SPI0_DLY_POST_DELAY_Msk             (0x0fUL << SPI0_DLY_POST_DELAY_Pos)                   /*!< SPI0 DLY: POST_DELAY Mask             */
#define SPI0_DLY_FRAME_DELAY_Pos            8                                                       /*!< SPI0 DLY: FRAME_DELAY Position        */
#define SPI0_DLY_FRAME_DELAY_Msk            (0x0fUL << SPI0_DLY_FRAME_DELAY_Pos)                  /*!< SPI0 DLY: FRAME_DELAY Mask            */
#define SPI0_DLY_TRANSFER_DELAY_Pos         12                                                      /*!< SPI0 DLY: TRANSFER_DELAY Position     */
#define SPI0_DLY_TRANSFER_DELAY_Msk         (0x0fUL << SPI0_DLY_TRANSFER_DELAY_Pos)               /*!< SPI0 DLY: TRANSFER_DELAY Mask         */

/* ---------------------------------  u0_spi_STAT  -------------------------------- */
#define SPI0_STAT_RXOV_Pos                  2                                                       /*!< SPI0 STAT: RXOV Position              */
#define SPI0_STAT_RXOV_Msk                  (0x01UL << SPI0_STAT_RXOV_Pos)                        /*!< SPI0 STAT: RXOV Mask                  */
#define SPI0_STAT_TXUR_Pos                  3                                                       /*!< SPI0 STAT: TXUR Position              */
#define SPI0_STAT_TXUR_Msk                  (0x01UL << SPI0_STAT_TXUR_Pos)                        /*!< SPI0 STAT: TXUR Mask                  */
#define SPI0_STAT_SSA_Pos                   4                                                       /*!< SPI0 STAT: SSA Position               */
#define SPI0_STAT_SSA_Msk                   (0x01UL << SPI0_STAT_SSA_Pos)                         /*!< SPI0 STAT: SSA Mask                   */
#define SPI0_STAT_SSD_Pos                   5                                                       /*!< SPI0 STAT: SSD Position               */
#define SPI0_STAT_SSD_Msk                   (0x01UL << SPI0_STAT_SSD_Pos)                         /*!< SPI0 STAT: SSD Mask                   */
#define SPI0_STAT_STALLED_Pos               6                                                       /*!< SPI0 STAT: STALLED Position           */
#define SPI0_STAT_STALLED_Msk               (0x01UL << SPI0_STAT_STALLED_Pos)                     /*!< SPI0 STAT: STALLED Mask               */
#define SPI0_STAT_ENDTRANSFER_Pos           7                                                       /*!< SPI0 STAT: ENDTRANSFER Position       */
#define SPI0_STAT_ENDTRANSFER_Msk           (0x01UL << SPI0_STAT_ENDTRANSFER_Pos)                 /*!< SPI0 STAT: ENDTRANSFER Mask           */
#define SPI0_STAT_MSTIDLE_Pos               8                                                       /*!< SPI0 STAT: MSTIDLE Position           */
#define SPI0_STAT_MSTIDLE_Msk               (0x01UL << SPI0_STAT_MSTIDLE_Pos)                     /*!< SPI0 STAT: MSTIDLE Mask               */

/* -------------------------------  u0_spi_INTENSET  ------------------------------ */
#define SPI0_INTENSET_RXOVEN_Pos            2                                                       /*!< SPI0 INTENSET: RXOVEN Position        */
#define SPI0_INTENSET_RXOVEN_Msk            (0x01UL << SPI0_INTENSET_RXOVEN_Pos)                  /*!< SPI0 INTENSET: RXOVEN Mask            */
#define SPI0_INTENSET_TXUREN_Pos            3                                                       /*!< SPI0 INTENSET: TXUREN Position        */
#define SPI0_INTENSET_TXUREN_Msk            (0x01UL << SPI0_INTENSET_TXUREN_Pos)                  /*!< SPI0 INTENSET: TXUREN Mask            */
#define SPI0_INTENSET_SSAEN_Pos             4                                                       /*!< SPI0 INTENSET: SSAEN Position         */
#define SPI0_INTENSET_SSAEN_Msk             (0x01UL << SPI0_INTENSET_SSAEN_Pos)                   /*!< SPI0 INTENSET: SSAEN Mask             */
#define SPI0_INTENSET_SSDEN_Pos             5                                                       /*!< SPI0 INTENSET: SSDEN Position         */
#define SPI0_INTENSET_SSDEN_Msk             (0x01UL << SPI0_INTENSET_SSDEN_Pos)                   /*!< SPI0 INTENSET: SSDEN Mask             */
#define SPI0_INTENSET_MSTIDLEEN_Pos         8                                                       /*!< SPI0 INTENSET: MSTIDLEEN Position     */
#define SPI0_INTENSET_MSTIDLEEN_Msk         (0x01UL << SPI0_INTENSET_MSTIDLEEN_Pos)               /*!< SPI0 INTENSET: MSTIDLEEN Mask         */

/* -------------------------------  u0_spi_INTENCLR  ------------------------------ */
#define SPI0_INTENCLR_RXOVCLR_Pos           2                                                       /*!< SPI0 INTENCLR: RXOVCLR Position       */
#define SPI0_INTENCLR_RXOVCLR_Msk           (0x01UL << SPI0_INTENCLR_RXOVCLR_Pos)                 /*!< SPI0 INTENCLR: RXOVCLR Mask           */
#define SPI0_INTENCLR_TXURCLR_Pos           3                                                       /*!< SPI0 INTENCLR: TXURCLR Position       */
#define SPI0_INTENCLR_TXURCLR_Msk           (0x01UL << SPI0_INTENCLR_TXURCLR_Pos)                 /*!< SPI0 INTENCLR: TXURCLR Mask           */
#define SPI0_INTENCLR_SSACLR_Pos            4                                                       /*!< SPI0 INTENCLR: SSACLR Position        */
#define SPI0_INTENCLR_SSACLR_Msk            (0x01UL << SPI0_INTENCLR_SSACLR_Pos)                  /*!< SPI0 INTENCLR: SSACLR Mask            */
#define SPI0_INTENCLR_SSDCLR_Pos            5                                                       /*!< SPI0 INTENCLR: SSDCLR Position        */
#define SPI0_INTENCLR_SSDCLR_Msk            (0x01UL << SPI0_INTENCLR_SSDCLR_Pos)                  /*!< SPI0 INTENCLR: SSDCLR Mask            */
#define SPI0_INTENCLR_MSTIDLECLR_Pos        8                                                       /*!< SPI0 INTENCLR: MSTIDLECLR Position    */
#define SPI0_INTENCLR_MSTIDLECLR_Msk        (0x01UL << SPI0_INTENCLR_MSTIDLECLR_Pos)              /*!< SPI0 INTENCLR: MSTIDLECLR Mask        */

/* --------------------------------  u0_spi_TXCTL  -------------------------------- */
#define SPI0_TXCTL_TXSSEL0_N_Pos            16                                                      /*!< SPI0 TXCTL: TXSSEL0_N Position        */
#define SPI0_TXCTL_TXSSEL0_N_Msk            (0x01UL << SPI0_TXCTL_TXSSEL0_N_Pos)                  /*!< SPI0 TXCTL: TXSSEL0_N Mask            */
#define SPI0_TXCTL_TXSSEL1_N_Pos            17                                                      /*!< SPI0 TXCTL: TXSSEL1_N Position        */
#define SPI0_TXCTL_TXSSEL1_N_Msk            (0x01UL << SPI0_TXCTL_TXSSEL1_N_Pos)                  /*!< SPI0 TXCTL: TXSSEL1_N Mask            */
#define SPI0_TXCTL_TXSSEL2_N_Pos            18                                                      /*!< SPI0 TXCTL: TXSSEL2_N Position        */
#define SPI0_TXCTL_TXSSEL2_N_Msk            (0x01UL << SPI0_TXCTL_TXSSEL2_N_Pos)                  /*!< SPI0 TXCTL: TXSSEL2_N Mask            */
#define SPI0_TXCTL_TXSSEL3_N_Pos            19                                                      /*!< SPI0 TXCTL: TXSSEL3_N Position        */
#define SPI0_TXCTL_TXSSEL3_N_Msk            (0x01UL << SPI0_TXCTL_TXSSEL3_N_Pos)                  /*!< SPI0 TXCTL: TXSSEL3_N Mask            */
#define SPI0_TXCTL_EOTR_Pos                 20                                                      /*!< SPI0 TXCTL: EOTR Position             */
#define SPI0_TXCTL_EOTR_Msk                 (0x01UL << SPI0_TXCTL_EOTR_Pos)                       /*!< SPI0 TXCTL: EOTR Mask                 */
#define SPI0_TXCTL_EOFR_Pos                 21                                                      /*!< SPI0 TXCTL: EOFR Position             */
#define SPI0_TXCTL_EOFR_Msk                 (0x01UL << SPI0_TXCTL_EOFR_Pos)                       /*!< SPI0 TXCTL: EOFR Mask                 */
#define SPI0_TXCTL_RXIGNORE_Pos             22                                                      /*!< SPI0 TXCTL: RXIGNORE Position         */
#define SPI0_TXCTL_RXIGNORE_Msk             (0x01UL << SPI0_TXCTL_RXIGNORE_Pos)                   /*!< SPI0 TXCTL: RXIGNORE Mask             */
#define SPI0_TXCTL_LEN_Pos                  24                                                      /*!< SPI0 TXCTL: LEN Position              */
#define SPI0_TXCTL_LEN_Msk                  (0x0fUL << SPI0_TXCTL_LEN_Pos)                        /*!< SPI0 TXCTL: LEN Mask                  */

/* ---------------------------------  u0_spi_DIV  --------------------------------- */
#define SPI0_DIV_DIVVAL_Pos                 0                                                       /*!< SPI0 DIV: DIVVAL Position             */
#define SPI0_DIV_DIVVAL_Msk                 (0x0000ffffUL << SPI0_DIV_DIVVAL_Pos)                 /*!< SPI0 DIV: DIVVAL Mask                 */

/* -------------------------------  u0_spi_INTSTAT  ------------------------------- */
#define SPI0_INTSTAT_RXOV_Pos               2                                                       /*!< SPI0 INTSTAT: RXOV Position           */
#define SPI0_INTSTAT_RXOV_Msk               (0x01UL << SPI0_INTSTAT_RXOV_Pos)                     /*!< SPI0 INTSTAT: RXOV Mask               */
#define SPI0_INTSTAT_TXUR_Pos               3                                                       /*!< SPI0 INTSTAT: TXUR Position           */
#define SPI0_INTSTAT_TXUR_Msk               (0x01UL << SPI0_INTSTAT_TXUR_Pos)                     /*!< SPI0 INTSTAT: TXUR Mask               */
#define SPI0_INTSTAT_SSA_Pos                4                                                       /*!< SPI0 INTSTAT: SSA Position            */
#define SPI0_INTSTAT_SSA_Msk                (0x01UL << SPI0_INTSTAT_SSA_Pos)                      /*!< SPI0 INTSTAT: SSA Mask                */
#define SPI0_INTSTAT_SSD_Pos                5                                                       /*!< SPI0 INTSTAT: SSD Position            */
#define SPI0_INTSTAT_SSD_Msk                (0x01UL << SPI0_INTSTAT_SSD_Pos)                      /*!< SPI0 INTSTAT: SSD Mask                */
#define SPI0_INTSTAT_MSTIDLE_Pos            8                                                       /*!< SPI0 INTSTAT: MSTIDLE Position        */
#define SPI0_INTSTAT_MSTIDLE_Msk            (0x01UL << SPI0_INTSTAT_MSTIDLE_Pos)                  /*!< SPI0 INTSTAT: MSTIDLE Mask            */

/* -------------------------------  u0_spi_FIFOCFG  ------------------------------- */
#define SPI0_FIFOCFG_ENABLETX_Pos           0                                                       /*!< SPI0 FIFOCFG: ENABLETX Position       */
#define SPI0_FIFOCFG_ENABLETX_Msk           (0x01UL << SPI0_FIFOCFG_ENABLETX_Pos)                 /*!< SPI0 FIFOCFG: ENABLETX Mask           */
#define SPI0_FIFOCFG_ENABLERX_Pos           1                                                       /*!< SPI0 FIFOCFG: ENABLERX Position       */
#define SPI0_FIFOCFG_ENABLERX_Msk           (0x01UL << SPI0_FIFOCFG_ENABLERX_Pos)                 /*!< SPI0 FIFOCFG: ENABLERX Mask           */
#define SPI0_FIFOCFG_SIZE_Pos               4                                                       /*!< SPI0 FIFOCFG: SIZE Position           */
#define SPI0_FIFOCFG_SIZE_Msk               (0x03UL << SPI0_FIFOCFG_SIZE_Pos)                     /*!< SPI0 FIFOCFG: SIZE Mask               */
#define SPI0_FIFOCFG_DMATX_Pos              12                                                      /*!< SPI0 FIFOCFG: DMATX Position          */
#define SPI0_FIFOCFG_DMATX_Msk              (0x01UL << SPI0_FIFOCFG_DMATX_Pos)                    /*!< SPI0 FIFOCFG: DMATX Mask              */
#define SPI0_FIFOCFG_DMARX_Pos              13                                                      /*!< SPI0 FIFOCFG: DMARX Position          */
#define SPI0_FIFOCFG_DMARX_Msk              (0x01UL << SPI0_FIFOCFG_DMARX_Pos)                    /*!< SPI0 FIFOCFG: DMARX Mask              */
#define SPI0_FIFOCFG_WAKETX_Pos             14                                                      /*!< SPI0 FIFOCFG: WAKETX Position         */
#define SPI0_FIFOCFG_WAKETX_Msk             (0x01UL << SPI0_FIFOCFG_WAKETX_Pos)                   /*!< SPI0 FIFOCFG: WAKETX Mask             */
#define SPI0_FIFOCFG_WAKERX_Pos             15                                                      /*!< SPI0 FIFOCFG: WAKERX Position         */
#define SPI0_FIFOCFG_WAKERX_Msk             (0x01UL << SPI0_FIFOCFG_WAKERX_Pos)                   /*!< SPI0 FIFOCFG: WAKERX Mask             */
#define SPI0_FIFOCFG_EMPTYTX_Pos            16                                                      /*!< SPI0 FIFOCFG: EMPTYTX Position        */
#define SPI0_FIFOCFG_EMPTYTX_Msk            (0x01UL << SPI0_FIFOCFG_EMPTYTX_Pos)                  /*!< SPI0 FIFOCFG: EMPTYTX Mask            */
#define SPI0_FIFOCFG_EMPTYRX_Pos            17                                                      /*!< SPI0 FIFOCFG: EMPTYRX Position        */
#define SPI0_FIFOCFG_EMPTYRX_Msk            (0x01UL << SPI0_FIFOCFG_EMPTYRX_Pos)                  /*!< SPI0 FIFOCFG: EMPTYRX Mask            */
#define SPI0_FIFOCFG_POPDBG_Pos             18                                                      /*!< SPI0 FIFOCFG: POPDBG Position         */
#define SPI0_FIFOCFG_POPDBG_Msk             (0x01UL << SPI0_FIFOCFG_POPDBG_Pos)                   /*!< SPI0 FIFOCFG: POPDBG Mask             */

/* -------------------------------  u0_spi_FIFOSTAT  ------------------------------ */
#define SPI0_FIFOSTAT_TXERR_Pos             0                                                       /*!< SPI0 FIFOSTAT: TXERR Position         */
#define SPI0_FIFOSTAT_TXERR_Msk             (0x01UL << SPI0_FIFOSTAT_TXERR_Pos)                   /*!< SPI0 FIFOSTAT: TXERR Mask             */
#define SPI0_FIFOSTAT_RXERR_Pos             1                                                       /*!< SPI0 FIFOSTAT: RXERR Position         */
#define SPI0_FIFOSTAT_RXERR_Msk             (0x01UL << SPI0_FIFOSTAT_RXERR_Pos)                   /*!< SPI0 FIFOSTAT: RXERR Mask             */
#define SPI0_FIFOSTAT_PERINT_Pos            3                                                       /*!< SPI0 FIFOSTAT: PERINT Position        */
#define SPI0_FIFOSTAT_PERINT_Msk            (0x01UL << SPI0_FIFOSTAT_PERINT_Pos)                  /*!< SPI0 FIFOSTAT: PERINT Mask            */
#define SPI0_FIFOSTAT_TXEMPTY_Pos           4                                                       /*!< SPI0 FIFOSTAT: TXEMPTY Position       */
#define SPI0_FIFOSTAT_TXEMPTY_Msk           (0x01UL << SPI0_FIFOSTAT_TXEMPTY_Pos)                 /*!< SPI0 FIFOSTAT: TXEMPTY Mask           */
#define SPI0_FIFOSTAT_TXNOTFULL_Pos         5                                                       /*!< SPI0 FIFOSTAT: TXNOTFULL Position     */
#define SPI0_FIFOSTAT_TXNOTFULL_Msk         (0x01UL << SPI0_FIFOSTAT_TXNOTFULL_Pos)               /*!< SPI0 FIFOSTAT: TXNOTFULL Mask         */
#define SPI0_FIFOSTAT_RXNOTEMPTY_Pos        6                                                       /*!< SPI0 FIFOSTAT: RXNOTEMPTY Position    */
#define SPI0_FIFOSTAT_RXNOTEMPTY_Msk        (0x01UL << SPI0_FIFOSTAT_RXNOTEMPTY_Pos)              /*!< SPI0 FIFOSTAT: RXNOTEMPTY Mask        */
#define SPI0_FIFOSTAT_RXFULL_Pos            7                                                       /*!< SPI0 FIFOSTAT: RXFULL Position        */
#define SPI0_FIFOSTAT_RXFULL_Msk            (0x01UL << SPI0_FIFOSTAT_RXFULL_Pos)                  /*!< SPI0 FIFOSTAT: RXFULL Mask            */
#define SPI0_FIFOSTAT_TXLVL_Pos             8                                                       /*!< SPI0 FIFOSTAT: TXLVL Position         */
#define SPI0_FIFOSTAT_TXLVL_Msk             (0x1fUL << SPI0_FIFOSTAT_TXLVL_Pos)                   /*!< SPI0 FIFOSTAT: TXLVL Mask             */
#define SPI0_FIFOSTAT_RXLVL_Pos             16                                                      /*!< SPI0 FIFOSTAT: RXLVL Position         */
#define SPI0_FIFOSTAT_RXLVL_Msk             (0x1fUL << SPI0_FIFOSTAT_RXLVL_Pos)                   /*!< SPI0 FIFOSTAT: RXLVL Mask             */

/* -------------------------------  u0_spi_FIFOTRIG  ------------------------------ */
#define SPI0_FIFOTRIG_TXLVLENA_Pos          0                                                       /*!< SPI0 FIFOTRIG: TXLVLENA Position      */
#define SPI0_FIFOTRIG_TXLVLENA_Msk          (0x01UL << SPI0_FIFOTRIG_TXLVLENA_Pos)                /*!< SPI0 FIFOTRIG: TXLVLENA Mask          */
#define SPI0_FIFOTRIG_RXLVLENA_Pos          1                                                       /*!< SPI0 FIFOTRIG: RXLVLENA Position      */
#define SPI0_FIFOTRIG_RXLVLENA_Msk          (0x01UL << SPI0_FIFOTRIG_RXLVLENA_Pos)                /*!< SPI0 FIFOTRIG: RXLVLENA Mask          */
#define SPI0_FIFOTRIG_TXLVL_Pos             8                                                       /*!< SPI0 FIFOTRIG: TXLVL Position         */
#define SPI0_FIFOTRIG_TXLVL_Msk             (0x0fUL << SPI0_FIFOTRIG_TXLVL_Pos)                   /*!< SPI0 FIFOTRIG: TXLVL Mask             */
#define SPI0_FIFOTRIG_RXLVL_Pos             16                                                      /*!< SPI0 FIFOTRIG: RXLVL Position         */
#define SPI0_FIFOTRIG_RXLVL_Msk             (0x0fUL << SPI0_FIFOTRIG_RXLVL_Pos)                   /*!< SPI0 FIFOTRIG: RXLVL Mask             */

/* -----------------------------  u0_spi_FIFOINTENSET  ---------------------------- */
#define SPI0_FIFOINTENSET_TXERR_Pos         0                                                       /*!< SPI0 FIFOINTENSET: TXERR Position     */
#define SPI0_FIFOINTENSET_TXERR_Msk         (0x01UL << SPI0_FIFOINTENSET_TXERR_Pos)               /*!< SPI0 FIFOINTENSET: TXERR Mask         */
#define SPI0_FIFOINTENSET_RXERR_Pos         1                                                       /*!< SPI0 FIFOINTENSET: RXERR Position     */
#define SPI0_FIFOINTENSET_RXERR_Msk         (0x01UL << SPI0_FIFOINTENSET_RXERR_Pos)               /*!< SPI0 FIFOINTENSET: RXERR Mask         */
#define SPI0_FIFOINTENSET_TXLVL_Pos         2                                                       /*!< SPI0 FIFOINTENSET: TXLVL Position     */
#define SPI0_FIFOINTENSET_TXLVL_Msk         (0x01UL << SPI0_FIFOINTENSET_TXLVL_Pos)               /*!< SPI0 FIFOINTENSET: TXLVL Mask         */
#define SPI0_FIFOINTENSET_RXLVL_Pos         3                                                       /*!< SPI0 FIFOINTENSET: RXLVL Position     */
#define SPI0_FIFOINTENSET_RXLVL_Msk         (0x01UL << SPI0_FIFOINTENSET_RXLVL_Pos)               /*!< SPI0 FIFOINTENSET: RXLVL Mask         */

/* -----------------------------  u0_spi_FIFOINTENCLR  ---------------------------- */
#define SPI0_FIFOINTENCLR_TXERR_Pos         0                                                       /*!< SPI0 FIFOINTENCLR: TXERR Position     */
#define SPI0_FIFOINTENCLR_TXERR_Msk         (0x01UL << SPI0_FIFOINTENCLR_TXERR_Pos)               /*!< SPI0 FIFOINTENCLR: TXERR Mask         */
#define SPI0_FIFOINTENCLR_RXERR_Pos         1                                                       /*!< SPI0 FIFOINTENCLR: RXERR Position     */
#define SPI0_FIFOINTENCLR_RXERR_Msk         (0x01UL << SPI0_FIFOINTENCLR_RXERR_Pos)               /*!< SPI0 FIFOINTENCLR: RXERR Mask         */
#define SPI0_FIFOINTENCLR_TXLVL_Pos         2                                                       /*!< SPI0 FIFOINTENCLR: TXLVL Position     */
#define SPI0_FIFOINTENCLR_TXLVL_Msk         (0x01UL << SPI0_FIFOINTENCLR_TXLVL_Pos)               /*!< SPI0 FIFOINTENCLR: TXLVL Mask         */
#define SPI0_FIFOINTENCLR_RXLVL_Pos         3                                                       /*!< SPI0 FIFOINTENCLR: RXLVL Position     */
#define SPI0_FIFOINTENCLR_RXLVL_Msk         (0x01UL << SPI0_FIFOINTENCLR_RXLVL_Pos)               /*!< SPI0 FIFOINTENCLR: RXLVL Mask         */

/* -----------------------------  u0_spi_FIFOINTSTAT  ----------------------------- */
#define SPI0_FIFOINTSTAT_TXERR_Pos          0                                                       /*!< SPI0 FIFOINTSTAT: TXERR Position      */
#define SPI0_FIFOINTSTAT_TXERR_Msk          (0x01UL << SPI0_FIFOINTSTAT_TXERR_Pos)                /*!< SPI0 FIFOINTSTAT: TXERR Mask          */
#define SPI0_FIFOINTSTAT_RXERR_Pos          1                                                       /*!< SPI0 FIFOINTSTAT: RXERR Position      */
#define SPI0_FIFOINTSTAT_RXERR_Msk          (0x01UL << SPI0_FIFOINTSTAT_RXERR_Pos)                /*!< SPI0 FIFOINTSTAT: RXERR Mask          */
#define SPI0_FIFOINTSTAT_TXLVL_Pos          2                                                       /*!< SPI0 FIFOINTSTAT: TXLVL Position      */
#define SPI0_FIFOINTSTAT_TXLVL_Msk          (0x01UL << SPI0_FIFOINTSTAT_TXLVL_Pos)                /*!< SPI0 FIFOINTSTAT: TXLVL Mask          */
#define SPI0_FIFOINTSTAT_RXLVL_Pos          3                                                       /*!< SPI0 FIFOINTSTAT: RXLVL Position      */
#define SPI0_FIFOINTSTAT_RXLVL_Msk          (0x01UL << SPI0_FIFOINTSTAT_RXLVL_Pos)                /*!< SPI0 FIFOINTSTAT: RXLVL Mask          */
#define SPI0_FIFOINTSTAT_PERINT_Pos         4                                                       /*!< SPI0 FIFOINTSTAT: PERINT Position     */
#define SPI0_FIFOINTSTAT_PERINT_Msk         (0x01UL << SPI0_FIFOINTSTAT_PERINT_Pos)               /*!< SPI0 FIFOINTSTAT: PERINT Mask         */

/* --------------------------------  u0_spi_FIFOWR  ------------------------------- */
#define SPI0_FIFOWR_TXDATA_Pos              0                                                       /*!< SPI0 FIFOWR: TXDATA Position          */
#define SPI0_FIFOWR_TXDATA_Msk              (0x0000ffffUL << SPI0_FIFOWR_TXDATA_Pos)              /*!< SPI0 FIFOWR: TXDATA Mask              */
#define SPI0_FIFOWR_TXSSEL0_N_Pos           16                                                      /*!< SPI0 FIFOWR: TXSSEL0_N Position       */
#define SPI0_FIFOWR_TXSSEL0_N_Msk           (0x01UL << SPI0_FIFOWR_TXSSEL0_N_Pos)                 /*!< SPI0 FIFOWR: TXSSEL0_N Mask           */
#define SPI0_FIFOWR_TXSSEL1_N_Pos           17                                                      /*!< SPI0 FIFOWR: TXSSEL1_N Position       */
#define SPI0_FIFOWR_TXSSEL1_N_Msk           (0x01UL << SPI0_FIFOWR_TXSSEL1_N_Pos)                 /*!< SPI0 FIFOWR: TXSSEL1_N Mask           */
#define SPI0_FIFOWR_TXSSEL2_N_Pos           18                                                      /*!< SPI0 FIFOWR: TXSSEL2_N Position       */
#define SPI0_FIFOWR_TXSSEL2_N_Msk           (0x01UL << SPI0_FIFOWR_TXSSEL2_N_Pos)                 /*!< SPI0 FIFOWR: TXSSEL2_N Mask           */
#define SPI0_FIFOWR_TXSSEL3_N_Pos           19                                                      /*!< SPI0 FIFOWR: TXSSEL3_N Position       */
#define SPI0_FIFOWR_TXSSEL3_N_Msk           (0x01UL << SPI0_FIFOWR_TXSSEL3_N_Pos)                 /*!< SPI0 FIFOWR: TXSSEL3_N Mask           */
#define SPI0_FIFOWR_EOTR_Pos                20                                                      /*!< SPI0 FIFOWR: EOTR Position            */
#define SPI0_FIFOWR_EOTR_Msk                (0x01UL << SPI0_FIFOWR_EOTR_Pos)                      /*!< SPI0 FIFOWR: EOTR Mask                */
#define SPI0_FIFOWR_EOFR_Pos                21                                                      /*!< SPI0 FIFOWR: EOFR Position            */
#define SPI0_FIFOWR_EOFR_Msk                (0x01UL << SPI0_FIFOWR_EOFR_Pos)                      /*!< SPI0 FIFOWR: EOFR Mask                */
#define SPI0_FIFOWR_RXIGNORE_Pos            22                                                      /*!< SPI0 FIFOWR: RXIGNORE Position        */
#define SPI0_FIFOWR_RXIGNORE_Msk            (0x01UL << SPI0_FIFOWR_RXIGNORE_Pos)                  /*!< SPI0 FIFOWR: RXIGNORE Mask            */
#define SPI0_FIFOWR_LEN_Pos                 24                                                      /*!< SPI0 FIFOWR: LEN Position             */
#define SPI0_FIFOWR_LEN_Msk                 (0x0fUL << SPI0_FIFOWR_LEN_Pos)                       /*!< SPI0 FIFOWR: LEN Mask                 */

/* --------------------------------  u0_spi_FIFORD  ------------------------------- */
#define SPI0_FIFORD_RXDATA_Pos              0                                                       /*!< SPI0 FIFORD: RXDATA Position          */
#define SPI0_FIFORD_RXDATA_Msk              (0x0000ffffUL << SPI0_FIFORD_RXDATA_Pos)              /*!< SPI0 FIFORD: RXDATA Mask              */
#define SPI0_FIFORD_RXSSEL0_N_Pos           16                                                      /*!< SPI0 FIFORD: RXSSEL0_N Position       */
#define SPI0_FIFORD_RXSSEL0_N_Msk           (0x01UL << SPI0_FIFORD_RXSSEL0_N_Pos)                 /*!< SPI0 FIFORD: RXSSEL0_N Mask           */
#define SPI0_FIFORD_RXSSEL1_N_Pos           17                                                      /*!< SPI0 FIFORD: RXSSEL1_N Position       */
#define SPI0_FIFORD_RXSSEL1_N_Msk           (0x01UL << SPI0_FIFORD_RXSSEL1_N_Pos)                 /*!< SPI0 FIFORD: RXSSEL1_N Mask           */
#define SPI0_FIFORD_RXSSEL2_N_Pos           18                                                      /*!< SPI0 FIFORD: RXSSEL2_N Position       */
#define SPI0_FIFORD_RXSSEL2_N_Msk           (0x01UL << SPI0_FIFORD_RXSSEL2_N_Pos)                 /*!< SPI0 FIFORD: RXSSEL2_N Mask           */
#define SPI0_FIFORD_RXSSEL3_N_Pos           19                                                      /*!< SPI0 FIFORD: RXSSEL3_N Position       */
#define SPI0_FIFORD_RXSSEL3_N_Msk           (0x01UL << SPI0_FIFORD_RXSSEL3_N_Pos)                 /*!< SPI0 FIFORD: RXSSEL3_N Mask           */
#define SPI0_FIFORD_SOT_Pos                 20                                                      /*!< SPI0 FIFORD: SOT Position             */
#define SPI0_FIFORD_SOT_Msk                 (0x01UL << SPI0_FIFORD_SOT_Pos)                       /*!< SPI0 FIFORD: SOT Mask                 */

/* -----------------------------  u0_spi_FIFORDNOPOP  ----------------------------- */
#define SPI0_FIFORDNOPOP_RXDATA_Pos         0                                                       /*!< SPI0 FIFORDNOPOP: RXDATA Position     */
#define SPI0_FIFORDNOPOP_RXDATA_Msk         (0x0000ffffUL << SPI0_FIFORDNOPOP_RXDATA_Pos)         /*!< SPI0 FIFORDNOPOP: RXDATA Mask         */
#define SPI0_FIFORDNOPOP_RXSSEL0_N_Pos      16                                                      /*!< SPI0 FIFORDNOPOP: RXSSEL0_N Position  */
#define SPI0_FIFORDNOPOP_RXSSEL0_N_Msk      (0x01UL << SPI0_FIFORDNOPOP_RXSSEL0_N_Pos)            /*!< SPI0 FIFORDNOPOP: RXSSEL0_N Mask      */
#define SPI0_FIFORDNOPOP_RXSSEL1_N_Pos      17                                                      /*!< SPI0 FIFORDNOPOP: RXSSEL1_N Position  */
#define SPI0_FIFORDNOPOP_RXSSEL1_N_Msk      (0x01UL << SPI0_FIFORDNOPOP_RXSSEL1_N_Pos)            /*!< SPI0 FIFORDNOPOP: RXSSEL1_N Mask      */
#define SPI0_FIFORDNOPOP_RXSSEL2_N_Pos      18                                                      /*!< SPI0 FIFORDNOPOP: RXSSEL2_N Position  */
#define SPI0_FIFORDNOPOP_RXSSEL2_N_Msk      (0x01UL << SPI0_FIFORDNOPOP_RXSSEL2_N_Pos)            /*!< SPI0 FIFORDNOPOP: RXSSEL2_N Mask      */
#define SPI0_FIFORDNOPOP_RXSSEL3_N_Pos      19                                                      /*!< SPI0 FIFORDNOPOP: RXSSEL3_N Position  */
#define SPI0_FIFORDNOPOP_RXSSEL3_N_Msk      (0x01UL << SPI0_FIFORDNOPOP_RXSSEL3_N_Pos)            /*!< SPI0 FIFORDNOPOP: RXSSEL3_N Mask      */
#define SPI0_FIFORDNOPOP_SOT_Pos            20                                                      /*!< SPI0 FIFORDNOPOP: SOT Position        */
#define SPI0_FIFORDNOPOP_SOT_Msk            (0x01UL << SPI0_FIFORDNOPOP_SOT_Pos)                  /*!< SPI0 FIFORDNOPOP: SOT Mask            */

/* --------------------------------  u0_spi_PSELID  ------------------------------- */
#define SPI0_PSELID_PERSEL_Pos              0                                                       /*!< SPI0 PSELID: PERSEL Position          */
#define SPI0_PSELID_PERSEL_Msk              (0x07UL << SPI0_PSELID_PERSEL_Pos)                    /*!< SPI0 PSELID: PERSEL Mask              */
#define SPI0_PSELID_LOCK_Pos                3                                                       /*!< SPI0 PSELID: LOCK Position            */
#define SPI0_PSELID_LOCK_Msk                (0x01UL << SPI0_PSELID_LOCK_Pos)                      /*!< SPI0 PSELID: LOCK Mask                */
#define SPI0_PSELID_SPIPRESENT_Pos          5                                                       /*!< SPI0 PSELID: SPIPRESENT Position      */
#define SPI0_PSELID_SPIPRESENT_Msk          (0x01UL << SPI0_PSELID_SPIPRESENT_Pos)                /*!< SPI0 PSELID: SPIPRESENT Mask          */
#define SPI0_PSELID_ID_Pos                  12                                                      /*!< SPI0 PSELID: ID Position              */
#define SPI0_PSELID_ID_Msk                  (0x000fffffUL << SPI0_PSELID_ID_Pos)                  /*!< SPI0 PSELID: ID Mask                  */

/* ----------------------------------  u0_spi_ID  --------------------------------- */
#define SPI0_ID_APERTURE_Pos                0                                                       /*!< SPI0 ID: APERTURE Position            */
#define SPI0_ID_APERTURE_Msk                (0x000000ffUL << SPI0_ID_APERTURE_Pos)                /*!< SPI0 ID: APERTURE Mask                */
#define SPI0_ID_MIN_REV_Pos                 8                                                       /*!< SPI0 ID: MIN_REV Position             */
#define SPI0_ID_MIN_REV_Msk                 (0x0fUL << SPI0_ID_MIN_REV_Pos)                       /*!< SPI0 ID: MIN_REV Mask                 */
#define SPI0_ID_MAJ_REV_Pos                 12                                                      /*!< SPI0 ID: MAJ_REV Position             */
#define SPI0_ID_MAJ_REV_Msk                 (0x0fUL << SPI0_ID_MAJ_REV_Pos)                       /*!< SPI0 ID: MAJ_REV Mask                 */
#define SPI0_ID_ID_Pos                      16                                                      /*!< SPI0 ID: ID Position                  */
#define SPI0_ID_ID_Msk                      (0x0000ffffUL << SPI0_ID_ID_Pos)                      /*!< SPI0 ID: ID Mask                      */


/* ================================================================================ */
/* ================         struct 'u1_spi' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u1_spi_CFG  --------------------------------- */
#define SPI1_CFG_ENABLE_Pos                 0                                                       /*!< SPI1 CFG: ENABLE Position             */
#define SPI1_CFG_ENABLE_Msk                 (0x01UL << SPI1_CFG_ENABLE_Pos)                       /*!< SPI1 CFG: ENABLE Mask                 */
#define SPI1_CFG_MASTER_Pos                 2                                                       /*!< SPI1 CFG: MASTER Position             */
#define SPI1_CFG_MASTER_Msk                 (0x01UL << SPI1_CFG_MASTER_Pos)                       /*!< SPI1 CFG: MASTER Mask                 */
#define SPI1_CFG_LSBF_Pos                   3                                                       /*!< SPI1 CFG: LSBF Position               */
#define SPI1_CFG_LSBF_Msk                   (0x01UL << SPI1_CFG_LSBF_Pos)                         /*!< SPI1 CFG: LSBF Mask                   */
#define SPI1_CFG_CPHA_Pos                   4                                                       /*!< SPI1 CFG: CPHA Position               */
#define SPI1_CFG_CPHA_Msk                   (0x01UL << SPI1_CFG_CPHA_Pos)                         /*!< SPI1 CFG: CPHA Mask                   */
#define SPI1_CFG_CPOL_Pos                   5                                                       /*!< SPI1 CFG: CPOL Position               */
#define SPI1_CFG_CPOL_Msk                   (0x01UL << SPI1_CFG_CPOL_Pos)                         /*!< SPI1 CFG: CPOL Mask                   */
#define SPI1_CFG_LOOP_Pos                   7                                                       /*!< SPI1 CFG: LOOP Position               */
#define SPI1_CFG_LOOP_Msk                   (0x01UL << SPI1_CFG_LOOP_Pos)                         /*!< SPI1 CFG: LOOP Mask                   */
#define SPI1_CFG_SPOL0_Pos                  8                                                       /*!< SPI1 CFG: SPOL0 Position              */
#define SPI1_CFG_SPOL0_Msk                  (0x01UL << SPI1_CFG_SPOL0_Pos)                        /*!< SPI1 CFG: SPOL0 Mask                  */
#define SPI1_CFG_SPOL1_Pos                  9                                                       /*!< SPI1 CFG: SPOL1 Position              */
#define SPI1_CFG_SPOL1_Msk                  (0x01UL << SPI1_CFG_SPOL1_Pos)                        /*!< SPI1 CFG: SPOL1 Mask                  */
#define SPI1_CFG_SPOL2_Pos                  10                                                      /*!< SPI1 CFG: SPOL2 Position              */
#define SPI1_CFG_SPOL2_Msk                  (0x01UL << SPI1_CFG_SPOL2_Pos)                        /*!< SPI1 CFG: SPOL2 Mask                  */
#define SPI1_CFG_SPOL3_Pos                  11                                                      /*!< SPI1 CFG: SPOL3 Position              */
#define SPI1_CFG_SPOL3_Msk                  (0x01UL << SPI1_CFG_SPOL3_Pos)                        /*!< SPI1 CFG: SPOL3 Mask                  */

/* ---------------------------------  u1_spi_DLY  --------------------------------- */
#define SPI1_DLY_PRE_DELAY_Pos              0                                                       /*!< SPI1 DLY: PRE_DELAY Position          */
#define SPI1_DLY_PRE_DELAY_Msk              (0x0fUL << SPI1_DLY_PRE_DELAY_Pos)                    /*!< SPI1 DLY: PRE_DELAY Mask              */
#define SPI1_DLY_POST_DELAY_Pos             4                                                       /*!< SPI1 DLY: POST_DELAY Position         */
#define SPI1_DLY_POST_DELAY_Msk             (0x0fUL << SPI1_DLY_POST_DELAY_Pos)                   /*!< SPI1 DLY: POST_DELAY Mask             */
#define SPI1_DLY_FRAME_DELAY_Pos            8                                                       /*!< SPI1 DLY: FRAME_DELAY Position        */
#define SPI1_DLY_FRAME_DELAY_Msk            (0x0fUL << SPI1_DLY_FRAME_DELAY_Pos)                  /*!< SPI1 DLY: FRAME_DELAY Mask            */
#define SPI1_DLY_TRANSFER_DELAY_Pos         12                                                      /*!< SPI1 DLY: TRANSFER_DELAY Position     */
#define SPI1_DLY_TRANSFER_DELAY_Msk         (0x0fUL << SPI1_DLY_TRANSFER_DELAY_Pos)               /*!< SPI1 DLY: TRANSFER_DELAY Mask         */

/* ---------------------------------  u1_spi_STAT  -------------------------------- */
#define SPI1_STAT_RXOV_Pos                  2                                                       /*!< SPI1 STAT: RXOV Position              */
#define SPI1_STAT_RXOV_Msk                  (0x01UL << SPI1_STAT_RXOV_Pos)                        /*!< SPI1 STAT: RXOV Mask                  */
#define SPI1_STAT_TXUR_Pos                  3                                                       /*!< SPI1 STAT: TXUR Position              */
#define SPI1_STAT_TXUR_Msk                  (0x01UL << SPI1_STAT_TXUR_Pos)                        /*!< SPI1 STAT: TXUR Mask                  */
#define SPI1_STAT_SSA_Pos                   4                                                       /*!< SPI1 STAT: SSA Position               */
#define SPI1_STAT_SSA_Msk                   (0x01UL << SPI1_STAT_SSA_Pos)                         /*!< SPI1 STAT: SSA Mask                   */
#define SPI1_STAT_SSD_Pos                   5                                                       /*!< SPI1 STAT: SSD Position               */
#define SPI1_STAT_SSD_Msk                   (0x01UL << SPI1_STAT_SSD_Pos)                         /*!< SPI1 STAT: SSD Mask                   */
#define SPI1_STAT_STALLED_Pos               6                                                       /*!< SPI1 STAT: STALLED Position           */
#define SPI1_STAT_STALLED_Msk               (0x01UL << SPI1_STAT_STALLED_Pos)                     /*!< SPI1 STAT: STALLED Mask               */
#define SPI1_STAT_ENDTRANSFER_Pos           7                                                       /*!< SPI1 STAT: ENDTRANSFER Position       */
#define SPI1_STAT_ENDTRANSFER_Msk           (0x01UL << SPI1_STAT_ENDTRANSFER_Pos)                 /*!< SPI1 STAT: ENDTRANSFER Mask           */
#define SPI1_STAT_MSTIDLE_Pos               8                                                       /*!< SPI1 STAT: MSTIDLE Position           */
#define SPI1_STAT_MSTIDLE_Msk               (0x01UL << SPI1_STAT_MSTIDLE_Pos)                     /*!< SPI1 STAT: MSTIDLE Mask               */

/* -------------------------------  u1_spi_INTENSET  ------------------------------ */
#define SPI1_INTENSET_RXOVEN_Pos            2                                                       /*!< SPI1 INTENSET: RXOVEN Position        */
#define SPI1_INTENSET_RXOVEN_Msk            (0x01UL << SPI1_INTENSET_RXOVEN_Pos)                  /*!< SPI1 INTENSET: RXOVEN Mask            */
#define SPI1_INTENSET_TXUREN_Pos            3                                                       /*!< SPI1 INTENSET: TXUREN Position        */
#define SPI1_INTENSET_TXUREN_Msk            (0x01UL << SPI1_INTENSET_TXUREN_Pos)                  /*!< SPI1 INTENSET: TXUREN Mask            */
#define SPI1_INTENSET_SSAEN_Pos             4                                                       /*!< SPI1 INTENSET: SSAEN Position         */
#define SPI1_INTENSET_SSAEN_Msk             (0x01UL << SPI1_INTENSET_SSAEN_Pos)                   /*!< SPI1 INTENSET: SSAEN Mask             */
#define SPI1_INTENSET_SSDEN_Pos             5                                                       /*!< SPI1 INTENSET: SSDEN Position         */
#define SPI1_INTENSET_SSDEN_Msk             (0x01UL << SPI1_INTENSET_SSDEN_Pos)                   /*!< SPI1 INTENSET: SSDEN Mask             */
#define SPI1_INTENSET_MSTIDLEEN_Pos         8                                                       /*!< SPI1 INTENSET: MSTIDLEEN Position     */
#define SPI1_INTENSET_MSTIDLEEN_Msk         (0x01UL << SPI1_INTENSET_MSTIDLEEN_Pos)               /*!< SPI1 INTENSET: MSTIDLEEN Mask         */

/* -------------------------------  u1_spi_INTENCLR  ------------------------------ */
#define SPI1_INTENCLR_RXOVCLR_Pos           2                                                       /*!< SPI1 INTENCLR: RXOVCLR Position       */
#define SPI1_INTENCLR_RXOVCLR_Msk           (0x01UL << SPI1_INTENCLR_RXOVCLR_Pos)                 /*!< SPI1 INTENCLR: RXOVCLR Mask           */
#define SPI1_INTENCLR_TXURCLR_Pos           3                                                       /*!< SPI1 INTENCLR: TXURCLR Position       */
#define SPI1_INTENCLR_TXURCLR_Msk           (0x01UL << SPI1_INTENCLR_TXURCLR_Pos)                 /*!< SPI1 INTENCLR: TXURCLR Mask           */
#define SPI1_INTENCLR_SSACLR_Pos            4                                                       /*!< SPI1 INTENCLR: SSACLR Position        */
#define SPI1_INTENCLR_SSACLR_Msk            (0x01UL << SPI1_INTENCLR_SSACLR_Pos)                  /*!< SPI1 INTENCLR: SSACLR Mask            */
#define SPI1_INTENCLR_SSDCLR_Pos            5                                                       /*!< SPI1 INTENCLR: SSDCLR Position        */
#define SPI1_INTENCLR_SSDCLR_Msk            (0x01UL << SPI1_INTENCLR_SSDCLR_Pos)                  /*!< SPI1 INTENCLR: SSDCLR Mask            */
#define SPI1_INTENCLR_MSTIDLECLR_Pos        8                                                       /*!< SPI1 INTENCLR: MSTIDLECLR Position    */
#define SPI1_INTENCLR_MSTIDLECLR_Msk        (0x01UL << SPI1_INTENCLR_MSTIDLECLR_Pos)              /*!< SPI1 INTENCLR: MSTIDLECLR Mask        */

/* --------------------------------  u1_spi_TXCTL  -------------------------------- */
#define SPI1_TXCTL_TXSSEL0_N_Pos            16                                                      /*!< SPI1 TXCTL: TXSSEL0_N Position        */
#define SPI1_TXCTL_TXSSEL0_N_Msk            (0x01UL << SPI1_TXCTL_TXSSEL0_N_Pos)                  /*!< SPI1 TXCTL: TXSSEL0_N Mask            */
#define SPI1_TXCTL_TXSSEL1_N_Pos            17                                                      /*!< SPI1 TXCTL: TXSSEL1_N Position        */
#define SPI1_TXCTL_TXSSEL1_N_Msk            (0x01UL << SPI1_TXCTL_TXSSEL1_N_Pos)                  /*!< SPI1 TXCTL: TXSSEL1_N Mask            */
#define SPI1_TXCTL_TXSSEL2_N_Pos            18                                                      /*!< SPI1 TXCTL: TXSSEL2_N Position        */
#define SPI1_TXCTL_TXSSEL2_N_Msk            (0x01UL << SPI1_TXCTL_TXSSEL2_N_Pos)                  /*!< SPI1 TXCTL: TXSSEL2_N Mask            */
#define SPI1_TXCTL_TXSSEL3_N_Pos            19                                                      /*!< SPI1 TXCTL: TXSSEL3_N Position        */
#define SPI1_TXCTL_TXSSEL3_N_Msk            (0x01UL << SPI1_TXCTL_TXSSEL3_N_Pos)                  /*!< SPI1 TXCTL: TXSSEL3_N Mask            */
#define SPI1_TXCTL_EOTR_Pos                 20                                                      /*!< SPI1 TXCTL: EOTR Position             */
#define SPI1_TXCTL_EOTR_Msk                 (0x01UL << SPI1_TXCTL_EOTR_Pos)                       /*!< SPI1 TXCTL: EOTR Mask                 */
#define SPI1_TXCTL_EOFR_Pos                 21                                                      /*!< SPI1 TXCTL: EOFR Position             */
#define SPI1_TXCTL_EOFR_Msk                 (0x01UL << SPI1_TXCTL_EOFR_Pos)                       /*!< SPI1 TXCTL: EOFR Mask                 */
#define SPI1_TXCTL_RXIGNORE_Pos             22                                                      /*!< SPI1 TXCTL: RXIGNORE Position         */
#define SPI1_TXCTL_RXIGNORE_Msk             (0x01UL << SPI1_TXCTL_RXIGNORE_Pos)                   /*!< SPI1 TXCTL: RXIGNORE Mask             */
#define SPI1_TXCTL_LEN_Pos                  24                                                      /*!< SPI1 TXCTL: LEN Position              */
#define SPI1_TXCTL_LEN_Msk                  (0x0fUL << SPI1_TXCTL_LEN_Pos)                        /*!< SPI1 TXCTL: LEN Mask                  */

/* ---------------------------------  u1_spi_DIV  --------------------------------- */
#define SPI1_DIV_DIVVAL_Pos                 0                                                       /*!< SPI1 DIV: DIVVAL Position             */
#define SPI1_DIV_DIVVAL_Msk                 (0x0000ffffUL << SPI1_DIV_DIVVAL_Pos)                 /*!< SPI1 DIV: DIVVAL Mask                 */

/* -------------------------------  u1_spi_INTSTAT  ------------------------------- */
#define SPI1_INTSTAT_RXOV_Pos               2                                                       /*!< SPI1 INTSTAT: RXOV Position           */
#define SPI1_INTSTAT_RXOV_Msk               (0x01UL << SPI1_INTSTAT_RXOV_Pos)                     /*!< SPI1 INTSTAT: RXOV Mask               */
#define SPI1_INTSTAT_TXUR_Pos               3                                                       /*!< SPI1 INTSTAT: TXUR Position           */
#define SPI1_INTSTAT_TXUR_Msk               (0x01UL << SPI1_INTSTAT_TXUR_Pos)                     /*!< SPI1 INTSTAT: TXUR Mask               */
#define SPI1_INTSTAT_SSA_Pos                4                                                       /*!< SPI1 INTSTAT: SSA Position            */
#define SPI1_INTSTAT_SSA_Msk                (0x01UL << SPI1_INTSTAT_SSA_Pos)                      /*!< SPI1 INTSTAT: SSA Mask                */
#define SPI1_INTSTAT_SSD_Pos                5                                                       /*!< SPI1 INTSTAT: SSD Position            */
#define SPI1_INTSTAT_SSD_Msk                (0x01UL << SPI1_INTSTAT_SSD_Pos)                      /*!< SPI1 INTSTAT: SSD Mask                */
#define SPI1_INTSTAT_MSTIDLE_Pos            8                                                       /*!< SPI1 INTSTAT: MSTIDLE Position        */
#define SPI1_INTSTAT_MSTIDLE_Msk            (0x01UL << SPI1_INTSTAT_MSTIDLE_Pos)                  /*!< SPI1 INTSTAT: MSTIDLE Mask            */

/* -------------------------------  u1_spi_FIFOCFG  ------------------------------- */
#define SPI1_FIFOCFG_ENABLETX_Pos           0                                                       /*!< SPI1 FIFOCFG: ENABLETX Position       */
#define SPI1_FIFOCFG_ENABLETX_Msk           (0x01UL << SPI1_FIFOCFG_ENABLETX_Pos)                 /*!< SPI1 FIFOCFG: ENABLETX Mask           */
#define SPI1_FIFOCFG_ENABLERX_Pos           1                                                       /*!< SPI1 FIFOCFG: ENABLERX Position       */
#define SPI1_FIFOCFG_ENABLERX_Msk           (0x01UL << SPI1_FIFOCFG_ENABLERX_Pos)                 /*!< SPI1 FIFOCFG: ENABLERX Mask           */
#define SPI1_FIFOCFG_SIZE_Pos               4                                                       /*!< SPI1 FIFOCFG: SIZE Position           */
#define SPI1_FIFOCFG_SIZE_Msk               (0x03UL << SPI1_FIFOCFG_SIZE_Pos)                     /*!< SPI1 FIFOCFG: SIZE Mask               */
#define SPI1_FIFOCFG_DMATX_Pos              12                                                      /*!< SPI1 FIFOCFG: DMATX Position          */
#define SPI1_FIFOCFG_DMATX_Msk              (0x01UL << SPI1_FIFOCFG_DMATX_Pos)                    /*!< SPI1 FIFOCFG: DMATX Mask              */
#define SPI1_FIFOCFG_DMARX_Pos              13                                                      /*!< SPI1 FIFOCFG: DMARX Position          */
#define SPI1_FIFOCFG_DMARX_Msk              (0x01UL << SPI1_FIFOCFG_DMARX_Pos)                    /*!< SPI1 FIFOCFG: DMARX Mask              */
#define SPI1_FIFOCFG_WAKETX_Pos             14                                                      /*!< SPI1 FIFOCFG: WAKETX Position         */
#define SPI1_FIFOCFG_WAKETX_Msk             (0x01UL << SPI1_FIFOCFG_WAKETX_Pos)                   /*!< SPI1 FIFOCFG: WAKETX Mask             */
#define SPI1_FIFOCFG_WAKERX_Pos             15                                                      /*!< SPI1 FIFOCFG: WAKERX Position         */
#define SPI1_FIFOCFG_WAKERX_Msk             (0x01UL << SPI1_FIFOCFG_WAKERX_Pos)                   /*!< SPI1 FIFOCFG: WAKERX Mask             */
#define SPI1_FIFOCFG_EMPTYTX_Pos            16                                                      /*!< SPI1 FIFOCFG: EMPTYTX Position        */
#define SPI1_FIFOCFG_EMPTYTX_Msk            (0x01UL << SPI1_FIFOCFG_EMPTYTX_Pos)                  /*!< SPI1 FIFOCFG: EMPTYTX Mask            */
#define SPI1_FIFOCFG_EMPTYRX_Pos            17                                                      /*!< SPI1 FIFOCFG: EMPTYRX Position        */
#define SPI1_FIFOCFG_EMPTYRX_Msk            (0x01UL << SPI1_FIFOCFG_EMPTYRX_Pos)                  /*!< SPI1 FIFOCFG: EMPTYRX Mask            */
#define SPI1_FIFOCFG_POPDBG_Pos             18                                                      /*!< SPI1 FIFOCFG: POPDBG Position         */
#define SPI1_FIFOCFG_POPDBG_Msk             (0x01UL << SPI1_FIFOCFG_POPDBG_Pos)                   /*!< SPI1 FIFOCFG: POPDBG Mask             */

/* -------------------------------  u1_spi_FIFOSTAT  ------------------------------ */
#define SPI1_FIFOSTAT_TXERR_Pos             0                                                       /*!< SPI1 FIFOSTAT: TXERR Position         */
#define SPI1_FIFOSTAT_TXERR_Msk             (0x01UL << SPI1_FIFOSTAT_TXERR_Pos)                   /*!< SPI1 FIFOSTAT: TXERR Mask             */
#define SPI1_FIFOSTAT_RXERR_Pos             1                                                       /*!< SPI1 FIFOSTAT: RXERR Position         */
#define SPI1_FIFOSTAT_RXERR_Msk             (0x01UL << SPI1_FIFOSTAT_RXERR_Pos)                   /*!< SPI1 FIFOSTAT: RXERR Mask             */
#define SPI1_FIFOSTAT_PERINT_Pos            3                                                       /*!< SPI1 FIFOSTAT: PERINT Position        */
#define SPI1_FIFOSTAT_PERINT_Msk            (0x01UL << SPI1_FIFOSTAT_PERINT_Pos)                  /*!< SPI1 FIFOSTAT: PERINT Mask            */
#define SPI1_FIFOSTAT_TXEMPTY_Pos           4                                                       /*!< SPI1 FIFOSTAT: TXEMPTY Position       */
#define SPI1_FIFOSTAT_TXEMPTY_Msk           (0x01UL << SPI1_FIFOSTAT_TXEMPTY_Pos)                 /*!< SPI1 FIFOSTAT: TXEMPTY Mask           */
#define SPI1_FIFOSTAT_TXNOTFULL_Pos         5                                                       /*!< SPI1 FIFOSTAT: TXNOTFULL Position     */
#define SPI1_FIFOSTAT_TXNOTFULL_Msk         (0x01UL << SPI1_FIFOSTAT_TXNOTFULL_Pos)               /*!< SPI1 FIFOSTAT: TXNOTFULL Mask         */
#define SPI1_FIFOSTAT_RXNOTEMPTY_Pos        6                                                       /*!< SPI1 FIFOSTAT: RXNOTEMPTY Position    */
#define SPI1_FIFOSTAT_RXNOTEMPTY_Msk        (0x01UL << SPI1_FIFOSTAT_RXNOTEMPTY_Pos)              /*!< SPI1 FIFOSTAT: RXNOTEMPTY Mask        */
#define SPI1_FIFOSTAT_RXFULL_Pos            7                                                       /*!< SPI1 FIFOSTAT: RXFULL Position        */
#define SPI1_FIFOSTAT_RXFULL_Msk            (0x01UL << SPI1_FIFOSTAT_RXFULL_Pos)                  /*!< SPI1 FIFOSTAT: RXFULL Mask            */
#define SPI1_FIFOSTAT_TXLVL_Pos             8                                                       /*!< SPI1 FIFOSTAT: TXLVL Position         */
#define SPI1_FIFOSTAT_TXLVL_Msk             (0x1fUL << SPI1_FIFOSTAT_TXLVL_Pos)                   /*!< SPI1 FIFOSTAT: TXLVL Mask             */
#define SPI1_FIFOSTAT_RXLVL_Pos             16                                                      /*!< SPI1 FIFOSTAT: RXLVL Position         */
#define SPI1_FIFOSTAT_RXLVL_Msk             (0x1fUL << SPI1_FIFOSTAT_RXLVL_Pos)                   /*!< SPI1 FIFOSTAT: RXLVL Mask             */

/* -------------------------------  u1_spi_FIFOTRIG  ------------------------------ */
#define SPI1_FIFOTRIG_TXLVLENA_Pos          0                                                       /*!< SPI1 FIFOTRIG: TXLVLENA Position      */
#define SPI1_FIFOTRIG_TXLVLENA_Msk          (0x01UL << SPI1_FIFOTRIG_TXLVLENA_Pos)                /*!< SPI1 FIFOTRIG: TXLVLENA Mask          */
#define SPI1_FIFOTRIG_RXLVLENA_Pos          1                                                       /*!< SPI1 FIFOTRIG: RXLVLENA Position      */
#define SPI1_FIFOTRIG_RXLVLENA_Msk          (0x01UL << SPI1_FIFOTRIG_RXLVLENA_Pos)                /*!< SPI1 FIFOTRIG: RXLVLENA Mask          */
#define SPI1_FIFOTRIG_TXLVL_Pos             8                                                       /*!< SPI1 FIFOTRIG: TXLVL Position         */
#define SPI1_FIFOTRIG_TXLVL_Msk             (0x0fUL << SPI1_FIFOTRIG_TXLVL_Pos)                   /*!< SPI1 FIFOTRIG: TXLVL Mask             */
#define SPI1_FIFOTRIG_RXLVL_Pos             16                                                      /*!< SPI1 FIFOTRIG: RXLVL Position         */
#define SPI1_FIFOTRIG_RXLVL_Msk             (0x0fUL << SPI1_FIFOTRIG_RXLVL_Pos)                   /*!< SPI1 FIFOTRIG: RXLVL Mask             */

/* -----------------------------  u1_spi_FIFOINTENSET  ---------------------------- */
#define SPI1_FIFOINTENSET_TXERR_Pos         0                                                       /*!< SPI1 FIFOINTENSET: TXERR Position     */
#define SPI1_FIFOINTENSET_TXERR_Msk         (0x01UL << SPI1_FIFOINTENSET_TXERR_Pos)               /*!< SPI1 FIFOINTENSET: TXERR Mask         */
#define SPI1_FIFOINTENSET_RXERR_Pos         1                                                       /*!< SPI1 FIFOINTENSET: RXERR Position     */
#define SPI1_FIFOINTENSET_RXERR_Msk         (0x01UL << SPI1_FIFOINTENSET_RXERR_Pos)               /*!< SPI1 FIFOINTENSET: RXERR Mask         */
#define SPI1_FIFOINTENSET_TXLVL_Pos         2                                                       /*!< SPI1 FIFOINTENSET: TXLVL Position     */
#define SPI1_FIFOINTENSET_TXLVL_Msk         (0x01UL << SPI1_FIFOINTENSET_TXLVL_Pos)               /*!< SPI1 FIFOINTENSET: TXLVL Mask         */
#define SPI1_FIFOINTENSET_RXLVL_Pos         3                                                       /*!< SPI1 FIFOINTENSET: RXLVL Position     */
#define SPI1_FIFOINTENSET_RXLVL_Msk         (0x01UL << SPI1_FIFOINTENSET_RXLVL_Pos)               /*!< SPI1 FIFOINTENSET: RXLVL Mask         */

/* -----------------------------  u1_spi_FIFOINTENCLR  ---------------------------- */
#define SPI1_FIFOINTENCLR_TXERR_Pos         0                                                       /*!< SPI1 FIFOINTENCLR: TXERR Position     */
#define SPI1_FIFOINTENCLR_TXERR_Msk         (0x01UL << SPI1_FIFOINTENCLR_TXERR_Pos)               /*!< SPI1 FIFOINTENCLR: TXERR Mask         */
#define SPI1_FIFOINTENCLR_RXERR_Pos         1                                                       /*!< SPI1 FIFOINTENCLR: RXERR Position     */
#define SPI1_FIFOINTENCLR_RXERR_Msk         (0x01UL << SPI1_FIFOINTENCLR_RXERR_Pos)               /*!< SPI1 FIFOINTENCLR: RXERR Mask         */
#define SPI1_FIFOINTENCLR_TXLVL_Pos         2                                                       /*!< SPI1 FIFOINTENCLR: TXLVL Position     */
#define SPI1_FIFOINTENCLR_TXLVL_Msk         (0x01UL << SPI1_FIFOINTENCLR_TXLVL_Pos)               /*!< SPI1 FIFOINTENCLR: TXLVL Mask         */
#define SPI1_FIFOINTENCLR_RXLVL_Pos         3                                                       /*!< SPI1 FIFOINTENCLR: RXLVL Position     */
#define SPI1_FIFOINTENCLR_RXLVL_Msk         (0x01UL << SPI1_FIFOINTENCLR_RXLVL_Pos)               /*!< SPI1 FIFOINTENCLR: RXLVL Mask         */

/* -----------------------------  u1_spi_FIFOINTSTAT  ----------------------------- */
#define SPI1_FIFOINTSTAT_TXERR_Pos          0                                                       /*!< SPI1 FIFOINTSTAT: TXERR Position      */
#define SPI1_FIFOINTSTAT_TXERR_Msk          (0x01UL << SPI1_FIFOINTSTAT_TXERR_Pos)                /*!< SPI1 FIFOINTSTAT: TXERR Mask          */
#define SPI1_FIFOINTSTAT_RXERR_Pos          1                                                       /*!< SPI1 FIFOINTSTAT: RXERR Position      */
#define SPI1_FIFOINTSTAT_RXERR_Msk          (0x01UL << SPI1_FIFOINTSTAT_RXERR_Pos)                /*!< SPI1 FIFOINTSTAT: RXERR Mask          */
#define SPI1_FIFOINTSTAT_TXLVL_Pos          2                                                       /*!< SPI1 FIFOINTSTAT: TXLVL Position      */
#define SPI1_FIFOINTSTAT_TXLVL_Msk          (0x01UL << SPI1_FIFOINTSTAT_TXLVL_Pos)                /*!< SPI1 FIFOINTSTAT: TXLVL Mask          */
#define SPI1_FIFOINTSTAT_RXLVL_Pos          3                                                       /*!< SPI1 FIFOINTSTAT: RXLVL Position      */
#define SPI1_FIFOINTSTAT_RXLVL_Msk          (0x01UL << SPI1_FIFOINTSTAT_RXLVL_Pos)                /*!< SPI1 FIFOINTSTAT: RXLVL Mask          */
#define SPI1_FIFOINTSTAT_PERINT_Pos         4                                                       /*!< SPI1 FIFOINTSTAT: PERINT Position     */
#define SPI1_FIFOINTSTAT_PERINT_Msk         (0x01UL << SPI1_FIFOINTSTAT_PERINT_Pos)               /*!< SPI1 FIFOINTSTAT: PERINT Mask         */

/* --------------------------------  u1_spi_FIFOWR  ------------------------------- */
#define SPI1_FIFOWR_TXDATA_Pos              0                                                       /*!< SPI1 FIFOWR: TXDATA Position          */
#define SPI1_FIFOWR_TXDATA_Msk              (0x0000ffffUL << SPI1_FIFOWR_TXDATA_Pos)              /*!< SPI1 FIFOWR: TXDATA Mask              */
#define SPI1_FIFOWR_TXSSEL0_N_Pos           16                                                      /*!< SPI1 FIFOWR: TXSSEL0_N Position       */
#define SPI1_FIFOWR_TXSSEL0_N_Msk           (0x01UL << SPI1_FIFOWR_TXSSEL0_N_Pos)                 /*!< SPI1 FIFOWR: TXSSEL0_N Mask           */
#define SPI1_FIFOWR_TXSSEL1_N_Pos           17                                                      /*!< SPI1 FIFOWR: TXSSEL1_N Position       */
#define SPI1_FIFOWR_TXSSEL1_N_Msk           (0x01UL << SPI1_FIFOWR_TXSSEL1_N_Pos)                 /*!< SPI1 FIFOWR: TXSSEL1_N Mask           */
#define SPI1_FIFOWR_TXSSEL2_N_Pos           18                                                      /*!< SPI1 FIFOWR: TXSSEL2_N Position       */
#define SPI1_FIFOWR_TXSSEL2_N_Msk           (0x01UL << SPI1_FIFOWR_TXSSEL2_N_Pos)                 /*!< SPI1 FIFOWR: TXSSEL2_N Mask           */
#define SPI1_FIFOWR_TXSSEL3_N_Pos           19                                                      /*!< SPI1 FIFOWR: TXSSEL3_N Position       */
#define SPI1_FIFOWR_TXSSEL3_N_Msk           (0x01UL << SPI1_FIFOWR_TXSSEL3_N_Pos)                 /*!< SPI1 FIFOWR: TXSSEL3_N Mask           */
#define SPI1_FIFOWR_EOTR_Pos                20                                                      /*!< SPI1 FIFOWR: EOTR Position            */
#define SPI1_FIFOWR_EOTR_Msk                (0x01UL << SPI1_FIFOWR_EOTR_Pos)                      /*!< SPI1 FIFOWR: EOTR Mask                */
#define SPI1_FIFOWR_EOFR_Pos                21                                                      /*!< SPI1 FIFOWR: EOFR Position            */
#define SPI1_FIFOWR_EOFR_Msk                (0x01UL << SPI1_FIFOWR_EOFR_Pos)                      /*!< SPI1 FIFOWR: EOFR Mask                */
#define SPI1_FIFOWR_RXIGNORE_Pos            22                                                      /*!< SPI1 FIFOWR: RXIGNORE Position        */
#define SPI1_FIFOWR_RXIGNORE_Msk            (0x01UL << SPI1_FIFOWR_RXIGNORE_Pos)                  /*!< SPI1 FIFOWR: RXIGNORE Mask            */
#define SPI1_FIFOWR_LEN_Pos                 24                                                      /*!< SPI1 FIFOWR: LEN Position             */
#define SPI1_FIFOWR_LEN_Msk                 (0x0fUL << SPI1_FIFOWR_LEN_Pos)                       /*!< SPI1 FIFOWR: LEN Mask                 */

/* --------------------------------  u1_spi_FIFORD  ------------------------------- */
#define SPI1_FIFORD_RXDATA_Pos              0                                                       /*!< SPI1 FIFORD: RXDATA Position          */
#define SPI1_FIFORD_RXDATA_Msk              (0x0000ffffUL << SPI1_FIFORD_RXDATA_Pos)              /*!< SPI1 FIFORD: RXDATA Mask              */
#define SPI1_FIFORD_RXSSEL0_N_Pos           16                                                      /*!< SPI1 FIFORD: RXSSEL0_N Position       */
#define SPI1_FIFORD_RXSSEL0_N_Msk           (0x01UL << SPI1_FIFORD_RXSSEL0_N_Pos)                 /*!< SPI1 FIFORD: RXSSEL0_N Mask           */
#define SPI1_FIFORD_RXSSEL1_N_Pos           17                                                      /*!< SPI1 FIFORD: RXSSEL1_N Position       */
#define SPI1_FIFORD_RXSSEL1_N_Msk           (0x01UL << SPI1_FIFORD_RXSSEL1_N_Pos)                 /*!< SPI1 FIFORD: RXSSEL1_N Mask           */
#define SPI1_FIFORD_RXSSEL2_N_Pos           18                                                      /*!< SPI1 FIFORD: RXSSEL2_N Position       */
#define SPI1_FIFORD_RXSSEL2_N_Msk           (0x01UL << SPI1_FIFORD_RXSSEL2_N_Pos)                 /*!< SPI1 FIFORD: RXSSEL2_N Mask           */
#define SPI1_FIFORD_RXSSEL3_N_Pos           19                                                      /*!< SPI1 FIFORD: RXSSEL3_N Position       */
#define SPI1_FIFORD_RXSSEL3_N_Msk           (0x01UL << SPI1_FIFORD_RXSSEL3_N_Pos)                 /*!< SPI1 FIFORD: RXSSEL3_N Mask           */
#define SPI1_FIFORD_SOT_Pos                 20                                                      /*!< SPI1 FIFORD: SOT Position             */
#define SPI1_FIFORD_SOT_Msk                 (0x01UL << SPI1_FIFORD_SOT_Pos)                       /*!< SPI1 FIFORD: SOT Mask                 */

/* -----------------------------  u1_spi_FIFORDNOPOP  ----------------------------- */
#define SPI1_FIFORDNOPOP_RXDATA_Pos         0                                                       /*!< SPI1 FIFORDNOPOP: RXDATA Position     */
#define SPI1_FIFORDNOPOP_RXDATA_Msk         (0x0000ffffUL << SPI1_FIFORDNOPOP_RXDATA_Pos)         /*!< SPI1 FIFORDNOPOP: RXDATA Mask         */
#define SPI1_FIFORDNOPOP_RXSSEL0_N_Pos      16                                                      /*!< SPI1 FIFORDNOPOP: RXSSEL0_N Position  */
#define SPI1_FIFORDNOPOP_RXSSEL0_N_Msk      (0x01UL << SPI1_FIFORDNOPOP_RXSSEL0_N_Pos)            /*!< SPI1 FIFORDNOPOP: RXSSEL0_N Mask      */
#define SPI1_FIFORDNOPOP_RXSSEL1_N_Pos      17                                                      /*!< SPI1 FIFORDNOPOP: RXSSEL1_N Position  */
#define SPI1_FIFORDNOPOP_RXSSEL1_N_Msk      (0x01UL << SPI1_FIFORDNOPOP_RXSSEL1_N_Pos)            /*!< SPI1 FIFORDNOPOP: RXSSEL1_N Mask      */
#define SPI1_FIFORDNOPOP_RXSSEL2_N_Pos      18                                                      /*!< SPI1 FIFORDNOPOP: RXSSEL2_N Position  */
#define SPI1_FIFORDNOPOP_RXSSEL2_N_Msk      (0x01UL << SPI1_FIFORDNOPOP_RXSSEL2_N_Pos)            /*!< SPI1 FIFORDNOPOP: RXSSEL2_N Mask      */
#define SPI1_FIFORDNOPOP_RXSSEL3_N_Pos      19                                                      /*!< SPI1 FIFORDNOPOP: RXSSEL3_N Position  */
#define SPI1_FIFORDNOPOP_RXSSEL3_N_Msk      (0x01UL << SPI1_FIFORDNOPOP_RXSSEL3_N_Pos)            /*!< SPI1 FIFORDNOPOP: RXSSEL3_N Mask      */
#define SPI1_FIFORDNOPOP_SOT_Pos            20                                                      /*!< SPI1 FIFORDNOPOP: SOT Position        */
#define SPI1_FIFORDNOPOP_SOT_Msk            (0x01UL << SPI1_FIFORDNOPOP_SOT_Pos)                  /*!< SPI1 FIFORDNOPOP: SOT Mask            */

/* --------------------------------  u1_spi_PSELID  ------------------------------- */
#define SPI1_PSELID_PERSEL_Pos              0                                                       /*!< SPI1 PSELID: PERSEL Position          */
#define SPI1_PSELID_PERSEL_Msk              (0x07UL << SPI1_PSELID_PERSEL_Pos)                    /*!< SPI1 PSELID: PERSEL Mask              */
#define SPI1_PSELID_LOCK_Pos                3                                                       /*!< SPI1 PSELID: LOCK Position            */
#define SPI1_PSELID_LOCK_Msk                (0x01UL << SPI1_PSELID_LOCK_Pos)                      /*!< SPI1 PSELID: LOCK Mask                */
#define SPI1_PSELID_SPIPRESENT_Pos          5                                                       /*!< SPI1 PSELID: SPIPRESENT Position      */
#define SPI1_PSELID_SPIPRESENT_Msk          (0x01UL << SPI1_PSELID_SPIPRESENT_Pos)                /*!< SPI1 PSELID: SPIPRESENT Mask          */
#define SPI1_PSELID_ID_Pos                  12                                                      /*!< SPI1 PSELID: ID Position              */
#define SPI1_PSELID_ID_Msk                  (0x000fffffUL << SPI1_PSELID_ID_Pos)                  /*!< SPI1 PSELID: ID Mask                  */

/* ----------------------------------  u1_spi_ID  --------------------------------- */
#define SPI1_ID_APERTURE_Pos                0                                                       /*!< SPI1 ID: APERTURE Position            */
#define SPI1_ID_APERTURE_Msk                (0x000000ffUL << SPI1_ID_APERTURE_Pos)                /*!< SPI1 ID: APERTURE Mask                */
#define SPI1_ID_MIN_REV_Pos                 8                                                       /*!< SPI1 ID: MIN_REV Position             */
#define SPI1_ID_MIN_REV_Msk                 (0x0fUL << SPI1_ID_MIN_REV_Pos)                       /*!< SPI1 ID: MIN_REV Mask                 */
#define SPI1_ID_MAJ_REV_Pos                 12                                                      /*!< SPI1 ID: MAJ_REV Position             */
#define SPI1_ID_MAJ_REV_Msk                 (0x0fUL << SPI1_ID_MAJ_REV_Pos)                       /*!< SPI1 ID: MAJ_REV Mask                 */
#define SPI1_ID_ID_Pos                      16                                                      /*!< SPI1 ID: ID Position                  */
#define SPI1_ID_ID_Msk                      (0x0000ffffUL << SPI1_ID_ID_Pos)                      /*!< SPI1 ID: ID Mask                      */


/* ================================================================================ */
/* ================         struct 'u_hash' Position & Mask        ================ */
/* ================================================================================ */


/* ---------------------------------  u_hash_CTRL  -------------------------------- */
#define HASH_CTRL_CTRL_Pos                  0                                                       /*!< HASH CTRL: CTRL Position              */
#define HASH_CTRL_CTRL_Msk                  (0xffffffffUL << HASH_CTRL_CTRL_Pos)                  /*!< HASH CTRL: CTRL Mask                  */

/* ---------------------------------  u_hash_STAT  -------------------------------- */
#define HASH_STAT_STAT_Pos                  0                                                       /*!< HASH STAT: STAT Position              */
#define HASH_STAT_STAT_Msk                  (0xffffffffUL << HASH_STAT_STAT_Pos)                  /*!< HASH STAT: STAT Mask                  */

/* --------------------------------  u_hash_INTEN  -------------------------------- */
#define HASH_INTEN_INTEN_Pos                0                                                       /*!< HASH INTEN: INTEN Position            */
#define HASH_INTEN_INTEN_Msk                (0xffffffffUL << HASH_INTEN_INTEN_Pos)                /*!< HASH INTEN: INTEN Mask                */

/* --------------------------------  u_hash_INTCLR  ------------------------------- */
#define HASH_INTCLR_INTCLR_Pos              0                                                       /*!< HASH INTCLR: INTCLR Position          */
#define HASH_INTCLR_INTCLR_Msk              (0xffffffffUL << HASH_INTCLR_INTCLR_Pos)              /*!< HASH INTCLR: INTCLR Mask              */

/* -------------------------------  u_hash_MEMCTRL  ------------------------------- */
#define HASH_MEMCTRL_MEMCTRL_Pos            0                                                       /*!< HASH MEMCTRL: MEMCTRL Position        */
#define HASH_MEMCTRL_MEMCTRL_Msk            (0xffffffffUL << HASH_MEMCTRL_MEMCTRL_Pos)            /*!< HASH MEMCTRL: MEMCTRL Mask            */

/* -------------------------------  u_hash_MEMADDR  ------------------------------- */
#define HASH_MEMADDR_MEMADDR_Pos            0                                                       /*!< HASH MEMADDR: MEMADDR Position        */
#define HASH_MEMADDR_MEMADDR_Msk            (0xffffffffUL << HASH_MEMADDR_MEMADDR_Pos)            /*!< HASH MEMADDR: MEMADDR Mask            */

/* --------------------------------  u_hash_INDATA  ------------------------------- */
#define HASH_INDATA_INDATA_Pos              0                                                       /*!< HASH INDATA: INDATA Position          */
#define HASH_INDATA_INDATA_Msk              (0xffffffffUL << HASH_INDATA_INDATA_Pos)              /*!< HASH INDATA: INDATA Mask              */

/* --------------------------------  u_hash_DIGEST  ------------------------------- */
#define HASH_DIGEST_DIGEST_Pos              0                                                       /*!< HASH DIGEST: DIGEST Position          */
#define HASH_DIGEST_DIGEST_Msk              (0xffffffffUL << HASH_DIGEST_DIGEST_Pos)              /*!< HASH DIGEST: DIGEST Mask              */

/* --------------------------------  u_hash_OUTD2  -------------------------------- */
#define HASH_OUTD2_OUTD2_Pos                0                                                       /*!< HASH OUTD2: OUTD2 Position            */
#define HASH_OUTD2_OUTD2_Msk                (0xffffffffUL << HASH_OUTD2_OUTD2_Pos)                /*!< HASH OUTD2: OUTD2 Mask                */

/* --------------------------------  u_hash_CRYPT  -------------------------------- */
#define HASH_CRYPT_CRYPT_Pos                0                                                       /*!< HASH CRYPT: CRYPT Position            */
#define HASH_CRYPT_CRYPT_Msk                (0xffffffffUL << HASH_CRYPT_CRYPT_Pos)                /*!< HASH CRYPT: CRYPT Mask                */

/* --------------------------------  u_hash_CONFIG  ------------------------------- */
#define HASH_CONFIG_CONFIG_Pos              0                                                       /*!< HASH CONFIG: CONFIG Position          */
#define HASH_CONFIG_CONFIG_Msk              (0xffffffffUL << HASH_CONFIG_CONFIG_Pos)              /*!< HASH CONFIG: CONFIG Mask              */

/* ---------------------------------  u_hash_MASK  -------------------------------- */
#define HASH_MASK_MASK_Pos                  0                                                       /*!< HASH MASK: MASK Position              */
#define HASH_MASK_MASK_Msk                  (0xffffffffUL << HASH_MASK_MASK_Pos)                  /*!< HASH MASK: MASK Mask                  */

/* ----------------------------------  u_hash_ID  --------------------------------- */
#define HASH_ID_APERTURE_Pos                0                                                       /*!< HASH ID: APERTURE Position            */
#define HASH_ID_APERTURE_Msk                (0x000000ffUL << HASH_ID_APERTURE_Pos)                /*!< HASH ID: APERTURE Mask                */
#define HASH_ID_MIN_REV_Pos                 8                                                       /*!< HASH ID: MIN_REV Position             */
#define HASH_ID_MIN_REV_Msk                 (0x0fUL << HASH_ID_MIN_REV_Pos)                       /*!< HASH ID: MIN_REV Mask                 */
#define HASH_ID_MAJ_REV_Pos                 12                                                      /*!< HASH ID: MAJ_REV Position             */
#define HASH_ID_MAJ_REV_Msk                 (0x0fUL << HASH_ID_MAJ_REV_Pos)                       /*!< HASH ID: MAJ_REV Mask                 */
#define HASH_ID_ID_Pos                      16                                                      /*!< HASH ID: ID Position                  */
#define HASH_ID_ID_Msk                      (0x0000ffffUL << HASH_ID_ID_Pos)                      /*!< HASH ID: ID Mask                      */



/* ================================================================================ */
/* ================              Peripheral memory map             ================ */
/* ================================================================================ */

#define u_syscon_BASE                   0x40000000UL
#define u_otpc_BASE                     0x40002000UL
#define u0_i2c_BASE                     0x40003000UL
#define u1_i2c_BASE                     0x40004000UL
#define u2_i2c_BASE                     0x40005000UL
#define u_iso7816_BASE                  0x40006000UL
#define u_cic_irb_BASE                  0x40007000UL
#define u_codepatch_BASE                0x40008000UL
#define u_flash_BASE                    0x40009000UL
#define u_wwdt_BASE                     0x4000A000UL
#define u_rtc_BASE                      0x4000B000UL
#define u_pwm_BASE                      0x4000C000UL
#define u_rng_BASE                      0x4000D000UL
#define u_inmux_BASE                    0x4000E000UL
#define u_iocon_BASE                    0x4000F000UL
#define u_pint_BASE                     0x40010000UL
#define u_gint_BASE                     0x40011000UL
#define u_pmc_BASE                      0x40012000UL
#define u_ble_dp_top_BASE               0x40014000UL
#define u_pvt_BASE                      0x40015000UL
#define u_async_syscon_BASE             0x40020000UL
#define u0_timer_BASE                   0x40021000UL
#define u1_timer_BASE                   0x40022000UL
#define u_gpio_BASE                     0x40080000UL
#define u_spifi_BASE                    0x40084000UL
#define u_dma_BASE                      0x40085000UL
#define u_aes256_BASE                   0x40086000UL
#define u_mailbox_BASE                  0x40087000UL
#define u_adc_BASE                      0x40089000UL
#define u_dmic_BASE                     0x4008A000UL
#define u0_usart_BASE                   0x4008B000UL
#define u1_usart_BASE                   0x4008C000UL
#define u0_spi_BASE                     0x4008D000UL
#define u1_spi_BASE                     0x4008E000UL
#define u_hash_BASE                     0x4008F000UL


/* ================================================================================ */
/* ================             Peripheral declaration             ================ */
/* ================================================================================ */

#define JN518X_SYSCON                        ((u_syscon_Type           *) u_syscon_BASE)
#define JN518X_OTPC                          ((u_otpc_Type             *) u_otpc_BASE)
#define JN518X_I2C0                          ((u0_i2c_Type             *) u0_i2c_BASE)
#define JN518X_I2C1                          ((u1_i2c_Type             *) u1_i2c_BASE)
#define JN518X_I2C2                          ((u2_i2c_Type             *) u2_i2c_BASE)
#define JN518X_ISO7816                       ((u_iso7816_Type          *) u_iso7816_BASE)
#define JN518X_IRB                       ((u_cic_irb_Type          *) u_cic_irb_BASE)
#define JN518X_CODEPATCH                     ((u_codepatch_Type        *) u_codepatch_BASE)
#define JN518X_FLASH                         ((u_flash_Type            *) u_flash_BASE)
#define JN518X_WWDT                          ((u_wwdt_Type             *) u_wwdt_BASE)
#define JN518X_RTC                           ((u_rtc_Type              *) u_rtc_BASE)
#define JN518X_PWM                           ((u_pwm_Type              *) u_pwm_BASE)
#define JN518X_RNG                           ((u_rng_Type              *) u_rng_BASE)
#define JN518X_INMUX                         ((u_inmux_Type            *) u_inmux_BASE)
#define JN518X_IOCON                         ((u_iocon_Type            *) u_iocon_BASE)
#define JN518X_PININT                          ((u_pint_Type             *) u_pint_BASE)
#define JN518X_GPIOINT                          ((u_gint_Type             *) u_gint_BASE)
#define JN518X_PMC                           ((u_pmc_Type              *) u_pmc_BASE)
#define JN518X_BLEMODEM                    ((u_ble_dp_top_Type       *) u_ble_dp_top_BASE)
#define JN518X_PVT                           ((u_pvt_Type              *) u_pvt_BASE)
#define JN518X_ASYSCON                  ((u_async_syscon_Type     *) u_async_syscon_BASE)
#define JN518X_CTIMER0                        ((u0_timer_Type           *) u0_timer_BASE)
#define JN518X_CTIMER1                        ((u1_timer_Type           *) u1_timer_BASE)
#define JN518X_GPIO                          ((u_gpio_Type             *) u_gpio_BASE)
#define JN518X_SPIFI                         ((u_spifi_Type            *) u_spifi_BASE)
#define JN518X_DMA                           ((u_dma_Type              *) u_dma_BASE)
#define JN518X_AES256                        ((u_aes256_Type           *) u_aes256_BASE)
#define JN518X_MAILBOX                       ((u_mailbox_Type          *) u_mailbox_BASE)
#define JN518X_ADC                           ((u_adc_Type              *) u_adc_BASE)
#define JN518X_DMIC                          ((u_dmic_Type             *) u_dmic_BASE)
#define JN518X_USART0                        ((u0_usart_Type           *) u0_usart_BASE)
#define JN518X_USART1                        ((u1_usart_Type           *) u1_usart_BASE)
#define JN518X_SPI0                          ((u0_spi_Type             *) u0_spi_BASE)
#define JN518X_SPI1                          ((u1_spi_Type             *) u1_spi_BASE)
#define JN518X_HASH                          ((u_hash_Type             *) u_hash_BASE)


#define u_ble_link__0x400A0000_BASE       0x400A0000UL
#define u_zb_modem__0x400B0000_BASE       0x400B0000UL
#define u_zb_mac__0x400B1000_BASE         0x400B1000UL
#define u_rfp_modem_0x40013000_BASE       0x40013000UL

#define JN518X_BLELNK                    ((BLE_LINK_IF_Type*) u_ble_link__0x400A0000_BASE)
#define JN518X_ZBMODEM                   ((ZB_MODEM_IF_Type*) u_zb_modem__0x400B0000_BASE)
#define JN518X_ZBMAC                     ((ZB_MAC_IF_Type*)   u_zb_mac__0x400B1000_BASE)
#define JN518X_RFPMODEM                  ((t_extapb_regfile*) u_rfp_modem_0x40013000_BASE)

/** @} */ /* End of group Device_Peripheral_Registers */
/** @} */ /* End of group jn518x */
/** @} */ /* End of group nxp.com */

#ifdef __cplusplus
}
#endif


#endif  /* _JN518XHW_H_ */
