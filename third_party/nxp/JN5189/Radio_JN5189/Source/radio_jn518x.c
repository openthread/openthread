// -- ----------------------------------------------------------------------------
// --                   Copyright Message
// -- ----------------------------------------------------------------------------
// --
// -- CONFIDENTIAL and PROPRIETARY
// -- COPYRIGHT (c) NXP B.V. 2016
// --
// -- All rights are reserved. Reproduction in whole or in part is
// -- prohibited without the written consent of the copyright owner.
// --
// -- ----------------------------------------------------------------------------
// --                   Design Information
// -- ----------------------------------------------------------------------------
// --
// -- Organisation    : Smart Home
// --
// -- File            : $RCSfile: radio_jn518x.C
// -- Date            : $Date: Wed Oct 26 17:54:55 2016 $
// -- Revision        : $Revision: 0.11 $
// --
// -- Author          : FranÃ§ois ROBBE
// -- Project         : jn518x
// --
// -- ----------------------------------------------------------------------------
// --                   Revision History
// -- ----------------------------------------------------------------------------
// --
// -- Date        Author  Revision  Change Description
// -- ==========  ======  ========  ==============================================
// --
// --
// -- ----------------------------------------------------------------------------
// --                   Revision History
// -- ----------------------------------------------------------------------------

#include "fsl_clock.h"
#include "jn518xHW.h"
#include "radio_jn518x.h"
#include "radio_test_jn518x.h"
#define vPrintf(FORMAT, ARGS...)
#define PRINTF(FORMAT, ARGS...)

extern __attribute__ ((weak)) bool bRadioCB_WriteNVM(uint8_t *pu8DataBlock, uint16_t u16Len);
extern __attribute__ ((weak)) uint16_t u16RadioCB_ReadNVM(uint8_t *pu8DataBlock , uint16_t u16MaxLen);

/***************************************************************************/
/***       Macros                                                        ***/
/***************************************************************************/
#define AGC_READY_PATCH
//#define INIT_OPTIM_ZB_BLE
#define INIT_OPTIM_ZB_BLE_2
#define FAST_TX_BLE
#define ACCESS_ADDRESS_PATCH
#define RECALTIMEAPI
#define USEXTALBASICTRIM
// #define AA_ERROR_RECOVERY_PATCH // do not enable this patch yet


// Calibration Values to apply

// Define values to put into the retention flops - for this test they are fixed values
// Normal operation they would be in efuse, flash or generated by calibration operations
// transceiver.r_rc_cal_d2r_if_val.fields.trimr_set
#define TRIMR_INIT_VAL                                  23   // 4bit resistor trim value (!! register complemented value)
// transceiver.r_rc_cal_d2r_if_val.fields.trimc_set
#define TRIMC_INIT_VAL                                  0x2   // 3bit capacitor trim value //RFT1676 SMB - value from sim 22/09/2017
// calibration.dco_cal_dc_offset_i.fields.fine_dc_offset_i
#define DCO_FINE_OFFSET_I_INIT_VAL                      0 // 12bit value to derive all 21 I offsets
// calibration.dco_cal_dc_offset_q.fields.fine_dc_offset_q
#define DCO_FINE_OFFSET_Q_INIT_VAL                      0 // 12bit value to derive all 21 Q offsets
// calibration.dco_cal_dc_offset_gain_index.fields.index
#define DCO_GAIN_INDEX_INIT_VAL                         0      //  5bit value for the gain index lookup reg
// calibration.dco_cal_dc_ana_offset_i.fields.coarse_dc_offset_i
#define DCO_ANA_OFFSET_I_INIT_VAL                       0   //4bit value to for standard coarse offset
// calibration.dco_cal_dc_ana_offset_q.fields.coarse_dc_offset_q
#define DCO_ANA_OFFSET_Q_INIT_VAL                       0   //4bit value to for standard coarse offset
// calibration.dco_cal_dc_ana_offset_i.fields.coarse_dc_offset_i_en
// calibration.dco_cal_dc_ana_offset_q.fields.coarse_dc_offset_q_en
#define DCO_ANA_OFFSET_EN_INIT_VAL                      0    // single bit, same value used for enabling I and Q offsets
// calibration.dco_cal_dc_ana_offset_lna_gain_i[i].fields.coarse_dc_offset_i
#define DCO_ANA_OFFSET_LNA_GAIN_I_INIT_VAL              0   //4bit value to derive all 5 ANA/Coarse offsets
// calibration.dco_cal_dc_ana_offset_lna_gain_q[i].fields.coarse_dc_offset_q
#define DCO_ANA_OFFSET_LNA_GAIN_Q_INIT_VAL              0   //4bit value to derive all 5 ANA/Coarse offsets
// calibration.dco_cal_dc_ana_offset_lna_gain_i[i].fields.coarse_dc_offset_i_en
// calibration.dco_cal_dc_ana_offset_lna_gain_q[i].fields.coarse_dc_offset_q_en
#define DCO_ANA_OFFSET_LNA_GAIN_EN_INIT_VAL             0    // single bit, same value used on all 5 I and Q offsets

// calibration.iq_cal_scale_factor.fields.iq_mismatch_scale_factor
#define IQ_MISMATCH_SCALE_FACTOR_INIT_VAL               256  // 9bit value
// calibration.iq_cal_cross_factor.fields.iq_mismatch_cross_factor
#define IQ_MISMATCH_CROSS_FACTOR_INIT_VAL               0  // 10bit value

// calibration.pa_cal_rcal[0].fields.rcal
#define PA_CAL_RCAL0_INIT_VAL                           0              // 10bit value
// calibration.pa_cal_rcal[1].fields.rcal
#define PA_CAL_RCAL1_INIT_VAL                           0            // 10bit value
// calibration.pa_cal_rcal[2].fields.rcal
#define PA_CAL_RCAL2_INIT_VAL                           0              // 10bit value
// calibration.pa_cal_rcal[3].fields.rcal
#define PA_CAL_RCAL3_INIT_VAL                           0              // 10bit value

// calibration.kmod_band_cal_count_1_msb.fields.count_1_msb
#define KMOD_BAND_CAL_COUNT_1_MSB_REG_INIT_VAL          9        //  6bit value
// calibration.kmod_band_cal_count_1_lsb.fields.count_1_lsb
#define KMOD_BAND_CAL_COUNT_1_LSB_REG_INIT_VAL          0x9556   // 16bit value  //RFT1676 SMB - value from sim 22/09/2017
// calibration.kmod_band_cal_count_2_msb.fields.count_1_msb
#define KMOD_BAND_CAL_COUNT_2_MSB_REG_INIT_VAL          9        //  6bit value
// calibration.kmod_band_cal_count_2_lsb.fields.count_1_lsb
#define KMOD_BAND_CAL_COUNT_2_LSB_REG_INIT_VAL          0x9441    // 16bit value  //RFT1676 SMB - value from sim 22/09/2017
// calibration.kmod_band_cal_corr_1.fields.corr_1
// tx_datapath.kmod_band_corr_1.fields.corr_1
#define KMOD_BAND_CAL_CORR_1_REG_INIT_VAL               946     // 16bit value   //RFT1676 SMB - value from sim 22/09/2017

// calibration.synth_cal_startup_aac_ictrl_out_store.fields.aac_ictrl_out_store
#define SYNTH_CAL_STARTUP_AAC_ICTRL_OUT_STORE_INIT_VAL  0        //  5bit value
// calibration.synth_cal_startup_afc_2_rx.fields.afc_2
#define SYNTH_CAL_STARTUP_AFC_2_RX_INIT_VAL             122      // 9bit value  //SMB - value from sim 12 June 2017
// calibration.synth_cal_startup_afc_2_tx.fields.afc_2
#define SYNTH_CAL_STARTUP_AFC_2_TX_INIT_VAL             122      // 9bit value   //SMB - value from sim 12 June 2017
// calibration.synth_cal_startup_afc_diff_rx.fields.afc_diff
#define SYNTH_CAL_STARTUP_AFC_DIFF_RX_INIT_VAL          15        // 8bit value  //SMB - value from sim 12 June 2017
// calibration.synth_cal_startup_afc_diff_tx.fields.afc_diff
#define SYNTH_CAL_STARTUP_AFC_DIFF_TX_INIT_VAL          15        // 8bit value  //SMB - value from sim 12 June 2017

// transceiver.bgr_d2r_if_val.fields.rx_bgr_cur5ua_1v8_set
#define RF_BGP_CUR5UA_INIT_VAL                          15       // 5bit value  //SMB - value from sim 12 June 2017

#define MF1_C_RADIO_ID 0x0003
#define MF1_C_PMU_ID 0x0006
#define C2_MF_RADIO_ID 0x0005
#define C2_MF_PMU_ID 0x0008

// Reset&restore Phy_MCTRL
/*					JN518X_ZBMODEM -> PHY_MCTRL_b.miom= 1; \ */
#define RESET_PHYON	u32PhyOn_sav= JN518X_ZBMODEM -> PHY_MCTRL_b.mphyon; \
					JN518X_ZBMODEM -> PHY_MCTRL_b.mphyon= 0;

#define RESTORE_PHYON	JN518X_ZBMODEM -> PHY_MCTRL_b.mphyon= u32PhyOn_sav;

#define RFPMODEM_FIELD_ENCODE(val, _REGNAME, _FLD)  (((val) << (EXTAPB_REGFILE_##_REGNAME##_##_FLD##_POS))  & EXTAPB_REGFILE_##_REGNAME##_##_FLD##_MASK)
#define RFPMODEM_FIELD_MASK(_REGNAME, _FLD)  EXTAPB_REGFILE_##_REGNAME##_##_FLD##_MASK
#define RFPMODEM_FIELD_POS(_REGNAME, _FLD)   EXTAPB_REGFILE_##_REGNAME##_##_FLD##_POS



#define TCAL_MASK (0x00000FFF)
#define TCAL_SHIFT 0
#define TCUR_MASK (0x0FFF0000)
#define TCUR_SHIFT 16
#define INIT_DONE_MASK (0x00008000)
#define INIT_DONE_SHIFT 15
#define TCUR_RECEIVED_MASK (0x40000000)
#define TCUR_RECEIVED_SHIFT 30
#define RECAL_NEEDED_MASK (0x80000000)
#define RECAL_NEEDED_SHIFT 31
#define AOREG_RADIO AOREG1

#define RTRIP_DELAY_BASIC     60
#define RXPWRUP_DELAY_BASIC  137
#define TXPWRDN_DELAY_BASIC   15
#define TXPWRUP_DELAY_BASIC   80

#define TMU_PRE_G1_BASIC       25
#define TMU_PRE_G2_BASIC       55
#define TMU_PRE_TX1_BASIC      30
#define TMU_PRE_TX2_BASIC      50
#define TMU_PRE_TX3_BASIC      81
#define TMU_PRE_RX1_BASIC      25
#define TMU_PRE_RX2_BASIC      55
#define TMU_PRE_RX3_BASIC      60
#define TMU_PACKET_START_BASIC 83
#define TMU_PRE_DP_RESET_BASIC  40
#define TMU_POST_DP_RESET_BASIC 15

#define TMU_PRE_G1_FAST         1
#define TMU_PRE_G2_FAST         2
#define TMU_PRE_TX1_FAST        0
#define TMU_PRE_TX2_FAST       20
#define TMU_PRE_TX3_FAST       51
#define TMU_PRE_RX1_FAST       20
#define TMU_PRE_RX2_FAST       30
#define TMU_PRE_RX3_FAST       40
#define TMU_PACKET_START_FAST  53
#define TMU_PRE_DP_RESET_FAST    2
#define TMU_POST_DP_RESET_FAST   9


#define OFF_RSSI 12

/*******************************************************************************/
/***                         Local Function Prototypes                       ***/
/*******************************************************************************/

void radio_jn518x_RX_ZigBee_Init(uint8_t InitVersion);
void radio_jn518x_TX_ZigBee_Init(uint8_t InitVersion);
void radio_TX_ZigBee_pll_dac_banked_set(void);
void radio_jn518x_DCO_cal_mode1_loop(void);
bool radio_jn518x_IsNotMF1C(int *Radio_Id, int *PMU_Id);
bool radio_jn518x_IsNotC2MF(int *Radio_Id, int *PMU_Id);

void vGetCalInfo(void);

void radio_jn518x_get_retention_info(uint32_t *pu32RetentionAvailable);

void vRadio_JN518x_Temp_GetInfos(void);
void vRadio_JN518x_Temp_SetInfos(void);
void vRadio_JN518x_Temp_GetKmodData(void);
void vRadio_JN518x_Temp_SetKmodData(void);
void vRadio_JN518x_Temp_InitKmodData(void);


uint32_t u32Radio_Jn518x_GetPhyState(void);

void radio_jn518x_PowerOn(void);
void vRadio_Jn518x_InitXtal(void);
void vRadio_JN518x_PowerOnSpecific(void);
void radio_jn518x_PowerOnCheckXtal(void);

void vRadio_Enable_DCO_DAC(void);

#ifndef USEXTALBASICTRIM
void vRadio_JN518x_XO_Trim(void);
#endif

// AGC_READY_PATCH - apply patch for issue where event in process never stops due to RX enable pulse of about 80us
#ifdef AGC_READY_PATCH
void RFP_TMU_IRQHandler(void);
void vRadio_Jn518x_start_rx_ISR(void);
// Global needed for patch
volatile bool b_event_in_process_patch_on;
#endif //AGC_READY_PATCH

/****************************************************************************/
/***		Local variables                                               ***/
/****************************************************************************/
#define DEFAULT_ATE_TEMP (26)

typedef struct _radio_config
{
	uint32_t u32InitMode;
	uint32_t u32TxPowerMode;
	uint32_t u32TXRadioStandard;
	uint32_t u32RXRadioStandard;
	uint32_t u32ATECalDate;
	int16_t  i16ATECalTemp;
	uint32_t u32RetentionAvailable;
	bool   bDoCalibrate;
	bool   bClockEnabled;
	bool   bSkipXTAL; // to be removed when XTAL init is out of radio driver
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	bool   bDisableZBRadio;
	bool   bDisableBLERadio;
#endif
	uint8_t u8ReCal_needed;
	uint8_t u8TCur_Received;
	uint8_t u8InitDone;
	int16_t i16TCur;
	int16_t i16TCal;
	bool 	bADEnabled;
	uint16_t u16ADConfigThr;
	uint8_t u8ADConfigTimer;
	int32_t i32RSSI_offset;
	bool	bDcoDacEnabled;
} RadioCfg_t;


#define KMOD_TEMP_POINTS 4
#define KMOD_AVERAGE_POINTS 25
#define KMOD_ITERDIV_COEFF (uint32_t)171798692

typedef struct _RadioKmodData
{
	int16_t  i16CalTemp;
	uint16_t u16Corr1;
	uint16_t u32Count1LSB;
	uint16_t u32Count1MSB;
	uint16_t u32Count2LSB;
	uint16_t u32Count2MSB;
} RadioKmodData_t;


#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
RadioCfg_t RadioConfiguration = {0,0,0,0,0,0,0,false,false,false,false,false,0,0,0,0,0,false,0x2c0,0xa,0, false};
#else
RadioCfg_t RadioConfiguration = {0,0,0,0,0,0,0,false,false,false,0,0,0,0,0,false,0x2c0,0xa,0, false};
#endif

volatile RadioKmodData_t RadioKmodCalData[KMOD_TEMP_POINTS];

uint32_t u32PhyOn_sav;
uint32_t u32LnaOffsetGainSav;
uint32_t u32XOSlaveSav;

uint32_t u32PaDccI1v1Set = 0x7; // 40 % Duty Cycle, default value for TxHighPower mode disabled
uint32_t u32PowerstageIbiasI1v8Set = 11; // set PA LDO output to 1.15 V with DCDC output at 1.3 V, default mode
uint32_t u32CoreVadjI1v8SetTx = 6; // set PA LDO output to 1.15 V with DCDC output at 1.3 V, default mode

/* The JN518x has 3 sets of operating 'standards', which affects the frequency
   response of the radio. For compliance it may be necessary to select
   different standards for different channels */
teRadioTxMode eTxMode        = E_RADIO_TX_MODE_STD;
teRadioTxMode eTxModeCh26    = E_RADIO_TX_MODE_STD;
teRadioTxMode eCurrentTxMode = E_RADIO_TX_MODE_RESET;

int8_t i8Radio_TxMaxPower = 127;
int8_t i8Radio_TxMaxPowerCh26 = 127;

const uint16_t lut_defaults[46]= { 1,2,2,2,3,           // 0:4
        3,3,4,4,5,           // 5:9
        5,6,6,7,8,           // 10:14
        9,10,11,13,14,       // 15:19
        16,18,21,23,26,      // 20:24
        30,33,38,43,49,      // 25:29
        56,64,74,85,99,     // 30:34
        116,137,162,197,241, // 35:39
        330,470,511,511,511, // 40:44
        511};                // 45

const uint16_t lut_hiTx_defaults[46]= { 1,1,2,2,2,           // 0:4
        2,2,3,3,3,           // 5:9
        4,4,5,5,6,           // 10:14
        6,7,8,9,10,          // 15:19
        11,13,14,16,18,      // 20:24
        20,23,26,29,33,      // 25:29
        37,42,48,54,62,      // 30:34
        71,81,94,109,127,    // 35:39
        149,177,214,276,361, // 40:44
        511};                // 45


const uint32_t freq_prog[7][5] = { 	{0x962,0x4,0x0,0x20,0x0},		//2402,1,1 //BLE_1MB
									{0x962,0x4,0x0,0x20,0x0},		//2402,2,2 //BLE_2MB
									{0x980,0x4,0xc,0x15,0x55},		//2432.0, 1.3125, 2 //PA CAL INIT
									{0x980,0x1404,0xc,0x15,0x55},	//2432.3125, 1.3125, 2 //IQ CAL INIT1
									{0x9a2,0x4,0x0,0x10,0x0},		//2466, 1, 2 //IQ CAL INIT2
									{0x991,0x1404,0xc,0x15,0x55},	//2449.3125, 1.3125, 2 //SYNTH CAL
									{0x98a,0x4,0x0,0x10,0x0}		//2442, 1, 2 //IQ CAL ATE
								};

int16_t i16RecalThresholdTemp = (40 << 1);

typedef struct _kmod_data
{
	uint32_t u32Count1MSB;
	uint32_t u32Count1LSB;
	uint32_t u32Count2MSB;
	uint32_t u32Count2LSB;
	uint32_t u32Corr1;
  	uint32_t u32DeltaCount;
} KmodData_t;

uint32_t u32TempReg;

//KmodData_t KmodDataStruct[KMOD_MAX_ITER];

/****************************************************************************/
/***		Local functions: general purpose		                      ***/
/****************************************************************************/

#define radio_waitNus CLOCK_uDelay

  bool radio_jn518x_IsNotC2MF(int *Radio_Id, int *PMU_Id)
  {
	  if (Radio_Id != NULL) *Radio_Id = JN518X_RFPMODEM -> transceiver.radio_id_r2d_if_val.fields.radio_id;
	  if (PMU_Id != NULL) *PMU_Id = JN518X_ASYSCON->ANALOGID_b.PMUID;
	  if ((JN518X_RFPMODEM -> transceiver.radio_id_r2d_if_val.fields.radio_id == C2_MF_RADIO_ID) &&
			  (JN518X_ASYSCON->ANALOGID_b.PMUID == C2_MF_PMU_ID))
	  {
		  return false;
	  }
	  else
	  {
		  return true;
	  }
  }

/****************************************************************************/
/***		Local test functions not used by the driver                   ***/
/****************************************************************************/

// --------------------------------------------------------------------------
// R calibrations initialisation.
// Select the RF DC-bus.
// Set-up of ATE communications for internal resistor to trimm.
// DIO settings for internal resistor to trimm access through DC-bus pins
// * GPIO18 is forced in analog mode then ATE can inject a reference current to 'rforce' port,
// * GPIO17 is forced in analog mode then ATE can measure the voltage at 'rsense' port
//   of the internal resistor pattern to be trimmed.
// LDO IF supply activated for R calibration proper operation,
// Set R trimm value to default one expected.
// --------------------------------------------------------------------------



//********************************************************************
//** IQ Mismatch calibration
// Assumes that radio G1/G2/PLL groups are off
// and leaves ALL groups OFF at the end
//************************************************************
//*****************************************************************************
//***** IQ MISMATCH CAL: Init function to configure ready for calibration *****
//*****************************************************************************
void  radio_jn518x_IQ_cal_init(void)
{

//*********************************************************
// /*  Config settings to align with table in excel
//*********************************************************

		RESET_PHYON

// Remove some earlier forces from register back to normal function
   // source=register, not func
   JN518X_RFPMODEM -> transceiver.lna_d2r_if_src_sel.fields.lna_gain_i_1v1_set = 1;
   JN518X_RFPMODEM -> transceiver.ifamp_d2r_if_src_sel.fields.ifamp_gain_i_1v1_set = 1;
   JN518X_RFPMODEM -> transceiver.aaf_1_d2r_if_src_sel.fields.rx_aaf_fc_set = 1;
   JN518X_RFPMODEM -> transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_q_set = 1;
   JN518X_RFPMODEM -> transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_gain_set = 1;


//*********************************************************
// Over-ride setting from statemachine where they are wrong
//*********************************************************
   // To cause the ldo_pa_powerstage enabled during RX1
   JN518X_RFPMODEM->transceiver.ldo_pa_d2r_if_src_sel.fields.powerstage_enable_1v8_rx = 1;

   // Override calibration/TMU for rx_dcoff_i_enable and rx_dcoff_q_enable
   // NOTE  - double check sim that these don't get asserted after coarse cal when a non-zero value is determined
   JN518X_RFPMODEM->transceiver.dcoff_d2r_if_val.fields.rx_dcoff_i_enable  = 1;
   JN518X_RFPMODEM->transceiver.dcoff_d2r_if_src_sel.fields.rx_dcoff_i_enable  = 0;  // 0= register NOT FSM
   JN518X_RFPMODEM->transceiver.dcoff_d2r_if_val.fields.rx_dcoff_q_enable  = 1;
   JN518X_RFPMODEM->transceiver.dcoff_d2r_if_src_sel.fields.rx_dcoff_q_enable  = 0;  // 0= register NOT FSM

   // release forced control of ifamp_gain that was applied earlier in testcase
   // Forcing these to align to excel - but these should be controlled by calibration FSM to try out the various gains
   // Leave commented out since this is not the required configuration
   JN518X_RFPMODEM -> transceiver.ifamp_d2r_if_src_sel.fields.ifamp_gain_i_1v1_set = 0;  //0=register NOT function
// RF - 20170901
   JN518X_RFPMODEM -> transceiver.ifamp_d2r_if_val.fields.ifamp_gain_i_1v1_set = 0x1; // RF - 20170901

   // release forced control of rx_aaf_gain that was applied earlier in testcase
   // Forcing these to align to excel - but these should be controlled by calibration FSM to try out the various gains
   JN518X_RFPMODEM -> transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_gain_set = 0;  //0=register NOT function
//   JN518X_RFPMODEM -> transceiver.aaf_d2r_if_val.fields.rx_aaf_gain_set = 0x4;  // This setting caused clipping
   JN518X_RFPMODEM -> transceiver.aaf_d2r_if_val.fields.rx_aaf_gain_set = 0x3;  // SMB - do clipping here but is this now too small? // RF - 20170901

   // release forced control of lna_gain that was applied earlier in testcase
   // Forcing these to align to excel - but these should be controlled by calibration FSM to try out the various gains
   JN518X_RFPMODEM -> transceiver.lna_d2r_if_src_sel.fields.lna_gain_i_1v1_set = 0;  //0=register NOT function
   JN518X_RFPMODEM -> transceiver.lna_d2r_if_val.fields.lna_gain_i_1v1_set = 0x7;

   // forced control of ls clipdet enable
   JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_ls_enable = 0;  //0=register NOT function
   JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_val.fields.rx_clipdet_ls_enable = 1;

   // force PLL_CAL_IP_AAFC_ENABLE low
   JN518X_RFPMODEM -> transceiver.pll_cal_d2r_if_val.fields.pll_cal_ip_aafc_enable = 0;    // set to 0
   JN518X_RFPMODEM -> transceiver.pll_cal_d2r_if_src_sel.fields.pll_cal_ip_aafc_enable = 0;    // 0=register NOT function

   // forced control of hs clipdet enable
   JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_hs_enable = 0;  //0=register NOT function
   JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_val.fields.rx_clipdet_hs_enable = 0;

  // Switch lna_enable off. Without doing this then LNA and tone2mixer both drive the RX path
  JN518X_RFPMODEM -> transceiver.lna_d2r_if_val.fields.lna_enable_1v1 = 1;         // lna_enable needs to be off to allow tone2mixer to feed into RX path

  JN518X_RFPMODEM -> transceiver.lna_d2r_if_src_sel.fields.lna_enable_1v1 = 0;         // 0=source from reg

  //  Following configurations can be set for the IQ mismatch calibration

  // Config Cal block itself
  JN518X_RFPMODEM->calibration.iq_cal_loop_en.fields.phase_loop_en = 0x7;

  // Bart's initial values
//  JN518X_RFPMODEM->calibration.iq_cal_phase_meas_period[0].fields.meas_period = 1008;
//  JN518X_RFPMODEM->calibration.iq_cal_phase_meas_period[1].fields.meas_period = 10000;
//  JN518X_RFPMODEM->calibration.iq_cal_phase_meas_period[2].fields.meas_period = 16000;
  // My reduced values for sim speed
  JN518X_RFPMODEM->calibration.iq_cal_phase_meas_period[0].fields.meas_period =  500;
  JN518X_RFPMODEM->calibration.iq_cal_phase_meas_period[1].fields.meas_period =  1000;
  JN518X_RFPMODEM->calibration.iq_cal_phase_meas_period[2].fields.meas_period = 4000;

  //*****************************************************************************
  //***** Config Tone generator**************************************************
  //*****************************************************************************

  // For IQ cal we need signal of 1MHz after mixer
  // Tone = 2.2747
  // IF = 1.4375MHz
  // RF = Tone + IF + 1MHz
  // Hence 2.2771375GHz
  // Int rf is 2277
  // Frac rf is 0.1375 *16384 = 2252.8 or 2253

  JN518X_RFPMODEM->synth_control.cfg.fields.cw_mode = 1;                               // Configures the CW mode for the synthesizer: 1-> Value = 0 is taken as input.
  radio_jn518x_Carrier_Frequency_Select_by_index(CFS_IQCALINIT1);



  JN518X_RFPMODEM->synth_control.cfg.fields.cw_mode = 1;                               // Configures the CW mode for the synthesizer: 1-> Value = 0 is taken as input.
  JN518X_RFPMODEM->transceiver.tone_1_d2r_if_val.fields.tone_divn_p_set =  0x4C; // to gettone freq 2.2747GHz
  JN518X_RFPMODEM->rx_datapath.cfg.fields.dec_en=0;     //disable decimation in RFP datapath


  // RFT1018 - tone generator not enabled - but should be
  JN518X_RFPMODEM->transceiver.tone_pll_d2r_if_val.fields.tone_pll_ldo_enable = 1; // set enable bit
  JN518X_RFPMODEM->transceiver.tone_pll_d2r_if_src_sel.fields.tone_pll_ldo_enable = 0; // control from register and not state machine
  // Tone ATT not enabled - but should be
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_val.fields.tone_att_n_enable = 1;     // set enable bit
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_att_n_enable = 0; // control from register and not state machine
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_val.fields.tone_att_p_enable = 1;     // set enable bit
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_att_p_enable = 0; // control from register and not state machine
  // Tone_cp_bias_enable not enabled - but should be
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_val.fields.tone_cp_bias_enable = 1;     // set enable bit
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_cp_bias_enable = 0; // control from register and not state machine
  // Tone_cp_slice_enable not enabled - but should be
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_val.fields.tone_cp_slice_enable = 1;     // set enable bit
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_cp_slice_enable = 0; // control from register and not state machine
  // Tone_pfd_enable not enabled - but should be
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_val.fields.tone_pfd_enable = 1;     // set enable bit
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_pfd_enable = 0; // control from register and not state machine
  // Tone_cco_drv_enable not enabled - but should be
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_val.fields.tone_cco_drv_enable = 1;     // set enable bit
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_cco_drv_enable = 0; // control from register and not state machine

  // Enable IQ calibration to phase only calibration   0=phase; 1=scale; 2=phase + scale
  JN518X_RFPMODEM->tmu.cal_mode.fields.iq_cal_mode = 2;

  // Initializes TMU for TX/RX packet transmission under SW control // RF - 20170901
  radio_jn518x_Trx_Packet_SW_Ctrl_Init(); // RF - 20170901

  // SW triggered pre-start. This will trigger the start of the global power sequence
  radio_jn518x_pre_start_to_pll_polled();  // call pre-start function to get to PLL group state

  // First the RX group signals must be asserted (to power the RX modules)
  radio_jn518x_rx_assert_polled(); // start RX group and poll for done

  // Following configurations can be set for the IQ mismatch calibration
  JN518X_RFPMODEM->calibration.iq_cal_loop_en.fields.mag_loop_en = 0x7;  // reduce to 2 phases for sim development

// Bart's initial values
//  JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[0].fields.meas_period = 10000;
//  JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[1].fields.meas_period = 10000;
//  JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[2].fields.meas_period = 10000;

// My reduced values
//  JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[0].fields.meas_period = 1000; //  64usec - fast adjustment here - allow some more timetc_00
  JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[0].fields.meas_period = 2000; // 128usec
  JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[1].fields.meas_period = 2000; // 128usec
//  JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[2].fields.meas_period = 3000; // 192usec  - still some settling with this
  JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[2].fields.meas_period = 6000; // 384usec
//  */      // End of new settings section

  /* Patch 2.0 */

  /* to be sure */
  JN518X_RFPMODEM->transceiver.tone_pll_d2r_if_val.fields.tone_pll_bypass_set =0;

  // De-assert RX group signals
	radio_jn518x_rx_deassert_polled(); // stop RX group and poll for done
	radio_jn518x_power_down_to_off_polled(); // switch off rest of radio

	// Main LO carrier frequency selection
	// 2465 MHz main LO in RX mode with Tone Test at 2464 MHz So -1 MHz IF frequency

	//radio_jn518x_Carrier_Frequency_Select(2466,1, 2);
	radio_jn518x_Carrier_Frequency_Select_by_index(CFS_IQCALINIT2);

	// SW triggered pre-start. This will trigger the start of the global power sequence
	radio_jn518x_pre_start_to_pll_polled();  // call pre-start function to get to PLL group state

	// First the RX group signals must be asserted (to power the RX modules)
	radio_jn518x_rx_assert_polled(); // start RX group and poll for done

	// Force no synthesizer path modulation
	JN518X_RFPMODEM->synth_control.cfg.fields.cw_mode = 1; // Configures the CW mode for the synthesizer: 1-> Value = 0 is taken as input.

	// forced control of rx_aaf_gain that was applied earlier in testcase
	JN518X_RFPMODEM->transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_gain_set = 0; // 0=register NOT function
	JN518X_RFPMODEM->transceiver.aaf_d2r_if_val.fields.rx_aaf_gain_set = 3; //can do clipping here

	// forced control of ifamp_gain that was applied earlier in testcase
	JN518X_RFPMODEM->transceiver.ifamp_d2r_if_src_sel.fields.ifamp_gain_i_1v1_set = 0; // 0=register NOT function
	JN518X_RFPMODEM->transceiver.ifamp_d2r_if_val.fields.ifamp_gain_i_1v1_set = 1;

	// forced control of lna_gain that was applied earlier in testcase
	JN518X_RFPMODEM->transceiver.lna_d2r_if_val.fields.lna_gain_i_1v1_set = 0; // 0=register NOT function
	JN518X_RFPMODEM->transceiver.lna_d2r_if_val.fields.lna_gain_i_1v1_set = 2;

	// release Switch lna_enable off. Without doing this then LNA and tone2mixer both drive the RX path
	JN518X_RFPMODEM->transceiver.lna_d2r_if_src_sel.fields.lna_enable_1v1 = 0; // 0=register NOT function
	JN518X_RFPMODEM->transceiver.tone_0_d2r_if_val.fields.tone_att_set = 0; // attenuation set to 32 dB
	JN518X_RFPMODEM->transceiver.tone_1_d2r_if_val.fields.tone_divn_p_set = 77; // BIST PLL at 2464 MHz
	JN518X_RFPMODEM->transceiver.tone_1_d2r_if_src_sel.fields.tone_divn_p_set = 0;

	// CALIBRATION_IQ_CAL_ALPHA_CFG0
	// Alpha parameters applied towards the DC offset compensation module during IQ mismatch calibration
	// PHASE 5-bits: default 0x8
	// MAG   5-bits: default 0x5
	JN518X_RFPMODEM->calibration.iq_cal_alpha_cfg0.fields.alpha_dc_offset_phase = 11;
	JN518X_RFPMODEM->calibration.iq_cal_alpha_cfg0.fields.alpha_dc_offset_mag = 11;

	// CALIBRATION_IQ_CAL_ALPHA_CFG1
	// Alpha parameters applied towards the IQ mismatch rectifier module during loop 0 and 1 of the IQ mismatch magnitude calibration
	// MAG LOOP0 5-bits: default 0xB (11)
	// MAG LOOP1 5-bits: default 0xE (14)
	// CALIBRATION_IQ_CAL_ALPHA_CFG2
	// Alpha parameters applied towards the IQ mismatch rectifier module during loop 2 and 3 of the IQ mismatch magnitude calibration
	// MAG LOOP2 5-bits: default 0x10 (16)
	// MAG LOOP3 5-bits: default 0x10 (16)
	JN518X_RFPMODEM->calibration.iq_cal_alpha_cfg1.fields.alpha_mag_loop0 = 11;
	JN518X_RFPMODEM->calibration.iq_cal_alpha_cfg1.fields.alpha_mag_loop1 = 11;
	JN518X_RFPMODEM->calibration.iq_cal_alpha_cfg2.fields.alpha_mag_loop2 = 11;
	JN518X_RFPMODEM->calibration.iq_cal_alpha_cfg2.fields.alpha_mag_loop3 = 11;

	// CALIBRATION_IQ_CAL_K_I_CFG
	//K_i parameters used by the IQ mismatch phase calibration during the different loops
	// K_I_LOOP0 4-bits: default 0x4 (4)
	// K_I_LOOP1 4-bits: default 0x6 (6)
	// K_I_LOOP2 4-bits: default 0x9 (9)
	// K_I_LOOP3 4-bits: default 0x9 (9)
	JN518X_RFPMODEM->calibration.iq_cal_k_i_cfg.fields.k_i_loop0 = 11;
	JN518X_RFPMODEM->calibration.iq_cal_k_i_cfg.fields.k_i_loop1 = 11;
	JN518X_RFPMODEM->calibration.iq_cal_k_i_cfg.fields.k_i_loop2 = 11;
	JN518X_RFPMODEM->calibration.iq_cal_k_i_cfg.fields.k_i_loop3 = 11;

	// CALIBRATION_IQ_CAL_LOOP_EN
	// Enable bits for the loops of the IQ mismatch calibration. A one-hot encoding is used.
	JN518X_RFPMODEM->calibration.iq_cal_loop_en.fields.phase_loop_en = 15;
	JN518X_RFPMODEM->calibration.iq_cal_loop_en.fields.mag_loop_en = 3;

	// CALIBRATION_IQ_CAL_PHASE_MEAS_PERIOD[3:0]
	// Specifies the measurement period for each loop of the IQ mismatch phase calibration, being the amount of samples processed by the IQ mismatch compensation module
	JN518X_RFPMODEM->calibration.iq_cal_phase_meas_period[0].fields.meas_period = 16383;
	JN518X_RFPMODEM->calibration.iq_cal_phase_meas_period[1].fields.meas_period = 65535;
	JN518X_RFPMODEM->calibration.iq_cal_phase_meas_period[2].fields.meas_period = 65535;
	JN518X_RFPMODEM->calibration.iq_cal_phase_meas_period[3].fields.meas_period = 65535;

	// CALIBRATION_IQ_CAL_MAG_MEAS_PERIOD[3:0]
	// Specifies the measurement period for each loop of the IQ mismatch magnitude calibration, being the amount of samples processed by the IQ mismatch compensation module
	JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[0].fields.meas_period = 8191;
	JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[1].fields.meas_period = 16383;
	JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[2].fields.meas_period = 16383;
	JN518X_RFPMODEM->calibration.iq_cal_mag_meas_period[3].fields.meas_period = 16383;

	/* end of patch 2.0 */


  RESTORE_PHYON
}

void radio_jn518x_IQ_cal_algo(void)
{
  uint32_t u32_CalMode;
  // Start IQ phase mismatch calibration
  // ----
  //vPrintf("IQ Mismatch CAl -phase cal first\n");


  //*****************************************************************************
  //***** Config Synth***********************************************************
  //*****************************************************************************

  // Read the cal mode setting. This will indicate what calibration to run
  // The init function enables both scale and phase cal
  // - so to control the calibration alter this before calling the function
  // Enable IQ calibration to phase only calibration   0=phase; 1=scale; 2=phase + scale
  u32_CalMode = JN518X_RFPMODEM->tmu.cal_mode.fields.iq_cal_mode;


  //*****************************************************************************
  //***** Start IQ phase*********************************************************
  //*****************************************************************************

  if ( (u32_CalMode ==0) || (u32_CalMode==2) )
  {

    // Trigger the IQ mismatch calibration
    //vPrintf("Start IQ Phase..\n");

    // Enable IQ calibration to scale only calibration
    // Enable IQ calibration to phase only calibration   0=phase; 1=scale; 2=phase + scale
    JN518X_RFPMODEM->tmu.cal_mode.fields.iq_cal_mode = 0;

    //JN518X_RFPMODEM->tmu.cal_triggers.fields.iq_cal_en = 1;
    JN518X_RFPMODEM->tmu.cal_triggers.val = (0x1 << EXTAPB_REGFILE_TMU_CAL_TRIGGERS_IQ_CAL_EN_POS);

    // Poll for IQ calibration busy bit
    JN518X_RFPMODEM->test.version_set_snap.val = 1;

    while(JN518X_RFPMODEM->test.status.fields.snack == 0)
    {
      radio_waitNus(1); // Wait some time
    }
    JN518X_RFPMODEM->test.reset_snap.val = 1;

    while((JN518X_RFPMODEM->tmu.cal_status.fields.cal_state >> 1) == 1)
    {
      JN518X_RFPMODEM->test.version_set_snap.val = 1;

      while(JN518X_RFPMODEM->test.status.fields.snack == 0)
      {
        radio_waitNus(1); // Wait some time
      }
      JN518X_RFPMODEM->test.reset_snap.val = 1;
    }
    //vPrintf("IQ Phase Done\n");
  }
  else
  {
    //vPrintf("NOT doing IQ Phase\n");
  }

  //*****************************************************************************
  //***** Start IQ scale*********************************************************
  //*****************************************************************************
  // -----
  if ( (u32_CalMode ==1) || (u32_CalMode==2) )
  {

    // Trigger the IQ mismatch calibration
    //vPrintf("Start IQ Scale..\n");



    // Enable IQ calibration to scale only calibration  0=phase; 1=scale; 2=phase + scale
    JN518X_RFPMODEM->tmu.cal_mode.fields.iq_cal_mode = 1;

    // Trigger the IQ mismatch calibration
    //JN518X_RFPMODEM->tmu.cal_triggers.fields.iq_cal_en = 1;
    JN518X_RFPMODEM->tmu.cal_triggers.val = (0x1 << EXTAPB_REGFILE_TMU_CAL_TRIGGERS_IQ_CAL_EN_POS);


    //  wait_for_interrupt(); // Wait till IQ mismatch calibration has been finished

    // Poll for IQ calibration busy bit
    JN518X_RFPMODEM->test.version_set_snap.val = 1;

    while(JN518X_RFPMODEM->test.status.fields.snack == 0)
    {
      radio_waitNus(1); // Wait some time
    }
    JN518X_RFPMODEM->test.reset_snap.val = 1;

    while((JN518X_RFPMODEM->tmu.cal_status.fields.cal_state >> 1) == 1)
    {
      JN518X_RFPMODEM->test.version_set_snap.val = 1;

      while(JN518X_RFPMODEM->test.status.fields.snack == 0)
      {
        radio_waitNus(1); // Wait some time
      }
      JN518X_RFPMODEM->test.reset_snap.val = 1;
    }
  }
  else
  {
    //vPrintf("NOT doing IQ scale\n");
  }

  // restore the initial mode value
  JN518X_RFPMODEM->tmu.cal_mode.fields.iq_cal_mode = u32_CalMode;

  // Remove some earlier forces from register back to normal function // RF - 20170901

  // RF - 20170901
  JN518X_RFPMODEM->transceiver.ldo_pa_d2r_if_src_sel.fields.powerstage_enable_1v8 = 1;  // Return to control from function - for PA cal it needed register control. 0=register NOT function // RF - 20170901
  JN518X_RFPMODEM->transceiver.lo_d2r_if_src_sel.fields.rx_enable_1v1 = 1;  // Return to control from function - for PA cal it needed register control. 0=register NOT function // RF - 20170901

  // RF - 20170901
	JN518X_RFPMODEM->synth_control.cfg.fields.cw_mode = 0;// RF - 20170901

  // Disable tone generator // RF - 20170901
  JN518X_RFPMODEM->transceiver.tone_pll_d2r_if_src_sel.fields.tone_pll_ldo_enable = 1; // control from state machine and not register // RF - 20170901
  // Tone ATT disabled // RF - 20170901
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_att_n_enable = 1; // control from state machine and not register // RF - 20170901
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_att_p_enable = 1; // control from state machine and not register // RF - 20170901
  // Tone_cp bias disabled // RF - 20170901
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_cp_bias_enable = 1; // control from state machine and not register // RF - 20170901
  // Tone_cp_slice disabled // RF - 20170901
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_cp_slice_enable = 1; // control from register and not state machine // RF - 20170901
  // Tone pfd disabled // RF - 20170901
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_pfd_enable = 1; // control from state machine and not register // RF - 20170901
  // Tone cco drv disabled // RF - 20170901
  JN518X_RFPMODEM->transceiver.tone_0_d2r_if_src_sel.fields.tone_cco_drv_enable = 1; // control from state machine and not register // RF - 20170901

  // Secondly release over-ride setting from state machine where they were wrong for the I/Q calibration // RF - 20170901

   // Release override calibration/TMU for rx_dcoff_i_enable and rx_dcoff_q_enable // RF - 20170901
   JN518X_RFPMODEM->transceiver.dcoff_d2r_if_src_sel.fields.rx_dcoff_i_enable  = 1;  // 0= register NOT FSM // RF - 20170901
   JN518X_RFPMODEM->transceiver.dcoff_d2r_if_src_sel.fields.rx_dcoff_q_enable  = 1;  // 0= register NOT FSM // RF - 20170901

   // release forced control of ifamp_gain that was applied earlier in testcase // RF - 20170901
   JN518X_RFPMODEM -> transceiver.ifamp_d2r_if_src_sel.fields.ifamp_gain_i_1v1_set = 1;  //0=register NOT function // RF - 20170901

   // release forced control of rx_aaf_gain that was applied earlier in testcase // RF - 20170901
   JN518X_RFPMODEM -> transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_gain_set = 1;  //0=register NOT function // RF - 20170901

   // release forced control of lna_gain that was applied earlier in testcase // RF - 20170901
   JN518X_RFPMODEM -> transceiver.lna_d2r_if_src_sel.fields.lna_gain_i_1v1_set = 1;  //0=register NOT function // RF - 20170901

   // release forced control of ls clipdet enable // RF - 20170901
   JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_ls_enable = 1;  //0=register NOT function // RF - 20170901

   // relaese forced PLL_CAL_IP_AAFC_ENABLE low // RF - 20170901
   JN518X_RFPMODEM -> transceiver.pll_cal_d2r_if_src_sel.fields.pll_cal_ip_aafc_enable = 1;    // 0=register NOT function // RF - 20170901


   // release forced control of hs clipdet enable // RF - 20170901
   JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_hs_enable = 1;  //0=register NOT function // RF - 20170901

  // release Switch lna_enable off. Without doing this then LNA and tone2mixer both drive the RX path // RF - 20170901
  JN518X_RFPMODEM -> transceiver.lna_d2r_if_src_sel.fields.lna_enable_1v1 = 1;         // 0=source from reg // RF - 20170901


}


/****************************************************************************/
/***		Local functions: standard init                                ***/
/****************************************************************************/

// --------------------------------------------------------------------------
// Transmitter settings for synthesizer 2 points modulation with BLE regular scheme (1Mbps)
// - Tx master clock towards the TMU enabled,
// - Bank selection of Tx datapath -> 1,
// - 32 MHz synthesizer reference frequency considered,
// --------------------------------------------------------------------------

void radio_jn518x_TX_BLE_1Mbs_Init(void)
{
	uint8_t trig_pre_const;

   vPrintf("(Tmp Fct:radio_jn518x_TX_BLE_1Mbs_Init used !)\n");

  // Tx datapath BLE 1Mbs bank selection
  JN518X_RFPMODEM -> tx_datapath.global.fields.tx_bank = 1; // Bank selection of Tx datapath

  // Before the digital Tx can function the Tx master clock towards the TMU must be  enabled.
  // The TMU will further distribute this towards the different subblocks of the Tx.
  // Next to this also the mode dependent division ratio of the clock must be set.
// RF - 20160930 -
  // Two successive accesses by field to the same register located in a bank are prohibited.
  // Indeed a read access to a register located into a Bank will return the value at reset whatever previous writings are.
  // So multi-field writing access by filed access is prohibited as register content will be reset value modified by the last writing only.
  // Code modified to prepare MRA2 version where bb_clk_divisor will be inserted into banks
// RF - 20160930 -  JN518X_RFPMODEM -> clockshop.tx_clk_cfg.fields.bb_clk_en = 1; // Clockgate control of the tx datapath,
                                                               // overriding the clockgate control of the tmu.
// RF - 20160930 -  JN518X_RFPMODEM -> clockshop.tx_clk_cfg.fields.bb_clk_divisor = 2; // For BLE at 1Mbps data rate
   JN518X_RFPMODEM->clockshop.tx_clk_cfg.val = (1<<EXTAPB_REGFILE_CLOCKSHOP_TX_CLK_CFG_BB_CLK_EN_POS | 2<<EXTAPB_REGFILE_CLOCKSHOP_TX_CLK_CFG_BB_CLK_DIVISOR_POS); // bb_clk_divisor = 2; // For BLE at 1Mbps data rate
// RF - 20160930 -

	// DAC amplitude is set for 1MBps mode (+/-250kHz frequency deviation)
	if (radio_jn518x_IsNotC2MF(NULL, NULL))
	{
		JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_mode2_enable = 0; // 1Mbps mode ON (!!! becareful uses negative logic)
																						   // back to the largest full scale due to VCO kmod redesign to get 10 MHz/V
		JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_c_set = 2;        // TX DAC output capacitor set for BLE 1MBps mode.

		trig_pre_const = 0;

		// Two paths modulation first point gain setting (put in comment lines corresponding to not used modes)
		JN518X_RFPMODEM -> tx_datapath.gain_first_point.fields.gain_first_point = 1925 ; // BLE 1Mbps mode value
	}
	else
	{
		// ES2 MF: trigger saving of the two above parameters in bank by writing pre_const reg
		// It has been chosen to write 1 in bits 7,6 and 5 for that
		// These bits belonged to the "len" field that is now only 5 bit
		//JN518X_RFPMODEM -> tx_datapath.pre_const.fields.len |= (0x7 << 5); // Do NOT write to bits[4:0] !

		// In fact mode2_enable (1bit) and pll_dac_c_set(2bits) are now mapped on bits 5-7 of pre_const register
		// These bits were part of the "len" field of this register on ES2
		// On ES2 MF, the len field definition has not been changed (still defined as 8bit field) but
		// only bits 0..4 are usable for len. Bits 5..7 are now used for mapping mode2_enable and pll_dac_c_set
		// so that these field are saved in banked registers
		// Be careful that these field must still be written in pll_dac_0_d2r_if_val register, but they are
		// actually written in bits 5..7 of pre_const. To read the banked value of these fields, we need to read
		// in pre_const. The values returned when reading pll_dac_0_d2r_if_val are the last values written,
		// not the banked values. In addition, values written in bits 5..7 of pre_const are not written but
		// trigger a write access that transfers the content of mode2_enable and pll_dac_c_set into these bits.

		// Here we don't write to pre_const right now as it is done after within the current function.

		JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_mode2_enable = 1; // 1Mbps mode ON (!!! becareful uses negative logic)
																						   // back to the largest full scale due to VCO kmod redesign to get 10 MHz/V
		JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_c_set = 1;        // TX DAC output capacitor set for BLE 1MBps mode.

		trig_pre_const = 0xE0;

		// Two paths modulation first point gain setting (put in comment lines corresponding to not used modes)
		JN518X_RFPMODEM -> tx_datapath.gain_first_point.fields.gain_first_point = 1802 ; // BLE 1Mbps mode value
  }

  // ---------------------------
  // 16MHz/32MHz clock distribution settings from synthesizer's XO in TX mode
  // Manual forcing to be removed when TX under TMU control
  // ---------------------------

  // Global configuration of the Tx Datapath

  // Bank configuration
  // Enable bit for CIC filter
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.cic_active    = 1; // For regular BLE (1Mbps data rate) only.
  // Mode settings to select shaping filter to be used and upsampling
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.gaussian_mode = 0;  // Gaussian filter BT=0.5. Applicable for both BLE and ZB
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.flush_cnt     = 24; // Flush counter for upsample gauss filter in clock cycles
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.zoh_shift     = 1;  // Data input position shift for all modes other than regular ZigBee mode.

  // Constant value to be prepended before packet (useful for to check preamble first effective bit existence)
  // ES2MF: These write operations in pre_const register trigger saving of pll_dac_mode2_enable and
  // pll_dac_c_set in the current bank
  JN518X_RFPMODEM -> tx_datapath.pre_const.fields.len = (0 | trig_pre_const); // Length of pre constant value
  JN518X_RFPMODEM -> tx_datapath.pre_const.fields.val = 0; // Constant value for prepend: -1, 0, +1
  JN518X_RFPMODEM -> tx_datapath.pre_const.fields.en  = 0; // Constant value is prepended before packet

  // Two paths modulation sampling delay compensation whatever synthesizer reference frequency & rata rate
  JN518X_RFPMODEM -> tx_datapath.delay.fields.first_point_fine = 2;   // Sample delay first point, fine
  JN518X_RFPMODEM -> tx_datapath.delay.fields.second_point     = 7;   // Sample delay second point

  // Two paths modulation sampling delay compensation with 32 MHz synthesizer reference frequency, whatever rata rate
  JN518X_RFPMODEM -> synth_control.cfg.fields.delay_second_point_super_fine = 1; // Sample delay second point, super fine
  JN518X_RFPMODEM -> synth_control.cfg.fields.zoh_en                        = 1; // Enables the ZOH in the CDC

  // Two paths modulation sampling delay compensation with 32 MHz synthesizer reference frequency, 2Mbps rata rate
  JN518X_RFPMODEM -> tx_datapath.delay.fields.first_point_coarse = 7; // Sample delay first point, coarse

  // Two paths modulation first point gain setting (put in comment lines corresponding to not used modes)
  // moved in the ES2/MF differences
  //JN518X_RFPMODEM -> tx_datapath.gain_first_point.fields.gain_first_point = 1925 ; // BLE 1Mbps mode value


  // Two paths modulation second point gain setting (put in comment lines corresponding to not used modes)
  JN518X_RFPMODEM -> tx_datapath.gain_second_point.fields.gain_second_point = 30 ; //BLE 1Mbps mode value

}


// --------------------------------------------------------------------------
// Transmitter settings for synthesizer 2 points modulation with BLE regular scheme (2Mbps)
// - Tx master clock towards the TMU enabled,
// - Bank selection of Tx datapath -> 2,
// - 32 MHz synthesizer reference frequency considered,
// --------------------------------------------------------------------------

void radio_jn518x_TX_BLE_2Mbs_Init(void)
{

	uint8_t trig_pre_const;

   vPrintf("(Tmp Fct:radio_jn518x_TX_BLE_2Mbs_Init used !)\n");

  // Tx datapath BLE 3Mbps bank selection
  JN518X_RFPMODEM -> tx_datapath.global.fields.tx_bank = 2; // Bank selection of Tx datapath

  // Before the digital Tx can function the Tx master clock towards the TMU must be  enabled.
  // The TMU will further distribute this towards the different subblocks of the Tx.
  // Next to this also the mode dependent division ratio of the clock must be set.
// RF - 20160930 -
  // Two successive accesses by field to the same register located in a bank are prohibited.
  // Indeed a read access to a register located into a Bank will return the value at reset whatever previous writings are.
  // So multi-field writing access by filed access is prohibited as register content will be reset value modified by the last writing only.
  // Code modified to prepare MRA2 version where bb_clk_divisor will be inserted into banks
// RF - 20160930 -  JN518X_RFPMODEM -> clockshop.tx_clk_cfg.fields.bb_clk_en = 1; // Clockgate control of the tx datapath,
                                                               // overriding the clockgate control of the tmu.
// RF - 20160930 -  JN518X_RFPMODEM -> clockshop.tx_clk_cfg.fields.bb_clk_divisor = 1; // For BLE at 2Mbps data rate
   JN518X_RFPMODEM->clockshop.tx_clk_cfg.val = (1<<EXTAPB_REGFILE_CLOCKSHOP_TX_CLK_CFG_BB_CLK_EN_POS | 1<<EXTAPB_REGFILE_CLOCKSHOP_TX_CLK_CFG_BB_CLK_DIVISOR_POS); // bb_clk_divisor = 1; // For BLE at 2Mbps data rate
// RF - 20160930 -

  // DAC amplitude is set for 2MBps mode
  // DAC amplitude is set for 2MBps mode (+/-500kHz frequency deviation)

    JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_mode2_enable = 0;	// back to the largest full scale du to VCO kmod redesign to get 10 MHz/V

    JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_c_set = 2;        // TX DAC output capacitor set for BLE 2MBps mode.

	// ES2 MF: trigger saving of the two above parameters in bank by writing pre_const reg
	// It has been chosen to write 1 in bits 7,6 and 5 for that
	// These bits belonged to the "len" field that is now only 5 bit
	//JN518X_RFPMODEM -> tx_datapath.pre_const.fields.len |= (0x7 << 5); // Do NOT write to bits[4:0] !

	// In fact mode2_enable (1bit) and pll_dac_c_set(2bits) are now mapped on bits 5-7 of pre_const register
	// These bits were part of the "len" field of this register on ES2
	// On ES2 MF, the len field definition has not been changed (still defined as 8bit field) but
	// only bits 0..4 are usable for len. Bits 5..7 are now used for mapping mode2_enable and pll_dac_c_set
	// so that these field are saved in banked registers
	// Be careful that these field must still be written in pll_dac_0_d2r_if_val register, but they are
	// actually written in bits 5..7 of pre_const. To read the banked value of these fields, we need to read
	// in pre_const. The values returned when reading pll_dac_0_d2r_if_val are the last values written,
	// not the banked values. In addition, values written in bits 5..7 of pre_const are not written but
	// trigger a write access that transfers the content of mode2_enable and pll_dac_c_set into these bits.

	// Here we don't write to pre_const right now as it is done after within the current function.
//	if (!(radio_jn518x_IsNotC2MF(NULL, NULL)))
//	{
//		JN518X_RFPMODEM -> tx_datapath.pre_const.fields.len |= (0x7 << 5); // Do NOT write to bits[4:0] !
//	}
	if (radio_jn518x_IsNotC2MF(NULL, NULL))
	{
		trig_pre_const = 0;
	}
	else
	{
		trig_pre_const = 0xE0;
	}

	  // ---------------------------
  // 16MHz/32MHz clock distribution settings from synthesizer's XO in TX mode
  // Manual forcing to be removed when TX under TMU control
  // ---------------------------

  // Bank configuration
  // Enable bit for CIC filter
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.cic_active    = 0; // Disables the CIC (only required for 1 Mbps modes)
  // Mode settings to select shaping filter to be used and upsampling
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.gaussian_mode = 0;  // Gaussian filter BT=0.5. Applicable for both BLE and ZB
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.flush_cnt     = 36; // Flush counter for upsample gauss filter in clock cycles
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.zoh_shift     = 0;  // Data input position shift for all modes other than regular ZigBee mode.

  // Constant value to be prepended before packet (useful for to check preamble first effective bit existence)
  // ES2MF: These write operations in pre_const register trigger saving of pll_dac_mode2_enable and
  // pll_dac_c_set in the current bank
  JN518X_RFPMODEM -> tx_datapath.pre_const.fields.len = (0 | trig_pre_const); // Length of pre constant value
  JN518X_RFPMODEM -> tx_datapath.pre_const.fields.val = 0; // Constant value for prepend: -1, 0, +1
  JN518X_RFPMODEM -> tx_datapath.pre_const.fields.en  = 0; // Constant value is prepended before packet

  // Two paths modulation sampling delay compensation whatever synthesizer reference frequency & rata rate
  JN518X_RFPMODEM -> tx_datapath.delay.fields.first_point_fine = 1;   // Sample delay first point, fine
  JN518X_RFPMODEM -> tx_datapath.delay.fields.second_point     = 5;   // Sample delay second point

  // Two paths modulation sampling delay compensation with 32 MHz synthesizer reference frequency, whatever rata rate
  JN518X_RFPMODEM -> synth_control.cfg.fields.delay_second_point_super_fine = 1; // Sample delay second point, super fine
  JN518X_RFPMODEM -> synth_control.cfg.fields.zoh_en                        = 1; // Enables the ZOH in the CDC

  // Two paths modulation sampling delay compensation with 32 MHz synthesizer reference frequency, 2Mbps rata rate
  JN518X_RFPMODEM -> tx_datapath.delay.fields.first_point_coarse = 10; // Sample delay first point, coarse

  // Two paths modulation first point gain setting (put in comment lines corresponding to not used modes)
  JN518X_RFPMODEM -> tx_datapath.gain_first_point.fields.gain_first_point =  1802 ; // BLE 2Mbps mode value

  // Two paths modulation second point gain setting (put in comment lines corresponding to not used modes)
  JN518X_RFPMODEM -> tx_datapath.gain_second_point.fields.gain_second_point = 60 ; //BLE 2Mbps mode value

}


void radio_TX_ZigBee_pll_dac_banked_set(void)
{
	// ES2 MF: trigger saving of the two above parameters in bank by writing pre_const reg
	// It has been chosen to write 1 in bits 7,6 and 5 for that
	// These bits belonged to the "len" field that is now only 5 bit
	//JN518X_RFPMODEM -> tx_datapath.pre_const.fields.len |= (0x7 << 5); // Do NOT write to bits[4:0] !

	// In fact mode2_enable (1bit) and pll_dac_c_set(2bits) are now mapped on bits 5-7 of pre_const register
	// These bits were part of the "len" field of this register on ES2
	// On ES2 MF, the len field definition has not been changed (still defined as 8bit field) but
	// only bits 0..4 are usable for len. Bits 5..7 are now used for mapping mode2_enable and pll_dac_c_set
	// so that these field are saved in banked registers
	// Be careful that these field must still be written in pll_dac_0_d2r_if_val register, but they are
	// actually written in bits 5..7 of pre_const. To read the banked value of these fields, we need to read
	// in pre_const. The values returned when reading pll_dac_0_d2r_if_val are the last values written,
	// not the banked values. In addition, values written in bits 5..7 of pre_const are not written but
	// trigger a write access that transfers the content of mode2_enable and pll_dac_c_set into these bits.

	JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_mode2_enable = 0;	// back to the largest full scale du to VCO kmod redesign to get 10 MHz/V																						// iso 18 MHz/V measured on ES1 (typical)
	JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_c_set = 3; // TX DAC output capacitor set for ZigBee regular mode

}

// --------------------------------------------------------------------------
// Transmitter settings for synthesizer 2 points modulation with ZigBee regular scheme (2Mcps, half-sine filtered only):
// - Tx master clock towards the TMU enabled,
// - Bank selection of Tx datapath -> 0,
// - 32 MHz synthesizer reference frequency considered,
// - DAC amplitude is set for 2MBps mode (+/-500kHz frequency deviation),
// - half-sine pulse shaping,
// - CIC filters configured,
// - Two paths modulation sampling delay compensation,
// - Two paths modulation first/second point gain setting.
// --------------------------------------------------------------------------

void radio_jn518x_TX_ZigBee_Init(uint8_t InitVersion)
{
	uint8_t trig_pre_const;

	RESET_PHYON

	   switch (InitVersion)
	   {
	 	  case TX_PROP_1:
	 		  vPrintf("(Tmp Fct:radio_jn518x_TX_ZigBee_Prop_1_Regular_Init used !)\n");
	 		  break;
	 	  case TX_PROP_2:
	 		  vPrintf("(Tmp Fct:radio_jn518x_TX_ZigBee_Prop_2_Regular_Init used !)\n");
	 		  break;
	 	  case TX_REGULAR:
	 	  default:
	 		  vPrintf("(Tmp Fct:radio_jn518x_TX_ZigBee_Regular_Init used !)\n");
	   }

   vPrintf("Configure RFP for TX in ZigBee regular mode (2Mcps, half-sine filtered only)\n");

  // Tx Datapath regular ZigBee bank selection
  JN518X_RFPMODEM -> tx_datapath.global.fields.tx_bank = 0; // Bank selection of Tx datapath

  // Before the digital Tx can function the Tx master clock towards the TMU must be enabled.
  // The TMU will further distribute this towards the different subblocks of the Tx.
  // Next to this also the mode dependent division ratio of the clock must be set.
// RF - 20160930 -
  // Two successive accesses by field to the same register located in a bank are prohibited.
  // Indeed a read access to a register located into a Bank will return the value at reset whatever previous writings are.
  // So multi-field writing access by filed access is prohibited as register content will be reset value modified by the last writing only.
  // Code modified to prepare MRA2 version where bb_clk_divisor will be inserted into banks
// RF - 20160930 -  JN518X_RFPMODEM -> clockshop.tx_clk_cfg.fields.bb_clk_en = 1; // Clockgate control of the tx datapath,
                                                               // overriding the clockgate control of the tmu.
// RF - 20160930 -  JN518X_RFPMODEM -> clockshop.tx_clk_cfg.fields.bb_clk_divisor = 1; // For radio standards at 2Mbps data rate (all excepted regular BLE).
   JN518X_RFPMODEM->clockshop.tx_clk_cfg.val = (1<<EXTAPB_REGFILE_CLOCKSHOP_TX_CLK_CFG_BB_CLK_EN_POS | 1<<EXTAPB_REGFILE_CLOCKSHOP_TX_CLK_CFG_BB_CLK_DIVISOR_POS); // bb_clk_divisor = 1; For radio standards at 2Mbps data rate (all excepted regular BLE).
// RF - 20160930 -

  // DAC amplitude is set for 2MBps mode (+/-500kHz frequency deviation)
  // DAC amplitude is set for 1MBps mode (+/-250kHz frequency deviation)
   switch (InitVersion)
   {
 	  case TX_PROP_1:
 	  case TX_PROP_2:
 	  case TX_REGULAR:
 	  default:
		   /* ES2 default */
//			JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_mode2_enable = 0;	// back to the largest full scale du to VCO kmod redesign to get 10 MHz/V
//																									// iso 18 MHz/V measured on ES1 (typical)
//		  JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_c_set = 3; // TX DAC output capacitor set for ZigBee regular mode

 		 radio_TX_ZigBee_pll_dac_banked_set();

		  // Here we don't write to pre_const right now as it is done after within the current function.
//		  if (!(radio_jn518x_IsNotC2MF(NULL, NULL)))
//		  {
//			    JN518X_RFPMODEM -> tx_datapath.pre_const.fields.len |= (0x7 << 5); // Do NOT write to bits[4:0] !
//		  }
 		if (radio_jn518x_IsNotC2MF(NULL, NULL))
 		{
 			trig_pre_const = 0;
 		}
 		else
 		{
 			trig_pre_const = 0xE0;
 		}


   }

  // ---------------------------
  // 16MHz/32MHz clock distribution settings from synthesizer's XO in TX mode
  // Manual forcing to be removed when TX under TMU control
  // ---------------------------

  JN518X_RFPMODEM -> transceiver.tone_0_d2r_if_val.fields.tone_pfd_enable = 0; // xo16m_tonepfd_enable_1v1
  JN518X_RFPMODEM -> transceiver.tone_0_d2r_if_src_sel.fields.tone_pfd_enable = 0; // Does it exist ?

  // Bank configuration
  // Enable bit for CIC filter
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.cic_active = 0; // For radio standards at 2Mbps data rate (all excepted regular BLE).
  // Mode settings to select shaping filter to be used and upsampling
  switch (InitVersion)
  {
	  case TX_PROP_1:
		  JN518X_RFPMODEM -> tx_datapath.cfg.fields.gaussian_mode = 1; // 8 ZOH. Applicable only for ZB
		  break;
	  case TX_PROP_2:
		  JN518X_RFPMODEM -> tx_datapath.cfg.fields.gaussian_mode = 0; // 8 ZOH. Applicable only for ZB
		  break;
	  case TX_REGULAR:
	  default:
		  JN518X_RFPMODEM -> tx_datapath.cfg.fields.gaussian_mode = 2; // 8 ZOH. Applicable only for ZB
  }
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.flush_cnt = 24; // Flush counter for upsample gauss filter in clock cycles
  JN518X_RFPMODEM -> tx_datapath.cfg.fields.zoh_shift = 6; // Data input position shift in regular ZigBee only

  // Constant value to be prepended before packet (useful for to check preamble first effective bit existence)
  // ES2MF: These write operations in pre_const register trigger saving of pll_dac_mode2_enable and
  // pll_dac_c_set in the current bank
  JN518X_RFPMODEM -> tx_datapath.pre_const.fields.len = (1 | trig_pre_const); // Length of pre constant value
  JN518X_RFPMODEM -> tx_datapath.pre_const.fields.val = 0; // Constant value for prepend: -1, 0, +1
  JN518X_RFPMODEM -> tx_datapath.pre_const.fields.en  = 1; // Constant value is prepended before packet

  switch (InitVersion)
  {
	  case TX_PROP_1:
	  case TX_PROP_2:
	  case TX_REGULAR:
	  default:
		  // Two paths modulation sampling delay compensation whatever synthesizer reference frequency & rata rate
		  JN518X_RFPMODEM -> tx_datapath.delay.fields.first_point_fine = 1;   // Sample delay first point, fine
		  JN518X_RFPMODEM -> tx_datapath.delay.fields.second_point = 4;       // Sample delay second point
		  // Two paths modulation sampling delay compensation with 32 MHz synthesizer reference frequency, whatever rata rate
		  JN518X_RFPMODEM -> synth_control.cfg.fields.delay_second_point_super_fine = 2; // Sample delay second point, super fine
  }
  // Two paths modulation sampling delay compensation with 32 MHz synthesizer reference frequency, whatever rata rate
  //JN518X_RFPMODEM -> synth_control.cfg.fields.delay_second_point_super_fine = 2; // Sample delay second point, super fine
  JN518X_RFPMODEM -> synth_control.cfg.fields.zoh_en = 1; // Enables the ZOH in the CDC

  switch (InitVersion)
  {
	  case TX_PROP_1:
	  case TX_PROP_2:
	  case TX_REGULAR:
	  default:
		  // Two paths modulation sampling delay compensation with 32 MHz synthesizer reference frequency, 2Mbps rata rate
		  JN518X_RFPMODEM -> tx_datapath.delay.fields.first_point_coarse = 10; // Sample delay first point, coarse
  }

  switch (InitVersion)
  {
	  case TX_PROP_2:
//		  // Two paths modulation first point gain setting (put in comment lines corresponding to not used modes)
		  JN518X_RFPMODEM -> tx_datapath.gain_first_point.fields.gain_first_point = 1802 ; // ZigBee modes value
//		  // Two paths modulation second point gain setting (put in comment lines corresponding to not used modes)
		  JN518X_RFPMODEM -> tx_datapath.gain_second_point.fields.gain_second_point = 60 ; // ZigBee modes value
		  break;
	  case TX_PROP_1:
	  case TX_REGULAR:
	  default:
		  // Two paths modulation first point gain setting (put in comment lines corresponding to not used modes)
		  JN518X_RFPMODEM -> tx_datapath.gain_first_point.fields.gain_first_point = 1787 ; // ZigBee modes value
		  // Two paths modulation second point gain setting (put in comment lines corresponding to not used modes)
		  JN518X_RFPMODEM -> tx_datapath.gain_second_point.fields.gain_second_point = 64 ; // ZigBee modes value
  }

  JN518X_ZBMODEM -> MTX_CTRL_b.tx_pol = 1;

  // RF - 20170907
  // Set MAC timing for when data is generated to align with radio TX path start-up time.
  // Be carefull, in order to get proper MAC modem reset, that otherwise will lead to miss the two first symbols 0,
  // then this timing must be set accordingly to the following relationship:
  // phytxtunetime = INT((((JN518X_RFPMODEM->tmu.comparator_packet_start.fields.comparator + ...
  //                 JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre)/2+4)/4+0.5))
  // It means that the MAC counter release time must occurs AFTER the generation of the RFP internal Packet start (starting the
  // digital Rx/Tx part) event.
  // Please note it exists into the MAC a 4us window uncertainty in between the PHYON assertion from MAC to RFP and the MAC counter start
  // (this one programmed with PHYTXTUNETIME_b.phytxtunetime register content).
  // RF - 20170907
  JN518X_ZBMAC -> PHYTXTUNETIME_b.phytxtunetime = 24; // allow 96usec (24 * 4usec) from PHYTX to generating data - radio ready in 91usec // RF - 20170907

  //# tx modulation dac biasing
  //wfield('RFP_TRANSCEIVER_PLL_DAC_1_D2R_IF_VAL_PLL_DAC_DCCUR_SET',0x0) # MP adjustment
  //# VCO adjustment
  //wfield('RFP_TRANSCEIVER_PLL_VCO_BOOST_D2R_IF_VAL_PLL_VCO_BOOST_SET',0x3) # MP adjustment

//  JN518X_RFPMODEM -> transceiver.pll_dac_1_d2r_if_val.fields.pll_dac_dccur_set = 0x0; // RF - 20170907
//  JN518X_RFPMODEM -> transceiver.pll_vco_boost_d2r_if_val.fields.pll_vco_boost_set = 0x3; // TO be removed ?? // RF - 20170907

  RESTORE_PHYON
}


void radio_jn518x_TX_ZigBee_Regular_Init(void)
{
	radio_jn518x_TX_ZigBee_Init(TX_REGULAR);
}

void radio_jn518x_TX_ZigBee_Prop_1_Regular_Init(void)
{
	radio_jn518x_TX_ZigBee_Init(TX_PROP_1);
}

void radio_jn518x_TX_ZigBee_Prop_2_Regular_Init(void)
{
	radio_jn518x_TX_ZigBee_Init(TX_PROP_2);
}


// --------------------------------------------------------------------------
// Global configuration of the Rx Datapath for RX in regular BLE 1 Mbps mode
// - Bank selection of Rx datapath -> 1.
// --------------------------------------------------------------------------

void radio_jn518x_RX_BLE_1Mbs_Init()
{
	int32_t i32RSSI_offset;

	vPrintf("(Tmp Fct:radio_jn518x_RX_BLE_1Mbs_Init used !)\n");

   // Global configuration of the Rx Datapath
   JN518X_RFPMODEM -> rx_datapath.global.fields.rx_bank = 1; // Bank selection of Rx datapath

   // Too much filtering in Radio by default

//   JN518X_RFPMODEM -> transceiver.aaf_1_d2r_if_val.fields.rx_aaf_fc_set = 0x03;

   // source=register, not func
//   JN518X_RFPMODEM -> transceiver.aaf_1_d2r_if_src_sel.fields.rx_aaf_fc_set = 0; // Anti-aliasing filter cut-off frequency sourced from regfile

   // Dynamic AGC

   // Timeout following a clipping detection during which clipping events are ignored and further gain reduction of the AAF is blocked
   JN518X_RFPMODEM -> rx_datapath.clip_det_3_timeout.val=20;
   // Timeout following a clipping detection during which clipping events are ignored and further gain reduction of the IFAMP is blocked
   JN518X_RFPMODEM -> rx_datapath.clip_det_2_timeout.val=8;
   // Timeout following a clipping detection during which clipping events are ignored and further gain reduction of the LNA is blocked
   JN518X_RFPMODEM -> rx_datapath.clip_det_1_timeout.val=2;

	JN518X_RFPMODEM->rx_datapath.clip_det_1_lev_sel.fields.clip_det_1_lev_sel = 1;   // Clip detector 1 (RF): detection level select. 0..3 -> 359mVp diff
	JN518X_RFPMODEM->rx_datapath.clip_det_2_lev_sel.fields.clip_det_2_lev_sel = 2;   // Clip detector 2 (IF): detection level select. 0..7 -> 259mVp diff

	//JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_val.fields.rx_clipdet_hs_amp_set=1; // Programmable clip amplitude level (359mVp(diff))
	JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_hs_amp_set=1; // Source selection for rx_clipdet_hs_amp_set -> Sourced from AGC (data_path)

	//JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_val.fields.rx_clipdet_ls_amp_set=3;
	JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_ls_amp_set=1; // Source selection for rx_clipdet_ls_amp_set -> Sourced from AGC (data_path)

	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.en_aaf_always_lsclip=1; // Allow AAF gain reduction despite continuous LS clipping when IF amp gain is
																	   // already at minimum value (op_ifamp_gain_d2r_set=0).

//   JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.en_if_always_hsclip=1; // Allow IF amplifier gain reduction despite continuous HS clipping when LNA gain
                                                                          // is already at minimum value (op_lna_gain_d2r_set =0).
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.en_if_always_hsclip=1;

   JN518X_RFPMODEM -> rx_datapath.clip_det_1_timeout_up.val=16384;  // 1024 ->66 us, 3*1024=200, gain come back max just before preamble then corrupt, so decrease a little for test (~-60 dBm)

   // better immunity to blockers
   JN518X_RFPMODEM->rx_datapath.agc_ctrl1.fields.offset_max_adc=15;

   // ---------------------------------------------
   // Switch to RX mode
   // ---------------------------------------------
// RF - 20160930 -
  // Two successive accesses by field to the same register located in a bank are prohibited.
  // Indeed a read access to a register located into a Bank will return the value at reset whatever previous writings are.
  // So multi-field writing access by filed access is prohibited as register content will be reset value modified by the last writing only.
  // Code modified to prepare MRA2 version where bb_clk_divisor will be inserted into banks
// RF - 20160930 -  JN518X_RFPMODEM -> clockshop.rx_clk_cfg.fields.bb_clk_en=1; // Clockgate control of the rx datapath,
                                                               // overriding the clockgate control of the tmu.
// RF - 20160930 -  JN518X_RFPMODEM -> clockshop.rx_clk_cfg.fields.bb_clk_divisor=1; // For BLE at 1Mbps data rate
   JN518X_RFPMODEM->clockshop.rx_clk_cfg.val = (1<<EXTAPB_REGFILE_CLOCKSHOP_RX_CLK_CFG_BB_CLK_EN_POS | 1<<EXTAPB_REGFILE_CLOCKSHOP_RX_CLK_CFG_BB_CLK_DIVISOR_POS); // bb_clk_divisor = 1; // For BLE at 1Mbps data rate
// RF - 20160930 -

   JN518X_RFPMODEM -> rx_datapath.cfg.fields.dec_en=1;                // Enable decimation in rfp for 1 Mbps packets


   //radio_jn518x_Carrier_Frequency_Select(2402,1,1);
   radio_jn518x_Carrier_Frequency_Select_by_index(CFS_BLE_1MB);
   radio_jn518x_Trx_Packet_HW_Ctrl_Init();

//   vPrintf("LDO PA powerstage enabled during RX1");
   // To get the ldo_pa_powerstage enabled during RX1
   JN518X_RFPMODEM->transceiver.ldo_pa_d2r_if_src_sel.fields.powerstage_enable_1v8_rx = 1;

//   vPrintf("Rx Datapath accepts data from ADC");
   // ADC-Rx Datapath interface is enabled. Rx Datapath accepts data from ADC.
   JN518X_RFPMODEM ->rx_datapath.global.fields.adc_en=1; // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! to be clarified, should be managed by TMU, so should be useless




  JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.enable_lut=0;                    // AGC normal mode, not low-level mode.

  // patch 1.04
  JN518X_RFPMODEM -> rx_datapath.clip_det_2_bucket_threshold.fields.clip_det_2_bucket_threshold = 1;
	JN518X_RFPMODEM -> rx_datapath.clip_det_3_thr_2.fields.clip_det_3_thr_2 = 0x1f;
  JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.en_clip_rst_on_gfreeze=1;  // Enable the possibility to reset cliping hs and ls when agc_freeze during 1 clock 16 MHz
  // patch 1.04

	// Fabian's patch 30/03/18
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.reinit_on_clip = 1;
	//def//JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.enable_lut=0;                    // AGC normal mode, not low-level mode.
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.compifaaf_det2=1;
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.compifaaf_det3=1;
	JN518X_RFPMODEM->rx_datapath.mute_ctrl1.fields.mn_ifamp_adc_mute_time = 4;   // Number of muted ADC samples following an
	                                                                                                                                                           // LNA & IFAMP gain change or change in mn_low_gain_setting
	JN518X_RFPMODEM->rx_datapath.mute_ctrl1.fields.mn_mute_enable=1;

	// Fabian 07/05/18
    JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_val.fields.rx_clipdet_ls_enable = 1;
    JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.clipls_end = 5;
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.cliphs_end = 5;
    JN518X_RFPMODEM->rx_datapath.aaf_fc_set.fields.aaf_fc_set = 3;                   // AAF cut-off frequency. 0->2.8MHz, 1->2.5MHz, 3->1.8MHz
	JN518X_RFPMODEM -> rx_datapath.clip_det_3_thr_1.fields.clip_det_3_thr_1 = 8;
    JN518X_RFPMODEM->rx_datapath.agc_bt_conf.fields.rssi_mux=1;
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.window_mode_clip3=1;
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.extend_nbrssi = 0;
	JN518X_RFPMODEM->rx_datapath.dc_offset_cfg.fields.alpha = 6;
	JN518X_RFPMODEM->rx_datapath.clip_det_3_timeout.fields.clip_det_3_timeout = 20;
	JN518X_RFPMODEM->rx_datapath.nb_rssi_hysteresis.fields.nb_rssi_hysteresis = 4;
	JN518X_RFPMODEM->rx_datapath.agc_ctrl1.fields.scale_rfp = 1;
	JN518X_RFPMODEM->rx_datapath.agc_ctrl1.fields.thres_rfp = 15;
	JN518X_RFPMODEM -> rx_datapath.global.fields.rx_data_range_sel = 2;

	JN518X_RFPMODEM->rx_datapath.nb_rssi_conv_to_dbm.fields.nb_rssi_conv_to_dbm = 0x2c8 - OFF_RSSI*4;// test RSSI  // Conversion factor for narrowband RSSI (including ADC gain, digital gain, conversion from dBV to dBm,
																				   // systematic error introduced by truncations) Values: -128..0 in steps of 0.25 dB
																				   // Check if value the same in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	JN518X_RFPMODEM->rx_datapath.wb_rssi_conv_to_dbm.fields.wb_rssi_conv_to_dbm = 0x183 - OFF_RSSI*2;//test RSSI  // Conversion factor for wideband RSSI (including ADC gain, digital gain, conversion from dBV to dBm,
																				   // systematic error introduced by truncations) Values: -128..0 in steps of 0.5 dB
																				   // Check if value the same in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	i32RSSI_offset = RadioConfiguration.i32RSSI_offset;
	i32RSSI_offset -= OFF_RSSI*4;
	if (i32RSSI_offset >63) i32RSSI_offset = 63;
	if (i32RSSI_offset <-64) i32RSSI_offset = -64;
	JN518X_RFPMODEM->rx_datapath.lna_setting.fields.lna_offset_gain_db = i32RSSI_offset;

}

// --------------------------------------------------------------------------
// Global configuration of the Rx Datapath for RX in regular BLE 2 Mbps mode
// - Bank selection of Rx datapath -> 2.
// --------------------------------------------------------------------------

void radio_jn518x_RX_BLE_2Mbs_Init()
{
	int32_t i32RSSI_offset;

	vPrintf("(Tmp Fct:radio_jn518x_RX_BLE_2Mbs_Init used !)\n");

   // Global configuration of the Rx Datapath
   JN518X_RFPMODEM -> rx_datapath.global.fields.rx_bank = 2; // Bank selection of Rx datapath

   // Too much filtering in Radio by default

//   JN518X_RFPMODEM -> transceiver.aaf_1_d2r_if_val.fields.rx_aaf_fc_set = 0x00;

   // source=register, not func
//   JN518X_RFPMODEM -> transceiver.aaf_1_d2r_if_src_sel.fields.rx_aaf_fc_set = 0; // Anti-aliasing filter cut-off frequency sourced from regfile

   // Dynamic AGC

   // Timeout following a clipping detection during which clipping events are ignored and further gain reduction of the AAF is blocked
   JN518X_RFPMODEM -> rx_datapath.clip_det_3_timeout.val=20;
   // Timeout following a clipping detection during which clipping events are ignored and further gain reduction of the IFAMP is blocked
   JN518X_RFPMODEM -> rx_datapath.clip_det_2_timeout.val=8;
   // Timeout following a clipping detection during which clipping events are ignored and further gain reduction of the LNA is blocked
   JN518X_RFPMODEM -> rx_datapath.clip_det_1_timeout.val=2;

	JN518X_RFPMODEM->rx_datapath.clip_det_1_lev_sel.fields.clip_det_1_lev_sel = 1;   // Clip detector 1 (RF): detection level select. 0..3 -> 359mVp diff
	JN518X_RFPMODEM->rx_datapath.clip_det_2_lev_sel.fields.clip_det_2_lev_sel = 2;   // Clip detector 2 (IF): detection level select. 0..7 -> 259mVp diff

	//JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_val.fields.rx_clipdet_hs_amp_set=0; // Programmable clip amplitude level (359mVp(diff))
	JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_hs_amp_set=1; // Source selection for rx_clipdet_hs_amp_set -> Sourced from AGC (data_path)

	//JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_val.fields.rx_clipdet_ls_amp_set=0; // Programmable clip amplitude level (285mVp(diff))
	JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_ls_amp_set=1; // Source selection for rx_clipdet_ls_amp_set -> Sourced from AGC (data_path)

	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.en_aaf_always_lsclip=1; // Allow AAF gain reduction despite continuous LS clipping when IF amp gain is
																	   // already at minimum value (op_ifamp_gain_d2r_set=0).

//   JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.en_if_always_hsclip=1; // Allow IF amplifier gain reduction despite continuous HS clipping when LNA gain
                                                                          // is already at minimum value (op_lna_gain_d2r_set =0).
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.en_if_always_hsclip=1;

   JN518X_RFPMODEM -> rx_datapath.clip_det_1_timeout_up.val=16384;  // 1024 ->66 us, 3*1024=200, gain come back max just before preamble then corrupt, so decrease a little for test (~-60 dBm)

   // better immunity to blockers
   JN518X_RFPMODEM->rx_datapath.agc_ctrl1.fields.offset_max_adc=15;

   // ---------------------------------------------
   // Switch to RX mode
   // ---------------------------------------------
// RF - 20160930 -
  // Two successive accesses by field to the same register located in a bank are prohibited.
  // Indeed a read access to a register located into a Bank will return the value at reset whatever previous writings are.
  // So multi-field writing access by filed access is prohibited as register content will be reset value modified by the last writing only.
  // Code modified to prepare MRA2 version where bb_clk_divisor will be inserted into banks
// RF - 20160930 -  JN518X_RFPMODEM -> clockshop.rx_clk_cfg.fields.bb_clk_en=1; // Clockgate control of the rx datapath,
                                                               // overriding the clockgate control of the tmu.
// RF - 20160930 -  JN518X_RFPMODEM -> clockshop.rx_clk_cfg.fields.bb_clk_divisor=1; // For BLE at 2Mbps data rate
   JN518X_RFPMODEM->clockshop.rx_clk_cfg.val = (1<<EXTAPB_REGFILE_CLOCKSHOP_RX_CLK_CFG_BB_CLK_EN_POS | 1<<EXTAPB_REGFILE_CLOCKSHOP_RX_CLK_CFG_BB_CLK_DIVISOR_POS); // bb_clk_divisor = 1; // For BLE at 2Mbps data rate
// RF - 20160930 -

   JN518X_RFPMODEM -> rx_datapath.cfg.fields.dec_en=0;                // Disable decimation in rfp for 2 Mbps packets


   //radio_jn518x_Carrier_Frequency_Select(2402,2,2);
   radio_jn518x_Carrier_Frequency_Select_by_index(CFS_BLE_2MB);
   radio_jn518x_Trx_Packet_HW_Ctrl_Init();

//   vPrintf("LDO PA powerstage enabled during RX1");
   // To get the ldo_pa_powerstage enabled during RX1
   JN518X_RFPMODEM->transceiver.ldo_pa_d2r_if_src_sel.fields.powerstage_enable_1v8_rx = 1;

//   vPrintf("Rx Datapath accepts data from ADC");
   // ADC-Rx Datapath interface is enabled. Rx Datapath accepts data from ADC.
   JN518X_RFPMODEM ->rx_datapath.global.fields.adc_en=1; // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! to be clarified, should be managed by TMU, so should be useless




  JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.enable_lut=0;                    // AGC normal mode, not low-level mode.

  // patch 1.04
  JN518X_RFPMODEM -> rx_datapath.clip_det_2_bucket_threshold.fields.clip_det_2_bucket_threshold = 1;
	JN518X_RFPMODEM -> rx_datapath.clip_det_3_thr_2.fields.clip_det_3_thr_2 = 0x1f;
  JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.en_clip_rst_on_gfreeze=1;  // Enable the possibility to reset cliping hs and ls when agc_freeze during 1 clock 16 MHz
  // patch 1.04

	// Fabian's patch 30/03/18
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.reinit_on_clip = 1;
	//def//JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.enable_lut=0;                    // AGC normal mode, not low-level mode.
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.compifaaf_det2=1;
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.compifaaf_det3=1;
	JN518X_RFPMODEM->rx_datapath.mute_ctrl1.fields.mn_ifamp_adc_mute_time = 4;   // Number of muted ADC samples following an
	                                                                                                                                                           // LNA & IFAMP gain change or change in mn_low_gain_setting
	JN518X_RFPMODEM->rx_datapath.mute_ctrl1.fields.mn_mute_enable=1;

	// Fabian 07/05/18
    JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_val.fields.rx_clipdet_ls_enable = 1;
    JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.clipls_end = 5;
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.cliphs_end = 5;
    JN518X_RFPMODEM->rx_datapath.aaf_fc_set.fields.aaf_fc_set = 0;                   // AAF cut-off frequency. 0->2.8MHz, 1->2.5MHz, 3->1.8MHz
	JN518X_RFPMODEM -> rx_datapath.clip_det_3_thr_1.fields.clip_det_3_thr_1 = 8;
    JN518X_RFPMODEM->rx_datapath.agc_bt_conf.fields.rssi_mux=1;
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.window_mode_clip3=1;
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.extend_nbrssi = 0;
	JN518X_RFPMODEM->rx_datapath.dc_offset_cfg.fields.alpha = 6;
	JN518X_RFPMODEM->rx_datapath.clip_det_3_timeout.fields.clip_det_3_timeout = 20;
	JN518X_RFPMODEM->rx_datapath.nb_rssi_hysteresis.fields.nb_rssi_hysteresis = 4;
	JN518X_RFPMODEM->rx_datapath.agc_ctrl1.fields.scale_rfp = 1;
	JN518X_RFPMODEM->rx_datapath.agc_ctrl1.fields.thres_rfp = 15;
	JN518X_RFPMODEM -> rx_datapath.global.fields.rx_data_range_sel = 2;

	JN518X_RFPMODEM->rx_datapath.nb_rssi_conv_to_dbm.fields.nb_rssi_conv_to_dbm = 0x2c8 - OFF_RSSI*4;// test RSSI  // Conversion factor for narrowband RSSI (including ADC gain, digital gain, conversion from dBV to dBm,
																				   // systematic error introduced by truncations) Values: -128..0 in steps of 0.25 dB
																				   // Check if value the same in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	JN518X_RFPMODEM->rx_datapath.wb_rssi_conv_to_dbm.fields.wb_rssi_conv_to_dbm = 0x183 - OFF_RSSI*2;//test RSSI  // Conversion factor for wideband RSSI (including ADC gain, digital gain, conversion from dBV to dBm,
																				   // systematic error introduced by truncations) Values: -128..0 in steps of 0.5 dB
																				   // Check if value the same in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	i32RSSI_offset = RadioConfiguration.i32RSSI_offset;
	i32RSSI_offset -= OFF_RSSI*4;
	if (i32RSSI_offset >63) i32RSSI_offset = 63;
	if (i32RSSI_offset <-64) i32RSSI_offset = -64;
	JN518X_RFPMODEM->rx_datapath.lna_setting.fields.lna_offset_gain_db = i32RSSI_offset;

}

// --------------------------------------------------------------------------
// Receiver settings for ZigBee regular scheme (2Mcps, half-sine filtered only):
// - Bank selection of Rx datapath -> 0.
// - Manual forcing of RX analog datapath gain (LNA, IFAMP & AAF cells)
// - Rx master clock towards the TMU enabled,
// - Disable the decimation
// - LDO PA powerstage enabled during RX1
// - Rx Datapath accepts data from ADC
// - IF frequency normalized to 2Mbps symbol rate when in RX mode (could be moved to carrier frequency selction function)
// - RSSI settings
// - Clip detector settings
// - 2.5MHz AAF cut-off frequency
// - AGC settings
// - Swap IQ in Rx DP
// - IF amp tail current initialization
// - AAF tail current initialization
// - AAF gain LUT
// --------------------------------------------------------------------------

/**
 * @brief	Global configuration of the Rx Datapath for RX in regular ZigBee mode
 * @return	Nothing
 * @note	Receiver settings for ZigBee regular scheme:
 * - Rx master clock towards the TMU enabled,<br>
 * - LDO PA powerstage enabled during RX1,<br>
 * - Rx Datapath accepts data from ADC,<br>
 * - IF frequency normalized to 2Mbps symbol rate when in RX mode (could be moved to carrier frequency selction function),<br>
 * - RSSI settings,<br>
 * - Clip detector settings,<br>
 * - 2.5MHz AAF cut-off frequency,<br>
 * - AGC settings,<br>
 * - Swap IQ in Rx DP,<br>
 * - IF amp tail current initialization,<br>
 * - AAF tail current initialization,<br>
 * - AAF gain LUT,<br>
 * <br>
 * Example: radio_jn518x_RX_ZigBee_Regular_Init();
 */

void radio_jn518x_RX_ZigBee_Init(uint8_t InitVersion)
{

	int32_t i32RSSI_offset;

	RESET_PHYON

//	   switch (InitVersion)
//	   {
//	 	  case PROP_1:
//	 		  vPrintf("(Tmp Fct:radio_jn518x_RX_ZigBee_Prop_1_Regular_Init used !)\n");
//	 		  break;
//	 	  case PROP_2:
//	 		  vPrintf("(Tmp Fct:radio_jn518x_RX_ZigBee_Prop_2_Regular_Init used !)\n");
//	 		  break;
//	 	  case REGULAR:
//	 	  default:
//	 		  vPrintf("(Tmp Fct:radio_jn518x_RX_ZigBee_Regular_Init used !)\n");
//	   }

   vPrintf("Configure RFP for RX\n");

   // Global configuration of the Rx Datapath
   JN518X_RFPMODEM -> rx_datapath.global.fields.rx_bank = 0; // Bank selection of Rx datapath

   // Dynamic AGC

   // Timeout following a clipping detection during which clipping events are ignored and further gain reduction of the AAF is blocked
   JN518X_RFPMODEM -> rx_datapath.clip_det_3_timeout.val=20;
   // Timeout following a clipping detection during which clipping events are ignored and further gain reduction of the IFAMP is blocked
   JN518X_RFPMODEM -> rx_datapath.clip_det_2_timeout.val=8;
   // Timeout following a clipping detection during which clipping events are ignored and further gain reduction of the LNA is blocked
   JN518X_RFPMODEM -> rx_datapath.clip_det_1_timeout.val=4;

   //>patch 1.02
   JN518X_RFPMODEM->rx_datapath.clip_det_1_lev_sel.fields.clip_det_1_lev_sel = 1;   // Clip detector 1 (RF): detection level select. 0..3 -> 359mVp diff
   JN518X_RFPMODEM->rx_datapath.clip_det_2_lev_sel.fields.clip_det_2_lev_sel = 3;   // Clip detector 2 (IF): detection level select. 0..7 -> 259mVp diff
   //<patch 1.02
   JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_hs_amp_set=1; // Source selection for rx_clipdet_hs_amp_set -> Sourced from AGC (data_path)

   //>patch 1.02
   //JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_val.fields.rx_clipdet_ls_amp_set=3; // Programmable clip amplitude level (285mVp(diff))
   //<patch 1.02
   JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_ls_amp_set=1; // Source selection for rx_clipdet_ls_amp_set -> Sourced from AGC (data_path)

   JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.en_aaf_always_lsclip=1; // Allow AAF gain reduction despite continuous LS clipping when IF amp gain is
                                                                           // already at minimum value (op_ifamp_gain_d2r_set=0).
                                                                           // NC2001: Not checked in IP2001 environment used for performance evaluation

//   JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.en_if_always_hsclip=1; // Allow IF amplifier gain reduction despite continuous HS clipping when LNA gain
                                                                          // is already at minimum value (op_lna_gain_d2r_set =0).

   JN518X_RFPMODEM -> rx_datapath.clip_det_1_timeout_up.val=16384;  // 1024 ->66 us, 3*1024=200, gain come back max just before preamble then corrupt, so decrease a little for test (~-60 dBm)

   // better immunity to blockers
   JN518X_RFPMODEM->rx_datapath.agc_ctrl1.fields.offset_max_adc=6;


   // ---------------------------------------------
   // Switch to RX mode
   // ---------------------------------------------

//   vPrintf("Default SW configurations for RX clockshop");
  // Default SW configurations for RX clockshop

// RF - 20160930 -
  // Two successive accesses by field to the same register located in a bank are prohibited.
  // Indeed a read access to a register located into a Bank will return the value at reset whatever previous writings are.
  // So multi-field writing access by filed access is prohibited as register content will be reset value modified by the last writing only.
  // Code modified to prepare MRA2 version where bb_clk_divisor will be inserted into banks
// RF - 20160930 -  JN518X_RFPMODEM->clockshop.rx_clk_cfg.fields.bb_clk_en = 1; // Clockgate control of the rx datapath,
                                                               // overriding the clockgate control of the tmu.
// RF - 20160930 -  JN518X_RFPMODEM->clockshop.rx_clk_cfg.fields.bb_clk_divisor = 1; // For ZigBee at 2Mbps data rate
   JN518X_RFPMODEM->clockshop.rx_clk_cfg.val = (1<<EXTAPB_REGFILE_CLOCKSHOP_RX_CLK_CFG_BB_CLK_EN_POS | 1<<EXTAPB_REGFILE_CLOCKSHOP_RX_CLK_CFG_BB_CLK_DIVISOR_POS); // bb_clk_divisor = 1; // For ZigBee at 2Mbps data rate
// RF - 20160930 -

  // -------------------------------------------------
  // Default SW configurations for RX datapath
//   vPrintf("Default SW configurations for RX datapath");

   // Enable bit for the decimation filter at Rx digital front-end
   JN518X_RFPMODEM ->rx_datapath.cfg.fields.dec_en=0; //for zigbee disable the decimation !

   // Selection of the sampling edge for the data coming from the ADC
   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Real need of the programmaing bellow to be reviewed after study
   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! of NxH's ADC retimming issue ticket (ULRF3096))
//   JN518X_RFPMODEM ->rx_datapath.global.fields.adc_sample_edge = 1; // 1: falling_edge: ADC input is sampled by RFP at the falling edge of the Rx Datapath
                                                                    //    baseband clock. It will help to maximaze time left for the conversion.
                                                                    //    Tracking is started on the falling edge of the ADC clock.

//   vPrintf("LDO PA powerstage enabled during RX1");
   // To get the ldo_pa_powerstage enabled during RX1
   JN518X_RFPMODEM->transceiver.ldo_pa_d2r_if_src_sel.fields.powerstage_enable_1v8_rx = 1;

//   vPrintf("Rx Datapath accepts data from ADC");
   // ADC-Rx Datapath interface is enabled. Rx Datapath accepts data from ADC.
   JN518X_RFPMODEM ->rx_datapath.global.fields.adc_en=1; // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! to be clarified, should be managed by TMU, so should be useless

//   vPrintf("1.4375MHz IF frequency selected");
   // IF frequency normalized to 2Mbps symbol rate when in RX mode (could be moved to carrier frequency selction function)
//   JN518X_RFPMODEM -> rx_datapath.if_freq_norm.fields.if_freq_norm = 0x17;        // 1.4375MHz IF frequency normalized to 2Mbps symbol rate - signed (3.5)

//   vPrintf("NB & WB RSSI settings");
   // RSSI settings
   JN518X_RFPMODEM ->rx_datapath.nb_rssi_ctrl1.fields.nb_rssi_timeout = 60;          // 2 Mpbs value narrowband rssi lowpass filter timeout constant. Value map: 0..6 -> 2**0..2**6
   JN518X_RFPMODEM->rx_datapath.nb_rssi_ctrl2.fields.nb_rssi_window = 64;           // 2 Mpbs value narrowband rssi lowpass filter window. Values: 0..8191.
   JN518X_RFPMODEM->rx_datapath.correlator_start_scan.fields.correlator_start_scan = 15; // Number of symbols at the beginning of a packet for which the correlator does not calculate the result
                                                                                   // Check if still relevant in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   JN518X_RFPMODEM->rx_datapath.nb_rssi_conv_to_dbm.fields.nb_rssi_conv_to_dbm = 0x2c8;  // Conversion factor for narrowband RSSI (including ADC gain, digital gain, conversion from dBV to dBm,
                                                                                   // systematic error introduced by truncations) Values: -128..0 in steps of 0.25 dB
                                                                                   // Check if value the same in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   JN518X_RFPMODEM->rx_datapath.wb_rssi_conv_to_dbm.fields.wb_rssi_conv_to_dbm = 0x183;  // Conversion factor for wideband RSSI (including ADC gain, digital gain, conversion from dBV to dBm,
                                                                                   // systematic error introduced by truncations) Values: -128..0 in steps of 0.5 dB
                                                                                   // Check if value the same in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  JN518X_RFPMODEM->rx_datapath.nb_rssi_ctrl1.fields.alpha1_nb_rssi = 2;                 // Narrowband rssi lowpass filter timeout constant. Value map: 0..6 -> 2**0..2**6
  JN518X_RFPMODEM->rx_datapath.nb_rssi_ctrl3.fields.alpha2_nb_rssi = 8;                 // Narrowband rssi lowpass filter window constant. Value map: 3..9 -> 2**3..2**9 (scan mode)
  JN518X_RFPMODEM->rx_datapath.nb_rssi_ctrl3.fields.alpha3_nb_rssi = 3;                 // Narrowband rssi lowpass filter window constant. Value map: 3..7 -> 2**3..2**7 (scan mode)
  JN518X_RFPMODEM->rx_datapath.nb_rssi_payload_ctrl.fields.alpha_nb_rssi_payload = 5;   // Narrowband rssi payload lowpass filter constant. Value map: 2..8 -> 2**2..2**8
  JN518X_RFPMODEM->rx_datapath.nb_rssi_hysteresis.fields.nb_rssi_hysteresis = 4;        // Hysteresis on subsequent narrowband RSSI measurements input to the gain setting lookup table
  JN518X_RFPMODEM->rx_datapath.nb_rssi_wakeup.fields.nb_rssi_wakeup = 410; // -98    // Threshold for narrowband rssi wakeup Signed values: -128..0 [dBm]
                                                                                   // To be checked as -98dBm should be 512-abs(-98)=414 !!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                                                   // 410 should be -102dBm that is a good value for ZigBee whose sensitivity is -100dBm targeted
  JN518X_RFPMODEM->rx_datapath.wb_rssi_ctrl.fields.alpha_wb_rssi = 7;                   // Wideband rssi lowpass filter constant. Value map: 4..10 -> 2**4..2**10
  JN518X_RFPMODEM->rx_datapath.wb_rssi_ctrl.fields.wb_rssi_window = 512;                  // Window for wideband rssi averaging. Values: 0..1023
  JN518X_RFPMODEM->rx_datapath.wb_rssi_wakeup.fields.wb_rssi_wakeup = 408; // -96    // Threshold for wideband rssi wakeup Signed values: -128..0 [dBm]
                                                                                   // To be checked as -96dBm should be 512-abs(-98)=416 !!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                                                   // 412 should be -100dBm that is a good value for ZigBee whose sensitity is -100dBm targeted
  JN518X_RFPMODEM->rx_datapath.nb_rssi_init_timeout.fields.nb_rssi_init_timeout = 220; // NB RSSI timeout at start of packet
  JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.extend_nbrssi=1;                 // enable possibility to recompute rssi when agc just freeze and apply lut

//   vPrintf("Clip detector settings");
  // Clip detector settings
  // Fabian 20171002 correct typo det_2 iso det_1 and value 2 iso 4
  JN518X_RFPMODEM->rx_datapath.clip_det_1_timeout.fields.clip_det_1_timeout = 4;   // Timeout following a clipping detection during which clipping events are ignored
                                                                                   // and further gain reduction of the LNA is blocked
                                                                                   // Check if value the same in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  JN518X_RFPMODEM->rx_datapath.clip_det_2_timeout.fields.clip_det_2_timeout = 8;   // Timeout following a clipping detection during which clipping events are ignored
                                                                                   // and further gain reduction of the IFAMP is blocked
                                                                                   // Check if value the same in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  JN518X_RFPMODEM->rx_datapath.clip_det_3_timeout.fields.clip_det_3_timeout = 20;   // Timeout following a clipping detection during which clipping events are ignored
                                                                                   // and further gain reduction of the AAF is blocked
                                                                                   // Check if value the same in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.window_mode_clip3=1;             // When set to '2' change aaf gain based on window new method (all gains in one step),
                                                                                   // when set to '1' change aaf change aaf gain based on window method,
                                                                                   // else change step by step on each ADC saturationgain based on window method

//   vPrintf("2.5MHz AAF cut-off frequency");
   // AAF settings
   JN518X_RFPMODEM->rx_datapath.aaf_q_set.fields.aaf_q_set2 = 0;                    // AAF Q factor. 0 value corresponds to Q=1.25. Obsolete, not anymore used
   JN518X_RFPMODEM->rx_datapath.aaf_fc_set.fields.aaf_fc_set = 1;                   // AAF cut-off frequency. 0->2.8MHz, 1->2.5MHz, 3->1.8MHz

//   vPrintf("AGC settings");
  JN518X_RFPMODEM->rx_datapath.mute_ctrl1.fields.mn_ifamp_adc_mute_time = 8;       // Number of muted ADC samples following an IFAMP gain change or change in mn_low_gain_setting
                                                                                   // Check if LNA uses it instead of MN which is not anymore instantiated !!!!!!!!!!!!!!!!!!
  JN518X_RFPMODEM->rx_datapath.dc_offset_cfg.fields.alpha = 4;                     // alpha towards the DC offset compensation module
  //JN518X_RFPMODEM->rx_datapath.aaf_gain_delay.fields.aaf_gain_delay = 0;           // Delay in applying a gain setting change to the anti-aliasing filter.
  //JN518X_RFPMODEM->rx_datapath.aaf_gain_delay.fields.aaf_gain_delay = 6;           // Delay in applying a gain setting change to the anti-aliasing filter.
                                                                                   // Used to introduce delay between simultaneous IFAMP and AAF gain adjustments.
                                                                                   // Check if value the same in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  JN518X_RFPMODEM->rx_datapath.mute_ctrl1.fields.aaf_adc_mute_time = 0;            // Number of muted ADC samples following an AAF gain change
  JN518X_RFPMODEM->rx_datapath.mute_ctrl2.fields.corr_mute_delay = 13;             // Delay for correlator input mute start
                                                                                   // Check if still relevant in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  JN518X_RFPMODEM->rx_datapath.dc_offset_delay.fields.dc_offset_delay = 10;        // Delay (16 MHz cycles) between gain update from AGC and reset of DC offset compensation filter

  // Enable CW mode for digital synthesizer and configure default FCW to 2400 MHz + 16 MHz/11
   // The FCW_int and FCW_frac are to be calculated as follows, re-using the 2401.45 MHz example as follow:
   //-	FCW_int = floor(RF_frequency / 16) = floor(2403.2 / 16) = 150
   //-	FCW_frac = frac(RF_frequency / 16) * (2**16) = 16MHz/11/16MHz * 65536 = 5957 = 0x1745
//   vPrintf("Enable CW mode for digital synthesizer and configure default FCW to 2400 MHz + 16 MHz/11");
//  JN518X_RFPMODEM->synth_control.cfg.fields.cw_mode = 0;                               // Configures the CW mode for the synthesizer: 1-> Value = 0 is taken as input.
//   JN518X_RFPMODEM->synth_control.fcw_int.fields.fcw_int = 129;                    // FCW integer part for 2400MHz generation.
//  JN518X_RFPMODEM->synth_control.fcw_frac.fields.fcw_frac = 5958;                 // FCW fractionnal part for 1.45MHz offset generation.

//  vPrintf("Disable CW mode for digital synthesizer and allows feedback path modulation");
//  JN518X_RFPMODEM->synth_control.cfg.fields.cw_mode = 0;                               // Configures the CW mode for the synthesizer: 1-> Value = 0 is taken as input.

//  vPrintf("Swap IQ in Rx DP");
  // Swap IQ in Rx DP (to compensate for a bug in the real analog)
//  JN518X_RFPMODEM->rx_datapath.global.fields.iq_swap_en = 1;                           // Enable for IQ swapping at input of DC offset.
                                                                                   // Check if still relevant in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  JN518X_ZBMODEM -> MRX_CTRL_b.rx_pol=2;
  //JN518X_ZBMODEM -> MRX_CTRL_b.rx_sync_mode=1;

  // Disable influence of PLL locking sequence to synthesizer reset
  // Could be removed as already done in calibration function
//  JN518X_RFPMODEM->tmu.reset_mask.fields.synth_reset_pll_lock_dis = 1;                 // When 0, the synth_reset is enabled till the PLL lockin sequence is started

//-------------------------------------
   // Rx analog settings (to be uncommented when default values not relevant)

  // Initialize IF amp tail current of OTA stages settings (could be removed as aligned with default settings)
/*  JN518X_RFPMODEM->rx_datapath.ifamp_ibias_set.fields.ifamp_ibias_set0 = 1;        // IFAMP ibias control signal; dependent on gain setting
  JN518X_RFPMODEM->rx_datapath.ifamp_ibias_set.fields.ifamp_ibias_set1 = 5;        // IFAMP ibias control signal; dependent on gain setting
  JN518X_RFPMODEM->rx_datapath.ifamp_ibias_set.fields.ifamp_ibias_set2 = 10;       // IFAMP ibias control signal; dependent on gain setting
*/
  // Initialize AAF tail current of OTA stages settings (could be removed as aligned with default settings)
/*  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set0.fields.aaf_opam1i_set0 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set1.fields.aaf_opam1i_set0 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set2.fields.aaf_opam1i_set0 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set3.fields.aaf_opam1i_set0 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set4.fields.aaf_opam1i_set0 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set5.fields.aaf_opam1i_set0 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set6.fields.aaf_opam1i_set0 = 8;

  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set0.fields.aaf_opam1i_set1 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set1.fields.aaf_opam1i_set1 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set2.fields.aaf_opam1i_set1 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set3.fields.aaf_opam1i_set1 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set4.fields.aaf_opam1i_set1 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set5.fields.aaf_opam1i_set1 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set6.fields.aaf_opam1i_set1 = 8;

  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set0.fields.aaf_opam1i_set2 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set1.fields.aaf_opam1i_set2 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set2.fields.aaf_opam1i_set2 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set3.fields.aaf_opam1i_set2 = 6;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set4.fields.aaf_opam1i_set2 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set5.fields.aaf_opam1i_set2 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam1i_set6.fields.aaf_opam1i_set2 = 10;

  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set0.fields.aaf_opam2i_set0 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set1.fields.aaf_opam2i_set0 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set2.fields.aaf_opam2i_set0 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set3.fields.aaf_opam2i_set0 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set4.fields.aaf_opam2i_set0 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set5.fields.aaf_opam2i_set0 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set6.fields.aaf_opam2i_set0 = 10;

  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set0.fields.aaf_opam2i_set1 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set1.fields.aaf_opam2i_set1 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set2.fields.aaf_opam2i_set1 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set3.fields.aaf_opam2i_set1 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set4.fields.aaf_opam2i_set1 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set5.fields.aaf_opam2i_set1 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set6.fields.aaf_opam2i_set1 = 10;

  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set0.fields.aaf_opam2i_set2 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set1.fields.aaf_opam2i_set2 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set2.fields.aaf_opam2i_set2 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set3.fields.aaf_opam2i_set2 = 8;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set4.fields.aaf_opam2i_set2 = 10;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set5.fields.aaf_opam2i_set2 = 10;
  JN518X_RFPMODEM->rx_datapath.aaf_opam2i_set6.fields.aaf_opam2i_set2 = 10;
*/
  // AAF gain values, required for RSSI calculation.
  // Values: 0..31.75 in steps of 0.25 dB
  // (could be removed as aligned with default settings)
/*
  JN518X_RFPMODEM->rx_datapath.aaf_gain_lut0.fields.aaf_gain_lut = 0*4;
  JN518X_RFPMODEM->rx_datapath.aaf_gain_lut1.fields.aaf_gain_lut = 3*4;
  JN518X_RFPMODEM->rx_datapath.aaf_gain_lut2.fields.aaf_gain_lut = 6*4;
  JN518X_RFPMODEM->rx_datapath.aaf_gain_lut3.fields.aaf_gain_lut = 9*4;
  JN518X_RFPMODEM->rx_datapath.aaf_gain_lut4.fields.aaf_gain_lut = 12*4;
  JN518X_RFPMODEM->rx_datapath.aaf_gain_lut5.fields.aaf_gain_lut = 15*4;
  JN518X_RFPMODEM->rx_datapath.aaf_gain_lut6.fields.aaf_gain_lut = 18*4;
*/
  // Set timing for when data is generated to align with radio
  JN518X_ZBMAC -> PHYRXTUNETIME_b.phyrxtunetime = 23;      // allow 92usec (23 * 4usec) from PHYTX to generating data - radio ready in 85usec

  //JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.enable_lut=0;                    // AGC normal mode, not low-level mode.


  switch (InitVersion)
  {
  case RX_ENABLE_LUT:
	  JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.enable_lut=1;                    // AGC normal mode, not low-level mode.
//      wfield('RFP_RX_DP_AGC_CTRL2_EXTEND_TIME1UP',0) # 0-> lut  ok above than -70 dBm
	  JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.extend_time1up = 0;
//	  JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.extend_time1up = 1;
//      wfield('RFP_RX_DP_CLIP_DET_1_TIMEOUT_UP_CLIP_DET_1_TIMEOUT_UP',0)
	  JN518X_RFPMODEM -> rx_datapath.clip_det_1_timeout_up.fields.clip_det_1_timeout_up = 0;
//	  JN518X_RFPMODEM -> rx_datapath.clip_det_1_timeout_up.fields.clip_det_1_timeout_up = 8192;
	  JN518X_RFPMODEM -> rx_datapath.dc_offset_cfg.fields.dc_comp_filter_flush_en = 1;
	  JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.reinit_on_clip = 0;
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_correction_db.fields.nb_rssi_correction_db = 7;
//      wfield('RFP_RX_DP_AGC_CTRL2_CLIPONE_NBRSSI',0)
	  JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.clipone_nbrssi = 0;
//      wfield('RFP_RX_DP_AGC_CTRL2_EXTEND_NBRSSI',0)
	  JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.extend_nbrssi = 0;
//      wfield('RFP_RX_DP_NB_RSSI_CTRL1_ALPHA1_NB_RSSI',2)
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_ctrl1.fields.alpha1_nb_rssi = 2;
//      wfield('RFP_RX_DP_NB_RSSI_MODEM_CTRL_NB_RSSI_TIMEOUT',80) # 40
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_modem_ctrl.fields.nb_rssi_timeout = 80;
//      wfield('RFP_RX_DP_NB_RSSI_CTRL3_ALPHA2_NB_RSSI',7)
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_ctrl3.fields.alpha2_nb_rssi = 7;
//      wfield('RFP_RX_DP_NB_RSSI_CTRL2_NB_RSSI_WINDOW',80) # 40
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_ctrl2.fields.nb_rssi_window = 80;

// rewrite LUT Seb Robert
//	  EXTAPB_REGFILE_RX_DP_RSSI_LNA_GAIN_LUT0_ADDR <- 0x924 # LUT0..3
	  JN518X_RFPMODEM -> rx_datapath.rssi_lna_gain_lut0.val= 0x924;
//	  EXTAPB_REGFILE_RX_DP_RSSI_LNA_GAIN_LUT1_ADDR <- 0x724 # LUT4..7
	  JN518X_RFPMODEM -> rx_datapath.rssi_lna_gain_lut1.val= 0x724;
//	  EXTAPB_REGFILE_RX_DP_RSSI_LNA_GAIN_LUT2_ADDR <- 0x149b # LUT8..12
	  JN518X_RFPMODEM -> rx_datapath.rssi_lna_gain_lut2.val= 0x149b;
//	  EXTAPB_REGFILE_RX_DP_RSSI_LNA_GAIN_LUT3_ADDR <- 0x249 # LUT13..17
	  JN518X_RFPMODEM -> rx_datapath.rssi_lna_gain_lut3.val= 0x249;
//	  EXTAPB_REGFILE_RX_DP_RSSI_LNA_GAIN_LUT4_ADDR <- 0x0 # LUT18..22
	  JN518X_RFPMODEM -> rx_datapath.rssi_lna_gain_lut4.val= 0x0;
//	  EXTAPB_REGFILE_RX_DP_RSSI_LNA_GAIN_LUT5_ADDR <- 0x0 # LUT23..24
	  JN518X_RFPMODEM -> rx_datapath.rssi_lna_gain_lut5.val= 0x0;
//
//	  EXTAPB_REGFILE_RX_DP_RSSI_IFAMP_GAIN_LUT0_ADDR <- 0x55aa # LUT0..7
	  JN518X_RFPMODEM -> rx_datapath.rssi_ifamp_gain_lut0.val= 0x55aa;
//	  EXTAPB_REGFILE_RX_DP_RSSI_IFAMP_GAIN_LUT1_ADDR <- 0x5aa5 # LUT8..15
	  JN518X_RFPMODEM -> rx_datapath.rssi_ifamp_gain_lut1.val= 0x5aa5;
//	  EXTAPB_REGFILE_RX_DP_RSSI_IFAMP_GAIN_LUT2_ADDR <- 0x155 # LUT16..22
	  JN518X_RFPMODEM -> rx_datapath.rssi_ifamp_gain_lut2.val= 0x155;
//	  EXTAPB_REGFILE_RX_DP_RSSI_IFAMP_GAIN_LUT3_ADDR <- 0x0 # LUT23..24
	  JN518X_RFPMODEM -> rx_datapath.rssi_ifamp_gain_lut3.val= 0x0;
//
//	  EXTAPB_REGFILE_RX_DP_RSSI_AAF_GAIN_LUT0_ADDR <- 0xbb6 # LUT0..3
	  JN518X_RFPMODEM -> rx_datapath.rssi_aaf_gain_lut0.val= 0xbb6;
//	  EXTAPB_REGFILE_RX_DP_RSSI_AAF_GAIN_LUT1_ADDR <- 0xc49 # LUT4..7
	  JN518X_RFPMODEM -> rx_datapath.rssi_aaf_gain_lut1.val= 0xc49;
//	  EXTAPB_REGFILE_RX_DP_RSSI_AAF_GAIN_LUT2_ADDR <- 0x1076 # LUT8..12
	  JN518X_RFPMODEM -> rx_datapath.rssi_aaf_gain_lut2.val= 0x1076;
//	  EXTAPB_REGFILE_RX_DP_RSSI_AAF_GAIN_LUT3_ADDR <- 0x3050 # LUT13..17
	  JN518X_RFPMODEM -> rx_datapath.rssi_aaf_gain_lut3.val= 0x3050;
//	  EXTAPB_REGFILE_RX_DP_RSSI_AAF_GAIN_LUT4_ADDR <- 0x260a # LUT18..22
	  JN518X_RFPMODEM -> rx_datapath.rssi_aaf_gain_lut4.val= 0x260a;
//	  EXTAPB_REGFILE_RX_DP_RSSI_AAF_GAIN_LUT5_ADDR <- 0x1 # LUT23..24
	  JN518X_RFPMODEM -> rx_datapath.rssi_aaf_gain_lut5.val= 0x1;
//
//	  RFP_RX_DP_NB_RSSI_CORRECTION_DB_NB_RSSI_CORRECTION_DB <-1
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_correction_db.fields.nb_rssi_correction_db = 1;
//	  RFP_RX_DP_NB_RSSI_HYSTERESIS_NB_RSSI_HYSTERESIS <-0
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_hysteresis.fields.nb_rssi_hysteresis= 4;
//
//	  RFP_RX_DP_CLIP_DET_2_LEV_SEL_CLIP_DET_2_LEV_SEL <-3
	  JN518X_RFPMODEM->rx_datapath.clip_det_2_lev_sel.fields.clip_det_2_lev_sel =3;

// rewrite LUT Seb Robert

	  break;
  case RX_DETECTOR_ONLY:
  default:
	  //while(1);
	  JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.enable_lut=0;                    // AGC normal mode, not low-level mode.
//      wfield('RFP_RX_DP_CLIP_DET_1_TIMEOUT_UP_CLIP_DET_1_TIMEOUT_UP',8192)
	  JN518X_RFPMODEM -> rx_datapath.clip_det_1_timeout_up.fields.clip_det_1_timeout_up = 8192;
//      wfield('RFP_RX_DP_AGC_CTRL2_EXTEND_TIME1UP',1) # set max gains each timer TIMEOUT_UP_CLIP_DET_1_TIMEOUT_UP
	  JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.extend_time1up = 1;
//      wfield('RFP_RX_DP_NB_RSSI_CTRL1_ALPHA1_NB_RSSI',2)
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_ctrl1.fields.alpha1_nb_rssi = 2;
//      wfield('RFP_RX_DP_NB_RSSI_MODEM_CTRL_NB_RSSI_TIMEOUT',80) # 40
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_modem_ctrl.fields.nb_rssi_timeout = 80;
//      wfield('RFP_RX_DP_NB_RSSI_CTRL3_ALPHA2_NB_RSSI',7)
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_ctrl3.fields.alpha2_nb_rssi = 7;
//      wfield('RFP_RX_DP_NB_RSSI_CTRL2_NB_RSSI_WINDOW',80) # 40
	  JN518X_RFPMODEM -> rx_datapath.nb_rssi_ctrl2.fields.nb_rssi_window = 80;

	  break;
  }

//  wfield('RFP_RX_DP_AAF_GAIN_DELAY_AAF_GAIN_DELAY',0) // already set before in the function (AAF settings). Changed value there
//  wfield('U_ZBMODEM_MRX_CTRL_FIELD_RX_RSSI_AVG_EN',0)
  //JN518X_ZBMODEM->MRX_CTRL_b.rx_rssi_avg_en = 0; // moved in radio_init

// LNA nominal step when switching from 1 to 0 gain setting.
// Value changed from -21dB to -22.25dB (8-bits 2âs complement coded, 0.25dB step)

	// patch 1.04
	JN518X_RFPMODEM -> rx_datapath.clip_det_2_bucket_threshold.fields.clip_det_2_bucket_threshold = 1;
	JN518X_RFPMODEM -> rx_datapath.clip_det_3_thr_2.fields.clip_det_3_thr_2 = 0x1f;
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.en_clip_rst_on_gfreeze=1;  // Enable the possibility to reset cliping hs and ls when agc_freeze during 1 clock 16 MHz
	// patch 1.04

	i32RSSI_offset = RadioConfiguration.i32RSSI_offset;
	if (i32RSSI_offset >63) i32RSSI_offset = 63;
	if (i32RSSI_offset <-64) i32RSSI_offset = -64;
	JN518X_RFPMODEM->rx_datapath.lna_setting.fields.lna_offset_gain_db = i32RSSI_offset;

	RESTORE_PHYON
}

void radio_jn518x_RX_ZigBee_Regular_Init(void)
{
	radio_jn518x_RX_ZigBee_Init(RX_DETECTOR_ONLY);
}

void radio_jn518x_RX_ZigBee_Prop_1_Regular_Init(void)
{
	radio_jn518x_RX_ZigBee_Init(RX_DETECTOR_ONLY);
}

void radio_jn518x_RX_ZigBee_Prop_2_Regular_Init(void)
{
	radio_jn518x_RX_ZigBee_Init(RX_DETECTOR_ONLY);
}

// Settings sent by Steve for BLE on the 22/03/18
void radio_jn518x_Patch_Ble(void)
{
	// Fabian 05/04/2018
    // Set the register dedicated to the BLE LinkLayer in the Infrastructure
    JN518X_SYSCON -> MODEMCTRL |= (	SYSCON_MODEMCTRL_BLE_FREQ_SEL_Msk |
    								SYSCON_MODEMCTRL_BLE_DP_DIV_EN_Msk |
									SYSCON_MODEMCTRL_BLE_HCLK_BLE_EN_Msk);

	// Fabian & Steve's initial settings for BLE
	JN518X_RFPMODEM->tmu.comparator_pre_g1.fields.comparator_pre = TMU_PRE_G1_BASIC;
	JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre = TMU_PRE_G2_BASIC; //27.5us
	JN518X_RFPMODEM->tmu.comparator_pre_tx1.fields.comparator_pre = TMU_PRE_TX1_BASIC;
	JN518X_RFPMODEM->tmu.comparator_pre_tx2.fields.comparator_pre = TMU_PRE_TX2_BASIC;
	JN518X_RFPMODEM->tmu.comparator_pre_tx3.fields.comparator_pre = TMU_PRE_TX3_BASIC; // changed to gain 7us at startup
	JN518X_RFPMODEM->tmu.comparator_packet_start.fields.comparator = TMU_PACKET_START_BASIC; //41.5us changed to gain 7us at startup

	// CHanges to get Radio switch off to 5us  - also needs the 2us ramp down setting
	JN518X_RFPMODEM->tmu.comparator_post_tx3.fields.comparator_post = 5; // 2.5us
	JN518X_RFPMODEM->tmu.comparator_post_tx2.fields.comparator_post = 6; // 3.0us
	JN518X_RFPMODEM->tmu.comparator_post_tx1.fields.comparator_post = 7; // 3.5us
	JN518X_RFPMODEM->tmu.comparator_post_pll.fields.comparator_post = 8; // 4.0us
	JN518X_RFPMODEM->tmu.comparator_post_g2.fields.comparator_post = 9; // 4.5us
	JN518X_RFPMODEM->tmu.comparator_post_g1.fields.comparator_post = 10; // 5.0us
	JN518X_RFPMODEM->tmu.comparator_post_rx3.fields.comparator_post = 1; // 0.5us
	JN518X_RFPMODEM->tmu.comparator_post_rx2.fields.comparator_post = 2; // 1.0us
	JN518X_RFPMODEM->tmu.comparator_post_rx1.fields.comparator_post = 3; // 1.5us

	JN518X_RFPMODEM->tmu.comparator_pre_dp_reset.fields.comparator_pre = TMU_PRE_DP_RESET_BASIC;
	JN518X_RFPMODEM->tmu.comparator_post_dp_reset.fields.comparator_post = TMU_POST_DP_RESET_BASIC;
	// Settings added

	// Radiopwrupdn  RTRIP_DELAY[30..24]   RXPWRUP[23..16]   TXPWRDN[12..8]   TXPWRUP[7..0]:
#ifndef ACCESS_ADDRESS_PATCH
	// Fabian 18/04/2018
	//JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN_b.rw_ble_radiopwrupdn = 0x3C890F4D; // changed to gain 7us at startup // standard value used for many sims - lengthen RTRIP delay to centre sync found
	JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN =    (RTRIP_DELAY_BASIC<<24)
										 | (RXPWRUP_DELAY_BASIC <<16)
										 | (TXPWRDN_DELAY_BASIC <<8)
										 |  TXPWRUP_DELAY_BASIC ;
#else
	JN518X_BLEMODEM->DP_AA_ERROR_CTRL_b.AA_ERROR_CNR_EN = 0;
	JN518X_BLEMODEM->FREQ_DOMAIN_CTRL1_b.RFAGC_TRACK_DLY = 0;
// RTRIP_DELAY +4 and RXPWRUP +4 to compensate rfagc_track_delay changed from 4 to 0
	//JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN_b.rw_ble_radiopwrupdn = 0x408D0F4D; // 21Nov: TXPWRUP now 84-27 (0x39) as G1 and G2 on
	JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN =    ((RTRIP_DELAY_BASIC+4)<<24)
										 | ((RXPWRUP_DELAY_BASIC+4) <<16)
										 | (TXPWRDN_DELAY_BASIC <<8)
										 |  TXPWRUP_DELAY_BASIC ;
#endif
	JN518X_RFPMODEM->tmu.comparator_pa_rampup.fields.comparator = 0; // remove a 1us delay before starting the ramp

	// speed up ramping (now moved to tmu_init as common setting for ZB and BLE)
	// SW Drv value  JN518X_RFPMODEM->pa_control.pa_ramp_cfg.fields.tx_pa_slice_incr_delay = 10; // (10+1)*62.5ns delay per ramp step    RFT1211 reduced ramp time
	//JN518X_RFPMODEM->pa_control.pa_ramp_cfg.fields.tx_pa_slice_incr_delay = 3; // (3+1)*62.5ns= 250ns delay per ramp step

	// allow burst_det to start 40us after enabling data path - this is length of preamble and access address - so potentially need a small bit more
	JN518X_RFPMODEM-> rx_datapath.rx_pwrup_cnt_th.fields.rx_pwrup_cnt_th1m =  40;
	JN518X_RFPMODEM-> rx_datapath.rx_pwrup_cnt_th.fields.rx_pwrup_cnt_th2m =  24;
	// Fabian 05/04/2018
	JN518X_RFPMODEM->pa_control.pa_ramp_cfg.fields.pa_slice_ramp_bypass_en = 0; // This line could be removed as forced value corresponds to default one at reset

#ifdef FAST_TX_BLE
	//vRadio_jn518x_EnableBLEFastTX(true);
#endif

#ifdef AA_ERROR_RECOVERY_PATCH
	JN518X_BLEMODEM->DP_AA_ERROR_CTRL_b.AA_ERROR_EN =  1;
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT1_SEL = DP_IRQ_SEL_CNT_AA_ERR_CTRL;
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT2_SEL = DP_IRQ_SEL_RX_FINISH;
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT1_MSK = 1;
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT2_MSK = 1;
	//GPIO_configure();
	NVIC_EnableIRQ(BLE_DP1_IRQn);
	NVIC_EnableIRQ(BLE_DP2_IRQn);
	NVIC_SetPriority(BLE_DP1_IRQn, 5);
	NVIC_SetPriority(BLE_DP2_IRQn, 5);
#endif
}

// Fabian's patch 30/03/18
void radio_jn518x_RX_BLE_1Mbs_Init_Patch()
{
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl2.fields.reinit_on_clip = 1;
	//def//JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.enable_lut=0;                    // AGC normal mode, not low-level mode.
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.compifaaf_det2=1;
	JN518X_RFPMODEM -> rx_datapath.agc_ctrl1.fields.compifaaf_det3=1;
	JN518X_RFPMODEM->rx_datapath.mute_ctrl1.fields.mn_ifamp_adc_mute_time = 4;   // Number of muted ADC samples following an
	                                                                                                                                                           // LNA & IFAMP gain change or change in mn_low_gain_setting
	JN518X_RFPMODEM->rx_datapath.mute_ctrl1.fields.mn_mute_enable=1;
}

// --------------------------------------------------------------------------
// TX and RX settings for BLE 1M regular scheme (1Mbps)
// --------------------------------------------------------------------------

void radio_jn518x_BLE_1Mbs_Init(void)
{
   vPrintf("(Tmp Fct:radio_jn518x_BLE_1Mbs_Init used !)\n");
   radio_jn518x_TX_BLE_1Mbs_Init();
   radio_jn518x_RX_BLE_1Mbs_Init();
   radio_jn518x_Patch_Ble();

   //   Note: changing mode for frequency control is now in radio_jn518x_Trx_Packet_SW_Ctrl_Init_Temp
   //   JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rf_carrier_freq_int_src = 0;  // 1 -> rf_carrier_freq_int  is sourced from regfile   0->  Not regfile
   //   JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rf_carrier_freq_frac_src = 0; // 1 -> rf_carrier_freq_frac is sourced from regfile   0 -> Not regfile

}

// --------------------------------------------------------------------------
// TX and RX settings for BLE 2M regular scheme (2Mbps)
// --------------------------------------------------------------------------

void radio_jn518x_BLE_2Mbs_Init(void)
{
   vPrintf("(Tmp Fct:radio_jn518x_BLE_2Mbs_Init used !)\n");
   radio_jn518x_TX_BLE_2Mbs_Init();
   radio_jn518x_RX_BLE_2Mbs_Init();
   radio_jn518x_Patch_Ble();

   //   Note: changing mode for frequency control is now in radio_jn518x_Trx_Packet_SW_Ctrl_Init_Temp
   //   JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rf_carrier_freq_int_src = 0;  // 1 -> rf_carrier_freq_int  is sourced from regfile   0->  Not regfile
   //   JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rf_carrier_freq_frac_src = 0; // 1 -> rf_carrier_freq_frac is sourced from regfile   0 -> Not regfile

}

// --------------------------------------------------------------------------
// Zigbee Init - call both the TX and RX functions
// --------------------------------------------------------------------------

void radio_jn518x_ZigBee_Regular_Init(void)
{
   vPrintf("(Tmp Fct:radio_jn518x_ZigBee_Regular_Init used !)\n");
   radio_jn518x_TX_ZigBee_Regular_Init();
   radio_jn518x_RX_ZigBee_Regular_Init();

   //   Note: changing mode for frequency control is now in radio_jn518x_Trx_Packet_SW_Ctrl_Init_Temp
   //   JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rf_carrier_freq_int_src = 0;  // 1 -> rf_carrier_freq_int  is sourced from regfile   0->  Not regfile
   //   JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rf_carrier_freq_frac_src = 0; // 1 -> rf_carrier_freq_frac is sourced from regfile   0 -> Not regfile

}


/****************************************************************************/
/***		Local functions: init and calibrations                        ***/
/****************************************************************************/

void radio_get_R_cal_results_from_flash(void)
{
	// TO BE COMPLETED
}



  //**************************************************************************************************
  // Common function that triggers  TMU to power off radio and polls until it finishes
  //**************************************************************************************************
  void radio_jn518x_power_down_to_off_polled(void)
  {
  //  vPrintf("PwrDn To Off");

    // Avoid interrupt is triggered when TMU is in power-down
    JN518X_RFPMODEM -> tmu.rfp_tmu_power_inten.fields.power_down_end = 0;           // Interrupt disabled for TMU in power-down

    // Clear the interrupt status bit
    JN518X_RFPMODEM->tmu.rfp_tmu_power_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_POWER_INTCLRSTAT_POWER_DOWN_END_POS);
    // Trigger the TMU down sequence
  //  vPrintf("Trigger the TMU power down sequence");
    JN518X_RFPMODEM->tmu.triggers.val = (0x1 << EXTAPB_REGFILE_TMU_TRIGGERS_POWER_DOWN_POS);

    // Interrupt poll loop
    //debugValue( 0x40);  //display value and write to register for trace window
    // Wait till the TMU power down sequence is reached
  //  vPrintf("Wait till the TMU power down is reached");
  //  vPrintf("Wait till G & PLL grp sigs are off");
    while(JN518X_RFPMODEM->tmu.rfp_tmu_power_intstat.fields.power_down_end == 0)
    {
       radio_waitNus(10); // Some dummy action
    }

    vPrintf("TMU power down is reached\n");

    // Clear the interrupt status bit
    JN518X_RFPMODEM->tmu.rfp_tmu_power_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_POWER_INTCLRSTAT_POWER_DOWN_END_POS);
    //reg_val= JN518X_RFPMODEM->tmu.rfp_tmu_power_intstat.val;
    //vPrintf(" rfp_tmu_power_intstat.val %x",reg_val);
    //reg_val= JN518X_RFPMODEM->tmu.rfp_tmu_intstat.val;
    //vPrintf(" rfp_tmu_intstat.val %x",reg_val);

  }

  //**************************************************************************************************
  // Trigger TMU to Enable G1, G2, PLL groups and poll until it finishes
  //**************************************************************************************************
  void radio_jn518x_pre_start_to_pll_polled(void)
  {
    // Avoid interrupt is triggered at the PLL state entering
    JN518X_RFPMODEM->tmu.rfp_tmu_inten.fields.pll_state_start = 0;
    //Clear interrupt
	JN518X_RFPMODEM->tmu.rfp_tmu_intclrstat.val = ~EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_PLL_STATE_START_MASK;
    // test
	JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = ~(EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTSTAT_KMOD_CHAN_CAL_DONE_MASK
														| EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTSTAT_SYNTH_CAL_OPERATION_DONE_MASK);
    // test

    // SW triggered pre-start. This will trigger the start of the global power sequence
    JN518X_RFPMODEM->tmu.triggers.val = (0x1 << EXTAPB_REGFILE_TMU_TRIGGERS_PRE_START_POS);  // call pre-start function to get to PLL group state
    vPrintf("SW trig pre-start\n");
    //JN518X_RFPMODEM->tmu.triggers.fields.pre_start = 1; // Register access to generate an equivalent rising edge of the phyon input signal.
    // Important note -> Stalling of CPU after JN518X_RFPMODEM->tmu.triggers_b.pre_start = 1; as lead to an error reported by the APB interface
    // Basically this register is a write-only register (so not readable) but when a field-based access is performed the CPU
    // implements this as a read-modify-write sequence.
    // At the moment the read is done, the op_wlc_apb_err coming out the modem_dual is being asserted.
    // But the ARM can hang completely on this.
    // To avoid this issue, the register must be written as a whole, so avoiding the field access.
    // JN518X_RFPMODEM->tmu.triggers.val = EXTAPB_REGFILE_TMU_TRIGGERS_PRE_START_MASK;

    // Wait till the entering PLL state interrupt status bit is asserted
    vPrintf("Wait till PLL state int stat bit asserted\n");
    while(JN518X_RFPMODEM->tmu.rfp_tmu_intstat.fields.pll_state_start == 0)
    {
       radio_waitNus(1); // Some dummy action
    }
    vPrintf("in PLL state\n");


    if (JN518X_RFPMODEM->tmu.mode_ctrl_2.fields.kmod_chan_cal_en )
    {
		while(JN518X_RFPMODEM->tmu.rfp_tmu_cal_intstat.fields.kmod_chan_cal_done == 0)
		{
		   radio_waitNus(1); // Some dummy action
		}
    }
    if (JN518X_RFPMODEM->tmu.mode_ctrl_2.fields.synth_cal_operation_en)
    {
		while(JN518X_RFPMODEM->tmu.rfp_tmu_cal_intstat.fields.synth_cal_operation_done == 0)
		{
		   radio_waitNus(1); // Some dummy action
		}
    }

    // Clear the interrupt status bit
    JN518X_RFPMODEM->tmu.rfp_tmu_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_INTCLRSTAT_PLL_STATE_START_POS);
    vPrintf("PLL state int stat cleared\n");
  }

  //**************************************************************************************************
  // Trigger TMU to Switch on transmit groups and poll until it finishes
  //**************************************************************************************************
  void radio_jn518x_tx_assert_polled(void)
  {
	vPrintf("Wait tx_assert_polled\n");
	JN518X_RFPMODEM->tmu.rfp_tmu_power_inten.fields.power_up_tx_end = 0;
	// Clear the interrupt status bit
	JN518X_RFPMODEM->tmu.rfp_tmu_power_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_POWER_INTCLRSTAT_POWER_UP_TX_END_POS);
	//trig TX power up
	JN518X_RFPMODEM->tmu.triggers.val = (0x1 << EXTAPB_REGFILE_TMU_TRIGGERS_POWER_UP_TX_POS);
	while(JN518X_RFPMODEM->tmu.rfp_tmu_power_intstat.fields.power_up_tx_end == 0)
	{
	   radio_waitNus(1); // Some dummy action
	}
	// Clear the interrupt status bit
	JN518X_RFPMODEM->tmu.rfp_tmu_power_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_POWER_INTCLRSTAT_POWER_UP_TX_END_POS);

  }

  //**************************************************************************************************
  // Trigger TMU to Switch on receive groups and poll until it finishes
  //**************************************************************************************************
  void radio_jn518x_rx_assert_polled(void)
  {
	// This function assumes that PLL and G1/ G2 groups are already on
	// Interrupt poll loop
	vPrintf("Wait rx_assert_polled\n");
	JN518X_RFPMODEM->tmu.rfp_tmu_power_inten.fields.power_up_rx_end = 0;
	// Clear the interrupt status bit
	JN518X_RFPMODEM->tmu.rfp_tmu_power_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_POWER_INTCLRSTAT_POWER_UP_RX_END_POS);
	//trig RX power up
	JN518X_RFPMODEM->tmu.triggers.val = (0x1 << EXTAPB_REGFILE_TMU_TRIGGERS_POWER_UP_RX_POS);
	while(JN518X_RFPMODEM->tmu.rfp_tmu_power_intstat.fields.power_up_rx_end == 0)
	{
	   radio_waitNus(1); // Some dummy action
	}
	// Clear the interrupt status bit
	JN518X_RFPMODEM->tmu.rfp_tmu_power_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_POWER_INTCLRSTAT_POWER_UP_RX_END_POS);
  }

  //**************************************************************************************************
  // Trigger TMU to Switch off receive groups and poll until it finishes
  //**************************************************************************************************
  void radio_jn518x_rx_deassert_polled(void)
  {
	// De-assert RX group signals
	//JN518X_RFPMODEM->tmu.rfp_tmu_power_inten.fields.power_down_rx_end = 1;
	JN518X_RFPMODEM->tmu.rfp_tmu_power_inten.fields.power_down_rx_end = 0;
	// Clear the interrupt status bit
	JN518X_RFPMODEM->tmu.rfp_tmu_power_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_POWER_INTCLRSTAT_POWER_DOWN_RX_END_POS);
	//trig RX power down
	JN518X_RFPMODEM->tmu.triggers.val = (0x1 << EXTAPB_REGFILE_TMU_TRIGGERS_POWER_DOWN_RX_POS);
	// poll loop
	vPrintf("Wait till RX group pwr dn int stat bit set\n");
	while(JN518X_RFPMODEM->tmu.rfp_tmu_power_intstat.fields.power_down_rx_end == 0)
	{
	   radio_waitNus(1); // Some dummy action
	}
	// Clear the interrupt status bit
	JN518X_RFPMODEM->tmu.rfp_tmu_power_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_POWER_INTCLRSTAT_POWER_DOWN_RX_END_POS);
  }

  //**************************************************************************************************
  // Trigger TMU to Switch off transmit groups and poll until it finishes
  //**************************************************************************************************
  void radio_jn518x_tx_deassert_polled(void)
  {
	// De-assert TX group signals
	//JN518X_RFPMODEM->tmu.rfp_tmu_power_inten.fields.power_down_tx_end = 1;
	JN518X_RFPMODEM->tmu.rfp_tmu_power_inten.fields.power_down_tx_end = 0;
	// Clear the interrupt status bit
	JN518X_RFPMODEM->tmu.rfp_tmu_power_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_POWER_INTCLRSTAT_POWER_DOWN_TX_END_POS);
	//JN518X_RFPMODEM->tmu.triggers_b.power_down_tx = 1;
	JN518X_RFPMODEM->tmu.triggers.val = (0x1 << EXTAPB_REGFILE_TMU_TRIGGERS_POWER_DOWN_TX_POS);

	// poll loop
	vPrintf("Wait till TX group pwr dn int stat bit set\n");
	while(JN518X_RFPMODEM->tmu.rfp_tmu_power_intstat.fields.power_down_tx_end == 0)
	{
	   radio_waitNus(1); // Some dummy action
	}
	// Clear the interrupt status bit
	JN518X_RFPMODEM->tmu.rfp_tmu_power_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_POWER_INTCLRSTAT_POWER_DOWN_TX_END_POS);
  }



  void radio_jn518x_Init(void)
  {
     // --------------------------------------------------------------------------
     // LDOs output voltage adjustment due to missing default settings at reset in RFP
     // --------------------------------------------------------------------------

		//RESET_PHYON

     vPrintf("(Tmp Fct:radio_jn518x_Init used !)\n");

  //   vPrintf("   LDOs output voltage adjustment ");

     // Synthesizer LDO
     JN518X_RFPMODEM -> transceiver.ldo_synth_d2r_if_val.fields.ibias_i_1v8_set  = 2; //2'b10; Adjust the biasing current

     // VCO LDO
     JN518X_RFPMODEM -> transceiver.ldo_vco_d2r_if_val.fields.ibias_i_1v8_set  = 2; //2'b10; Adjust the biasing current

     // LO LDO
     JN518X_RFPMODEM -> transceiver.ldo_lo_d2r_if_val.fields.ibias_i_1v8_set  = 2; //2'b10; Adjust the biasing current

     // IF LDO
     JN518X_RFPMODEM -> transceiver.ldo_if_d2r_if_val.fields.ibias_i_1v8_set  = 2; //2'b10; Adjust the biasing current

	u32TempReg = JN518X_RFPMODEM->transceiver.rx_ldo_d2r_if_val.val;
	u32TempReg &= ~(EXTAPB_REGFILE_TRANSCEIVER_RX_LDO_D2R_IF_VAL_RX_LDO_ADC_FBRES_SET_MASK
														 |EXTAPB_REGFILE_TRANSCEIVER_RX_LDO_D2R_IF_VAL_RX_LDO_1V2_VOUT_SET_MASK);
	 if (radio_jn518x_IsNotC2MF(NULL, NULL))
	 {
		 // RX LDO ADC settings for 0.95V
		 // Vout(ldo_adc) = 0.64 + 0.01*fbres
		 // OPTIM
		 //JN518X_RFPMODEM->transceiver.rx_ldo_d2r_if_val.fields.rx_ldo_adc_fbres_set = 31;
		 u32TempReg |= ((31 << EXTAPB_REGFILE_TRANSCEIVER_RX_LDO_D2R_IF_VAL_RX_LDO_ADC_FBRES_SET_POS)
				 	 	 	 	 	 	 	 	 	 	 	 	 |(5 << EXTAPB_REGFILE_TRANSCEIVER_RX_LDO_D2R_IF_VAL_RX_LDO_1V2_VOUT_SET_POS));

	 }
	 else
	 {
	     // RX LDO ADC settings for 0.96V
		 // Vout(ldo_adc) = 0.65185 + 0.0115*fbres
		 // OPTIM
	     //JN518X_RFPMODEM->transceiver.rx_ldo_d2r_if_val.fields.rx_ldo_adc_fbres_set = 26;
		 u32TempReg |= ((26 << EXTAPB_REGFILE_TRANSCEIVER_RX_LDO_D2R_IF_VAL_RX_LDO_ADC_FBRES_SET_POS)
				 	 	 	 	 	 	 	 	 	 	 	 	 |(5 << EXTAPB_REGFILE_TRANSCEIVER_RX_LDO_D2R_IF_VAL_RX_LDO_1V2_VOUT_SET_POS));
	 }
	JN518X_RFPMODEM->transceiver.rx_ldo_d2r_if_val.val = u32TempReg;

     // Rx LDO RF interface
	 // OPTIM
     //JN518X_RFPMODEM->transceiver.rx_ldo_d2r_if_val.fields.rx_ldo_1v2_vout_set = 5;  // LDO output voltage adjustment

     // Bist Tone PLL LDO
     // For CCO performance improvement then maximum output voltage is targeted, mean programming value equal to 31.
     // LDO output voltage is set according to equation hereafter
     // ES2: Vout(ldo_tone) = ref0v6 * [fbres*2+128]/120 =0.6*(31*2+128)/120=0.95V
     // ES2MF: Vout(ldo_tone) = ref0v6 * [fbres* 3,0475+132]/120
     // RF - 20170901 - Fix to allow simulation limitation due to `define vdda_ldoplltone_max (0.9+1u) setting
     // RF - 20170901 - into /home/smciot/work/rfcs_zble_es2/frq04773/Work/data/rfcs_zble_dig_lib/data/radio_top/BEHAVIOUR/wreal/set_globals.vams
     //     JN518X_RFPMODEM->transceiver.tone_pll_d2r_if_val.fields.tone_pll_ldo_fbres_set = 31;  // LDO output voltage adjustment // RF - 20170901
	 if (radio_jn518x_IsNotC2MF(NULL, NULL))
	 {
		 JN518X_RFPMODEM->transceiver.tone_pll_d2r_if_val.fields.tone_pll_ldo_fbres_set = 31;  // LDO output voltage adjustment
	 }
	 else
	 {
	     JN518X_RFPMODEM->transceiver.tone_pll_d2r_if_val.fields.tone_pll_ldo_fbres_set = 20;  // LDO output voltage adjustment
	 }

     // RF front-end (PA core unit and Transformer/LNA/Mixer) LDO output voltage adjustment

     // RF front-end LDO output voltage adjustment when TMU bypassed (regfile sourced)
     JN518X_RFPMODEM -> transceiver.ldo_rf_d2r_if_val.fields.core_vadj_i_1v8_set = 5;//3'b101;

     // RF front-end LDO output voltage adjustment in RX mode
     JN518X_RFPMODEM -> transceiver.ldo_rf_d2r_if_val.fields.core_vadj_i_1v8_set_rx = 5; // 1.1V output voltage

     // RF front-end LDO output voltage adjustment in TX mode
     JN518X_RFPMODEM -> transceiver.ldo_rf_d2r_if_val.fields.core_vadj_i_1v8_set_tx = u32CoreVadjI1v8SetTx; // 1.15V output voltage

     // RF front-end LDO biasing current adjustment
     JN518X_RFPMODEM -> transceiver.ldo_rf_d2r_if_val.fields.core_ibias_i_1v8_set = 3; // Adjust the biasing current

     // LDO PA
     JN518X_RFPMODEM -> transceiver.ldo_pa_d2r_if_val.fields.powerstage_ibias_i_1v8_set  = 3;                            //2'b11; Adjust the biasing current
     JN518X_RFPMODEM -> transceiver.ldo_pa_d2r_if_val.fields.powerstage_vadj_i_1v8_set   = u32PowerstageIbiasI1v8Set;

     // 1.0 ->
	// Radio LDO stabmode input forced to 0 for good PSSR s best radio performance
	// but at higher consumption expense
     JN518X_ASYSCON ->XTAL32MLDOCTRL_b.STABMODE= 0x0;
     JN518X_RFPMODEM -> transceiver.ldo_lo_d2r_if_val.fields.stabmode_i_1v8_set = 0x0;
     JN518X_RFPMODEM -> transceiver.ldo_if_d2r_if_val.fields.stabmode_i_1v8_set = 0x0;
     JN518X_RFPMODEM -> transceiver.ldo_synth_d2r_if_val.fields.stabmode_i_1v8_set = 0x0;
     JN518X_RFPMODEM -> transceiver.ldo_vco_d2r_if_val.fields.stabmode_i_1v8_set = 0x0;
     // <- 1.0




  //   vPrintf("   PA Duty Cycle adjustment ");

     // PA
     JN518X_RFPMODEM -> transceiver.pa_1_d2r_if_val.fields.pa_dcc_i_1v1_set        = u32PaDccI1v1Set;

     // ADC sampling time adjustment
     JN518X_RFPMODEM -> transceiver.adc_d2r_if_val.fields.rx_adc_samptime_set = 1; // ADC sampling time is long enough to guarantee gain thanks a
                                                                                   // complete sampling (1dB loss if value equal to 0),
                                                                                   // short enough to allow complete conversion process
  // RF - 20160930 -
     // Selection of the sampling edge for the data coming from the ADC
     // (comes from NxH's ADC retimming issue ticket (ULRF3096) study)
     JN518X_RFPMODEM ->rx_datapath.global.fields.adc_sample_edge = 1; // 1: falling_edge: ADC input is sampled by RFP at the falling edge of the Rx Datapath
                                                                      //    baseband clock. It will help to maximaze time left for the conversion.
                                                                      //    Tracking is started on the falling edge of the ADC clock.
  // RF - 20160930

  // RF - 20160930
    // Selection of the sampling edge for the data coming from the Transmitter digital data path
    JN518X_RFPMODEM -> tx_datapath.global.fields.dac_output_edge = 0; // Data is output towards DAC at the rising edge of the Tx Symbol clock
    JN518X_RFPMODEM -> tx_datapath.global.fields.pll_output_edge = 0; // Data is output towards PLL at the rising edge of the Tx Reference clock
  // RF - 20160930
    // -	RFP_SYNTH_CONTROL_CFG_OUTPUT_EDGE = 1 Modif Mathieu 20170929
    JN518X_RFPMODEM -> synth_control.cfg.fields.output_edge =1;

     // RX mixer biasing voltage adjutment
     JN518X_RFPMODEM -> transceiver.mixer_d2r_if_val.fields.mixer_vgadjust_i_1v1_set = 1;

    // pll charge pump offset current source sel correction - set this field to control from function
   JN518X_RFPMODEM -> transceiver.pll_cp_d2r_if_src_sel.fields.pll_cp_offcur_set = 1;   // source=not register, synthesizer calibration

  // TX output power tuning (becareful, overwriten by DCO & I/Q cal init -> to be removed from those calibration functions)
   JN518X_RFPMODEM -> transceiver.transfo_tx_d2r_if_val.fields.transfo_cap_filter_tune_i_1v1_set=0x7;
   JN518X_RFPMODEM -> transceiver.transfo_tx_d2r_if_val.fields.transfo_cap_prim_tune_i_1v1_set= 0x7;
   JN518X_RFPMODEM -> transceiver.transfo_tx_d2r_if_val.fields.transfo_cap_sec_tx_i_1v1_set= 0x3;

   // RX input match/gain tuning (becareful, overwriten by DCO & I/Q cal init -> to be removed from those calibration functions)
   JN518X_RFPMODEM -> transceiver.transfo_rx_d2r_if_val.fields.transfo_cap_filter_tune_i_1v1_set=0x0;
   JN518X_RFPMODEM -> transceiver.transfo_rx_d2r_if_val.fields.transfo_cap_prim_tune_i_1v1_set= 0x0;
   JN518X_RFPMODEM -> transceiver.transfo_rx_d2r_if_val.fields.transfo_cap_sec_tx_i_1v1_set= 0x0;

   //1.02 >>
   JN518X_RFPMODEM->rx_datapath.aaf_gain_delay.fields.aaf_gain_delay = 0;           // Delay in applying a gain setting change to the anti-aliasing filter.
   //JN518X_ZBMODEM->MRX_CTRL_b.rx_rssi_avg_en = 0;								// Reset value and in addition cannot been written before ZigBee clock has been activated

   // RSSI calibration
   radio_jn518x_RSSI_cal();

   //  wfield('RFP_RX_DP_LNA_GAIN_LUT0_LNA_GAIN_LUT',167)     #add michel  modif gain LNA  1db
     JN518X_RFPMODEM -> rx_datapath.lna_gain_lut0.fields.lna_gain_lut = 167;
   //  wfield('RFP_RX_DP_LNA_GAIN_LUT1_LNA_GAIN_LUT',219)     #add michel  modif gain LNA -0.25db
     JN518X_RFPMODEM -> rx_datapath.lna_gain_lut1.fields.lna_gain_lut = 219;
   //  wfield('RFP_RX_DP_LNA_GAIN_LUT2_LNA_GAIN_LUT',243)     #add michel  modif gain LNA -0.25db
     JN518X_RFPMODEM -> rx_datapath.lna_gain_lut2.fields.lna_gain_lut = 243;
   //  wfield('RFP_RX_DP_LNA_GAIN_LUT4_LNA_GAIN_LUT',58)     #add michel  modif gain LNA  -0.75db
     JN518X_RFPMODEM -> rx_datapath.lna_gain_lut4.fields.lna_gain_lut = 58;
   //  wfield('RFP_RX_DP_IFAMP_GAIN_LUT0_IFAMP_GAIN_LUT',5) #add michel  modif gain IFamp  -0.5db
     JN518X_RFPMODEM -> rx_datapath.ifamp_gain_lut0.fields.ifamp_gain_lut = 5;
   //  wfield('RFP_RX_DP_AAF_GAIN_LUT3_AAF_GAIN_LUT',37) #add michel  modif gain IFamp  -0.25db
     JN518X_RFPMODEM -> rx_datapath.aaf_gain_lut3.fields.aaf_gain_lut = 37;
   //  wfield('RFP_RX_DP_AAF_GAIN_LUT4_AAF_GAIN_LUT',47) #add michel  modif gain IFamp  -0.5db
     JN518X_RFPMODEM -> rx_datapath.aaf_gain_lut4.fields.aaf_gain_lut = 47;
   //  wfield('RFP_RX_DP_AAF_GAIN_LUT5_AAF_GAIN_LUT',59) #add michel  modif gain IFamp  -0.25db
     JN518X_RFPMODEM -> rx_datapath.aaf_gain_lut5.fields.aaf_gain_lut = 59;

   //<< 1.02

     // Set-up the digital to analog spare bits (static settings) // RF - 20170912

     // Coarse trimming of the VCO gain in analog domain (design update in progress - TO BE CONFIRMED) // RF - 20170912
     // Controlled by spare registers: dummy_d2r_1v1<6:5> -> ??<1:0> // RF - 20170912
     // 0x00: Nominal value (default) // RF - 20170912
     // 0x01: +30% // RF - 20170912
     // 0x11: -30% // RF - 20170912

     // Selection of the XO flag input triggering duty cycle range (ES2 change) // RF - 20170912
     // Controlled by spare registers: dummy_d2r_1v1<4:3> -> pll_xoflag_dcy_1v1_set<1:0> // RF - 20170912
     // For XO flag output rising edge : dcyset<1:0> = 0x01 (default): [0.25, 0.75] duty cycle range, // RF - 20170912
     // For XO flag output falling edge: dcyset<1:0> = 0x01 (default): [0.17, 0.83] duty cycle range, // RF - 20170912

     // DC-offset compensation DAC disabling (static force) // RF - 20170912
     // Controlled by spare registers: dummy_d2r_1v1<2> -> rx_dcoffset_dac_dis_1v1_set // RF - 20170912
     // 0: DC-offset compensation DAC enabled (default), 1: DC-offset compensation DAC disabled

     // Programmable Post Filter cut-off frequency :
     // Controlled by spare registers: dummy_d2r_1v1<1:0> -> pll_lf_rlf2_set_1v1_set<1:0> // RF - 20170912
     // Trade-Off Between PLL Phase Margin and Spurs ans SDM Noise Rejection // RF - 20170912
     // Allows to trimm the Rlf2 resistor value of this RC Low-pass filter (constant 4.81pF capacitor value) // RF - 20170912
     // Rlf2 = 21k + 21k * rlf2_set<0> + 42k * rlf2_set<1> with rlf2_set<1:0>=0 default // RF - 20170912

     // Effective update of the previously described spare bits // RF - 20170912
	 if (radio_jn518x_IsNotC2MF(NULL, NULL))
	 {
		//JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val = (0x0 << 5) | (0x1 << 3) | (0x0 << 2) | 0x0; // RF - 20170912
		JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val &= ~( EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_LF_RLF2_SET_1V1_SET_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_RX_DCOFFSET_DAC_DIS_1V1_SET_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_XOFLAG_DCY_1V1_SET_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_VCO_GAIN_ADJ_MASK);
		JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val |= (  (0x0 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_LF_RLF2_SET_1V1_SET_POS)
																		|(0x0 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_RX_DCOFFSET_DAC_DIS_1V1_SET_POS)
																		|(0x1 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_XOFLAG_DCY_1V1_SET_POS)
																		|(0x0 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_VCO_GAIN_ADJ_POS));
	 }
	 else
	 {
		//JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val = (0x6 << 8) | (0x0 << 5) | (0x1 << 3) | (0x0 << 2) | 0x0; // RF - 20170912
		// set also new bit RSSI_READY_IGNORE
		// reset bits G1/G2/PLL_GRP_FORCED
		JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val &= ~( EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_LF_RLF2_SET_1V1_SET_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_RX_DCOFFSET_DAC_DIS_1V1_SET_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_XOFLAG_DCY_1V1_SET_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_VCO_GAIN_ADJ_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PRE_CONST_LEN_TIE_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_LL_AGC_RSSI_READY_IGNORE_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_AD_DOUBLE_ZERO_DETECT_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_AD_TIMER_ONLY_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_G1_GRP_FORCED_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_G2_GRP_FORCED_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_GRP_FORCED_MASK);

		JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val |= (  (0x0 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_LF_RLF2_SET_1V1_SET_POS)
																		|(0x0 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_RX_DCOFFSET_DAC_DIS_1V1_SET_POS)
																		|(0x1 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_XOFLAG_DCY_1V1_SET_POS)
																		|(0x0 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_VCO_GAIN_ADJ_POS)
																		|(0x0 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PRE_CONST_LEN_TIE_POS)
																		|(0x1 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_LL_AGC_RSSI_READY_IGNORE_POS)
																		|(0x0 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_G1_GRP_FORCED_POS)
																		|(0x0 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_G2_GRP_FORCED_POS)
																		|(0x0 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_GRP_FORCED_POS));
	 }

     //RESTORE_PHYON
  }

  void radio_jn518x_RSSI_cal(void)
  {
	  int32_t i32RSSI_offset;
	  int32_t i32RSSI_Cal;
	  int32_t i32DeltaT;
	  int32_t i32OffsetCorT;

	   i32RSSI_Cal = *(uint32_t *)0x9FCD8;
	   if (i32RSSI_Cal & 0x1)
	   {
		   i32RSSI_Cal = (i32RSSI_Cal << 24) >> 25;  // sign extension (5.2) and remove VALID bit
		   i32RSSI_offset = -7 + i32RSSI_Cal;  // default value for lna_offset_gain_db is 121= 0x79 (7 bits signed) = -7
		   // apply correction based on current Temp
		   // correction is given by cor = -0.0255*deltaT+0.851
		   // as Temps are in 11.1, deltaT = i32DeltaT/2 so cor = -0.0255*i32DeltaT/2 + 0.851
		   // if we multiply by 2^17, we get (2^17)*cor = -1671*i32DeltaT + 111542
		   // so cor = (-1671*i32DeltaT + 111542) >> 17
		   // as RSSI_offset in given in fourth of db, we need to multiply this value by 4, that is shift left by 2
		   // so i32OffsetCorT = ((-1671*i32DeltaT + 111542) >> 17) << 2
		   i32DeltaT = (int32_t)(RadioConfiguration.i16TCur - RadioConfiguration.i16ATECalTemp);
		   i32OffsetCorT = ((-1671*i32DeltaT +111542) >> 15);
		   i32RSSI_offset += i32OffsetCorT;
		   RadioConfiguration.i32RSSI_offset = i32RSSI_offset;
		   if (i32RSSI_offset >63) i32RSSI_offset = 63;
		   if (i32RSSI_offset <-64) i32RSSI_offset = -64;
	   }
	   else
	   {
		   RadioConfiguration.i32RSSI_offset = -7;
		   i32RSSI_offset = RadioConfiguration.i32RSSI_offset;
	   }

	   JN518X_RFPMODEM->rx_datapath.lna_setting.fields.lna_offset_gain_db = i32RSSI_offset;
  }

  // ---------------------------------------------
  // TMU settings, signal group sequencing and power on/off
  // timing information for different analogue blocks
  // ---------------------------------------------

  void radio_jn518x_TMU_Init(void)
  {

     vPrintf("(Tmp Fct:radio_jn518x_TMU_Init used !)\n");

     // After pre-start (SW triggered, or triggered by ZB modem/BLE link layer)
     // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     // * At pre-start, G1 is immediately asserted

     // * G2 is asserted a configurable time after pre-start
     //   Time window between the assertion of the G1 group signals and G2 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_pre_g1.fields.comparator_pre = 40; // 20us

     // * PLL group signal is asserted a configurable time after pre-start
     //   Time window between the assertion of the G1 group signals and the start of the PLL phase. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre = 80; // 40us

     // After the TMU has reach the PLL state : generation of the packet start
     // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     // * Packet start (starting the digital Rx/Tx part) is asserted a configurable time after the TMU has entered the PLL state
     //   Time window between the start of the PLL phase and the generation of the internal packet start. (If enabled). Unit = 0.5 us
     // Time window between the start of the PLL phase and the generation of the internal packet start. (If enabled). Unit = 0.5 us
     // !!!! Please insure internal packet start is generated after the RX1/2/3 signals
     // Hence the digital receiver will be enabled only after the RX analog modules are enabled.
  // RF - 20160930 -   JN518X_RFPMODEM->tmu.comparator_packet_start.fields.comparator = 90; // 45us
     JN518X_RFPMODEM->tmu.comparator_packet_start.fields.comparator = 102; // 51us // RF - 20160930 -

     // After the TMU has reached the PLL state  : assertion of TX group signals
     // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     // * TX1 is asserted JN518X_RFPMODEM->tmu.comparator_pre_tx1.fields.comparator_pre * 0.5 us after entering the PLL state
     //   Time window between the start of the PLL phase and the assertion of the TX1 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_pre_tx1.fields.comparator_pre = 50; // 25us

     // * TX2 is asserted JN518X_RFPMODEM->tmu.comparator_pre_tx2.fields.comparator_pre * 0.5 us after entering the PLL state
     //   Time window between the start of the PLL phase and the assertion of the TX2 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_pre_tx2.fields.comparator_pre = 70; // 35us

     // * TX3 is asserted JN518X_RFPMODEM->tmu.comparator_pre_tx3.fields.comparator_pre * 0.5 us after entering the PLL state
     //   Time window between the start of the PLL phase and the assertion of the TX3 group signals. Unit = 0.5 us
  // RF - 20160930 -    JN518X_RFPMODEM->tmu.comparator_pre_tx3.fields.comparator_pre = 80; // 40us
     JN518X_RFPMODEM->tmu.comparator_pre_tx3.fields.comparator_pre = 100; // 50us // RF - 20160930 - Change from 40us to 50us to start PA ramping-up
                                                                                    // RF - 20160930 - when TX DAC is completely settled and PLL output
                                                                                    // RF - 20160930 - frequency is quite after TX DAC activation.

     // After the TMU has reached the PLL state  : assertion of RX group signals
     // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     // !!!!! Please note that current rx timings are just a copy of tx one. Later are mapped on actual analog block timing settling time

     // * RX1 is asserted JN518X_RFPMODEM->tmu.comparator_pre_rx1.fields.comparator_pre * 0.5 us after entering the PLL state
     //   Time window between the start of the PLL phase and the assertion of the RX1 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_pre_rx1.fields.comparator_pre = TMU_PRE_RX1_BASIC; // 25us

     // * RX2 is asserted JN518X_RFPMODEM->tmu.comparator_pre_rx2.fields.comparator_pre * 0.5 us after entering the PLL state
     //   Time window between the start of the PLL phase and the assertion of the RX2 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_pre_rx2.fields.comparator_pre = TMU_PRE_RX2_BASIC; // 35us

     // * RX3 is asserted JN518X_RFPMODEM->tmu.comparator_pre_rx3.fields.comparator_pre * 0.5 us after entering the PLL state
     //   Time window between the start of the PLL phase and the assertion of the RX3 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_pre_rx3.fields.comparator_pre = TMU_PRE_RX3_BASIC; // 40us

     // At end of the TX phase (SW triggered, or triggered by ZB modem/BLE link layer)
     // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     // TX closing time register
     // TX closing time: time in baseband clock cycles between TX datapath finished (EOP) and TX analog modules disable.
     JN518X_RFPMODEM->tmu.post_tx.fields.cnt = 5+16*10;

     // * TX3 is de-asserted a configurable time after end of the TX phase
     //   Time window between the end of the TX phase and the de-assertion of the TX3 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_post_tx3.fields.comparator_post = 10; // 6us    RFT1211

     // * TX2 is de-asserted a configurable time after end of the TX phase
     //   Time window between the end of the TX phase and the de-assertion of the TX2 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_post_tx2.fields.comparator_post = 12; // 7us    RFT1211

     // * TX1 is de-asserted a configurable time after end of the TX phase
     //   Time window between the end of the TX phase and the de-assertion of the TX1 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_post_tx1.fields.comparator_post = 14; // 8us    RFT1211

     // SMB - configure new setting for PLL post
     JN518X_RFPMODEM->tmu.comparator_post_pll.fields.comparator_post = 0; // 0us    RFT1211 NEW FIELD

     // RFT1211 - this setting could go with functions for TX configuration
     // speed up ramping
     //JN518X_RFPMODEM->pa_control.pa_ramp_cfg.fields.tx_pa_slice_incr_delay = 10; // (10+1)*62.5ns delay per ramp step    RFT1211 reduced ramp time
     JN518X_RFPMODEM->pa_control.pa_ramp_cfg.fields.tx_pa_slice_incr_delay = 3; // (3+1)*62.5ns= 250ns delay per ramp step

     // After the TMU has reached the PLL state  : de-assertion of PLL and G1/2 group signals
     // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     // Datapath is reseted a configurable time after the de-assertion of the PLL group signals
     // Time window between the start of the power down sequence and the assertion of the reset signal towards the datapath.
     JN518X_RFPMODEM->tmu.comparator_post_dp_reset.fields.comparator_post = 12;

     // * G2 is de-asserted a configurable time after end of the TX phase
     // Time window between the start of the power-down sequence and the de-assertion of the G2 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_post_g2.fields.comparator_post = 18; // 9us

      // * G1 is de-asserted a configurable time after end of the TX phase
     // Time window between the start of the power-down sequence and the de-assertion of the G1 group signals. Unit = 0.5 us
     JN518X_RFPMODEM->tmu.comparator_post_g1.fields.comparator_post = 20; // 10us

     // HW access to configuration banks
     // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     // HW access in RX mode.
     // This selects the bank which content is used for the RX datapath during an actual packet transfer.
     // The control of this "RX order" is configured JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rx_order_src in the following way:
     // * 1 (default value) : The RX bank is selected by JN518X_RFPMODEM->tmu.mode_ctrl.fields.rx_order
     // * 0 : The RX bank is selected by the source giving the "pre_start":
     //     i.	Pre-start is caused by a rising edge of the ZB PHYON : RX bank 0 is selected
     //     ii.	Pre-start is caused by a rising edge of BLE RX EN in 1 Mbps mode : RX bank 1 is selected
     //     iii.	Pre-start is caused by a rising edge of BLE RX EN in 2 Mbps mode : RX bank 2 is selected
     //     iv.	Pre-start is caused by SW writing a '1' to JN518X_RFPMODEM->tmu.triggers.fields.pre_start : RX bank is configured by JN518X_RPFMODEM->tmu.mode_ctrl.fields.rx_order
     JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rx_order_src = 0;

     // HW access in TX mode.
     // This selects the bank which content is used for the TX datapath during an actual packet transfer.
     // The control of this "TX order" is configured by JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.tx_order_src in the following way:
     // * 1 (default value) : The TX bank is selected by JN518X_RFPMODEM->tmu.mode_ctrl.fields.tx_order
     // * 0 : The TX bank is selected by the source giving the "pre_start":
     //     i.	Pre-start is caused by a rising edge of the ZB PHYON : TX bank 0 is selected
     //     ii.	Pre-start is caused by a rising edge of BLE TX EN in 1 Mbps mode : TX bank 1 is selected
     //     iii.	Pre-start is caused by a rising edge of BLE TX EN in 2 Mbps mode : TX bank 2 is selected
     //     iv.	Pre-start is caused by SW writing a '1' to JN518X_RFPMODEM->tmu.triggers.fields.pre_start : TX bank is configured by JN518X_RPFMODEM->tmu.mode_ctrl.fields.tx_order
     JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.tx_order_src = 0;

     // Note - in addition to these timings the ZB and BLE need to be configured to account for this delay as well

     // Relevant settings for ZB are: PHYTXTUNETIME. phytxtunetime  (see radio_jn518x_TX_ZigBee_Regular_Init)
     // Relevant settings for ZB are: PHYRXTUNETIME. phyrxtunetime  (see radio_jn518x_RX_ZigBee_Regular_Init)

  }


  void radio_jn518x_Use_Cal_Values(void)
  {

   uint32_t u32TmpVal;

	RESET_PHYON

vPrintf("(Tmp Fct:radio_jn518x_Use_Cal_Values used !)\n");

    // TRIMR
	u32TmpVal = *(uint32_t *)0x9FC88;
	if (u32TmpVal & 0x1)
	{
		u32TmpVal = (u32TmpVal >> 1) & 0x0000001f;
	}
	else
	{
		u32TmpVal = 32-TRIMR_INIT_VAL-1; // RF - 20170601
	}

    JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_val.fields.trimr_set = u32TmpVal;       // complemented R Calibration trim value
    JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_src_sel.fields.trimr_set = 0;                // source=register, not R calibration nominal value




    // TRIMC
	u32TmpVal = *(uint32_t *)0x9FD10;
	if (u32TmpVal & 0x1)
	{
		u32TmpVal = (u32TmpVal >> 1) & 0x00000007;
	}
	else
	{
		u32TmpVal = TRIMC_INIT_VAL; // RF - 20170601
	}

    JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_val.fields.trimc_set = u32TmpVal;       // RC calibration trim value
    JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_src_sel.fields.trimc_set = 0;                // source=register, not C calibration nominal

    JN518X_RFPMODEM->calibration.kmod_band_cal_count_1_msb.fields.count_1_msb =(KMOD_BAND_CAL_COUNT_1_MSB_REG_INIT_VAL);
    JN518X_RFPMODEM->calibration.kmod_band_cal_count_1_lsb.fields.count_1_lsb =(KMOD_BAND_CAL_COUNT_1_LSB_REG_INIT_VAL);
    JN518X_RFPMODEM->calibration.kmod_band_cal_count_2_msb.fields.count_2_msb =(KMOD_BAND_CAL_COUNT_2_MSB_REG_INIT_VAL);
    JN518X_RFPMODEM->calibration.kmod_band_cal_count_2_lsb.fields.count_2_lsb =(KMOD_BAND_CAL_COUNT_2_LSB_REG_INIT_VAL);
    JN518X_RFPMODEM->calibration.kmod_band_cal_corr_1.fields.corr_1 =(KMOD_BAND_CAL_CORR_1_REG_INIT_VAL); // Please note that this line as no effect on corr_1 setting at transceiver level.
    JN518X_RFPMODEM->tx_datapath.kmod_band_corr_1.fields.corr_1 = (KMOD_BAND_CAL_CORR_1_REG_INIT_VAL);
    JN518X_RFPMODEM->tx_datapath.global.fields.kmod_band_corr_1_upd_on_cal_en = 0; // Result of the KMod band calibration is NOT copied automatically to the KMod band correction factor of the Tx datapath.

    JN518X_RFPMODEM->calibration.synth_cal_startup_aac_ictrl_out_store.fields.aac_ictrl_out_store =(SYNTH_CAL_STARTUP_AAC_ICTRL_OUT_STORE_INIT_VAL);
    JN518X_RFPMODEM->calibration.synth_cal_startup_afc_2_rx.fields.afc_2 =(SYNTH_CAL_STARTUP_AFC_2_RX_INIT_VAL);
    JN518X_RFPMODEM->calibration.synth_cal_startup_afc_2_tx.fields.afc_2 =(SYNTH_CAL_STARTUP_AFC_2_TX_INIT_VAL);
    JN518X_RFPMODEM->calibration.synth_cal_startup_afc_diff_rx.fields.afc_diff =(SYNTH_CAL_STARTUP_AFC_DIFF_RX_INIT_VAL);
    JN518X_RFPMODEM->calibration.synth_cal_startup_afc_diff_tx.fields.afc_diff =(SYNTH_CAL_STARTUP_AFC_DIFF_TX_INIT_VAL);

    // RF bandgap
    // Cal value is held in JN518X_RFPMODEM->rf_bgr_cal.iref.fields.iref;  // this is the location of the cal result - but it is read only
    // To restore a cal value need to write to register below and have source select 0
    JN518X_RFPMODEM->transceiver.bgr_d2r_if_val.fields.rx_bgr_cur5ua_1v8_set =(RF_BGP_CUR5UA_INIT_VAL);
    JN518X_RFPMODEM->transceiver.bgr_d2r_if_src_sel.fields.rx_bgr_cur5ua_1v8_set = 0; //0=register NOT function

    RESTORE_PHYON

    return;

  }

// SMB 14/06/2017

  void radio_jn518x_Use_Retained_Cal_Values(void)
  {

                RESET_PHYON

    vPrintf("(Tmp Fct:radio_jn518x_Use_Retained_Cal_Values used !)\n");

    // TRIMR
    JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_src_sel.fields.trimr_set = 0;                // source=register, not R calibration nominal value

    // TRIMC
    JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_src_sel.fields.trimc_set = 0;                // source=register, not C calibration nominal value

  /*
  TODO: Update when DCO, IQ cal, PA cal is updated in main Use_Cal_Val function
  */

    // RF bandgap
    JN518X_RFPMODEM->transceiver.bgr_d2r_if_src_sel.fields.rx_bgr_cur5ua_1v8_set = 0; //0=register NOT function

    RESTORE_PHYON

    return;

  }





  int radio_jn518x_rfbandgap_cal(uint32_t u32CalMode) //SMB 13/06
  {
    int ret_code = 0;

    uint32_t u32BandGapCalValue;
	/* always read current calibration from flash*/
	u32BandGapCalValue = *(uint32_t *)0x9fc88;

    JN518X_RFPMODEM->transceiver.bgr_d2r_if_val.fields.rx_bgr_cur5ua_1v8_set =((u32BandGapCalValue>>14) & 0x1f);
    JN518X_RFPMODEM->transceiver.bgr_d2r_if_src_sel.fields.rx_bgr_cur5ua_1v8_set = 0; //0=register NOT function
	return (ret_code);
  }



  // --------------------------------------------------------------------------
  // RC calibration set-up
  // - LDO IF supply activated for RC calibration proper operation,
  // - Set RC calibration discharge delay time
  // - Select RC calibration threshold time
  // --------------------------------------------------------------------------

  void radio_jn518x_Rc_Cal_init(void)
  {
  //   vPrintf("   RC calibration set-up");

		//RESET_PHYON

     // Source selection for rx_rccal_enable
     JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_src_sel.fields.rx_rccal_enable = 1; // source = not register, TMU

     // Source selection for rx_rccal_trig
     JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_src_sel.fields.rx_rccal_trig = 1; // source = not register, TMU

     // Source selection for rx_trimc_set
     JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_src_sel.fields.trimc_set = 1; // source = not register, TMU

     // LDO_IF interface: manual enabling
     JN518X_RFPMODEM -> transceiver.ldo_if_d2r_if_val.fields.enable_1v8 = 1; // LDO IF activation forced
                                                                 // !!!!!! To be clarified why not automatically activated
                                                                 // during RC calibration.

     // LDO_IF interface: source selection
     JN518X_RFPMODEM -> transceiver.ldo_if_d2r_if_src_sel.fields.enable_1v8 = 0; // source=register, not TMU

     // Wait for LDO_IF output voltage settling time
     radio_waitNus(10); // 10us Wait for IF LDO output voltage settling time after ldo_if_enable signal assertion.

     // RC calibration discharge delay time above 46 us (expressed in us)
     JN518X_RFPMODEM -> calibration.rc_cal_discharge_period.fields.discharge_period = 0; // No extra wait state on top of the 46us

     // RC calibration delay (expressed in 16 MHz clock cycles) used to let the analog settle after an update of the trimc_set value.
     JN518X_RFPMODEM -> calibration.rc_cal_transient_period.fields.transient_period = 320; // 20us wait state (default value)

     // RC calibration threshold time expressed in 16 MHz clock cycles.
     // res_trim_r = 1.36M  + 34k * (2**5-1) - trimr_set;
     // cap_trim_r = Cpar_cmp + 22*250f + 250f * trimc_set;
     // Charge time = - res_trim_r * cap_trim_r * (1-ln(6/10)
     JN518X_RFPMODEM -> calibration.rc_cal_treshold_period.fields.treshold_period = 186; // Value for nominal settings trimr=19, trimc=3

     //RESTORE_PHYON
  }

  // -----------------------------------------
  // Run RC calibration
  // - Avoid interrupt is triggered at the end of the RC calibration
  // - Trigger the RC calibration
  // - Wait till the RC calibration interrupt status bit is asserted
  // - Release LDO IF supply activation.
  // -----------------------------------------

  void radio_jn518x_Rc_Cal_algo(void)
  {
		//RESET_PHYON

     // Avoid interrupt is triggered at the end of the RC calibration
     JN518X_RFPMODEM -> tmu.rfp_tmu_cal_inten.fields.rc_cal_done = 0;
	 // Clear the interrupt status bit
	 JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_RC_CAL_DONE_POS);

      // Trigger the RC calibration
      // JN518X_RFPMODEM->tmu.cal_triggers.field.rc_cal_en = 1;;     // Trigger the RC calibration
      vPrintf("Trigger the RC calibration\n");
      JN518X_RFPMODEM->tmu.cal_triggers.val = (0x1 << EXTAPB_REGFILE_TMU_CAL_TRIGGERS_RC_CAL_EN_POS);
      // Wait till the RC calibration interrupt status bit is asserted
      //  vPrintf("Wait till the RC calibration interrupt status bit is asserted");
      while(JN518X_RFPMODEM->tmu.rfp_tmu_cal_intstat.fields.rc_cal_done == 0)
      {
         radio_waitNus(10); // Some dummy action
      }

      vPrintf("RC calibration is finished\n");

      // Clear the interrupt status bit
      JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_RC_CAL_DONE_POS);
      //  vPrintf("RC calibration done interrupt status bit cleared");

     // LDO_IF interface: source selection
     JN518X_RFPMODEM -> transceiver.ldo_if_d2r_if_src_sel.fields.enable_1v8 = 1; // source=not register, TMU


     //RESTORE_PHYON
  }


  // --------------------------------------------------------------------------
  // RC calibrations main routine
  // --------------------------------------------------------------------------

  void radio_jn518x_Rc_Cal(bool bDoCal)
  {
     // --------------------------------------------------------------------------
     // RC calibration
     // --------------------------------------------------------------------------

  //   vPrintf("   RC calibration set-up");

     if (bDoCal) // Do calibration
     {
		 // RC calibration set-up
		 // - LDO IF supply activated for RC calibration proper operation,
		 // - Set RC calibration discharge delay time
		 // - Select RC calibration threshold time
		 radio_jn518x_Rc_Cal_init();

		 // Trigger the RC calibration
		 // Wait till the RC calibration interrupt status bit is asserted
		 radio_jn518x_Rc_Cal_algo();

     }
     else
     {
		 vPrintf("   NOT DOING R & RC calibration\n");
		 // Nothing else to do here

     }
  }

  void radio_jn518x_Carrier_Frequency_Select_by_index(uint8_t index)
  {
	    // Selects the rf carrier frequency source
	    // By setting the 2 bits mentioned bellow, the RFP is forced to ignore those values provided by the ZB and
	    // BLE modem, and use the SW configured value instead
	    JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rf_carrier_freq_int_src = 1;  // 1 -> rf_carrier_freq_int  is sourced from regfile
	    JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rf_carrier_freq_frac_src = 1; // 1 -> rf_carrier_freq_frac is sourced from regfile
	    // Integer part of the RF carrier frequency
	     JN518X_RFPMODEM -> tmu.rf_carrier_freq_int.fields.rf_carrier_freq_int = freq_prog[index][0]; // Integer part of the ISM band middle frequency.
	    // Fractional part of the RF carrier frequency
	    JN518X_RFPMODEM -> tmu.rf_carrier_freq_frac.fields.rf_carrier_freq_frac = freq_prog[index][1] ; // Fractional part of the ISM band middle frequency.
	    if ((index != CFS_BLE_1MB) && (index != CFS_BLE_2MB)) JN518X_ZBMODEM -> RXFE_CONFIG_b.selfi = freq_prog[index][2];
	    JN518X_RFPMODEM -> rx_datapath.if_freq_norm.fields.if_freq_norm = freq_prog[index][3];
	    JN518X_RFPMODEM -> rx_datapath.if_freq_norm.fields.if_freq_norm_extended = freq_prog[index][4];
	    // Side injection selection
	    JN518X_RFPMODEM -> calibration.synth_cal_cfg.fields.high_side_injection = 0; // For Rx mode, selects between
  }


  // -----------------------------------------
  // This function initializes synthesizer path (synthesizer 2nd modulated point scaling + SDM part)
  // for fracN PLL CW mode
  // -----------------------------------------

  void radio_jn518x_Synthesizer_Cw_Mode_Init(void)
  {
  //  vPrintf("Disable CW mode for digital synthesizer and allows feedback path modulation");
    JN518X_RFPMODEM->synth_control.cfg.fields.cw_mode = 0;                               // Configures the CW mode for the synthesizer: 1-> Value = 0 is taken as input.

    // Disable influence of PLL locking sequence to synthesizer reset
    JN518X_RFPMODEM->tmu.reset_mask.fields.synth_reset_pll_lock_dis = 1;                 // When 0, the synth_reset is enabled till the PLL lockin sequence is started
  }


  // -----------------------------------------
  // This function initializes TMU for TX/RX packet transmission under SW control
  // - Packet start is generated internally based on a SW control,
  // - Disable internal generation of packet start (after pre_start),
  // - Disable automatic assertion of the RX/TX group signals,
  // - At pre-start SW assertion then TMU must simply stay in PLL phase, and not start any RX or TX transfer
  // - SW will choose itself later on which part (Rx/Tx) it will power-up/power-down.
  // - set frequency control to come from modem
  // -----------------------------------------

  void radio_jn518x_Trx_Packet_SW_Ctrl_Init(void)
  {
    // Disable internal generation of packet start (after pre_start). TMU must simply
    // stay in PLL phase, and not start any RX or TX transfer
    JN518X_RFPMODEM->tmu.mode_ctrl.fields.packet_start_mode = 0; // packet_start_external: The externally generated packet start is generated.
                                                                 // To be clarified !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // Disable automatic assertion of the RX/TX group signals. SW will chose itself
    // later on which part (Rx/Tx) it will power-up/power-down.
    JN518X_RFPMODEM->tmu.mode_ctrl_2.fields.trx_powerup_en = 0; // Specifies whether the TMU initiates the power up for the selected mode during the PLL phase.
                                                                // 0 -> dis: The powerup of the selected mode is under SW control. (Not handled by TMU HW)

    // Remark :
    // SW power up TX : JN518X_RFPMODEM->tmu.triggers.fields.power_up_tx = 1;
    // SW power down TX : JN518X_RFPMODEM->tmu.triggers.fields.power_down_tx = 1;
    // SW power up RX : JN518X_RFPMODEM->tmu.triggers.fields.power_up_rx = 1;
    // SW power down RX : JN518X_RFPMODEM->tmu.triggers.fields.power_down_rx = 1;
  }


  void radio_jn518x_Disable_Auto_Kmod_Chan_and_Synth_Cal_Operation(void)
  {
	    // Disable automatic kmod_chan_cal and synth_cal_operation for synthe full cal called from recal
	    JN518X_RFPMODEM->tmu.mode_ctrl_2.fields.kmod_chan_cal_en = 0;
		JN518X_RFPMODEM->tmu.mode_ctrl_2.fields.synth_cal_operation_en = 0;
  }

  // -----------------------------------------
  // Pre-initialisation for synthesizer calibration for startup
  // - Pll calibration divider (located within the analog part) setting
  // - Settings applicable for the AAFC
  // - Vtune voltage precharge settings
  // - VCO current forcing as AAC isn't used and would force curset_set=0 due to initial VCO calibration reset
  // -----------------------------------------

  void radio_jn518x_Synthesizer_Cal_Startup_init(void)
  {

		RESET_PHYON

    // Some configuration for the VCO to let the synth cal startup calibration work

    // Pll calibration divider (located within the analog part) setting
	//  vPrintf("Pll calibration divider (located within the analog part) setting");
	// see patch 1.01 later in the function
    JN518X_RFPMODEM->calibration.synth_cal_pll_cal_div_set.fields.pll_cal_div_set = 0x2;   // Pll cal divset -> Divided Fvco = [ 2.4GHz + (16MHz/11) ] / 2 / 4 = 300.1818MHz

    // Settings applicable for the AFC
  //  vPrintf("Settings applicable for the AFC");
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_fref_sel = 0x6; // Divider ratio N_afc. Divide-by-2(0), 4(1), 8(2), 16(3), 32(4), 64(5), 128(6), 256(7).
                                                                        // Frequency measurement Fref_afc=Fxo/N_afc
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg0.fields.afc_mdes = 0x12c;   // Desired counter value M_afc=Fvco_div/Fref_afc (0-4095).
                                                                        // (Fvco_div=Fvco/8 or Fvco/12 by means of fixed divider).
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_ki = 6;         // Frequency gain integrator ki_f=0.5(7), 0.25(6), 0.125(5), 0.0625(4), 1/32(3)...etc
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg2.fields.afc_fsel_init = 0x80; // Initial value for fsel (value on capacitor bank) during manual mode.
                                                                          // Without using the manual mode, the initial value for afc_fsel_out = 128.
                                                                          // 0 = maximum VCO frequency, 255 = minimum VCO frequency.
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg2.fields.afc_fsel_min = 0x20;  // Minimal value for fsel (value on capacitor bank)
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_lock_ctrl1 = 0x2; // Lock criterium AFC loop 1
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_lock_ctrl2 = 0x7; // Lock criterium AFC loop 2

    // Settings applicable for the AAC
  //  vPrintf("Settings applicable for the AAC");
    JN518X_RFPMODEM->calibration.vco_cal_aac_cfg0.fields.aac_ades_in = 7;   // Desired amplitude setting. Desired amplitude setting also depends on aac_iref_ctrl_in
    JN518X_RFPMODEM->calibration.vco_cal_aac_cfg0.fields.aac_ki = 7;        // Amplitude gain integrator ki_a
    JN518X_RFPMODEM->calibration.vco_cal_aac_cfg0.fields.aac_lock_ctrl = 7; // Lock criterion
    JN518X_RFPMODEM->calibration.vco_cal_aac_cfg0.fields.aac_manual = 1;    // Manual control AAC (= disabled). Set amplitude loop in manual mode ( make aac_ictrl_out = aac_ictrl_init).
                                                                            // The time needed to make aac_ictrl_out = aac_ictrl_init is equal to: 5/Fxo~0.19us.

    // Settings applicable for the out-of-range DET(ection)
  //  vPrintf("Settings applicable for the DET");
    // VCO calibration frequency meter reset not anymore usefull as done automatically now by VCO calibration engine.
    //JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_val.fields.pll_cal_ip_vco_rst_set = 1; // Reset the out-of-range counter (VCO calibration part located in analog part).
                                                                                       // Without this reset then the "op_det_toggle" signal state is undefined and
                                                                                       // the VCO-clock looks out-of-range (reg_det_out_of_range_i stuck at '1').
                                                                                       // As an unexpected result the synthesizer calibration is blocked.
                                                                                       // Indeed the complete AAFC loop will be in lock when AFC is locked,
                                                                                       // AAC is locked and if the VCO-clock is not out-of-range.
    //JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_val.fields.pll_cal_ip_vco_rst_set = 0; // Disassert reset of the out-of-range counter to allow possibly VCO-clock not
                                                                                       // out-of-range (reg_det_out_of_range_i stuck at '0').
    JN518X_RFPMODEM -> calibration.vco_cal_det_cfg0.fields.det_kmin = 0x8b;            // Minimum counter value kmin -> Out-of-range as soon Flo<2232 MHz
    JN518X_RFPMODEM -> calibration.vco_cal_det_cfg0.fields.det_kmin_runin = 0x7d;      // Minimum counter value during VCO run-in period kmin_runin
                                                                                       // -> Start with calibrating (det_run_in=1) as soon Flo>2000 MHz

    // Vtune voltage precharge
  //  vPrintf("Vtune voltage precharge");
    JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_n = 0x7;      // Precharge settings before cal. measurement (before the AAC start). 0x0 : disabled. Xxx : enable resistor from ground to Vtune.
    JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_p = 0x7;      // Precharge settings before cal. measurement (before the AAC start). 0x0 : disabled. Xxx : enable resistor from supply to Vtune.
    JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_n_hold = 0x3; // Precharge settings during cal. measurement (till the AFC2 is finished). 0x0 : disabled. Xxx : enable resistor from ground to Vtune.
    JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_p_hold = 0x3; // Precharge settings during cal. measurement (till the AFC2 is finished). 0x0 : disabled. Xxx : enable resistor from supply to Vtune.
    JN518X_RFPMODEM -> transceiver.pll_lf_d2r_if_src_sel.fields.pll_lf_pch_n_set = 1;         // Precharge sourced from calibration
    JN518X_RFPMODEM -> transceiver.pll_lf_d2r_if_src_sel.fields.pll_lf_pch_p_set = 1;         // Precharge sourced from calibration
    JN518X_RFPMODEM->tmu.synth_cal_cfg.fields.pll_vtune_hold_en = 1;                             // When set to 1, prolonge the "hold" value of the vtune settings till the vco coarse calibration is completely finished

  //  JN518X_RFPMODEM -> transceiver.pll_lf_d2r_if_val.fields.pll_lf_pch_n_set = 0x6;         // Forced precharge settings. 0x0 : disabled. Xxx : enable resistor from ground to Vtune.
  //  JN518X_RFPMODEM -> transceiver.pll_lf_d2r_if_val.fields.pll_lf_pch_p_set = 0x4;         // Forced precharge settings. 0x0 : disabled. Xxx : enable resistor from supply to Vtune.
  //  JN518X_RFPMODEM -> transceiver.pll_lf_d2r_if_src_sel.fields.pll_lf_pch_n_set = 0;       // Precharge sourced from register
  //  JN518X_RFPMODEM -> transceiver.pll_lf_d2r_if_src_sel.fields.pll_lf_pch_p_set = 0;       // Precharge sourced from register

    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_skip_loop1 = 1;                // When set to 1, the second AFC loop is skipped
                                                                                            // By default 2 AFC runs are executed (with an AAC in between).
                                                                                            // Setting afc_skip_loop1 = 1; skips this first AFC run.
                                                                                            // The second one will be kept. If you don't want to run any AFC
                                                                                            // run at all the afc_manual must be set to 1.

    JN518X_RFPMODEM->tmu.synth_cal_cfg.fields.pll_vco_ff_amp_cor = 1;                       // When 1, the feedforward amplitude correction is enabled.
                                                                                            // In the original architecture for the synthesizer architecture,
                                                                                            // the pll_vco_ff_amp_cor = 1 selected the AAC/AFC1/AFC2 path.
                                                                                            // When pll_vco_ff_amp_cor = 0 selected the AAFC1/AAFC2 path
                                                                                            // Check if still relevant in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // 1.0/1.01 ->
    // Set PLL_VCO_BOOST
//    JN518X_RFPMODEM->transceiver.pll_vco_boost_d2r_if_val.fields.pll_vco_boost_en_rx  = 2; // RF - 20170907
//    JN518X_RFPMODEM->transceiver.pll_vco_boost_d2r_if_val.fields.pll_vco_boost_en_tx  = 3; // RF - 20170907
//    JN518X_RFPMODEM->transceiver.pll_vco_boost_d2r_if_val.fields.pll_vco_boost_set  = 3; // RF - 20170907
    // <- 1.0/1.01

    // Synthesizer calibration setting

    //>patch 1.01/1.02
    JN518X_RFPMODEM->calibration.synth_cal_startup_ratio_bin_thermo.fields.ratio_bin_thermo = 14; // Amount of thermometer capacitors in the range of 1 binary bank capacitor
                                                                                             // Check value in JN518x !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //<patch 1.01/1.02

    //>patch 1.01
    // VCO calibration integrator gain
    //wfield('RFP_CALIBRATION_VCO_CAL_AFC_CFG1_AFC_KI',0x5)
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_ki = 0x5;

	// VCO calibration frequencies use for VCO calibration (0_> 2416 +2480 MHz/ 1 -> 2432+2464MHz)
	//wfield('RFP_CALIBRATION_SYNTH_CAL_CFG_FCW_SEL',0x0)
    JN518X_RFPMODEM->calibration.synth_cal_cfg.fields.fcw_sel = 0x0;

	// VCO calibration reference time window
	//wfield('RFP_CALIBRATION_VCO_CAL_AFC_CFG1_AFC_FREF_SEL',0x5)
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_fref_sel = 0x5;

	// VCO calibration vco/4 clock divider (set 2 for 600 MHz output/4 for 300MHz output)
	//wfield('RFP_CALIBRATION_SYNTH_CAL_PLL_CAL_DIV_SET_PLL_CAL_DIV_SET',0x2)
    // replaced value of above write operation (at the beginning of the function)
    //JN518X_RFPMODEM->calibration.synth_cal_pll_cal_div_set.fields.pll_cal_div_set = 0x2;

	// VCO calibration afc skip loop1
	//wfield('RFP_CALIBRATION_VCO_CAL_AFC_CFG1_AFC_SKIP_LOOP1',0x1)
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_skip_loop1 = 0x1;

	// VCO calibration lock criteria for afc loop2
	//wfield('RFP_CALIBRATION_VCO_CAL_AFC_CFG1_AFC_LOCK_CTRL2',0x0)
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_lock_ctrl2 = 0x0;

	// VCO calibration vtune precharge during cal(480 mV)
	//wfield('RFP_CALIBRATION_SYNTH_CAL_PRE_CHARGE_PLL_LF_PCH_PLL_LF_PCH_N_HOLD',0x5)
	//wfield('RFP_CALIBRATION_SYNTH_CAL_PRE_CHARGE_PLL_LF_PCH_PLL_LF_PCH_P_HOLD',0x7)
    JN518X_RFPMODEM->calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_n_hold = 0x5;
    JN518X_RFPMODEM->calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_p_hold = 0x7;
    //<patch 1.01

    //>patch 1.02
    // VCO current forcing as AAC isn't used and would force curset_set=0 due to initial VCO calibration reset
     JN518X_RFPMODEM -> transceiver.pll_vco_curset_d2r_if_src_sel.fields.pll_vco_curset_set = 0;  // source=register, not synthesizer calibration // RF - 20160805
     JN518X_RFPMODEM -> transceiver.pll_vco_curset_d2r_if_src_sel.fields.pll_vco_curset_rx = 0;   // source=register, not synthesizer calibration
     JN518X_RFPMODEM -> transceiver.pll_vco_curset_d2r_if_src_sel.fields.pll_vco_curset_tx = 0;   // source=register, not synthesizer calibration
     JN518X_RFPMODEM -> transceiver.pll_vco_curset_d2r_if_val.fields.pll_vco_curset_set = 31;     // 5'bxxxxx; xxx uA default VCO current settings // RF - 20160805
     JN518X_RFPMODEM -> transceiver.pll_vco_curset_d2r_if_val.fields.pll_vco_curset_tx = 31;      // 5'bxxxxx; xxx uA default VCO current settings
     JN518X_RFPMODEM -> transceiver.pll_vco_curset_d2r_if_val.fields.pll_vco_curset_rx = 31;      // 5'bxxxxx; xxx uA default VCO current settings

     JN518X_RFPMODEM -> transceiver.pll_vco_boost_d2r_if_src_sel.fields.pll_vco_boost_set = 0;    // source=register, not TMU
     JN518X_RFPMODEM -> transceiver.pll_vco_boost_d2r_if_val.fields.pll_vco_boost_set = 3;        // Boost VCO tail current
     JN518X_RFPMODEM -> transceiver.pll_vco_boost_d2r_if_val.fields.pll_vco_boost_en_tx = 3;      // Boost VCO tail current
     JN518X_RFPMODEM -> transceiver.pll_vco_boost_d2r_if_val.fields.pll_vco_boost_en_rx = 2;      // Boost VCO tail current

     JN518X_RFPMODEM -> transceiver.pll_vco_0_d2r_if_val.fields.pll_vco_vtail_enable = 1;         // Enable VCO tail resistor, set to 1 in order to cancel out an AM modulation around 25 to 40MHz

     JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_period.fields.pre_charge_period = 96; // 6us pre_charge period
     //<patch 1.02


     RESTORE_PHYON
  }

  // -----------------------------------------
  // Run synthesizer calibration for startup
  // - Avoid interrupt is triggered at the end of the synthesizer calibration for startup
  // - SW enabling of PLL calibration counter in order to activate its supply before to reset it
  // - Trigger the synthesizer calibration for startup (done in "RX" by default)
  // - Wait till the synthesizer calibration interrupt status bit is asserted
  // - Release of the SW enabling of PLL calibration counter used to activate its supply before to reset it.
  // - Copy the "RX" results to "TX"
  // -----------------------------------------

  void radio_jn518x_Synthesizer_Cal_Startup_algo(void)
  {
    // Removal of possible VCO capacitor bank forcing
    // JN518X_RFPMODEM -> transceiver.pll_vco_0_d2r_if_src_sel.fields.pll_vco_fctrl_bin_set   = 1; // source=not register, synthesizer calibration
    // JN518X_RFPMODEM -> transceiver.pll_vco_1_d2r_if_src_sel.fields.pll_vco_fctrl_therm_set = 1; // source=not register, synthesizer calibration

		RESET_PHYON

	       //radio_waitNus(1);
    // Avoid interrupt is triggered at the end of the synthesizer calibration for startup
    JN518X_RFPMODEM->tmu.rfp_tmu_cal_inten.fields.synth_cal_startup_done = 0;
	// Clear the interrupt status bit
	JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_SYNTH_CAL_STARTUP_DONE_POS);

		// TEST clear ITs
	    //JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = 0x1FFF;
	       //radio_waitNus(1);


    // PFD forced in reset to avoid CP output activity leading to precharge disturbance (done automatically now by VCO calibration engine)
    // JN518X_RFPMODEM -> transceiver.pll_pfd_d2r_if_val.fields.pll_pfd_rst_set = 1;

    // SW enabling of PLL calibration counter in order to activate its supply before to reset it.
    // Current design status is automatic reset at begining of the synthesizer calibration for startup
    // occurs before availability of internal supply of calibration counter (available when pll_cal_enable signal is asserted).
    // Possibly extra wait state could be needed in order to insure internal supply is properly settled when reset is asserted.
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_val.fields.pll_cal_enable = 1; // Enabling of PLL calibration counter.
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_src_sel.fields.pll_cal_enable = 0; // Sourced from regfile, not from Calibration

    // Trigger the synthesizer calibration for startup

    JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = 0x1FFF;

    // JN518X_RFPMODEM->tmu.synth_cal_triggers.fields.synth_cal_startup_start = 1;
    vPrintf("Trigger the synthesizer calibration for startup\n");
    JN518X_RFPMODEM->tmu.synth_cal_triggers.val = (0x1 << EXTAPB_REGFILE_TMU_SYNTH_CAL_TRIGGERS_SYNTH_CAL_STARTUP_START_POS);
    // Wait till the synthesizer calibration interrupt status bit is asserted
  //  vPrintf("Wait till the synthesizer calibration interrupt status bit is asserted");
    while(JN518X_RFPMODEM->tmu.rfp_tmu_cal_intstat.fields.synth_cal_startup_done == 0)
    {
       radio_waitNus(10); // Some dummy action
    }
    // Clear the PFD reset bit (done automatically now by VCO calibration engine)
    // JN518X_RFPMODEM -> transceiver.pll_pfd_d2r_if_val.fields.pll_pfd_rst_set = 0;             // PFD in free running mode.

    vPrintf("Synthesizer calibration for startup done\n");

    // Clear the interrupt status bit
    JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_SYNTH_CAL_STARTUP_DONE_POS);
  //  vPrintf("Synthesizer calibration done interrupt status bit cleared");

    // Release of the SW enabling of PLL calibration counter used to activate its supply before to reset it.
    // Moreover internal supply of calibration counter is only available when pll_cal_enable signal is asserted.
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_src_sel.fields.pll_cal_enable = 1; // Sourced not from regfile, from Calibration
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_val.fields.pll_cal_enable = 0; // Enabling of PLL calibration counter.

    // The results for the synth calibration for startup are always stored as RX status.
    // --> To clarify how to perform in TX !!!!!!!!!!!!!!!!!!!!!
    // If required, SW is responsible to copy to the TX location.
    // One can also perform 2 Synth cal startup runs:
    // - First run the one for TX. Copy the "RX" results to "TX"
    // - Second run the RX run. The results are already at the right location afterwards.
    // Remark both the RX and TX fields are both readable and writeable (override!) for SW
    JN518X_RFPMODEM -> calibration.synth_cal_startup_afc_2_tx.fields.afc_2 =
      JN518X_RFPMODEM->calibration.synth_cal_startup_afc_2_rx.fields.afc_2;       // Resulting afc_2 value from AFC calibration during synthesizer startup calibration.
                                                                                  // Input for cap bank calculation during Rx mode.
    JN518X_RFPMODEM->calibration.synth_cal_startup_afc_diff_tx.fields.afc_diff =
      JN518X_RFPMODEM->calibration.synth_cal_startup_afc_diff_rx.fields.afc_diff; // Resulting afc_diff value from AFC calibration during synthesizer startup calibration.
                                                                                  // Input for cap bank calculation during Rx mode.

    RESTORE_PHYON
  }


  // --------------------------------------------------------------------------
  // Synthesizer calibration for startup main routine
  // --------------------------------------------------------------------------

  void radio_jn518x_Synthesizer_Cal_Startup(bool bDoCal)
  {

     // -----------------------------------------
     // Start synthesizer calibration for startup
     // -----------------------------------------

     // Some configurations for the VCO, Vtune precharge as well as algorithm to let the synth cal startup calibration work
     radio_jn518x_Synthesizer_Cal_Startup_init();

     if (bDoCal)    // Do the calibration function
     {
       // Trigger the synthesizer calibration for startup
       // And wait till the synthesizer calibration for startup interrupt status bit is asserted
       radio_jn518x_Synthesizer_Cal_Startup_algo();
     }
     else
     {
     // Nothing needed here if not calibrating
     vPrintf("NOT DOING Synthesizer calibration for startup\n");
     }
  }


  // --------------------------------------------------------------------------
  // Pre-initialisation for synthesizer calibration for operation and locking sequence
  // - PLL locking sequence will start assuming VCO calibration (synthesizer calibration at startup) has been run at least once before
  // - Disable the PLL locking sequence launched at assertion TX3 group signal
  // - Lock detector operation settings
  // - PLL locking sequence FSM settings
  // - Charge-pump reference & offset current setting
  // - PLL SDM clock polarity w.r.t. pfd feedback clock setting
  // - Settings of loop-filter configuration and its voltage precharge during calibration for operation and locking sequence
  // --------------------------------------------------------------------------

  void radio_jn518x_Synthesizer_Cal_Operation_And_Lock_init(void)
  {
	  uint32_t u32Pch_N_Hold = 0;
	  uint32_t u32Pch_P_Hold = 0;

		RESET_PHYON

	// save pch_N_hold and pch_P_hold as they will be temporary modified
	u32Pch_N_Hold = JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_n_hold;
	u32Pch_P_Hold = JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_p_hold;


    // PLL locking sequence will start assuming VCO calibration (synthesizer calibration at startup) has been run at least once before.

	//  vPrintf("PLL locking sequence setting");

    // Configuration to be done before synthesizer calibration for operation is started

    // Control of the PLL locking sequence launched at assertion TX3 group signal
    JN518X_RFPMODEM -> tmu.synth_cal_cfg.fields.pll_lock_tx3_active = 0; // Disable the PLL locking sequence launched at assertion TX3 group signal

    // Lock detector operation control
    JN518X_RFPMODEM -> transceiver.pll_lock_d2r_if_val.fields.pll_lock_det_enable = 1;         // Enable signal for the lock detector
    JN518X_RFPMODEM -> transceiver.pll_lock_d2r_if_src_sel.fields.pll_lock_det_enable = 0;     // Sourced from regfile, not TMU
    JN518X_RFPMODEM -> transceiver.pll_lock_d2r_if_val.fields.pll_lock_det_mode_ctrl_set = 19;   // Mode select for lock detector:
                                                                                                  // [4:3] : set delay for integration counter time window (00: shortest window, 11: longest window),
                                                                                                  // As long as the PFD activity (up + dn) is greater than the programmed delay, the counter is reseted,
                                                                                                  // As soon as it becomes smaller, the counter start to increment its internal value.
                                                                                                  // When maximum value is reached, PLL lock status is asserted.
                                                                                                  // [2:0] : 3-bits code (N) setting the integration counter incrementation step.
                                                                                                  //         Hence 13-bit integration counter is incremented in 2^(7-N) step size.
    JN518X_RFPMODEM -> transceiver.pll_lock_d2r_if_val.fields.pll_lock_det_force_rst_set = 1;  // Force lock detector reset
    JN518X_RFPMODEM -> transceiver.pll_lock_d2r_if_val.fields.pll_lock_det_force_rst_set = 0;  // Release reset lock reset

    // PLL locking sequence FSM settings
    JN518X_RFPMODEM -> tmu.synth_cal_cfg.fields.redo_aafc = 0;                // AAFC is disabled during synthesizer calibration during operation.
    JN518X_RFPMODEM -> tmu.synth_cal_cfg.fields.pll_vco_ff_amp_cor = 1;       // Feedforward VCO amplitude correction is disabled
    JN518X_RFPMODEM -> tmu.synth_cal_cfg.fields.pll_lock_aac_lock_active = 0; // AAC during pll locking sequence is disabled as not be able to run in JN518x.
    JN518X_RFPMODEM -> tmu.synth_cal_cfg.fields.pll_lock_aac_pch_active = 0; // pre-charge during AAC done in PLL locking sequence is disabled.
                                                                             // Previous both bits must be set to 0 in order to allow the end of the PLL locking sequence.
                                                                             // Otherwise the locking sequence will never ends creating a repetitive pattern made
                                                                             // of locking sequence restart every 512us wiih default AAC timer threshold value.
                                                                             // Indeed the FSM state for the PLL locking sequence inside the cal tmu is contained
                                                                             // by the signal named "reg_synth_cal_pll_lock_state".
                                                                             // As soon the PLL locking sequence is started, this FSM transitions from
                                                                             // "e_synth_cal_pll_lock_idle" to "e_synth_cal_pll_lock_busy".
                                                                             // During this last stage a counter/timer is used to start:
                                                                             // -	The initial pre-charge (default)
                                                                             // -	The AAC during the pre-charge (when JN518X_RFPMODEM->tmu.synth_cal_cfg.fields.pll_lock_aac_pch_active = 1)
                                                                             // -	The AAC during the locking phase (when JN518X_RFPMODEM->tmu.synth_cal_cfg.fields.pll_lock_aac_lock_active = 1)
                                                                             // -	The loop1/2/3.
                                                                             // The PLL locking sequence will end only when all of following registers are '1' (all inside cal_tmu):
                                                                             // -	reg_tmu_synth_cal_pll_lock_aac_pch_done_latched :
                                                                             //   when JN518X_RFPMODEM->tmu.synth_cal_cfg.fields.pll_lock_aac_pch_active = 0
                                                                             //   this signal is always asserted and no AAC during pre-charge is launched
                                                                             //   (reg_tmu_synth_cal_pll_lock_aac_pch_start_p stays low).
                                                                             // -	reg_tmu_synth_cal_pll_lock_aac_lock_done_latched :
                                                                             //   when JN518X_RFPMODEM->tmu.synth_cal_cfg.fields.pll_lock_aac_lock_active = 0
                                                                             //   this signal is always asserted and no AAC during locking is launched
                                                                             //   (reg_tmu_synth_cal_pll_lock_aac_lock_start_p stays low).
                                                                             // -	reg_tmu_synth_cal_pll_lock_loop1_done_latched : asserted as soon loop1 is started
                                                                             // -	reg_tmu_synth_cal_pll_lock_loop2_done_latched : asserted as soon loop2 is started
                                                                             // -	reg_tmu_synth_cal_pll_lock_loop3_done_latched : asserted as soon loop3 is started
                                                                             // When for some reason the PLL locking sequence is not able to reach the end :
                                                                             // the timer used is not saturating, but will wrap around, and start again at value 0.
                                                                             // This makes you get the repetitive pattern.

  //  vPrintf("RF carrier frequency setting done");

  //  vPrintf("Charge-pump reference & offset current setting on-going");

     // Charge-pump setting
     // Removal of any charge pump current forcing by register done prior to PLL locking sequence
     JN518X_RFPMODEM -> transceiver.pll_cp_d2r_if_src_sel.fields.pll_cp_slice_set = 1;   // source=not register, synthesizer calibration
     JN518X_RFPMODEM -> transceiver.pll_cp_d2r_if_src_sel.fields.pll_cp_offcur_set = 1;   // source=not register, synthesizer calibration

    // Charge-pump reference current settings (JN518x values that targets 50uA final value)
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_init_cfg.fields.pll_cp_slice_en = 0; // 0uA value applied at start of the PLL locking sequence
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_loop1_cfg.fields.pll_cp_slice_en = 30; // 150uA value applied at start of loop #1 of the PLL locking sequence
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_loop2_cfg.fields.pll_cp_slice_en = 20; // 100uA value applied at start of loop #2 of the PLL locking sequence
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_loop3_cfg.fields.pll_cp_slice_en = 10; // 50uA value applied at start of loop #3 of the PLL locking sequence

    // Charge-pump output offset current settings (JN518x values)
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_init_cfg.fields.pll_cp_offcur_en = 0; // 0uA value applied at start of the PLL locking sequence
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_loop1_cfg.fields.pll_cp_offcur_en = 0; // 0uA value applied at start of 31 loop #1 of the PLL locking sequence
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_loop2_cfg.fields.pll_cp_offcur_en = 0; // 0uA value applied at start of 33 loop #2 of the PLL locking sequence
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_loop3_cfg.fields.pll_cp_offcur_en = 0; // 0uA value applied at start of 35 loop #3 of the PLL locking sequence

    // Charge-pump output offset current polarity
    JN518X_RFPMODEM -> transceiver.pll_cp_d2r_if_val.fields.pll_cp_offcur_pol_set = 1; // Select PMOS (when 1 then source mode, better CP main source linearity)
                                                                                       // or NMOS (when 0 then sink mode) offset current sources in the CP

    // PLL SDM clock polarity w.r.t. pfd feedback clock
    JN518X_RFPMODEM -> transceiver.pll_divn_d2r_if_val.fields.pll_divn_sdm_pol_set = 0; // pll_divn_sdm_pol_set bit value is aligned on pll_cp_offcur_pol_set
                                                                                        // bit value in order to start SDM calculation (on sdm clk rising edge) after
                                                                                        // the end of the PFD comparison (feedback divider falling edge when charge-pump
                                                                                        // output offset current in source mode). In such a case there are two benefits:
                                                                                        // * PFD comparison isn't poluted by SDM activity,
                                                                                        // * Time left to the SDM for calculation without PDF disturbance is maximazed
                                                                                        //   (29 ns according to analog nominal condition simulation result).

  //  vPrintf("Charge-pump reference & offset current setting done");

  //  vPrintf("Loop-filter setting on-going");

    // Loop-filter resistor divided by 2 for PLL lock-boost settings
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_init_cfg.fields.pll_lf_lock_boost_en = 1; // resistor divided by 2 for PLL lock-boost at start of the PLL locking sequence
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_loop1_cfg.fields.pll_lf_lock_boost_en = 1; // resistor normal value and no more boost at start of 31 loop #1 of the PLL locking sequence
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_loop2_cfg.fields.pll_lf_lock_boost_en = 0; // resistor normal value and no more boost at start of loop #2 of the PLL locking sequence
    JN518X_RFPMODEM -> calibration.synth_cal_pll_lock_loop3_cfg.fields.pll_lf_lock_boost_en = 0; // resistor normal value and no more boost at start of loop #3 of the PLL locking sequence

    // Settings of loop-filter precharge triggered at startup calibration/operation calibration and pll locking sequence
    // Synthesizer calibration pre_charge period (expressed in 16 MHz clock cycles)
    JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_period.fields.pre_charge_period = 96; // 6us pre_charge period
    JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_n = 0x7;      // Precharge settings before cal. measurement (before the AAC start). 0x0 : disabled. Xxx : enable resistor from ground to Vtune.
    JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_p = 0x7;      // Precharge settings before cal. measurement (before the AAC start). 0x0 : disabled. Xxx : enable resistor from supply to Vtune.
    JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_n_hold = 0x3; // Precharge settings during cal. measurement (till the AFC2 is finished). 0x0 : disabled. Xxx : enable resistor from ground to Vtune.
    JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_p_hold = 0x3; // Precharge settings during cal. measurement (till the AFC2 is finished). 0x0 : disabled. Xxx : enable resistor from supply to Vtune.
    JN518X_RFPMODEM -> transceiver.pll_lf_d2r_if_src_sel.fields.pll_lf_pch_n_set = 1;         // Precharge sourced from calibration
    JN518X_RFPMODEM -> transceiver.pll_lf_d2r_if_src_sel.fields.pll_lf_pch_p_set = 1;         // Precharge sourced from calibration

    // RF - 20160720

    // To get rid of some side effects as soon the synthesizer calibration for startup is finished.
    // Indeed, without those lines when synthesizer calibration during operation is running, there are some activities on
    // ip_aac_fref, ip_afc_fref and ip_det_fref reference output signals toward the frequency meter located into the radio analog part.
    // But remember the synthesizer calibration for operation should be a purely computational thing, and no interfacing with
    // the analog is required. So this means indeed the generation of those reference signals is not required.
    // VCO calibration reference signals are only generated during KMod band calibration, and when the VCO calibration core
    // is active.
    // The combined setting aac_manual together with afc_skip_loop1 has some side-effects like this one mentionned above.
    // When those settings are both set to '1', the VCO cal (and reference signal generation) is activated
    // automatically each time the synthesizer calibration for operation is started. The calibration outputs are ignored,
    // but nevertheless they generate an unwanted activity. It's a very strange effect, but this workaround do the trick.

    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_skip_loop1 = 0;
    JN518X_RFPMODEM->calibration.vco_cal_aac_cfg0.fields.aac_manual = 0;

  //  vPrintf("Loop-filter setting done");

	// restore pch_N_hold and pch_P_hold
	JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_n_hold = u32Pch_N_Hold;
	JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_p_hold = u32Pch_P_Hold;

    RESTORE_PHYON
  }

  // --------------------------------------------------------------------------
  // Run synthesizer calibration for operation and locking sequence
  // - PLL locking sequence will start assuming VCO calibration (synthesizer calibration at startup) has been run at least once before
  // - Avoid interrupt is triggered at the end of the synthesizer calibration during operation
  // - Trigger the synthesizer calibration during operation
  // - Wait till the synthesizer calibration during operation is done
  // --------------------------------------------------------------------------

  void radio_jn518x_Synthesizer_Cal_Operation_And_Lock_algo(void)
  {
  //  vPrintf("Start the synthesizer calibration during operation");

    // Avoid interrupt is triggered at the end of the synthesizer calibration during operation
    JN518X_RFPMODEM->tmu.rfp_tmu_cal_inten.fields.synth_cal_operation_done = 0;
    // Clear the interrupt status bit
    JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_SYNTH_CAL_OPERATION_DONE_POS);

    // Trigger the synthesizer calibration during operation
    vPrintf("Trigger the synthesizer calibration during operation\n");
    //  JN518X_RFPMODEM->tmu.synth_cal_triggers.val = (0x1 << EXTAPB_REGFILE_TMU_SYNTH_CAL_TRIGGERS_SYNTH_CAL_OPERATION_START_POS) | (0x1 << EXTAPB_REGFILE_TMU_SYNTH_CAL_TRIGGERS_SYNTH_CAL_LOCKING_SEQUENCE_START_POS);
    JN518X_RFPMODEM->tmu.synth_cal_triggers.val = (0x1 << EXTAPB_REGFILE_TMU_SYNTH_CAL_TRIGGERS_SYNTH_CAL_OPERATION_START_POS);
    // Wait till the synthesizer calibration interrupt status bit is asserted
    //  vPrintf("Wait till the synthesizer calibration interrupt status bit is asserted");
    while(JN518X_RFPMODEM->tmu.rfp_tmu_cal_intstat.fields.synth_cal_operation_done == 0)
    {
       radio_waitNus(10); // Some dummy action
    }

    vPrintf("Synthesizer calibration during operation done\n");

    // Clear the interrupt status bit
    JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_SYNTH_CAL_OPERATION_DONE_POS);
  //  vPrintf("Synthesizer calibration during operation done interrupt status bit cleared");

  //  vPrintf("Start the synthesizer locking sequence");

    // Calibration TMU is allowed to trigger the start of the locking sequence (independent from the synth calibration for operation)
  //  JN518X_RFPMODEM -> tmu.synth_cal_triggers.fields.synth_cal_locking_sequence_start = 1;

  //  vPrintf("Start the synthesizer locking sequence done");

    // Status readable after synthesizer calibration for operation is finished are given hereafter:

    // Calculated frequency control word from carrier frequency specification can be read out as following register location
    // calibration.synth_cal_operation_fcw_frac.fcw_frac // fractional part of calculated FCW
    // calibration.synth_cal_operation_fcw_int.fcw_int // integer part of calculated FCW

    // The calculated values for afc_fsel_bin and afc_fsel_therm can be read out as following register location
    // calibration.synth_cal_operation_afc_fsel_bin.afc_fsel_bin // Calculated binary cap bank value for VCO during synthesizer calibration during operation.
    // calibration.synth_cal_operation_afc_fsel_bin.afc_fsel_therm // Calculated thermo cap bank settings for VCO during synthesizer calibration during operation.

  }


  // --------------------------------------------------------------------------
  // Synthesizer calibration for operation and locking sequence main routine
  // --------------------------------------------------------------------------

  void radio_jn518x_Synthesizer_Cal_Operation_And_Lock(bool bDoCal)
  {
	// -----------------------------------------
	// After the operation VCO calibration has been done the PLL locking sequence will start.
    // -----------------------------------------

	// Configuration to be done before synthesizer calibration for operation is started
	//  vPrintf("PLL locking sequence setting");
    radio_jn518x_Synthesizer_Cal_Operation_And_Lock_init();

	//  vPrintf("Start the synthesizer calibration during operation");

    if (bDoCal)    // Do the calibration function
    {
      // Trigger the synthesizer calibration during operation
      // Wait till the synthesizer calibration interrupt during operation status bit is asserted
      radio_jn518x_Synthesizer_Cal_Operation_And_Lock_algo();
    }
    else
    {
      // Nothing needed here if not calibrating
      vPrintf("NOT DOING Synth cal during op\n");
    }
  }

  // --------------------------------------------------------------------------
  // Pre-initialisation for KMod band calibration sequence
  // - Specifies the negative and positive code applied to the DAC input during KMod band calibration
  // - Configures the AFC counter integration window for targeted accuracy
  // - DAC amplitude is set for 1MBps mode (+/-250kHz frequency deviation)
  // --------------------------------------------------------------------------

  void radio_jn518x_Synthesizer_Kmod_Band_init(void)
  {
    // The calibration will be performed in open loop whilst keeping Vtune fixed to halfway supply and ground.
    // A Vmod level is applied to the VCO, via the DAC and low-pass filter, and the resulting impact on the
    // RF frequency will be measured by comparing the divided (modulated) VCO clock signal with a reference
    // clock derived from the reference XO (16 MHz).
    // Hereto existing functionality from the VCO coarse calibration circuit will be reused,

		RESET_PHYON

  //  vPrintf("KMod Band calibration setting");

    // Some configuration for the KMod band calibration

    // KMod band calibration parameters
    JN518X_RFPMODEM -> calibration.kmod_band_cal_cfg.fields.calib_code_exp = 6; // Specifies the negative and positive code applied to the DAC input during KMod band calibration as a power of 2. Code is +/-2**calib_code_exp corresponding to about +/-500kHz with value equal to 64.
    JN518X_RFPMODEM -> calibration.kmod_band_cal_cfg.fields.fref_kmod_calib_sel = 1; // Configures the AFC counter integration window in terms of divided reference (XO) clocks.
    JN518X_RFPMODEM -> calibration.kmod_band_cal_cfg.fields.kmod_precision_factor = 1; // Specifies the KMod precision factor.
    JN518X_RFPMODEM -> calibration.kmod_band_cal_cfg.fields.startup_transient = 96; // Specifies the timeout period to avoid transient effects after the DAC code changes. (Expressed in XO clock periods).
                                                                                    // Specifies how many fref_xo cycles are skipped in the beginning, to avoid taking in transient data into the measurement.
    JN518X_RFPMODEM -> tx_datapath.global.fields.kmod_band_corr_1_upd_on_cal_en = 1; // Enables automatic copy of KMod band calibration to Kmod corr1 parameter as used by TX datapath.

    // DAC amplitude is set for 1MBps mode (+/-250kHz frequency deviation)
    //JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_mode2_enable = 0;	// back to the largest full scale du to VCO kmod redesign to get 10 MHz/V
    																						// iso 18 MHz/V measured on ES1 (typical)
    radio_TX_ZigBee_pll_dac_banked_set();
	if (!radio_jn518x_IsNotC2MF(NULL, NULL)) // if MF chip
	{
		// registers set in above function are now in banks...
		// We use values defined for ZB
		// Select ZB bank to set values (write access)
		// and force usage of this bank (read access by HW forced by SW)
		JN518X_RFPMODEM -> tx_datapath.global.fields.tx_bank = 0; // Bank selection of Tx datapath
		JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.tx_order_src = 1;
		JN518X_RFPMODEM->tmu.mode_ctrl.fields.tx_order = 0;
		JN518X_RFPMODEM -> tx_datapath.pre_const.fields.len |= (0x7 << 5); // Trig write access in pre_const to write content of registers set in above function
	}


    //>>1.02
    JN518X_RFPMODEM -> transceiver.pll_dac_1_d2r_if_val.fields.pll_dac_dccur_set = 0x0;
    //JN518X_RFPMODEM -> transceiver.pll_dac_0_d2r_if_val.fields.pll_dac_c_set = 3;        // TX DAC output capacitor set for ZB mode (7.05MHz cut-offset).
    JN518X_RFPMODEM->calibration.synth_cal_pll_cal_div_set.fields.pll_cal_div_set = 0x2;   // Pll cal divset -> Divided Fvco = [ 2.4GHz + (16MHz/11) ] / 2 / 4 = 300.1818MHz
    JN518X_RFPMODEM->calibration.vco_cal_afc_cfg1.fields.afc_fref_sel = 0x5;
    JN518X_RFPMODEM->calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_n_hold = 0x6;
    JN518X_RFPMODEM->calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_p_hold = 0x7;
    JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_period.fields.pre_charge_period = 96; // 6us pre_charge period
    //<<1.02

    RESTORE_PHYON
  }

  // --------------------------------------------------------------------------
  // Run KMod band calibration sequence
  // - Avoid interrupt is triggered at the end of the kmod band calibration
  // - SW enabling of PLL calibration counter in order to activate its supply before to reset it
  // - VCO calibration frequency meter reset not automatically done by VCO Kmod calibration engine
  // - Trigger the Kmod band calibration
  // - Wait till the Kmod pre calibration interrupt status bit is asserted
  // - Release of the SW enabling of PLL calibration counter in order to activate its supply before to reset it
  // --------------------------------------------------------------------------

  uint32_t radio_jn518x_Synthesizer_Kmod_Band_algo(void)
  {
	  //uint32_t u32Count1 = 0;
	  //uint32_t u32Count2 = 0;
	  uint32_t u32DeltaCount = 0;
	  //uint32_t u32DeltaCountExpected = 0;
	  //uint32_t u32Temp = 0;

		RESET_PHYON

  //  vPrintf("Start the Kmod band calibration");

    // Avoid interrupt is triggered at the end of the kmod band calibration
    JN518X_RFPMODEM -> tmu.rfp_tmu_cal_inten.fields.kmod_band_cal_done = 0;
	// Clear the interrupt status bit
	JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_KMOD_BAND_CAL_DONE_POS);

    // SW enabling of PLL calibration counter in order to activate its supply before to reset it.
    // Current design status is reset is missing at begining of the Kmod calibration.
    // Moreover internal supply of calibration counter is only available when pll_cal_enable signal is asserted.
    // Possibly extra wait state could be needed in order to insure internal supply is properly settled when reset is asserted.
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_val.fields.pll_cal_enable = 1; // Enabling of PLL calibration counter.
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_src_sel.fields.pll_cal_enable = 0; // Sourced from regfile, not from Calibration

    // VCO calibration frequency meter reset not automatically done by VCO Kmod calibration engine.
    // !!!!!!! Already done during VCO calibration at start-up. Should be unuseful.
    // !!!!!!! Reaset inserted anyway in order to clean-up wreal simulation, to avoid TX/RX loopback issue.
    // To be clearified.

    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_val.fields.pll_cal_ip_vco_rst_set = 1; // Reset the out-of-range counter (VCO calibration part located in analog part).
                                                                                       // Without this reset then the "op_det_toggle" signal state is undefined and
                                                                                       // the VCO-clock looks out-of-range (reg_det_out_of_range_i stuck at '1').
                                                                                       // As an unexpected result the synthesizer calibration is blocked.
                                                                                       // Indeed the complete AAFC loop will be in lock when AFC is locked,
                                                                                       // AAC is locked and if the VCO-clock is not out-of-range.
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_src_sel.fields.pll_cal_ip_vco_rst_set = 0; // Sourced from regfile, not from Calibration
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_val.fields.pll_cal_ip_vco_rst_set = 0; // Disassert reset of the out-of-range counter to allow possibly VCO-clock not
                                                                                       // out-of-range (reg_det_out_of_range_i stuck at '0').
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_src_sel.fields.pll_cal_ip_vco_rst_set = 1; // Sourced no from regfile, from Calibration

    // Trigger the Kmod band calibration
    vPrintf("Trigger the Kmod band calibration\n");
    JN518X_RFPMODEM->tmu.kmod_cal_triggers.val = (0x1 << EXTAPB_REGFILE_TMU_KMOD_CAL_TRIGGERS_KMOD_BAND_CAL_EN_POS);
    // Wait till the Kmod pre calibration interrupt status bit is asserted
    //  vPrintf("Wait till the Kmod pre calibration interrupt status bit is asserted");
    while(JN518X_RFPMODEM->tmu.rfp_tmu_cal_intstat.fields.kmod_band_cal_done == 0)
    {
       radio_waitNus(100); // Some dummy action
    }

    vPrintf("Kmod Band calibration is finished\n");

    // Clear the interrupt status bit
    JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_KMOD_BAND_CAL_DONE_POS);
    //  vPrintf("Kmod pre calibration done interrupt status bit cleared");

    // Release of the SW enabling of PLL calibration counter in order to activate its supply before to reset it.
    // Current design status is reset is missing at begining of the Kmod calibration.
    // Moreover internal supply of calibration counter is only available when pll_cal_enable signal is asserted.
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_src_sel.fields.pll_cal_enable = 1; // Sourced not from regfile, from Calibration
    JN518X_RFPMODEM->transceiver.pll_cal_d2r_if_val.fields.pll_cal_enable = 0; // Enabling of PLL calibration counter.

    // The results from the KMod band calibration are stored at following locations,
    // which are all readable AND writeable (override!) for SW
    // JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_lsb.fields.count_1_lsb;
    // JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_msb.fields.count_1_msb;
    // JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_lsb.fields.count_2_lsb;
    // JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_msb.fields.count_2_msb;
    // JN518X_RFPMODEM -> calibration.kmod_band_cal_corr_1.fields.corr_1;
    // JN518X_RFPMODEM -> tx_datapath.kmod_band_corr_1.fields.corr_1;

    //>>1.02 SW Patch
#if 0 // directly moved to radio_jn518x_Synthesizer_Kmod_Band because of mean algorithm
    u32Count1 = (JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_msb.fields.count_1_msb)<<16;
    u32Count1 += (JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_lsb.fields.count_1_lsb) & 0xFFFF;
    u32Count2 = (JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_msb.fields.count_2_msb)<<16;
    u32Count2 += (JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_lsb.fields.count_2_lsb) & 0xFFFF;
    u32DeltaCount = u32Count1 - u32Count2;
    u32DeltaCountExpected = 2 << ( (JN518X_RFPMODEM -> calibration.kmod_band_cal_cfg.fields.kmod_precision_factor)
    							  +(JN518X_RFPMODEM -> calibration.kmod_band_cal_cfg.fields.calib_code_exp));


    u32Temp = ((u32DeltaCountExpected << 11)/u32DeltaCount +1)/2;

    JN518X_RFPMODEM -> calibration.kmod_band_cal_corr_1.fields.corr_1 = u32Temp;
    //<<1.02 SW Patch
#endif


    RESTORE_PHYON

	return(u32DeltaCount);
  }


  void radio_jn518x_Synthesizer_Kmod_Band(bool bDoCal)
  {
	  uint8_t i;

	  uint32_t u32KmodIter;
	  uint64_t u64Count1 = 0;
	  uint64_t u64Count2 = 0;
	  uint32_t u32DeltaCount;
	  uint32_t u32DeltaCountExpected;
	  uint32_t u32CalculatedCorr1;

    // -----------------------------------------
    // After the synthesizer locking sequence has been done the PLL KMod Band calibration will start.
    // -----------------------------------------

    // The VCO gain calibration will be performed in open loop whilst keeping Vtune fixed to halfway supply and ground.
    // A Vmod level is applied to the VCO, via the DAC and low-pass filter, and the resulting impact on the
    // RF frequency will be measured by comparing the divided (modulated) VCO clock signal with a reference
    // clock derived from the reference XO (16 MHz).
    // Hereto existing functionality from the VCO coarse calibration circuit will be reused,

	  uint32_t u32Pch_N_Hold = 0;
	  uint32_t u32Pch_P_Hold = 0;


	// save pch_N_hold and pch_P_hold as they will be temporary modified
	u32Pch_N_Hold = JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_n_hold;
	u32Pch_P_Hold = JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_p_hold;

    //  vPrintf("KMod Band calibration setting");

    // Some configuration for the KMod band calibration
    radio_jn518x_Synthesizer_Kmod_Band_init();

    // check if Kmod cal is available for this temp
    if (bDoCal==1)    // Do the calibration function
    {
    	// read Kmod cal results form flash
    	//vRadio_JN518x_Temp_GetKmodData(); // already done in radio_init
    	for (i = 0; i<KMOD_TEMP_POINTS; i++)
    	{
    		if (((RadioKmodCalData[i].i16CalTemp-i16RecalThresholdTemp) <= RadioConfiguration.i16TCur)
    			&& (RadioConfiguration.i16TCur <= (RadioKmodCalData[i].i16CalTemp+i16RecalThresholdTemp)))
    		{
				JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_msb.fields.count_1_msb = RadioKmodCalData[i].u32Count1MSB;
				JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_lsb.fields.count_1_lsb = RadioKmodCalData[i].u32Count1LSB;
				JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_msb.fields.count_2_msb = RadioKmodCalData[i].u32Count2MSB;
				JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_lsb.fields.count_2_lsb = RadioKmodCalData[i].u32Count2LSB;
				JN518X_RFPMODEM -> calibration.kmod_band_cal_corr_1.fields.corr_1 = RadioKmodCalData[i].u16Corr1;
				bDoCal= 0;
				break;
    		}
    	}
    }

    if (bDoCal==1)    // Do the calibration function as no data has been found in flash
    {
        for (u32KmodIter = 0; u32KmodIter<KMOD_AVERAGE_POINTS; u32KmodIter++)
    	{
    		radio_jn518x_Synthesizer_Kmod_Band_algo();

    		u64Count1 += ( (JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_msb.fields.count_1_msb << 16) |
    						JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_lsb.fields.count_1_lsb);
    		u64Count2 += ( (JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_msb.fields.count_2_msb << 16) |
    						JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_lsb.fields.count_2_lsb);
    	}

    	u64Count1 = (u64Count1 * KMOD_ITERDIV_COEFF) >> 32;
    	u64Count2 = (u64Count2 * KMOD_ITERDIV_COEFF) >> 32;

        u32DeltaCount = (uint32_t)u64Count1 - (uint32_t)u64Count2;
        u32DeltaCountExpected = 2 << ( (JN518X_RFPMODEM -> calibration.kmod_band_cal_cfg.fields.kmod_precision_factor)
        							  +(JN518X_RFPMODEM -> calibration.kmod_band_cal_cfg.fields.calib_code_exp));


        u32CalculatedCorr1 = ((u32DeltaCountExpected << 11)/u32DeltaCount +1)/2;


		JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_msb.fields.count_1_msb = (uint16_t)((u64Count1 >> 16) & 0x3F);
		JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_lsb.fields.count_1_lsb = (uint16_t)((u64Count1) & 0xFFFF);
		JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_msb.fields.count_2_msb = (uint16_t)((u64Count2 >> 16) & 0x3F);
		JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_lsb.fields.count_2_lsb = (uint16_t)((u64Count2) & 0xFFFF);
		JN518X_RFPMODEM -> calibration.kmod_band_cal_corr_1.fields.corr_1 = u32CalculatedCorr1;

		// copy new results in flash
		for (i = 0; i<KMOD_TEMP_POINTS; i++)
		{
			//find new free index
			if (RadioKmodCalData[i].i16CalTemp == (int16_t)0x8000)
			{
				RadioKmodCalData[i].u32Count1MSB = JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_msb.fields.count_1_msb;
				RadioKmodCalData[i].u32Count1LSB = JN518X_RFPMODEM -> calibration.kmod_band_cal_count_1_lsb.fields.count_1_lsb;
				RadioKmodCalData[i].u32Count2MSB = JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_msb.fields.count_2_msb;
				RadioKmodCalData[i].u32Count2LSB = JN518X_RFPMODEM -> calibration.kmod_band_cal_count_2_lsb.fields.count_2_lsb;
				RadioKmodCalData[i].u16Corr1 = JN518X_RFPMODEM -> calibration.kmod_band_cal_corr_1.fields.corr_1;
				RadioKmodCalData[i].i16CalTemp = RadioConfiguration.i16TCur;
				// read Kmod cal results form flash
				vRadio_JN518x_Temp_SetKmodData();
				break;
			}
		}

    }
    else
    {
      // Nothing to do if bypassing the Kmod Band cal
      vPrintf("NOT DOING Kmod Band pre cal\n");
    }

    /* always copy calibration.kmod_band_cal_corr_1.fields.corr_1 to tx_datapath.kmod_band_corr_1.fields.corr_1 */
    JN518X_RFPMODEM -> tx_datapath.kmod_band_corr_1.fields.corr_1 = JN518X_RFPMODEM -> calibration.kmod_band_cal_corr_1.fields.corr_1;

	// restore pch_N_hold and pch_P_hold
	JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_n_hold = u32Pch_N_Hold;
	JN518X_RFPMODEM -> calibration.synth_cal_pre_charge_pll_lf_pch.fields.pll_lf_pch_p_hold = u32Pch_P_Hold;

	if (!radio_jn518x_IsNotC2MF(NULL, NULL)) // if MF chip
	{
		// some registers used are now in banks...
		// ZB bank has been selected in Synthesizer_Kmod_Band_init and HW bank selection has been forced in SW control
		// Restore HW control
		JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.tx_order_src = 0;
	}

  }


  void radio_jn518x_Synthesizer_Full_Cal(void)
  {
	   //radio_jn518x_Carrier_Frequency_Select(2449.3125, 1.3125, 2); // Change Mat. P. 20170929
	   radio_jn518x_Carrier_Frequency_Select_by_index(CFS_SYNTHCAL);

	   //Initializes synthesizer path (synthesizer 2nd modulated point scaling + SDM part)
	   //for frac-N PLL CW mode
	   radio_jn518x_Synthesizer_Cw_Mode_Init();

       //radio_jn518x_RX_ZigBee_Regular_Init(); // Need confirmation of its need but to be used for safety reason at that moment // RF-20170606

	   //Starts operation of Radio synthesizer functions (activation of G1, G2 and PLL groups controlled by TMU)

	   if (RadioConfiguration.bDoCalibrate)
	   {
		   radio_jn518x_Trx_Packet_SW_Ctrl_Init();
		   // Starting Synthesizer Calibration after Synthe cal operation generate conflict in VCO control
		   // So disable auto Synth cal operation when starting PLL
		   radio_jn518x_Disable_Auto_Kmod_Chan_and_Synth_Cal_Operation();
		   radio_jn518x_pre_start_to_pll_polled();
		   //radio_waitNus(1);
	   }

	   //Synthesizer calibration at start-up (VCO characterisation at two frequencies)

	   radio_jn518x_Synthesizer_Cal_Startup(RadioConfiguration.bDoCalibrate);
	   //Synthesizer calibration during operation (VCO trimming for carrier frequency used during Kmod calibration)

	   radio_jn518x_Synthesizer_Cal_Operation_And_Lock(RadioConfiguration.bDoCalibrate);

	   //VCO gain (Kmod) calibration for the full band

	   radio_jn518x_Synthesizer_Kmod_Band(RadioConfiguration.bDoCalibrate);

	  if (RadioConfiguration.bDoCalibrate)
	  {
		  //Switch-off operation of Radio synthesizer functions (dis-assertion of G1, G2 and PLL groups controlled by TMU)
		   radio_jn518x_power_down_to_off_polled();
		   radio_jn518x_Trx_Packet_HW_Ctrl_Init();
	   }

  }


  void radio_jn518x_Trx_Packet_HW_Ctrl_Init(void)
  {

		RESET_PHYON

    vPrintf("TMU setting to allow for normal packet sending operation\n");

    // Enable internal generation of packet start (after pre_start). TMU won't anymore simply
    // stay in PLL phase, and will start any RX or TX transfer
    JN518X_RFPMODEM->tmu.mode_ctrl.fields.packet_start_mode = 1; // The packet start is generated internally based on a counter.
                                                                 // To be clarified !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // Enable automatic assertion of the RX/TX group signals.
    JN518X_RFPMODEM->tmu.mode_ctrl_2.fields.trx_powerup_en = 1; // Specifies whether the TMU initiates the power up for the selected mode during the PLL phase.
                                                                // 1 -> enable: The powerup of the selected mode is under TMU (HW) control

    // Operation mode control register setting for automatic calibration launch.
    // !!!! Cannot be written without reference clock: any next write will hang !!!!!!

    // Specifies whether the TMU initiates the KMod channel calibration during the PLL phase.
    JN518X_RFPMODEM->tmu.mode_ctrl_2.fields.kmod_chan_cal_en = 1; // 1 -> The Kmod channel calibration is under TMU (HW) control

    // RF - 20160930
    // Result of the KMod channel calibration is copied automatically to the KMod band correction factor (corr 2) of the Tx datapath.
    JN518X_RFPMODEM -> tx_datapath.global.fields.kmod_chan_corr_2_upd_on_cal_en = 1; // Result of the KMod channel calibration is copied automatically to the KMod band correction factor of the Tx datapath.
    // RF - 20160930

    // Specifies whether the TMU initiates the synthesizer calibration for operation during the PLL phase.
    JN518X_RFPMODEM->tmu.mode_ctrl_2.fields.synth_cal_operation_en = 1; // 1 -> The synthesizer calibration for operation is under TMU (HW) control


    // SMB - 20161110 - last check in had these wrongly in radio_jn518x_Trx_Packet_SW_Ctrl_Init_Temp
    // allow channel selection modem
    JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rf_carrier_freq_int_src = 0;  // 1 -> rf_carrier_freq_int  is sourced from regfile   0->  Not regfile
    //>patch 1.01/1.02
    JN518X_RFPMODEM->tmu.mode_ctrl_src.fields.rf_carrier_freq_frac_src = 1; // 1 -> rf_carrier_freq_frac is sourced from regfile   0 -> Not regfile
    JN518X_RFPMODEM->tmu.rf_carrier_freq_frac.fields.rf_carrier_freq_frac =4 ; // 4 bits shift on the frac word but 2 LSB extension
    //<patch 1.01/1.02


    RESTORE_PHYON
  }


  //************************************************************
  // PA cal configuration
  // Assumes that radio G1/G2/PLL groups are on under TMU control
  // then sets up common configuration used by ATE cal and normal internal cal
  //************************************************************

  void radio_jn518x_PA_rewrite_lut(void)
  {
	  const uint16_t *pLut_Table;
	  if (RadioConfiguration.u32TxPowerMode == RADIO_MODE_LOPOWER)
	  {
		  pLut_Table = lut_defaults;
	  }
	  else // High TX power Mode
	  {
		  pLut_Table = lut_hiTx_defaults;

	  }

		JN518X_RFPMODEM->pa_control.pa_lut0.fields.nslice = pLut_Table[0]; // for -30 dBm
		JN518X_RFPMODEM->pa_control.pa_lut1.fields.nslice = pLut_Table[1]; // for -29 dBm
		JN518X_RFPMODEM->pa_control.pa_lut2.fields.nslice = pLut_Table[2]; // for -28 dBm
		JN518X_RFPMODEM->pa_control.pa_lut3.fields.nslice = pLut_Table[3]; // for -27 dBm
		JN518X_RFPMODEM->pa_control.pa_lut4.fields.nslice = pLut_Table[4]; // for -26 dBm
		JN518X_RFPMODEM->pa_control.pa_lut5.fields.nslice = pLut_Table[5]; // for -25 dBm
		JN518X_RFPMODEM->pa_control.pa_lut6.fields.nslice = pLut_Table[6]; // for -24 dBm
		JN518X_RFPMODEM->pa_control.pa_lut7.fields.nslice = pLut_Table[7]; // for -23 dBm
		JN518X_RFPMODEM->pa_control.pa_lut8.fields.nslice = pLut_Table[8]; // for -22 dBm
		JN518X_RFPMODEM->pa_control.pa_lut9.fields.nslice = pLut_Table[9]; // for -21 dBm
		JN518X_RFPMODEM->pa_control.pa_lut10.fields.nslice = pLut_Table[10]; // for -20 dBm
		JN518X_RFPMODEM->pa_control.pa_lut11.fields.nslice = pLut_Table[11]; // for -19 dBm
		JN518X_RFPMODEM->pa_control.pa_lut12.fields.nslice = pLut_Table[12]; // for -18 dBm
		JN518X_RFPMODEM->pa_control.pa_lut13.fields.nslice = pLut_Table[13]; // for -17 dBm
		JN518X_RFPMODEM->pa_control.pa_lut14.fields.nslice = pLut_Table[14]; // for -16 dBm
		JN518X_RFPMODEM->pa_control.pa_lut15.fields.nslice = pLut_Table[15]; // for -15 dBm
		JN518X_RFPMODEM->pa_control.pa_lut16.fields.nslice = pLut_Table[16]; // for -14 dBm
		JN518X_RFPMODEM->pa_control.pa_lut17.fields.nslice = pLut_Table[17]; // for -13 dBm
		JN518X_RFPMODEM->pa_control.pa_lut18.fields.nslice = pLut_Table[18]; // for -12 dBm
		JN518X_RFPMODEM->pa_control.pa_lut19.fields.nslice = pLut_Table[19]; // for -11 dBm
		JN518X_RFPMODEM->pa_control.pa_lut20.fields.nslice = pLut_Table[20]; // for -10 dBm
		JN518X_RFPMODEM->pa_control.pa_lut21.fields.nslice = pLut_Table[21]; // for -9 dBm
		JN518X_RFPMODEM->pa_control.pa_lut22.fields.nslice = pLut_Table[22]; // for -8 dBm
		JN518X_RFPMODEM->pa_control.pa_lut23.fields.nslice = pLut_Table[23]; // for -7 dBm
		JN518X_RFPMODEM->pa_control.pa_lut24.fields.nslice = pLut_Table[24]; // for -6 dBm
		JN518X_RFPMODEM->pa_control.pa_lut25.fields.nslice = pLut_Table[25]; // for -5 dBm
		JN518X_RFPMODEM->pa_control.pa_lut26.fields.nslice = pLut_Table[26]; // for -4 dBm
		JN518X_RFPMODEM->pa_control.pa_lut27.fields.nslice = pLut_Table[27]; // for -3 dBm
		JN518X_RFPMODEM->pa_control.pa_lut28.fields.nslice = pLut_Table[28]; // for -2 dBm
		JN518X_RFPMODEM->pa_control.pa_lut29.fields.nslice = pLut_Table[29]; // for -1 dBm
		JN518X_RFPMODEM->pa_control.pa_lut30.fields.nslice = pLut_Table[30]; // for 0 dBm
		JN518X_RFPMODEM->pa_control.pa_lut31.fields.nslice = pLut_Table[31]; // for 1 dBm
		JN518X_RFPMODEM->pa_control.pa_lut32.fields.nslice = pLut_Table[32]; // for 2 dBm
		JN518X_RFPMODEM->pa_control.pa_lut33.fields.nslice = pLut_Table[33]; // for 3 dBm
		JN518X_RFPMODEM->pa_control.pa_lut34.fields.nslice = pLut_Table[34]; // for 4 dBm
		JN518X_RFPMODEM->pa_control.pa_lut35.fields.nslice = pLut_Table[35]; // for 5 dBm
		JN518X_RFPMODEM->pa_control.pa_lut36.fields.nslice = pLut_Table[36]; // for 6 dBm
		JN518X_RFPMODEM->pa_control.pa_lut37.fields.nslice = pLut_Table[37]; // for 7 dBm
		JN518X_RFPMODEM->pa_control.pa_lut38.fields.nslice = pLut_Table[38]; // for 8 dBm
		JN518X_RFPMODEM->pa_control.pa_lut39.fields.nslice = pLut_Table[39]; // for 9 dBm
		JN518X_RFPMODEM->pa_control.pa_lut40.fields.nslice = pLut_Table[40]; // for 10 dBm
		JN518X_RFPMODEM->pa_control.pa_lut41.fields.nslice = pLut_Table[41]; // for 11 dBm
		JN518X_RFPMODEM->pa_control.pa_lut42.fields.nslice = pLut_Table[42]; // for 12 dBm
		JN518X_RFPMODEM->pa_control.pa_lut43.fields.nslice = pLut_Table[43]; // for 13 dBm
		JN518X_RFPMODEM->pa_control.pa_lut44.fields.nslice = pLut_Table[44]; // for 14 dBm
		JN518X_RFPMODEM->pa_control.pa_lut45.fields.nslice = pLut_Table[45]; // for 15 dBm;
  }

  //************************************************************
  // PA cal starting
  // Assumes that radio G1/G2/PLL groups are on under TMU control
  // and leaves ALL groups OFF at the end
  //************************************************************

  void radio_jn518x_PA_cal(void)
  {
	radio_jn518x_PA_rewrite_lut();
  }


  //********************************************************************
  //** DCO calibration
  //********************************************************************


  void  radio_jn518x_DCO_cal_init(void)
  {

		RESET_PHYON

    // Start DC offset calibration from Bart's file
    vPrintf("Start DC offset cal\n");

    // Following configurations can be set for the DC offset calibration
    //
    // Enable DCO calibration for all 21 gain values (one-hot encoded)
    // For the real software the settings in the next two lines enables all 21 calibrations
    //  JN518X_RFPMODEM->calibration.dco_cal_gain_en_low.fields.gain_en = 0xFFFF;
    //  JN518X_RFPMODEM->calibration.dco_cal_gain_en_high.fields.gain_en = 0x1F;


    // configure to make DC offset block control the coarse offset to the radio
    // this is the 4 bits bus (format MSB=sign, 3LSB=magnitude) op_rx_dcoff_i_d2r_set and op_rx_dcoff_q_d2r_set
    JN518X_RFPMODEM->transceiver.dcoff_d2r_if_src_sel.fields.rx_dcoff_i_set = 1; // 1=function/ cal state machine NOT register
    JN518X_RFPMODEM->transceiver.dcoff_d2r_if_src_sel.fields.rx_dcoff_q_set = 1; // 1=function/ cal state machine NOT register

    // Configure the number of settling/ convergence loops for each of the gain stages being calibrated
    // - up to 4 (one-hot encoded) ie. 0x1, 0x3, 0x7 or 0xf
    // NXH setting was 0x3 (2 loops enabled) - so start with expectation that this will be the required setting
    JN518X_RFPMODEM->calibration.dco_cal_cfg.fields.loop_en = 0x3; // NXH setting was 0x3 to use 2 loops
    //JN518X_RFPMODEM->calibration.dco_cal_cfg.fields.loop_en = 0x1; // This setting would give quickest sim, but may not converge properly
    //JN518X_RFPMODEM->calibration.dco_cal_cfg.fields.loop_en = 0xF; // This would use all stages

    //1.02 >>
    // Disable the update of the coarse DC offset value related to the LNA gain
    JN518X_RFPMODEM->calibration.dco_cal_cfg.fields.lna_gain_val_upd_on_cal_en = 0;
    //<< 1.02

    // Enable the use of the LNA gain related DC offset value later on
  //  JN518X_RFPMODEM->calibration.dco_cal_cfg.fields.lna_gain_val_en = 1;

    // Set the LNA gain for which the DC offset calibration is run
    JN518X_RFPMODEM->calibration.dco_cal_cfg.fields.lna_gain = 7;

    // convergence in each loop is affected by:
    //     the alpha value to affect how quickly the filter reacts, 5bit field // TODO -  what is format of this
    //     the measuring period for the specific loop - units of 1usec, 16bit value up to 65536

    // SMB - shortened even more
    // RF - 1.02
    //1.02 >>
    // Configure the measurement period for each of the loops to 10 us (short simulation)
    JN518X_RFPMODEM->calibration.dco_cal_meas_period[0].fields.meas_period = 625;  // 39.0625us
    JN518X_RFPMODEM->calibration.dco_cal_meas_period[1].fields.meas_period = 625;  // 39.0625us

  // only two loops configured so no need to set measurement periods here
    JN518X_RFPMODEM->calibration.dco_cal_meas_period[2].fields.meas_period = 625;  // 39.0625us
    JN518X_RFPMODEM->calibration.dco_cal_meas_period[3].fields.meas_period = 625;  // 39.0625us
    //<< 1.02

    // Configure the settling time taken into account after gain switch (unit : 62.5 ns)
    JN518X_RFPMODEM->tmu.dco_cal_gain_switch_settling_time.fields.dco_cal_settling_time = 100; // 6.25usec

    //1.02 >>
    // Configure the pause between coarse and find calibration (unit 0.5 us)
    JN518X_RFPMODEM->tmu.dco_cal_fine_cal_pause.fields.dc_fine_cal_pause = 10; // 5usec
    //<< 1.02

    // Configure the DCO cal mode : (0 : coarse only, 1 : fine only, 2: coarse and fine)
    JN518X_RFPMODEM->tmu.cal_mode.fields.dco_cal_mode = 2;
    //JN518X_RFPMODEM->tmu.cal_mode.fields.dco_cal_mode = 3;
    vPrintf("Coarse DCO Config done\n");

  //*********************************************************
  // /*  Config settings to align with table in excel
  //*********************************************************

  // Remove some earlier forces from register back to normal function
     // source=register, not func
     JN518X_RFPMODEM -> transceiver.lna_d2r_if_src_sel.fields.lna_gain_i_1v1_set = 1;
     JN518X_RFPMODEM -> transceiver.ifamp_d2r_if_src_sel.fields.ifamp_gain_i_1v1_set = 1;
     JN518X_RFPMODEM -> transceiver.aaf_1_d2r_if_src_sel.fields.rx_aaf_fc_set = 1;
     JN518X_RFPMODEM -> transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_q_set = 1;
     JN518X_RFPMODEM -> transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_gain_set = 1;


  //*********************************************************
  // Secondly over-ride setting from statemachine where they are wrong
  //*********************************************************
     // To cause the ldo_pa_powerstage enabled during RX1
     JN518X_RFPMODEM->transceiver.ldo_pa_d2r_if_src_sel.fields.powerstage_enable_1v8_rx = 1;  // 1=state machine NOT register

     // force PLL_CAL_IP_AAFC_ENABLE low
     JN518X_RFPMODEM -> transceiver.pll_cal_d2r_if_val.fields.pll_cal_ip_aafc_enable = 0;    // set to 0
     JN518X_RFPMODEM -> transceiver.pll_cal_d2r_if_src_sel.fields.pll_cal_ip_aafc_enable = 0;    // 0=register NOT function


  //*********************************************************
  // Thirdly over-ride change settings to support old method
  //*********************************************************
	 // forced control of lna_enable
	 JN518X_RFPMODEM -> transceiver.lna_d2r_if_src_sel.fields.lna_enable_1v1 = 1;  //0=register NOT function
	 JN518X_RFPMODEM -> transceiver.lna_d2r_if_val.fields.lna_enable_1v1 = 1;

	 // forced control of mixer_enable
	 JN518X_RFPMODEM -> transceiver.mixer_d2r_if_src_sel.fields.enable_1v1 = 1;  //0=register NOT function
	 JN518X_RFPMODEM -> transceiver.mixer_d2r_if_val.fields.enable_1v1 = 1;

	 // forced control of lo_rx_enable
	 JN518X_RFPMODEM -> transceiver.lo_d2r_if_src_sel.fields.rx_enable_1v1 = 1;  //0=register NOT function
	 JN518X_RFPMODEM -> transceiver.lo_d2r_if_val.fields.rx_enable_1v1 = 1;

	 // forced control of hs clipdet enable
	 JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_src_sel.fields.rx_clipdet_hs_enable = 1;  //0=register NOT function
	 JN518X_RFPMODEM -> transceiver.clipdet_d2r_if_val.fields.rx_clipdet_hs_enable = 1;

	 // Set the LNA gain for which the DC-offset calibration is run
	 JN518X_RFPMODEM -> calibration.dco_cal_cfg.fields.lna_gain =7;

     vPrintf("Mixer on settings\n");

     // DC-offset estimator Low-Pass filter cut-off frequecy.
	// Higher 'Alpha' is, Lower the cut-off frequency is.
	//wfield('RFP_CALIBRATION_DCO_CAL_ALPHA_CFG0_ALPHA_LOOP0',0x5)
  	JN518X_RFPMODEM -> calibration.dco_cal_alpha_cfg0.fields.alpha_loop0 = 0x5;
	//wfield('RFP_CALIBRATION_DCO_CAL_ALPHA_CFG0_ALPHA_LOOP1',0x9)
  	JN518X_RFPMODEM -> calibration.dco_cal_alpha_cfg0.fields.alpha_loop1 = 0x9;
	//wfield('RFP_CALIBRATION_DCO_CAL_ALPHA_CFG1_ALPHA_LOOP2',0xa)
  	JN518X_RFPMODEM -> calibration.dco_cal_alpha_cfg1.fields.alpha_loop2 = 0xa;
	//wfield('RFP_CALIBRATION_DCO_CAL_ALPHA_CFG1_ALPHA_LOOP3',0xf)
  	JN518X_RFPMODEM -> calibration.dco_cal_alpha_cfg1.fields.alpha_loop3 = 0xf;



  //*********************************************************
  // End of over-ride change settings to support old method
  //*********************************************************


  //  */      // End of new settings section
    // Disable internal generation of packet start (after pre_start). TMU must simply
    // stay in PLL phase, and not start any RX or TX transfer
    JN518X_RFPMODEM->tmu.mode_ctrl.fields.packet_start_mode = 0; // packet_start_external: The externally generated packet start is generated.
                                                                 // To be clarified !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // Disable automatic assertion of the RX/TX group signals. SW will chose itself
    // later on which part (Rx/Tx) it will power-up/power-down.
    JN518X_RFPMODEM->tmu.mode_ctrl_2.fields.trx_powerup_en = 0; // Specifies whether the TMU initiates the power up for the selected mode during the PLL phase.
                                                                // 0 -> dis: The powerup of the selected mode is under SW control. (Not handled by TMU HW)

    // Avoid interrupt is triggered at the PLL state entering
    JN518X_RFPMODEM->tmu.rfp_tmu_inten.fields.pll_state_start = 0;

//	  // Moved to DCO_cal
//    // SW triggered pre-start. This will trigger the start of the global power sequence
//    radio_jn518x_pre_start_to_pll_polled();  // call pre-start function to get to PLL group state
//
//    radio_jn518x_rx_assert_polled(); // start RX group and poll for done

    RESTORE_PHYON
    }



  void  radio_jn518x_DCO_cal(void)
  {
		// fix implementation
		uint8_t i;

		int32_t fine_a_I, fine_a_Q;
	    int32_t fine_b_I, fine_b_Q;
	    int32_t fine_c_I, fine_c_Q;
	    int32_t DCO_IFamp_input_I_x2048, DCO_IFamp_input_Q_x2048;
	    int32_t DCO_AAF_output_I_x2048, DCO_AAF_output_Q_x2048;
	    int32_t DCO_IFamp_output_I_x2048, DCO_IFamp_output_Q_x2048;
	    int32_t i32remain_I_x2048, i32remain_Q_x2048;
	    int32_t i32fine_I_fix, i32fine_Q_fix;
	    uint16_t reg_fine_a_I, reg_fine_a_Q;
	    uint16_t reg_fine_b_I, reg_fine_b_Q;
	    uint16_t reg_fine_c_I, reg_fine_c_Q;
	    int32_t DCO_I_Calc_div_LSBexp_x2048, DCO_Q_Calc_div_LSBexp_x2048;
	    int64_t DCO_I_Calc_div_LSBexp_x2048x4096x65536, DCO_Q_Calc_div_LSBexp_x2048x4096x65536;
	    uint8_t u8CoarseI_en_fix, u8CoarseQ_en_fix;
	    uint8_t u8CoarseI_fix, u8CoarseQ_fix;

	    uint8_t LSBexp[7] = {23, 33, 23, 33, 23, 33, 47};

	    int16_t G_AAF_LSBexpx65536[7][2] = {{2849, 2849},
	    								 {2838, 1986},
	    								 {5685, 2849},
										 {5662, 1986},
										 {10959, 2849},
										 {10789, 1986},
										 {10815, 1409}}; // 7.673615/46.5, 1.0/46.5, that is 46.5 iso 47 previously

	    uint16_t G_IFampx4096[3] = {4096, 15218, 44912};


     radio_jn518x_DCO_cal_init();

     if (RadioConfiguration.bDoCalibrate)
     {

		 RESET_PHYON

		// 2 following calls moved from DCO_cal_init
		// SW triggered pre-start. This will trigger the start of the global power sequence
		radio_jn518x_pre_start_to_pll_polled();  // call pre-start function to get to PLL group state
		radio_jn518x_rx_assert_polled(); // start RX group and poll for done

		// RAZ previous DCO_cal results
		for (i=0;i<21;i++)
		{
			JN518X_RFPMODEM ->calibration.dco_cal_dc_offset_gain_index.val = i;

			JN518X_RFPMODEM ->calibration.dco_cal_dc_ana_offset_i.val = 0;
			JN518X_RFPMODEM ->calibration.dco_cal_dc_ana_offset_q.val = 0;
			JN518X_RFPMODEM ->calibration.dco_cal_dc_offset_i.val= 0;
			JN518X_RFPMODEM ->calibration.dco_cal_dc_offset_q.val= 0;
		}


		JN518X_RFPMODEM->tmu.cal_mode.fields.dco_cal_mode = 1;           // Fine_only: Only fine DC offset calibration is selected.
		JN518X_RFPMODEM->calibration.dco_cal_cfg.fields.coarse_tables=0; // When set to 0 : ???

		 // First step is to measure DCO for 3 gain configurations
		 // fine cal for index 0 and 6
		JN518X_RFPMODEM->calibration.dco_cal_gain_en_low.fields.gain_en = 0x0041;
		JN518X_RFPMODEM->calibration.dco_cal_gain_en_high.fields.gain_en = 0x00;
		// Forcing ifamp_gain - HW FSM sets this to 2 during all DCO operations. BUT this should be controlled in coarse dco and then affected by the fine dco loop value
		JN518X_RFPMODEM -> transceiver.ifamp_d2r_if_src_sel.fields.ifamp_gain_i_1v1_set = 0;  //0=register NOT function
		JN518X_RFPMODEM -> transceiver.ifamp_d2r_if_val.fields.ifamp_gain_i_1v1_set = 0;

		JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_DCO_CAL_DONE_POS);

		JN518X_RFPMODEM->tmu.cal_triggers.val = (0x1 << EXTAPB_REGFILE_TMU_CAL_TRIGGERS_DCO_CAL_EN_POS);

		while(JN518X_RFPMODEM->tmu.rfp_tmu_cal_intstat.fields.dco_cal_done == 0)
		{
		  radio_waitNus(1); // Some dummy action
		}
		JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_DCO_CAL_DONE_POS);

		 // fine cal for index 20
		JN518X_RFPMODEM->calibration.dco_cal_gain_en_low.fields.gain_en = 0x0000;
		JN518X_RFPMODEM->calibration.dco_cal_gain_en_high.fields.gain_en = 0x10;
		// Forcing ifamp_gain - HW FSM sets this to 2 during all DCO operations. BUT this should be controlled in coarse dco and then affected by the fine dco loop value
		JN518X_RFPMODEM -> transceiver.ifamp_d2r_if_src_sel.fields.ifamp_gain_i_1v1_set = 0;  //0=register NOT function
		JN518X_RFPMODEM -> transceiver.ifamp_d2r_if_val.fields.ifamp_gain_i_1v1_set = 2;

		JN518X_RFPMODEM->tmu.cal_triggers.val = (0x1 << EXTAPB_REGFILE_TMU_CAL_TRIGGERS_DCO_CAL_EN_POS);

		while(JN518X_RFPMODEM->tmu.rfp_tmu_cal_intstat.fields.dco_cal_done == 0)
		{
		  radio_waitNus(1); // Some dummy action
		}
		JN518X_RFPMODEM->tmu.rfp_tmu_cal_intclrstat.val = (0x1 << EXTAPB_REGFILE_TMU_RFP_TMU_CAL_INTCLRSTAT_DCO_CAL_DONE_POS);

		// 2 following calls moved from vRadio_Jn518x_RadioInit
		radio_jn518x_rx_deassert_polled();
		radio_jn518x_power_down_to_off_polled();

		RESTORE_PHYON
     }

	//Then restore some settings

	JN518X_RFPMODEM -> transceiver.ifamp_d2r_if_src_sel.fields.ifamp_gain_i_1v1_set = 1;  //1=function NOT register

	 JN518X_RFPMODEM -> transceiver.pll_cal_d2r_if_src_sel.fields.pll_cal_ip_aafc_enable = 1;  // 1=function NOT register

	 JN518X_RFPMODEM->calibration.dco_cal_cfg.fields.coarse_tables=2; // When set to 0 : ???

	 // The fine registers at index 0,6,20 are now filled with the DC offset values
	// The next step is to calculate the 3 DC offset contributors
	// by solving the 3 equations / 3 unknowns system



     if (RadioConfiguration.bDoCalibrate)
     {
	    // get fine_a/b/c values from cal results
	    JN518X_RFPMODEM ->calibration.dco_cal_dc_offset_gain_index.val = 0;
	    reg_fine_a_I = JN518X_RFPMODEM -> calibration.dco_cal_dc_offset_i.fields.fine_dc_offset_i;
	    reg_fine_a_Q = JN518X_RFPMODEM -> calibration.dco_cal_dc_offset_q.fields.fine_dc_offset_q;
	    fine_a_I = ((int32_t)(reg_fine_a_I<<20))>>20;
	    fine_a_Q = ((int32_t)(reg_fine_a_Q<<20))>>20;
	    JN518X_RFPMODEM ->calibration.dco_cal_dc_offset_gain_index.val = 6;
	    reg_fine_b_I = JN518X_RFPMODEM -> calibration.dco_cal_dc_offset_i.fields.fine_dc_offset_i;
	    reg_fine_b_Q = JN518X_RFPMODEM -> calibration.dco_cal_dc_offset_q.fields.fine_dc_offset_q;
	    fine_b_I = ((int32_t)(reg_fine_b_I<<20))>>20;
	    fine_b_Q = ((int32_t)(reg_fine_b_Q<<20))>>20;
	    JN518X_RFPMODEM ->calibration.dco_cal_dc_offset_gain_index.val = 20;
	    reg_fine_c_I = JN518X_RFPMODEM -> calibration.dco_cal_dc_offset_i.fields.fine_dc_offset_i;
	    reg_fine_c_Q = JN518X_RFPMODEM -> calibration.dco_cal_dc_offset_q.fields.fine_dc_offset_q;
	    fine_c_I = ((int32_t)(reg_fine_c_I<<20))>>20;
	    fine_c_Q = ((int32_t)(reg_fine_c_Q<<20))>>20;

	    // 3 DC offset contributors calculation (with approximation)
	    DCO_IFamp_input_I_x2048 = (fine_c_I - fine_b_I)*5;
	    DCO_IFamp_input_Q_x2048 = (fine_c_Q - fine_b_Q)*5;

	    DCO_AAF_output_I_x2048 = 447 * fine_a_I - 57 * fine_b_I;
	    DCO_AAF_output_Q_x2048 = 447 * fine_a_Q - 57 * fine_b_Q;

	    DCO_IFamp_output_I_x2048 = -57 * fine_a_I + 62 * fine_b_I - 5 * fine_c_I;
	    DCO_IFamp_output_Q_x2048 = -57 * fine_a_Q + 62 * fine_b_Q - 5 * fine_c_Q;

	    // loop to calculate the 21 fine and coarse values based on a table containing for each index:
	    // int16 gain_AAF/LSBexp*65536, int16 1/LSBexp*65536, uint16 GainIFamp*65536 and uint8_t LSBexp

	    for (i=0;i<21;i++)
	    {
	    	DCO_I_Calc_div_LSBexp_x2048x4096x65536 = (int64_t)(G_IFampx4096[((uint8_t)(i/7))]) * (int64_t)(G_AAF_LSBexpx65536[i%7][0]) * (int64_t)DCO_IFamp_input_I_x2048 +
	    											(int64_t)(G_AAF_LSBexpx65536[i%7][0]) * (int64_t)DCO_IFamp_output_I_x2048*4096 +
													(int64_t)DCO_AAF_output_I_x2048 * (int64_t)(G_AAF_LSBexpx65536[i%7][1])*4096;
	    	DCO_Q_Calc_div_LSBexp_x2048x4096x65536 = (int64_t)(G_IFampx4096[((uint8_t)(i/7))]) * (int64_t)(G_AAF_LSBexpx65536[i%7][0]) * (int64_t)DCO_IFamp_input_Q_x2048 +
	    											(int64_t)(G_AAF_LSBexpx65536[i%7][0]) * (int64_t)DCO_IFamp_output_Q_x2048*4096 +
													(int64_t)DCO_AAF_output_Q_x2048 * (int64_t)(G_AAF_LSBexpx65536[i%7][1]*4096);

	    	DCO_I_Calc_div_LSBexp_x2048 = (int32_t)(DCO_I_Calc_div_LSBexp_x2048x4096x65536/4096/65536);
	    	DCO_Q_Calc_div_LSBexp_x2048 = (int32_t)(DCO_Q_Calc_div_LSBexp_x2048x4096x65536/4096/65536);

	    	if ((DCO_I_Calc_div_LSBexp_x2048>=(-1024)) && (DCO_I_Calc_div_LSBexp_x2048<=1024))
	    	{
	    		u8CoarseI_en_fix = 0;
	    		u8CoarseI_fix =0;
	    		i32remain_I_x2048 = DCO_I_Calc_div_LSBexp_x2048 * LSBexp[i%7];
	    	}
	    	else
	    	{
	    		u8CoarseI_en_fix = 1;
	    		if (DCO_I_Calc_div_LSBexp_x2048>1024)
	    		{
	    			u8CoarseI_fix = (uint8_t)((DCO_I_Calc_div_LSBexp_x2048 + 1024)/2048) -1;
	    		}
	    		else
	    		{
	    			u8CoarseI_fix = 7 - (uint8_t)((DCO_I_Calc_div_LSBexp_x2048 - 1024)/2048);
	    		}
	    		//if (u8CoarseI_fix < 0) u8CoarseI_fix = 0; // cannot happen the way it is calculated
	    		if (u8CoarseI_fix > 15) u8CoarseI_fix = 15;

	    		if (u8CoarseI_fix < 8)
	    			i32remain_I_x2048 = (DCO_I_Calc_div_LSBexp_x2048 - (u8CoarseI_fix + 1)*2048) * LSBexp[i%7];
	    		else
	    			i32remain_I_x2048 = (DCO_I_Calc_div_LSBexp_x2048 + (u8CoarseI_fix - 7)*2048) * LSBexp[i%7];
	    	}

	    	if ((DCO_Q_Calc_div_LSBexp_x2048>=(-1024)) && (DCO_Q_Calc_div_LSBexp_x2048<=1024))
	    	{
	    		u8CoarseQ_en_fix = 0;
	    		u8CoarseQ_fix =0;
	    		i32remain_Q_x2048 = DCO_Q_Calc_div_LSBexp_x2048 * LSBexp[i%7];
	    	}
	    	else
	    	{
	    		u8CoarseQ_en_fix = 1;
	    		if (DCO_Q_Calc_div_LSBexp_x2048>1024)
	    		{
	    			u8CoarseQ_fix = (uint8_t)((DCO_Q_Calc_div_LSBexp_x2048 + 1024)/2048) -1;
	    		}
	    		else
	    		{
	    			u8CoarseQ_fix = 7 - (uint8_t)((DCO_Q_Calc_div_LSBexp_x2048 - 1024)/2048);
	    		}
	    		//if (u8CoarseQ_fix < 0) u8CoarseQ_fix = 0; // cannot happen the way it is calculated
	    		if (u8CoarseQ_fix > 15) u8CoarseQ_fix = 15;

	    		if (u8CoarseQ_fix < 8)
	    			i32remain_Q_x2048 = (DCO_Q_Calc_div_LSBexp_x2048 - (u8CoarseQ_fix + 1)*2048) * LSBexp[i%7];
	    		else
	    			i32remain_Q_x2048 = (DCO_Q_Calc_div_LSBexp_x2048 + (u8CoarseQ_fix - 7)*2048) * LSBexp[i%7];
	    	}

	    	i32fine_I_fix = (int32_t)((i32remain_I_x2048/390) + 0.5);
	    	if (i32fine_I_fix <-2048) i32fine_I_fix =-2048;
	    	if (i32fine_I_fix >2047) i32fine_I_fix =2047;

    		i32fine_Q_fix = (int32_t)((i32remain_Q_x2048/390) + 0.5);

	    	if (i32fine_Q_fix <-2048) i32fine_Q_fix =-2048;
	    	if (i32fine_Q_fix >2047) i32fine_Q_fix =2047;

	    	// write values
		    JN518X_RFPMODEM ->calibration.dco_cal_dc_offset_gain_index.val = i;

		    JN518X_RFPMODEM ->calibration.dco_cal_dc_ana_offset_i.fields.coarse_dc_offset_i_en = u8CoarseI_en_fix;
		    JN518X_RFPMODEM ->calibration.dco_cal_dc_ana_offset_q.fields.coarse_dc_offset_q_en = u8CoarseQ_en_fix;
		    JN518X_RFPMODEM ->calibration.dco_cal_dc_ana_offset_i.fields.coarse_dc_offset_i = u8CoarseI_fix;
		    JN518X_RFPMODEM ->calibration.dco_cal_dc_ana_offset_q.fields.coarse_dc_offset_q = u8CoarseQ_fix;
		    JN518X_RFPMODEM ->calibration.dco_cal_dc_offset_i.fields.fine_dc_offset_i = i32fine_I_fix;
		    JN518X_RFPMODEM ->calibration.dco_cal_dc_offset_q.fields.fine_dc_offset_q = i32fine_Q_fix;

	    }
     } // eof if (RadioConfiguration.bDoCalibrate)
  }


  //********************************************************************
  //** IQ Mismatch calibration
  // Assumes that radio G1/G2/PLL groups are off
  // and leaves ALL groups OFF at the end
  //************************************************************
  //********************************************************************

  void  radio_jn518x_IQ_cal(void)
  {
	    uint32_t u32IQCrossGain;
	    uint32_t u32IQ_Cross_val;
	    uint32_t u32IQ_Scale_val;

	    /* read current calibration from flash*/
		u32IQCrossGain = *(uint32_t *)0x9fd20;
		u32IQ_Cross_val = ((u32IQCrossGain >> 10) & 0x7FF);
		u32IQ_Scale_val = u32IQCrossGain & 0x3FF;

		if ((u32IQ_Cross_val & 0x1) && (u32IQ_Scale_val & 0x1) && (RadioConfiguration.u32ATECalDate >= 20180301))
		{
		    JN518X_RFPMODEM->calibration.iq_cal_cross_factor.fields.iq_mismatch_cross_factor= (u32IQ_Cross_val >> 1);
		    JN518X_RFPMODEM->calibration.iq_cal_scale_factor.fields.iq_mismatch_scale_factor = (u32IQ_Scale_val >> 1);

		}
		else
		{

		}
  }




  void vRadio_jn518x_ActivateXtal32MRadioBiasing(void)
  {
	     uint32_t u32TmpVal;

	     // TEST ZB RESET&CLK: reset RFP only
#ifdef INIT_OPTIM_ZB_BLE
	  if (RadioConfiguration.bDisableZBRadio)
	  {
		  JN518X_SYSCON -> PRESETCTRLSET1 = 	(SYSCON_PRESETCTRLSET1_RFP_RST_SET_Msk);
	  }
	  else
	  {
		  JN518X_SYSCON -> PRESETCTRLSET1 = 	(	SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk
												  | SYSCON_PRESETCTRLSET1_RFP_RST_SET_Msk);
	  }
#else
		JN518X_SYSCON -> PRESETCTRLSET1 = 	(	SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk
											  | SYSCON_PRESETCTRLSET1_RFP_RST_SET_Msk);
#endif

	  	// Enable access to Async APB
	  	JN518X_SYSCON -> ASYNCAPBCTRL_b.ENABLE = 1; // Enables the asynchronous APB bridge and subsystem

	  	// Enable Zigbee and BLE APB clocks (for Registers Access)
	  	//     JN518X_SYSCON -> AHBCLKCTRL1_b.ZIGBEE       = 1;
	  	//     JN518X_SYSCON -> AHBCLKCTRL1_b.BLE          = 1;
	  	//     JN518X_SYSCON -> AHBCLKCTRL1_b.RFP          = 1;
	  	//     JN518X_SYSCON -> AHBCLKCTRL1_b.MODEM_MASTER = 1; // master clock for DMA
	  	// TEST ZB RESET&CLK
#ifdef INIT_OPTIM_ZB_BLE
		if (RadioConfiguration.bDisableZBRadio)
		{
			JN518X_SYSCON -> AHBCLKCTRLSET1 = (   SYSCON_AHBCLKCTRL1_BLE_Msk
												 | SYSCON_AHBCLKCTRL1_RFP_Msk
												 |SYSCON_AHBCLKCTRL1_MODEM_MASTER_Msk);
		}
		else if (RadioConfiguration.bDisableBLERadio)
		{
			JN518X_SYSCON -> AHBCLKCTRLSET1 = (   SYSCON_AHBCLKCTRL1_ZIGBEE_Msk
												 | SYSCON_AHBCLKCTRL1_RFP_Msk
												 |SYSCON_AHBCLKCTRL1_MODEM_MASTER_Msk);
		}
		else
		{
			JN518X_SYSCON -> AHBCLKCTRLSET1 = (   SYSCON_AHBCLKCTRL1_ZIGBEE_Msk
												 | SYSCON_AHBCLKCTRL1_BLE_Msk
												 | SYSCON_AHBCLKCTRL1_RFP_Msk
												 |SYSCON_AHBCLKCTRL1_MODEM_MASTER_Msk);
		}
#else

		JN518X_SYSCON -> AHBCLKCTRLSET1 = (   SYSCON_AHBCLKCTRL1_ZIGBEE_Msk
											 | SYSCON_AHBCLKCTRL1_BLE_Msk
											 | SYSCON_AHBCLKCTRL1_RFP_Msk
											 |SYSCON_AHBCLKCTRL1_MODEM_MASTER_Msk);
#endif
	  	JN518X_SYSCON -> PRESETCTRLCLR1 = 	(SYSCON_PRESETCTRLSET1_RFP_RST_SET_Msk);

	     // get trimr
	     JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 1;    // Disable the 16MHz clock to RFP
	                                                                                          // (op_xo16m_to_rfp_enable_d2r)
	  	u32TmpVal = *(uint32_t *)0x9FC88;
	  	if (u32TmpVal & 0x1)
	  	{
	  		u32TmpVal = (u32TmpVal >> 1) & 0x0000001f;
	  	}
	  	else
	  	{
	  		u32TmpVal = 32-TRIMR_INIT_VAL-1; // RF - 20170601
	  	}

	      // TRIMR
	      JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_val.fields.trimr_set = u32TmpVal;       // complemented R Calibration trim value
	      JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_src_sel.fields.trimr_set = 0;                // source=register, not R calibration nominal value



	     // Disable the 16MHz clock (xo16m_clk_r2d) distribution to RFP as long as XTAL 32 MHz not ready
	     // This line could be removed as xo16m_to_rfp_enable = 0 at reset now, in order to protect RFP flop states at JN518x restart.
	     // Hence at restart, the RFP 16MHz clock is defined to LOW level as long as the radio XO 32MHz isn't avaliable.
	     // See RFT1165 artifact for more details.

	     JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 0;    // Disable the 16MHz clock to RFP
	                                                                                          // (op_xo16m_to_rfp_enable_d2r)

	     // Enable 1.4V LDO for DC-bus biasing start-up asap
	     JN518X_RFPMODEM -> transceiver.rx_ldo_d2r_if_val.fields.rx_ldo_1v4_enable = 1;       // op_rx_ldo_1v4_enable_d2r
	     JN518X_RFPMODEM -> transceiver.rx_ldo_d2r_if_src_sel.fields.rx_ldo_1v4_enable = 0;   // source=register, not func

	     // Enable synthesizer internal current mirror to allow XTAL biasing
	     JN518X_RFPMODEM -> transceiver.pll_cur_mir_d2r_if_val.fields.pll_cur_mir_enable = 0; // op_pll_cur_mir_enable_d2r

#ifdef INIT_OPTIM_ZB_BLE
#else
	     radio_waitNus(30); // 30us Wait for good settling of the XO biasing current provided by radio biasing in order to avoid disappearing
	                               // of the XO output signal.
#endif

	     // XTAL not in standalone mode in order to be radio biased (will be effective when XTAL 32 MHz controls coming from PMC disabled)
	     //JN518X_ASYSCON -> XTAL32MCTRL |= (1<<27); // pll_xo_standalone_enable_d2r_core forced to 1
	     JN518X_ASYSCON -> XTAL32MCTRL_b.XO_STANDALONE_ENABLE = 1; // pll_xo_standalone_enable_d2r_core forced to 0

	     // XTAL 32 MHz is already running as it's controlled by the PMC. Hence pll_xo_standalone_enable_d2r_core has been forced to 1.

	     // Enable the 32MHz clock distribution to MCU when XTAL 32 MHz ready
	     // Assumption is here the XTAL 32 MHz ready but for MRA2 then activation will have to be done only after checking
	     // that JN518X_ASYSCON -> RADIOSTATUS is asserted.
	     // Be careful, this programming will be effective only when XTAL 32 MHz controls coming from PMC will be disabled.
	     // Please note that 32MHz clock to digital core distribution is already activated automaticallty by PMC.
	     // Following writing is to avoid temporary stop of the 32MHz clock to digital core distribution.
	//     JN518X_ASYSCON -> XTAL32MCTRL |= (1<<28); // Enable the 32MHz clock to digital core (CGU, MCU)

	     // XTAL 32 MHz is already running as it's controlled by the PMC. Hence pll_xo_standalone_enable_d2r_core has been forced to 1.

	     // Early synthesizer LDO activation to get out of loop-back divider meta-stable state (in rare cases)
	     // before radio analog part activation. pll_ldo_synth is used to enable the div-N.
	     JN518X_RFPMODEM -> transceiver.ldo_synth_d2r_if_val.fields.enable_1v8 = 1 ;              // op_ldo_synth_enable_d2r
	     JN518X_RFPMODEM -> transceiver.ldo_synth_d2r_if_src_sel.fields.enable_1v8 = 0 ;          // source=register, not TMU


	     //JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 1;    // Enable the 16MHz clock to RFP
	                                                                                          // (op_xo16m_to_rfp_enable_d2r)

	     // Enable the 32MHz clock distribution to MCU when XTAL 32 MHz ready
	//     JN518X_ASYSCON -> XTAL32MCTRL |= (1<<28); // Enable the 32MHz clock to digital core (CGU, MCU)


	   	// TEST ZB RESET&CLK
#ifdef INIT_OPTIM_ZB_BLE
			if (!RadioConfiguration.bDisableZBRadio)
			{
			   	JN518X_SYSCON -> PRESETCTRLCLR1 = 	(SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk);
			}
#else
	   	JN518X_SYSCON -> PRESETCTRLCLR1 = 	(SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk);
#endif

	   	// Modem Clocks source selection
	   	// TEST ZB RESET&CLK
#ifdef INIT_OPTIM_ZB_BLE
		if (RadioConfiguration.bDisableZBRadio)
		{
		   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_BLE       = 0;
		}
		else if (RadioConfiguration.bDisableBLERadio)
		{
		   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_ZIGBEE    = 0;
		}
		else
		{
		   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_ZIGBEE    = 0;
		   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_BLE       = 0;
		}
#else
	   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_ZIGBEE    = 0;
	   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_BLE       = 0;
#endif

		// RFBandGap calibration
		//radio_jn518x_rfbandgap_cal(RadioConfiguration.u32InitMode);
	    JN518X_RFPMODEM->transceiver.bgr_d2r_if_val.fields.rx_bgr_cur5ua_1v8_set =(((*(uint32_t *)0x9fc88)>>14) & 0x1f);
	    JN518X_RFPMODEM->transceiver.bgr_d2r_if_src_sel.fields.rx_bgr_cur5ua_1v8_set = 0; //0=register NOT function

		// switch XO to Radio Biasing
		//vRadio_JN518x_PowerOnSpecific();
	     //JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 0;    // Dsable the 16MHz clock to RFP


	     JN518X_RFPMODEM -> transceiver.bgr_d2r_if_val.fields.rx_bgr_enable = 1;              // op_rx_bgr_enable_d2r
	     JN518X_RFPMODEM -> transceiver.bgr_d2r_if_src_sel.fields.rx_bgr_enable = 0;          // source=register, not func
#ifdef INIT_OPTIM_ZB_BLE
#else
	     radio_waitNus(15); // 15us RF bandgap currents & 0.6V reference input voltage (vref_vi_0v6) settling time after rx_bgr_enable_1v8 signal assertion.
#endif
	     JN518X_RFPMODEM -> transceiver.pll_cur_mir_d2r_if_val.fields.pll_cur_mir_enable = 1; // op_pll_cur_mir_enable_d2r

#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	     radio_waitNus(15); // 15us Wait for good settling of the XO biasing current provided by radio biasing in order to avoid disappearing
	                               // of the XO output signal.
#else
	     radio_waitNus(30); // 30us Wait for good settling of the XO biasing current provided by radio biasing in order to avoid disappearing
	                               // of the XO output signal.
#endif

	     // Be careful, this programming will be effective only when XTAL 32 MHz controls coming from PMC will be disabled.
	     // Please note that 32MHz clock to digital core distribution is already activated automaticallty by PMC.
	     // Following writing is to avoid temporary stop of the 32MHz clock to digital core distribution.
	     JN518X_ASYSCON -> XTAL32MCTRL_b.XO32M_TO_MCU_ENABLE =1;

	     // Before switching to radio biasing, it is needed to set signals that are controlled by the PMC:
	     // - pll_xo_enable_d2r_core that is JN518X_ASYSCON -> XTAL32MCTRL_b.XO_ENABLE to be set to 1
	     // - ldo_xo_enable_d2r_core that is JN518X_ASYSCON -> XTAL32MLDOCTRL_b.ENABLE to be set to 1
	     // - pll_xo_standalone_enable_d2r_core that is JN518X_ASYSCON -> XTAL32MCTRL_b.XO_STANDALONE_ENABLE to be set to 1
	     // Then we can disable PMC control (JN518X_SYSCON -> XTAL32MCTRL_b.DEACTIVATE_PMC_CTRL = 1)
	     // We keep PMC biasing until we reset pll_xo_standalone_enable_d2r_core to switch to radio biasing

	     JN518X_ASYSCON -> XTAL32MLDOCTRL_b.ENABLE = 1; // ldo_xo_enable
	     JN518X_ASYSCON -> XTAL32MCTRL_b.XO_ENABLE = 1; // pll_xo_enable forced to 1
	     JN518X_SYSCON -> XTAL32MCTRL_b.DEACTIVATE_PMC_CTRL = 1; //disable PMC control
	     JN518X_ASYSCON -> XTAL32MCTRL_b.XO_STANDALONE_ENABLE = 0; // pll_xo_standalone_enable_d2r_core forced to 0

	     JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 1;    // Enable the 16MHz clock to RFP

	     // Early start of DCO_DAC
	     vRadio_Enable_DCO_DAC();

  }


  void radio_jn518x_PowerOnCheckXtal(void)
  {
  	 unsigned long int tmpUIntMask;

     if (JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable == 1)
     { // indicates already done power-up
         vPrintf("   Nothing to do - already done start-up\n");
     }
     else
     {
         vPrintf("   not called before\n");


     // Disable the 16MHz clock (xo16m_clk_r2d) distribution to RFP as long as XTAL 32 MHz not ready
     // This line could be removed as xo16m_to_rfp_enable = 0 at reset now, in order to protect RFP flop states at JN518x restart.
     // Hence at restart, the RFP 16MHz clock is defined to LOW level as long as the radio XO 32MHz isn't avaliable.
     // See RFT1165 artifact for more details.

     JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 0;    // Disable the 16MHz clock to RFP
                                                                                          // (op_xo16m_to_rfp_enable_d2r)

     // Enable 1.4V LDO for DC-bus biasing start-up asap
     JN518X_RFPMODEM -> transceiver.rx_ldo_d2r_if_val.fields.rx_ldo_1v4_enable = 1;       // op_rx_ldo_1v4_enable_d2r
     JN518X_RFPMODEM -> transceiver.rx_ldo_d2r_if_src_sel.fields.rx_ldo_1v4_enable = 0;   // source=register, not func

     // Enable synthesizer internal current mirror to allow XTAL biasing
     JN518X_RFPMODEM -> transceiver.pll_cur_mir_d2r_if_val.fields.pll_cur_mir_enable = 0; // op_pll_cur_mir_enable_d2r

     if (JN518X_PMC -> DPDCTRL_b.XTAL32MSTARTENA == 1)
       {

       // XTAL 32 MHz is already running as it's controlled by the PMC. Hence pll_xo_standalone_enable_d2r_core has been forced to 1.
       // In order to avoid to kill the benefit of have early start of the XTAL, then before to switch XTAL biasing from PMU to Radio biasing
       // (done by pll_xo_standalone_enable_d2r_core forced to 0) then an extra wait stat is added to allow proper settling of the PLL current mirror.
       // Otherwise the XTAL output signal will vanish because radio biasing currents at mirror output are too low.
       // And bad consequence is the XTAL core will have to restart it's convergence.
       radio_waitNus(30); // 30us Wait for good settling of the XO biasing current provided by radio biasing in order to avoid disappearing
                               // of the XO output signal.
       }
     else
       {
       // XTAL 32 MHz is not already running as it's not controlled by the PMC, but by software.
       // Wait for 1.4V LDO output voltage settling time.
       radio_waitNus(10); // 10us Wait for 1.4V LDO output voltage settling time after rx_ldo_1v4_enable signal assertion.
       }

     // XTAL not in standalone mode in order to be radio biased (will be effective when XTAL 32 MHz controls coming from PMC disabled)
     JN518X_ASYSCON -> XTAL32MCTRL |= (1<<27); // pll_xo_standalone_enable_d2r_core forced to 1

     // Set-up XTAL 32 MHz clock LDO
     tmpUIntMask = JN518X_ASYSCON -> XTAL32MLDOCTRL;
     tmpUIntMask &= ~0x3FA; // Mask to clean-up bits fields that will bit written next line
     tmpUIntMask |=  0x1AA;                      // 9:8 7:6 5:3 1
     JN518X_ASYSCON -> XTAL32MLDOCTRL = tmpUIntMask;

     // Enable SW control of XTAL 32 MHz & its LDO.

     if (JN518X_PMC -> DPDCTRL_b.XTAL32MSTARTENA == 0)
     {
     // XTAL 32 MHz is not already running as it's not controlled by the PMC, but by software.

     // Wait for xo32M LDO output voltage settling time before Xo core activation.
     // As a result XTAL 32 MHz ready status bit reset is maintained (pll_xo_enable_d2r_core=0) as long as xo32M LDO output voltage isn't settled.
     radio_waitNus(20); // 20us Wait for xo32M LDO output voltage settling time after op_ldo_xo_enable_d2r_core signal assertion.
     }
     else
     {
     // XTAL 32 MHz is already running as it's controlled by the PMC. Hence pll_xo_standalone_enable_d2r_core has been forced to 1.

     // Enable the 32MHz clock distribution to MCU when XTAL 32 MHz ready
     // Assumption is here the XTAL 32 MHz ready but for MRA2 then activation will have to be done only after checking
     // that JN518X_ASYSCON -> RADIOSTATUS is asserted.
     // Be careful, this programming will be effective only when XTAL 32 MHz controls coming from PMC will be disabled.
     // Please note that 32MHz clock to digital core distribution is already activated automaticallty by PMC.
     // Following writing is to avoid temporary stop of the 32MHz clock to digital core distribution.
     JN518X_ASYSCON -> XTAL32MCTRL |= (1<<28); // Enable the 32MHz clock to digital core (CGU, MCU)
     }

     // Enable & set-up XTAL 32 MHz clock core

     tmpUIntMask = JN518X_ASYSCON -> XTAL32MCTRL;
     tmpUIntMask &= ~0x03C3FFFE;                  // Mask to clean-up bits fields that will bit written next line
     tmpUIntMask |=  0x01C00008;                  // GM 25:23, EN 22, XO_OSC_CAP_OUT 17:11, XO_OSC_CAP_IN 10:4, XO_AMP 3:1
     tmpUIntMask |=  (0x61<<11);                  // Configure XO_OSC_CAP_OUT
     tmpUIntMask |=  (0x61<<4);                   // Configure XO_OSC_CAP_IN
     tmpUIntMask |=  (0x01<<26);				  // Configure XO_Salve TO BE CHEKED AND REPLACE BY SYMBOLS

     JN518X_ASYSCON -> XTAL32MCTRL = tmpUIntMask;

     if (JN518X_PMC -> DPDCTRL_b.XTAL32MSTARTENA == 1)
     {
     // XTAL 32 MHz is already running as it's controlled by the PMC. Hence pll_xo_standalone_enable_d2r_core has been forced to 1.

     // Early synthesizer LDO activation to get out of loop-back divider meta-stable state (in rare cases)
     // before radio analog part activation. pll_ldo_synth is used to enable the div-N.
     JN518X_RFPMODEM -> transceiver.ldo_synth_d2r_if_val.fields.enable_1v8 = 1 ;              // op_ldo_synth_enable_d2r
     JN518X_RFPMODEM -> transceiver.ldo_synth_d2r_if_src_sel.fields.enable_1v8 = 0 ;          // source=register, not TMU

     }
     else
     {
     // XTAL 32 MHz is not already running as it's not controlled by the PMC, but by software.

    // Early synthesizer LDO activation to get out of loop-back divider meta-stable state (in rare cases)
     // before radio analog part activation. pll_ldo_synth is used to enable the div-N.
     JN518X_RFPMODEM -> transceiver.ldo_synth_d2r_if_val.fields.enable_1v8 = 1 ;              // op_ldo_synth_enable_d2r
     JN518X_RFPMODEM -> transceiver.ldo_synth_d2r_if_src_sel.fields.enable_1v8 = 0 ;          // source=register, not TMU

     // Enable the 16MHz clock (xo16m_clk_r2d) distribution to RFP when XTAL 32 MHz ready
     // Add wait state loop while XTAL 32 MHz not stabilized
     // -> either wait for "ip_pll_xo_ready" status signal assertion,
     // -> or wait for timer duration (clkout toggling expected after 220us
     //    or 90% osc_in full swing ~520usec with Crystal FA128 & 1.1V supply)
     // Then 16 MHz clock can be provided to RFP

     // Wait for 32 MHz XTAL settling time
     // Please note that "ip_pll_xo_ready" status signal pooling method is the prefered one before
     // 16MHz clock distribution to RFP, as done by the code in comment bellow.
     // However due to hardware limitation, this method need redesign of the control & functionnnality of the block
     // providing the 'XO flag ready' information. This redesign is postpone to MRA2.
     // The existing design doesn't guarantee XO signal activity indication & XTAL 32 MHz ready status reset not
     // guaranteed when XO starts-up under PMC control
     // Take a look one RFT1157 & RFT1159 artifacts for more details.

  #if defined(CPU_JN518X_REV)&&(CPU_JN518X_REV == 1)
     radio_waitNus(620); // 620us wait state as 32MHz XO wreal model has a 600us start-up time.
  #else
     while((JN518X_ASYSCON -> RADIOSTATUS & 1) == 0) // -> To be considered for MRA2
     {
        radio_waitNus(10); // Some dummy action -> To be considered for MRA2
     }
     radio_waitNus(200); // extra wait to ensure XTAL is accurate enougth
  #endif

     }

     JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 1;    // Enable the 16MHz clock to RFP
                                                                                          // (op_xo16m_to_rfp_enable_d2r)

     // Enable the 32MHz clock distribution to MCU when XTAL 32 MHz ready
     JN518X_ASYSCON -> XTAL32MCTRL |= (1<<28); // Enable the 32MHz clock to digital core (CGU, MCU)

     }  // end of else linked to check if function already called

  }


  void radio_jn518x_PowerOn(void)
  {

     if (JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable == 1)
     { // indicates already done power-up
         vPrintf("   Nothing to do - already done start-up\n");
     }
     else
     {
         vPrintf("   not called before\n");


     // Disable the 16MHz clock (xo16m_clk_r2d) distribution to RFP as long as XTAL 32 MHz not ready
     // This line could be removed as xo16m_to_rfp_enable = 0 at reset now, in order to protect RFP flop states at JN518x restart.
     // Hence at restart, the RFP 16MHz clock is defined to LOW level as long as the radio XO 32MHz isn't avaliable.
     // See RFT1165 artifact for more details.

     JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 0;    // Disable the 16MHz clock to RFP
                                                                                          // (op_xo16m_to_rfp_enable_d2r)

     // Enable 1.4V LDO for DC-bus biasing start-up asap
     JN518X_RFPMODEM -> transceiver.rx_ldo_d2r_if_val.fields.rx_ldo_1v4_enable = 1;       // op_rx_ldo_1v4_enable_d2r
     JN518X_RFPMODEM -> transceiver.rx_ldo_d2r_if_src_sel.fields.rx_ldo_1v4_enable = 0;   // source=register, not func

     // Enable synthesizer internal current mirror to allow XTAL biasing
     JN518X_RFPMODEM -> transceiver.pll_cur_mir_d2r_if_val.fields.pll_cur_mir_enable = 0; // op_pll_cur_mir_enable_d2r

     radio_waitNus(30); // 30us Wait for good settling of the XO biasing current provided by radio biasing in order to avoid disappearing
                               // of the XO output signal.

     // XTAL not in standalone mode in order to be radio biased (will be effective when XTAL 32 MHz controls coming from PMC disabled)
     JN518X_ASYSCON -> XTAL32MCTRL |= (1<<27); // pll_xo_standalone_enable_d2r_core forced to 1

     // XTAL 32 MHz is already running as it's controlled by the PMC. Hence pll_xo_standalone_enable_d2r_core has been forced to 1.

     // Enable the 32MHz clock distribution to MCU when XTAL 32 MHz ready
     // Assumption is here the XTAL 32 MHz ready but for MRA2 then activation will have to be done only after checking
     // that JN518X_ASYSCON -> RADIOSTATUS is asserted.
     // Be careful, this programming will be effective only when XTAL 32 MHz controls coming from PMC will be disabled.
     // Please note that 32MHz clock to digital core distribution is already activated automaticallty by PMC.
     // Following writing is to avoid temporary stop of the 32MHz clock to digital core distribution.
     JN518X_ASYSCON -> XTAL32MCTRL |= (1<<28); // Enable the 32MHz clock to digital core (CGU, MCU)

     // XTAL 32 MHz is already running as it's controlled by the PMC. Hence pll_xo_standalone_enable_d2r_core has been forced to 1.

     // Early synthesizer LDO activation to get out of loop-back divider meta-stable state (in rare cases)
     // before radio analog part activation. pll_ldo_synth is used to enable the div-N.
     JN518X_RFPMODEM -> transceiver.ldo_synth_d2r_if_val.fields.enable_1v8 = 1 ;              // op_ldo_synth_enable_d2r
     JN518X_RFPMODEM -> transceiver.ldo_synth_d2r_if_src_sel.fields.enable_1v8 = 0 ;          // source=register, not TMU


     JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 1;    // Enable the 16MHz clock to RFP
                                                                                          // (op_xo16m_to_rfp_enable_d2r)

     // Enable the 32MHz clock distribution to MCU when XTAL 32 MHz ready
//     JN518X_ASYSCON -> XTAL32MCTRL |= (1<<28); // Enable the 32MHz clock to digital core (CGU, MCU)

     }  // end of else linked to check if function already called

  }




  void vRadio_JN518x_PowerOnSpecific(void)
  {
	  // switch to radio biasing
	 JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 0;    // Dsable the 16MHz clock to RFP


	 JN518X_RFPMODEM -> transceiver.bgr_d2r_if_val.fields.rx_bgr_enable = 1;              // op_rx_bgr_enable_d2r
	 JN518X_RFPMODEM -> transceiver.bgr_d2r_if_src_sel.fields.rx_bgr_enable = 0;          // source=register, not func
	 radio_waitNus(15); // 15us RF bandgap currents & 0.6V reference input voltage (vref_vi_0v6) settling time after rx_bgr_enable_1v8 signal assertion.
	 JN518X_RFPMODEM -> transceiver.pll_cur_mir_d2r_if_val.fields.pll_cur_mir_enable = 1; // op_pll_cur_mir_enable_d2r

	 radio_waitNus(30); // 30us Wait for good settling of the XO biasing current provided by radio biasing in order to avoid disappearing
							   // of the XO output signal.
     JN518X_ASYSCON -> XTAL32MLDOCTRL_b.ENABLE = 1; // ldo_xo_enable
     JN518X_ASYSCON -> XTAL32MCTRL_b.XO_ENABLE = 1; // pll_xo_enable forced to 1
     JN518X_SYSCON -> XTAL32MCTRL_b.DEACTIVATE_PMC_CTRL = 1; //disable PMC control
     JN518X_ASYSCON -> XTAL32MCTRL_b.XO_STANDALONE_ENABLE = 0; // pll_xo_standalone_enable_d2r_core forced to 0

	 JN518X_RFPMODEM -> transceiver.various_d2r_if_val.fields.xo16m_to_rfp_enable = 1;    // Enable the 16MHz clock to RFP

  }



#ifndef USEXTALBASICTRIM
  void vRadio_JN518x_XO_Trim(void)
  {
  	//Light Implementation
  	// for both ES1 and ES2
  	JN518X_ASYSCON -> XTAL32MCTRL_b.XO_SLAVE = 1;
  	JN518X_ASYSCON -> XTAL32MCTRL_b.XO_ACBUF_PASS_ENABLE =1;
  #if defined(CPU_JN518X_REV)&&(CPU_JN518X_REV == 1)
     /* ES1  if explicitly configured */
  	JN518X_ASYSCON -> XTAL32MCTRL_b.XO_OSC_CAP_IN = 103;
  	JN518X_ASYSCON -> XTAL32MCTRL_b.XO_OSC_CAP_OUT = 99;
  #else
     /* ES2 default */
  	JN518X_ASYSCON -> XTAL32MCTRL_b.XO_OSC_CAP_IN = 34;
  	JN518X_ASYSCON -> XTAL32MCTRL_b.XO_OSC_CAP_OUT = 30;
  #endif
  }
#endif

  void vRadio_Jn518x_InitXtal(void)
  {
	// TEST ZB RESET&CLK: reset RFP only
#ifdef INIT_OPTIM_ZB_BLE
	  if (RadioConfiguration.bDisableZBRadio)
	  {
		  JN518X_SYSCON -> PRESETCTRLSET1 = 	(SYSCON_PRESETCTRLSET1_RFP_RST_SET_Msk);
	  }
	  else
	  {
		  JN518X_SYSCON -> PRESETCTRLSET1 = 	(	SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk
												  | SYSCON_PRESETCTRLSET1_RFP_RST_SET_Msk);
	  }
#else
		JN518X_SYSCON -> PRESETCTRLSET1 = 	(	SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk
											  | SYSCON_PRESETCTRLSET1_RFP_RST_SET_Msk);
#endif

  	// Enable access to Async APB
  	JN518X_SYSCON -> ASYNCAPBCTRL_b.ENABLE = 1; // Enables the asynchronous APB bridge and subsystem

  	// Enable Zigbee and BLE APB clocks (for Registers Access)
  	//     JN518X_SYSCON -> AHBCLKCTRL1_b.ZIGBEE       = 1;
  	//     JN518X_SYSCON -> AHBCLKCTRL1_b.BLE          = 1;
  	//     JN518X_SYSCON -> AHBCLKCTRL1_b.RFP          = 1;
  	//     JN518X_SYSCON -> AHBCLKCTRL1_b.MODEM_MASTER = 1; // master clock for DMA

  	// TEST ZB RESET&CLK
#ifdef INIT_OPTIM_ZB_BLE
		if (RadioConfiguration.bDisableZBRadio)
		{
			JN518X_SYSCON -> AHBCLKCTRLSET1 = (   SYSCON_AHBCLKCTRL1_BLE_Msk
												 | SYSCON_AHBCLKCTRL1_RFP_Msk
												 |SYSCON_AHBCLKCTRL1_MODEM_MASTER_Msk);
		}
		else if (RadioConfiguration.bDisableBLERadio)
		{
			JN518X_SYSCON -> AHBCLKCTRLSET1 = (   SYSCON_AHBCLKCTRL1_ZIGBEE_Msk
												 | SYSCON_AHBCLKCTRL1_RFP_Msk
												 |SYSCON_AHBCLKCTRL1_MODEM_MASTER_Msk);
		}
		else
		{
			JN518X_SYSCON -> AHBCLKCTRLSET1 = (   SYSCON_AHBCLKCTRL1_ZIGBEE_Msk
												 | SYSCON_AHBCLKCTRL1_BLE_Msk
												 | SYSCON_AHBCLKCTRL1_RFP_Msk
												 |SYSCON_AHBCLKCTRL1_MODEM_MASTER_Msk);
		}
#else

	JN518X_SYSCON -> AHBCLKCTRLSET1 = (   SYSCON_AHBCLKCTRL1_ZIGBEE_Msk
										 | SYSCON_AHBCLKCTRL1_BLE_Msk
										 | SYSCON_AHBCLKCTRL1_RFP_Msk
										 |SYSCON_AHBCLKCTRL1_MODEM_MASTER_Msk);
#endif
  	JN518X_SYSCON -> PRESETCTRLCLR1 = 	(SYSCON_PRESETCTRLSET1_RFP_RST_SET_Msk);

	/* Power with or without checking/staring XTAL */
	if (RadioConfiguration.bSkipXTAL)
	{
		radio_jn518x_PowerOn();
	}
	else
	{
		radio_jn518x_PowerOnCheckXtal();
	}

  	// TEST ZB RESET&CLK
#ifdef INIT_OPTIM_ZB_BLE
	if (!RadioConfiguration.bDisableZBRadio)
	{
	  	JN518X_SYSCON -> PRESETCTRLCLR1 = 	(SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk);
	}
#else
  	JN518X_SYSCON -> PRESETCTRLCLR1 = 	(SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk);
#endif

  	// Modem Clocks source selection
  	// TEST ZB RESET&CLK
#ifdef INIT_OPTIM_ZB_BLE
		if (RadioConfiguration.bDisableZBRadio)
		{
		   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_BLE       = 0;
		}
		else if (RadioConfiguration.bDisableBLERadio)
		{
		   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_ZIGBEE    = 0;
		}
		else
		{
		   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_ZIGBEE    = 0;
		   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_BLE       = 0;
		}
#else
  	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_ZIGBEE    = 0;
  	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_BLE       = 0;
#endif

	/* Trim XTAL if not done externally */
	if (!RadioConfiguration.bSkipXTAL)
	{
#ifndef USEXTALBASICTRIM
		vRadio_JN518x_XO_Trim();
#else
		CLOCK_XtalBasicTrim();
#endif
	}

  }

  /******************************************************************************************************/
  /*  THE 3 PRECEDING FUNCTIONS ARE TO BE REMOVED WHEN XTAL INIT HAVE BEEN MOVED AWAY FROM RADIO DRIVER */
  /******************************************************************************************************/


/****************************************************************************/
/***		Public functions                                          ***/
/****************************************************************************/

void vRadio_Jn518x_RadioInit(uint32_t u32RadioMode)
{
	int16_t s16DeltaTemp;

	/* do reset and XTAL management only if radio_jn518x_ActivateXtal32MRadioBiasing has not been called before */
	/* To detect it, we check if the XTAL is still under PMC control */
	if (JN518X_SYSCON -> XTAL32MCTRL_b.DEACTIVATE_PMC_CTRL == 0)
	{
		/* Reset HW blocs and prepare XTAL for switching to radio biasing */
		vRadio_Jn518x_InitXtal();
		vRadio_Enable_DCO_DAC();

	}


	// read ATE Calibration date and temp from flash
	vGetCalInfo();
	vRadio_JN518x_Temp_InitKmodData();

	/* Set Init and TxPower mode configuration */
	RadioConfiguration.u32InitMode = (u32RadioMode & 0xff);
	RadioConfiguration.u32TxPowerMode = ((u32RadioMode>>8) & 0xff);



	/* Set RetentionAvailable and CalDate in configuration */
	radio_jn518x_get_retention_info(&RadioConfiguration.u32RetentionAvailable);

	/*Get Temperature info */
	vRadio_JN518x_Temp_GetInfos();

	// First, if TCur not set, assume TCur= TCal_ATE
	if (RadioConfiguration.u8TCur_Received == 0)
	{
			RadioConfiguration.i16TCur = RadioConfiguration.i16ATECalTemp;
	}


	// Evaluate Calibration need
	if ((RadioConfiguration.u32InitMode == RADIO_INIT_DEF_VAL) || (RadioConfiguration.u32InitMode == RADIO_INIT_RETENTION))
	{
		RadioConfiguration.bDoCalibrate =false;
	}
	else if (RadioConfiguration.u32InitMode == RADIO_INIT_FORCE_CAL)
	{
		RadioConfiguration.bDoCalibrate =true; // force all calibrations
	}
	else
	{
		RadioConfiguration.bDoCalibrate =true; // force all calibrations

		if (RadioConfiguration.u8InitDone)
		{
			// calculate delta temp
			s16DeltaTemp = RadioConfiguration.i16TCur - RadioConfiguration.i16TCal;
			// abs value of delta temp
			if (s16DeltaTemp <0) s16DeltaTemp = -s16DeltaTemp;
			// if abs value is lower than 13dCelsius (in 11.1 format) and Retention values are available, no calibration needed
			if ((s16DeltaTemp < i16RecalThresholdTemp) && (RadioConfiguration.u32RetentionAvailable != 0))
			{
				RadioConfiguration.bDoCalibrate =false;
			} // else keep decision to run calibration and TempCur will be taken as TCal
			else
			{
				RadioConfiguration.bDoCalibrate =true;
			}
		} // else keep decision to run calibration and TempCur will be taken as TCal, clear ReCal needed
		else
		{
			RadioConfiguration.bDoCalibrate =true;
		}
	}

	// Check bDoCalibrate, update TCal and reset Recal_Needed if case of new calibration
	if (RadioConfiguration.bDoCalibrate)
	{
		RadioConfiguration.u8ReCal_needed = 0;
	}

	radio_jn518x_Init();

	radio_jn518x_TMU_Init();

// SMB
//         Some initialisation is needed here of cal values to allow full sequence to happen
//         There have three options here -
//         1. we are doing full calibration/initialisation
//              So we can initialise as much as necessary - values will be updated soon anyway
//         2. we have had calibration retention
//              So must not overwrite previous cal values - but good values are in registers
//         3. we are doing init but reusing known cal values to give quicker sim time
//              So we can initialise as much as necessary - values will be updated soon anyway
//
//	// If init with default values or Calibration is forced load default values
//	if ( (RadioConfiguration.u32InitMode == RADIO_INIT_DEF_VAL) || (RadioConfiguration.u32InitMode == RADIO_INIT_FORCE_CAL) )
//	 radio_jn518x_Use_Cal_Values();
//	// else if init forced to use retention (and if Calibration has not been decided iniernaly fefore) use retention values
//	else if ( (RadioConfiguration.u32InitMode == RADIO_INIT_RETENTION) || (!RadioConfiguration.bDoCalibrate))
//	 radio_jn518x_Use_Retained_Cal_Values();

	// If init with retention forced or init cal mode and no calibration decided use retention valuesload default values
	if ( (RadioConfiguration.u32InitMode == RADIO_INIT_RETENTION) ||
		((RadioConfiguration.u32InitMode == RADIO_INIT_INITCAL) && (!RadioConfiguration.bDoCalibrate)) )
		radio_jn518x_Use_Retained_Cal_Values();
	// else load default values
	else
		radio_jn518x_Use_Cal_Values();

	/* Here we can start to run calibrations */

	// RFBandGap calibration
	radio_jn518x_rfbandgap_cal(RadioConfiguration.u32InitMode);

	/* activate radio biasing only if radio_jn518x_ActivateXtal32MRadioBiasing has not been called before */
	/* To detect it, we check if the XTAL is still under PMC control */
	if (JN518X_SYSCON -> XTAL32MCTRL_b.DEACTIVATE_PMC_CTRL == 0)
	{
		// RFBandGap calibration
		//radio_jn518x_rfbandgap_cal(RadioConfiguration.u32InitMode);

		// switch XO to Radio Biasing
		vRadio_JN518x_PowerOnSpecific();
	}


	//C calibration
	radio_jn518x_Rc_Cal(false);

	// Synthe calibration
	radio_jn518x_Synthesizer_Full_Cal();

	// set Zigbee mode before to continue (why ?)
	radio_jn518x_ZigBee_Regular_Init(); // Need confirmation of its need but to be used for safety reason at that moment

	//DC-offset coarse calibration
	//DC-offset fine calibration
	   radio_jn518x_DCO_cal();

// ALPHA
//	// 2 following calls moved to DCO_cal
//	radio_jn518x_rx_deassert_polled();
//	radio_jn518x_power_down_to_off_polled();
// ALPHA



	//I/Q phase mismatch calibration
	//I/Q amplitude mismatch calibration
// ALPHA
	radio_jn518x_IQ_cal(); // TO BE FIXED

	//PA calibration
	radio_jn518x_PA_cal(); // TO BE FIXED

	// Radio control to come from Modem/MAC
	radio_jn518x_Trx_Packet_HW_Ctrl_Init();

	// SMB - options on startup  17/06/2017
	// Since Calibration has not been run - need to set good cal values again
	if ( (RadioConfiguration.u32InitMode == RADIO_INIT_DEF_VAL) )
	  radio_jn518x_Use_Cal_Values();  // write in known good values

	/* End of calibrations */

	/* always enable RFRX and RFTX */
	JN518X_RFPMODEM->transceiver.rf_txrx_d2r_if_val.fields.rfrx =1;
	JN518X_RFPMODEM->transceiver.rf_txrx_d2r_if_val.fields.rftx =1;
	JN518X_RFPMODEM->transceiver.rf_txrx_d2r_if_src_sel.fields.rfrx =1;
	JN518X_RFPMODEM->transceiver.rf_txrx_d2r_if_src_sel.fields.rftx =1;


	// Write radio driver version number in dummy register to tag the driver
	JN518X_RFPMODEM ->dummy.dummy_reg[0].fields.dummy_val= RADIO_JN518X_VERSION;

	// flag that RadioInit has been done and save TCal
	if (RadioConfiguration.bDoCalibrate)
	{
		RadioConfiguration.i16TCal = RadioConfiguration.i16TCur;
		RadioConfiguration.bDoCalibrate = false;
	}
	RadioConfiguration.u8InitDone = 1;

	vRadio_JN518x_Temp_SetInfos();

#if (defined INIT_OPTIM_ZB_BLE_2)
	if (RadioConfiguration.bDisableZBRadio)
	{
	   	JN518X_SYSCON -> PRESETCTRLSET1 = (SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk);
	   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_ZIGBEE = 1;
		JN518X_SYSCON -> AHBCLKCTRLCLR1 = (SYSCON_AHBCLKCTRLCLR1_ZIGBEE_CLK_CLR_Msk);
	}

	if (RadioConfiguration.bDisableBLERadio)
	{
	   	JN518X_SYSCON -> PRESETCTRLSET1 = (SYSCON_PRESETCTRLSET1_BLE_RST_SET_Msk);
	   	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_BLE = 1;
		JN518X_SYSCON -> AHBCLKCTRLCLR1 = (SYSCON_AHBCLKCTRLCLR1_BLE_CLK_CLR_Msk);
	}
#endif

}

void vRadio_Jn518x_RadioDeInit(void)
{
#ifdef INIT_OPTIM_ZB_BLE
	// Disable AHB clock for ZB and BLE
	JN518X_SYSCON -> AHBCLKCTRLCLR1 = (SYSCON_AHBCLKCTRL1_ZIGBEE_Msk | SYSCON_AHBCLKCTRL1_BLE_Msk);
	// Remove modems clk
	JN518X_SYSCON -> MODEMCLKSEL = 0;
#endif
	JN518X_SYSCON -> XTAL32MCTRL_b.DEACTIVATE_PMC_CTRL = 0;
	vRadio_Disable_DCO_DAC();

}


void radio_jn518x_get_retention_info(uint32_t *pu32RetentionAvailable)
{
	*pu32RetentionAvailable = 0; // TO BE COMPLETED

	/* check a set of retention values against their init value */
	/* if all contain the init value, we conclude that calibration has to be done once*/
	// removed trimr test because trimr is now updated in vRadio_jn518x_ActivateXtal32MRadioBiasing, so no longer reliable
	// *pu32RetentionAvailable = (JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_val.fields.trimr_set ^ 0xa);
	*pu32RetentionAvailable = (JN518X_RFPMODEM -> transceiver.r_rc_cal_d2r_if_val.fields.trimc_set ^ 0x3);
	*pu32RetentionAvailable |= (JN518X_RFPMODEM->calibration.kmod_band_cal_corr_1.fields.corr_1 ^ 0x0);
	*pu32RetentionAvailable |= (JN518X_RFPMODEM->calibration.synth_cal_startup_afc_diff_rx.fields.afc_diff ^ 0x0);
	*pu32RetentionAvailable |= (JN518X_RFPMODEM->calibration.synth_cal_startup_afc_2_rx.fields.afc_2 ^ 0x0);
}


void vRadio_Jn518x_Standard_Init(uint32_t u32RadioStandard)
{
	   //----------------------------------------------------------------------------
	   // Check RadioStandard and do appropriate calibrations
	   //----------------------------------------------------------------------------

	   // save Standard

	   RadioConfiguration.u32RXRadioStandard = ((u32RadioStandard >> 8) & 0xFF);
	   RadioConfiguration.u32TXRadioStandard = (u32RadioStandard & 0xFF);

	   switch (u32RadioStandard)
	   {
	   case RADIO_STANDARD_BLE_1MB:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableBLERadio)
	  {
#endif
		   radio_jn518x_TX_BLE_1Mbs_Init();
		   radio_jn518x_RX_BLE_1Mbs_Init();
		   radio_jn518x_Patch_Ble();
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RADIO_STANDARD_BLE_2MB:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableBLERadio)
	  {
#endif
		   radio_jn518x_TX_BLE_2Mbs_Init();
		   radio_jn518x_RX_BLE_2Mbs_Init();
		   radio_jn518x_Patch_Ble();
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RADIO_STANDARD_BLE_RX1MB_TX2MB:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableBLERadio)
	  {
#endif
		   radio_jn518x_TX_BLE_2Mbs_Init();
		   radio_jn518x_RX_BLE_1Mbs_Init();
		   radio_jn518x_Patch_Ble();
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RADIO_STANDARD_BLE_RX2MB_TX1MB:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableBLERadio)
	  {
#endif
		   radio_jn518x_TX_BLE_1Mbs_Init();
		   radio_jn518x_RX_BLE_2Mbs_Init();
		   radio_jn518x_Patch_Ble();
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RADIO_STANDARD_ZIGBEE_PROP_1_LUT:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_TX_ZigBee_Init(TX_PROP_1);
		   radio_jn518x_RX_ZigBee_Init(RX_ENABLE_LUT);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RADIO_STANDARD_ZIGBEE_PROP_1:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_TX_ZigBee_Init(TX_PROP_1);
		   radio_jn518x_RX_ZigBee_Init(RX_DETECTOR_ONLY);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RADIO_STANDARD_ZIGBEE_PROP_2_LUT:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_TX_ZigBee_Init(TX_PROP_2);
		   radio_jn518x_RX_ZigBee_Init(RX_ENABLE_LUT);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RADIO_STANDARD_ZIGBEE_PROP_2:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_TX_ZigBee_Init(TX_PROP_2);
		   radio_jn518x_RX_ZigBee_Init(RX_DETECTOR_ONLY);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RADIO_STANDARD_ZIGBEE_REGULAR_LUT:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_TX_ZigBee_Init(TX_REGULAR);
		   radio_jn518x_RX_ZigBee_Init(RX_ENABLE_LUT);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RADIO_STANDARD_ZIGBEE_REGULAR:
	   default:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_TX_ZigBee_Init(TX_REGULAR);
		   radio_jn518x_RX_ZigBee_Init(RX_DETECTOR_ONLY);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   }

}

void vRadio_Jn518x_Standard_Init_TX(uint32_t u32RadioStandard)
{
	   //----------------------------------------------------------------------------
	   // Check RadioStandard and do appropriate calibrations
	   //----------------------------------------------------------------------------

	   RadioConfiguration.u32TXRadioStandard = u32RadioStandard;

	   switch (u32RadioStandard)
	   {
	   case TX_BLE_1MB:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableBLERadio)
	  {
#endif
		   radio_jn518x_TX_BLE_1Mbs_Init();
		   // Steve B. settings
		   radio_jn518x_Patch_Ble();
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case TX_BLE_2MB:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableBLERadio)
	  {
#endif
		   radio_jn518x_TX_BLE_2Mbs_Init();
		   // Steve B. settings
		   radio_jn518x_Patch_Ble();
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case TX_PROP_1:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_TX_ZigBee_Init(TX_PROP_1);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case TX_PROP_2:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_TX_ZigBee_Init(TX_PROP_2);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case TX_REGULAR:
	   default:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_TX_ZigBee_Init(TX_REGULAR);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   }

}

void vRadio_Jn518x_Standard_Init_RX(uint32_t u32RadioStandard)
{
	   //----------------------------------------------------------------------------
	   // Check RadioStandard and do appropriate calibrations
	   //----------------------------------------------------------------------------

	   RadioConfiguration.u32RXRadioStandard = u32RadioStandard;

	   switch (u32RadioStandard)
	   {
	   case RX_BLE_1MB:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableBLERadio)
	  {
#endif
		   radio_jn518x_RX_BLE_1Mbs_Init();
		   // Steve B. settings
		   radio_jn518x_Patch_Ble();
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RX_BLE_2MB:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableBLERadio)
	  {
#endif
		   radio_jn518x_RX_BLE_2Mbs_Init();
		   // Steve B. settings
		   radio_jn518x_Patch_Ble();
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RX_ENABLE_LUT:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_RX_ZigBee_Init(RX_ENABLE_LUT);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   case RX_DETECTOR_ONLY:
	   default:
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  if (!RadioConfiguration.bDisableZBRadio)
	  {
#endif
		   radio_jn518x_RX_ZigBee_Init(RX_DETECTOR_ONLY);
#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
	  }
#endif
		   break;
	   }

}

uint8_t u8Radio_Jn518x_GetEDfromRSSI(int16_t i16RSSIval)
{
    uint32_t u32Rssi;
    uint8_t  u8Ed;


    /* Values are all 4 times larger than the -100 to +10 range, because of
     * the extra 2 bits of precision. We will deal with this during the
     * scaling process. First, range check and determine fixed values if
     * beyond range */
    if (i16RSSIval <= -400)
    {
    	u8Ed = 0;
    }
    else if (i16RSSIval >= 40)
    {
    	u8Ed = 255;
    }
    else
    {
    	/* Values are in range -400 to +40, for -100dBm to +10dBm. Shift to
    	 * all +ve values by adding 400, so range becomes 0 to +440 */
    	i16RSSIval += 400;

    	/* Now treat as unsigned, and scale from 0 to 440 into 0 to 255 by
    	 * multiplying by 0.57954545 (multiply by 4861579, divide by 8388608).
    	 * 8388608 is (1 << 23), chosen for fast division */
    	u32Rssi = (uint32_t)i16RSSIval * 4861579UL;
    	u32Rssi >>= 23;

    	u8Ed = (uint8_t)u32Rssi;
    }

return (u8Ed);


}

uint32_t u32Radio_Jn518x_RadioModesAvailable(void)
{
	return (1<<RADIO_MODE_LOPOWER);
}

uint32_t u32Radio_Jn518x_RadioGetVersion(void)
{
	return (RADIO_JN518X_VERSION);
}

void vGetCalInfo(void)
{
	uint32_t u32Temp;
	RadioConfiguration.u32ATECalDate = *(uint32_t *)0x9FC68;
	u32Temp = *(uint32_t *)0x9FDC8;
	   if (u32Temp & 0x1) // TCal_ATE has been written in flash
	   {
		   RadioConfiguration.i16ATECalTemp = (((u32Temp << 15) + (32 << 16)) >> 16) >> 6; // sign extension, remove VALID bit and round if from s9.7 to s15.1
	   }
	   else // TCal_ATE not written in flash: use DEFAULT_ATE_TEMP dCelsius as TCal_ATE
	   {
		   RadioConfiguration.i16ATECalTemp = DEFAULT_ATE_TEMP*2;
	   }
}


int vRadio_Jn518x_RFT1778_bad_crc(void)
{
	if (JN518X_ZBMAC -> RXSTAT_b.fcs_error)
	{
		// override MAC control
	    JN518X_ZBMODEM -> PHY_MCTRL_b.miom = 1;

		// Initializes TMU for TX/RX packet transmission under SW control // RF - 20171204
		radio_jn518x_Trx_Packet_SW_Ctrl_Init(); // RF - 20171204

		// First de-assert RX group signals to clean-up potential RX lock-up state
		radio_jn518x_rx_deassert_polled(); // stop RX group and poll for done

		// Then RX group signals must be asserted again (to power the RX modules)
		radio_jn518x_rx_assert_polled(); // start RX group and poll for done

		// Radio control to come from Modem/MAC
		radio_jn518x_Trx_Packet_HW_Ctrl_Init();

		// restore MAC control
	    JN518X_ZBMODEM -> PHY_MCTRL_b.miom = 0;

		return (1);
	}
	else
	{
		return (0);
	}

}


uint32_t u32Radio_Jn518x_GetPhyState(void)
{
    uint32_t u32Store;
    uint32_t u32State;

    //MICRO_DISABLE_AND_SAVE_INTERRUPTS(u32Store);
    u32Store = DisableGlobalIRQ();

    JN518X_RFPMODEM->test.version_set_snap.fields.version = 1;
    do
    {
        volatile uint8_t i;
        /* Short delay */
        for (i = 0; i < 10; i++);
    } while (JN518X_RFPMODEM->test.status.fields.snack == 0);

    JN518X_RFPMODEM->test.reset_snap.val = 1;

    u32State = JN518X_RFPMODEM->tmu.global_status.fields.global_state;

    //MICRO_RESTORE_INTERRUPTS(u32Store);
    EnableGlobalIRQ(u32Store);

    return u32State;
}

#if 0
void vRadio_Jn518x_CheckRxStarted(void)
{
    int iLoopCount;
    uint32 u32RfpGlobalStatus;
    uint32 u32PreCountOrig;

    /* As the interrupt bit is checked after the TX and RX interrupt bits,
       there is a slim possibility that it fired at the same time that some
       other activity completed, that activity changed what the radio is now
       expected to be doing and hence this timeout is no longer appropriate.
       However, we can live with this: a false positive resulting in an
       unnecessary recovery is not the end of the world. Also, we do have a
       flag that we can check to cope with the case where the RX  has now been
       stopped */
    if (bWorkaroundTimerRunning)
    {
        bWorkaroundTimerRunning = FALSE;

        /* If we are also transmitting (such as for RX in CCA) then we don't
           try any recovery as the radio state may be transitioning and so is
           harder to check reliably. In this case, a lock-up will be recovered
           from by the TX lock-up recovery code */
        if (0 == u32REG_BbcRead(REG_BBC_TXCTL))
        {
            /* Not in TX so check radio status, which should now be at RX
               state */
            u32RfpGlobalStatus = u32MMAC_GetPhyState();
		    if (0 == (u32RfpGlobalStatus & 8))
		    {
		        /* Not in RX, so perform recovery procedure.
		           Store pre-count value, then replace with maximum value.
		           This should cause RFP state to move out of stuck state
		           waiting for PLL */
                u32PreCountOrig = JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre;
                JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre = 0x7FF;

                /* Wait for change to take effect */
                iLoopCount = 0;
                do
                {
                	iLoopCount++;
                    u32RfpGlobalStatus = u32MMAC_GetPhyState();
                } while ((iLoopCount < 100) && (0 == (u32RfpGlobalStatus & 8)));

        		/* Restore pre-count value */
        		JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre = u32PreCountOrig;
		    }
    	}
    }
}
#endif

void vRadio_Jn518x_LockupCheckAndAbortRadio(void)
{
    /* Recovery code is from Steve Bate, 24th August 2017 */
    uint8_t u8LoopCount;
    uint32_t u32RfpGlobalStatus;
    uint32_t  u32PreCountOrig;

    JN518X_RFPMODEM->tmu.rfp_tmu_intclrstat.val = 0x7FFF;

    /* Trigger abort; register does not need clearing afterwards */
    JN518X_RFPMODEM->tmu.triggers.val = (1 << EXTAPB_REGFILE_TMU_TRIGGERS_ABORT_POS);


	/* Store pre-count value, then replace with maximum value. This should
	   cause RFP state to move out of stuck state waiting for PLL */
	u32PreCountOrig = JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre;
	JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre = 0x7FF;
    if (JN518X_RFPMODEM->tmu.rfp_tmu_intstat.val != 0)   // expect to get PLL_STATE_START intstat bit set if it was locked up in tmu_wait_for_pll state
    {
		/* RFP will then move to RX, so we can send an abort, and it will then
		   move to TX, so we can send another abort. The RFP global state goes
		   to 0 for one cycle during this, so we must be robust to that. This
		   loop deals with all of these factors */
		u8LoopCount = 2;
		while (u8LoopCount > 0)
		{
			u32RfpGlobalStatus = u32Radio_Jn518x_GetPhyState();

			/* If status is 'RX' or 'TX', trigger an abort */
			if ((u32RfpGlobalStatus & 0x4) || (u32RfpGlobalStatus & 0x08))
			{
				/* Trigger abort; register does not need clearing afterwards */
				JN518X_RFPMODEM->tmu.triggers.val = (1 << EXTAPB_REGFILE_TMU_TRIGGERS_ABORT_POS);
			}

			/* If status is 0, count down: need this to happen twice before we
			   can exit */
			if (u32RfpGlobalStatus == 0x0)
			{
				u8LoopCount--;
			}
		}
    }
    /* Restore pre-count value */
	JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre = u32PreCountOrig;

#ifdef AA_ERROR_RECOVERY_PATCH
	// removepatch
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT1_MSK = 0;
	JN518X_BLEMODEM -> DP_ANTENNA_CTRL_b.TEST_FD_POWER = 0;
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT1 = 1;
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT1_MSK = 1;
#endif

}





/****************************************************************************/
/***        Public Functions                                              ***/
/****************************************************************************/
void vRadio_SetComplianceLimits(int8_t i8TxMaxPower,
                                       int8_t i8TxMaxPowerCh26)
{
    i8Radio_TxMaxPower     = i8TxMaxPower;
    i8Radio_TxMaxPowerCh26 = i8TxMaxPowerCh26;
}

/* The JN518x has 3 sets of operating 'standards', which affects the frequency
   response of the radio:
     normal
     proprietary 1
     proprietary 2

   For compliance it may be necessary to select different standards for
   different channels, and this function allows that to be configured.
   Note that this function has the AppApi prefix rather than the MMAC
   prefix; we have traditionally provided customer-facing functions with
   the AppApi prefix and this avoids a level of indirection via the shim
   layer. */
void vRadio_SetChannelStandards(teRadioTxMode eNewTxMode,
                                       teRadioTxMode eNewTxModeCh26)
{
    /* Store values for use later */
    eTxMode     = eNewTxMode;
    eTxModeCh26 = eNewTxModeCh26;
}

void vRadio_InitialiseRadioStandard(void)
{
    eCurrentTxMode = E_RADIO_TX_MODE_RESET;
    vRadio_UpdateRadioStandard(JN518X_ZBMODEM->PHY_CHAN_b.chan);
}

void vRadio_UpdateRadioStandard(uint8_t u8NewChannel)
{
    teRadioTxMode eNewTxMode;
    uint16_t const au16RadioStandard[] = {
         RADIO_STANDARD_ZIGBEE_REGULAR,
         RADIO_STANDARD_ZIGBEE_PROP_1,
         RADIO_STANDARD_ZIGBEE_PROP_2
        };

    if (26 == u8NewChannel)
    {
        eNewTxMode = eTxModeCh26;
    }
    else
    {
        eNewTxMode = eTxMode;
    }

    if (eNewTxMode != eCurrentTxMode)
    {
        vRadio_Jn518x_Standard_Init(au16RadioStandard[(uint8_t)eNewTxMode]);
        eCurrentTxMode = eNewTxMode;
    }
}

void vRadio_SetChannelAndPower(uint8_t u8Channel, int8_t i8TxPower_dBm)
{
    /* Change channel */
    //vREG_PhyWrite(REG_PHY_CHAN, u8Channel);
	JN518X_ZBMODEM->PHY_CHAN_b.chan = u8Channel;

    vRadio_UpdateRadioStandard(u8Channel);

    /* Modify TX power level down to limits (if applied) for use with
       high-power modules. Two limits:
         i8MMAC_HpmTxMaxPower for channels 11 to 25
         i8MMAC_HpmTxMaxPowerCh26 for channel 26
     */
    if (26 == u8Channel)
    {
        if (i8TxPower_dBm > i8Radio_TxMaxPowerCh26)
        {
            i8TxPower_dBm = i8Radio_TxMaxPowerCh26;
        }
    }
    else
    {
        if (i8TxPower_dBm > i8Radio_TxMaxPower)
        {
            i8TxPower_dBm = i8Radio_TxMaxPower;
        }
    }

    /* Write to register, which is in steps of 0.25dB from -30 to +15dBm, with
       0dBm as 0 */
    //vREG_PhyWrite(PHY_PWR, i8TxPower_dBm * 4);
    JN518X_ZBMODEM->PHY_PWR_b.pwr = i8TxPower_dBm * 4;
}


int8_t i8Radio_GetTxPowerLevel_dBm(void)
{
    int8_t  i8Value;

    i8Value = (int8_t)(JN518X_ZBMODEM->PHY_PWR_b.pwr);

    /* Value in register is in steps of 0.25dB, so convert to dB */
    return i8Value / 4;
}


int16_t i16Radio_Jn518x_GetRSSI(uint32_t u32DurationSymbols,bool bAverage, uint8_t *u8antenna)
{
    /* Energy detect is performed synchronously */

    /* Reset energy detect accumulator */
    uint8_t  u8AccumulatedEnergy = 0;
    uint8_t  u8SampleEnergy;
    uint32_t u32EndTime;
    uint32_t u32Rssi;
    uint32_t u32PhyMctrl;
	int16_t rssi_val_signed;


    // save MCTRL value
    u32PhyMctrl = JN518X_ZBMODEM -> PHY_MCTRL; //READ_REG32(ADDR_PHY_MCTRL);

    /* Turn on PHY in RX mode */

    /* Need to enable BBC_RMI even though we are supposedly forcing modem
     * control with MIOM; presumably the original logic didn't survive in the
     * move to the JN518x. Also note that the PHY_MCTRL register in the ZBMAC
     * is not the same as a the PHY_MCTRL register in the ZBMODEM */
    JN518X_ZBMAC->PHY_MCTRL = 1;
    while ((JN518X_ZBMAC->PHY_MSTATUS & 1) == 0);

    /* Turn on PHY in RX mode, clearing status bit first so we can detect when
       RX has been entered */
    JN518X_RFPMODEM->tmu.rfp_tmu_intclrstat.val = EXTAPB_REGFILE_TMU_RFP_TMU_INTCLRSTAT_RX_STATE_START_MASK;

//    vREG_PhyWrite(REG_PHY_MCTRL, REG_PHY_MCTRL_MPHYON_MASK
//                                 | REG_PHY_MCTRL_MIOM_MASK);
    JN518X_ZBMODEM -> PHY_MCTRL_b.miom = 1;
    JN518X_ZBMODEM -> PHY_MCTRL_b.mphydir = 0;
    JN518X_ZBMODEM -> PHY_MCTRL_b.mphyon = 1;

    /* Read event for when RX state has been entered */
    while (JN518X_RFPMODEM->tmu.rfp_tmu_intstat.fields.rx_state_start == 0);

    /* Use SCFRC to time directly */
//    u32EndTime = u32REG_BbcRead(REG_BBC_SCFRC) + u32DurationSymbols;
    u32EndTime = JN518X_ZBMAC->SCFRC + u32DurationSymbols;


    do
    {
        /* Clear event status */
//        vREG_PhyWrite(ZB_EVENTS_CLEAR, REG_PHY_INT_ED_MASK);
        (JN518X_ZBMODEM -> ZB_EVENTS_CLEAR) |= (1 << 3);
        /* Start energy detect */
//        vREG_PhyWrite(REG_PHY_MCTRL, REG_PHY_MCTRL_MPHYON_MASK
//                                     | REG_PHY_MCTRL_MIOM_MASK
//                                     | REG_PHY_MCTRL_MEDT_MASK);
    	if (bAverage)
    		JN518X_ZBMODEM -> MRX_CTRL_b.rx_rssi_avg_en = 1;
    	else
    		JN518X_ZBMODEM -> MRX_CTRL_b.rx_rssi_avg_en = 0;

    	if (RadioConfiguration.bADEnabled)
    		JN518X_ZBMODEM->MRX_CTRL_b.rx_rssi_pulse_mode = 1;
    	else
    		JN518X_ZBMODEM->MRX_CTRL_b.rx_rssi_pulse_mode = 0;


    	JN518X_ZBMODEM -> PHY_MCTRL_b.medt = 1;

        /* Wait for completion */
//        while (0 == (u32REG_PhyRead(ZB_EVENTS_STATUS) & REG_PHY_INT_ED_MASK));
        while (0 == ((JN518X_ZBMODEM -> ZB_EVENTS_STATUS) & (1 << 3)));

    	if (u8antenna != NULL)
    	*u8antenna = JN518X_ZBMODEM->MSTAT_b.rx_ad_ant;

    	/* Read value: value is signed 10-bit (seems dB, but unknown offset).
		 * Read it here, then pass to a generic function to convert it to the
		 * 0 to 255 range */
//		u32Rssi = u32REG_PhyRead(REG_PHY_MSTAT0);
//		u32Rssi &= REG_PHY_MSTAT_ED_MASK;
//		u32Rssi >>= REG_PHY_MSTAT_ED_BIT;
		/* Get averaged RSSI value*/
		u32Rssi = JN518X_ZBMODEM -> MSTAT_b.rx_rssi_avg;
    	/* calculate RSSI true value in dBm */
    	rssi_val_signed = ((int16_t)(u32Rssi << 6) >> 6);

        if (u32DurationSymbols !=0)
        {
			//u8SampleEnergy = u8Radio_Jn518x_GetEDfromRSSI(u32Rssi);
			u8SampleEnergy = u8Radio_Jn518x_GetEDfromRSSI(rssi_val_signed);

			if (u8SampleEnergy > u8AccumulatedEnergy)
			{
				u8AccumulatedEnergy = u8SampleEnergy;
			}
        }
//    } while (((int32_t)(u32EndTime - u32REG_BbcRead(REG_BBC_SCFRC))) > 0)
	} while (((int32_t)(u32EndTime - JN518X_ZBMAC->SCFRC)) > 0);

    /* Clear event status */
//    vREG_PhyWrite(ZB_EVENTS_CLEAR, REG_PHY_INT_ED_MASK);
    (JN518X_ZBMODEM -> ZB_EVENTS_CLEAR) |= (1 << 3);

    /* Turn off PHY */
//    vREG_PhyWrite(REG_PHY_MCTRL, 0);
    // Restore MCTRL value
    JN518X_ZBMODEM -> PHY_MCTRL = u32PhyMctrl;

    /* Also clear RMI */
    JN518X_ZBMAC->PHY_MCTRL &= ~1;

    if (u32DurationSymbols !=0)
    {
    	return (int16_t)u8AccumulatedEnergy;
    }
    else
    {
    	return rssi_val_signed;
    }
}

int8_t i8Radio_Jn518x_GetLastPacketRSSI(void)
{
    uint32_t u32Rssi = 0;
    int16_t int16RssiValSigned = 0;
    int8_t i8RssiDbm = 0;

    u32Rssi = JN518X_RFPMODEM->rx_datapath.mf_rssi_dbm_packet.val;
    int16RssiValSigned = ((int16_t)(u32Rssi << 6) >> 6);

    int16RssiValSigned = i16Radio_Jn518x_BoundRssiValue(int16RssiValSigned);
    /* RSSI reported by radio is in 1/4 dBm step,
     * meaning values are 4 times larger than real dBm value.
     */
    i8RssiDbm = (int8_t)(int16RssiValSigned >> 2);

    return i8RssiDbm;
}

int16_t i16Radio_Jn518x_BoundRssiValue(int16_t value)
{
    if (value <= RADIO_JN5189_MIN_RSSI_REPORT)
    {
        value = RADIO_JN5189_MIN_RSSI_REPORT;
    }
    else if (value >= RADIO_JN5189_MAX_RSSI_REPORT)
    {
        value = RADIO_JN5189_MAX_RSSI_REPORT;
    }

    return value;
}

void vRadio_JN518x_Temp_GetInfos(void)
{
	uint32_t temp_reg;

	temp_reg = JN518X_PMC -> AOREG_RADIO;

	RadioConfiguration.u8ReCal_needed = (temp_reg & RECAL_NEEDED_MASK) >> RECAL_NEEDED_SHIFT;
	RadioConfiguration.u8TCur_Received = (temp_reg & TCUR_RECEIVED_MASK) >> TCUR_RECEIVED_SHIFT;
	RadioConfiguration.u8InitDone = (temp_reg & INIT_DONE_MASK) >> INIT_DONE_SHIFT;
	if (RadioConfiguration.u8TCur_Received)
	{
		RadioConfiguration.i16TCur = (int16_t)(((temp_reg & TCUR_MASK) >> TCUR_SHIFT) << 4) >> 4;  // with sign extension
	}
	else
	{
		RadioConfiguration.i16TCur = (int16_t)0x8000;
	}
	if (RadioConfiguration.u8InitDone)
	{
		RadioConfiguration.i16TCal = (int16_t)(((temp_reg & TCAL_MASK) >> TCAL_SHIFT) << 4) >> 4;  // with sign extension
	}
	else
	{
		RadioConfiguration.i16TCal = (int16_t)0x8000;
	}
}

void vRadio_JN518x_Temp_SetKmodData(void)
{
	if (u16RadioCB_ReadNVM)
	{
		bRadioCB_WriteNVM((uint8_t *)RadioKmodCalData, sizeof(RadioKmodCalData));
	}
}

void vRadio_JN518x_Temp_GetKmodData(void)
{
	if (u16RadioCB_ReadNVM)
	{
		u16RadioCB_ReadNVM((uint8_t *)RadioKmodCalData , sizeof(RadioKmodCalData));
	}
}

void vRadio_JN518x_Temp_SetInfos(void)
{
	uint32_t temp_reg;

	temp_reg  = (RadioConfiguration.i16TCal << TCAL_SHIFT) & TCAL_MASK;
	temp_reg |= (RadioConfiguration.i16TCur << TCUR_SHIFT) & TCUR_MASK;
	temp_reg |= (RadioConfiguration.u8InitDone << INIT_DONE_SHIFT) & INIT_DONE_MASK;
	temp_reg |= (RadioConfiguration.u8TCur_Received << TCUR_RECEIVED_SHIFT) & TCUR_RECEIVED_MASK;
	temp_reg |= (RadioConfiguration.u8ReCal_needed << RECAL_NEEDED_SHIFT) & RECAL_NEEDED_MASK;
	JN518X_PMC -> AOREG_RADIO = temp_reg;
}


void vRadio_JN518x_Temp_InitKmodData(void)
{
	uint8_t i;
	uint32_t u32Temp;

    if (((RadioConfiguration.u32ATECalDate>=20180701) && (RadioKmodCalData[0].i16CalTemp != RadioConfiguration.i16ATECalTemp)) ||
    	((RadioConfiguration.u32ATECalDate<20180701) && (RadioKmodCalData[0].u16Corr1==0)))// no value available in RAM
    {
		vRadio_JN518x_Temp_GetKmodData();
		if (((RadioConfiguration.u32ATECalDate>=20180701) && (RadioKmodCalData[0].i16CalTemp != RadioConfiguration.i16ATECalTemp)) ||
			((RadioConfiguration.u32ATECalDate<20180701) && ((RadioKmodCalData[0].u16Corr1==0) && (RadioKmodCalData[0].i16CalTemp != (int16_t)0x8000)))) // Flash version of KmodData never initialiased
		{
			// set every CalTemp to min int16 value and every Corr1 to 0
			for (i = 0; i<KMOD_TEMP_POINTS; i++)
			{
				RadioKmodCalData[i].i16CalTemp = (int16_t)0x8000;
				RadioKmodCalData[i].u16Corr1 = 0;
			}
			// if cal date post 2018/07/01 try to collect data from flash. Otherwise stop here.
			if (RadioConfiguration.u32ATECalDate>=20181018)
			{
				u32Temp = *(uint32_t *)0x9FDAC; // read Corr1 ATE value
				if (u32Temp & 0x1) // if value valid, continue else stop here and keep RadioKmodCalData[0].i16CalTemp = 0x8000
				{
					RadioKmodCalData[0].u16Corr1 = (u32Temp >> 1 & 0x7FF);

					u32Temp = *(uint32_t *)0x9FDB0; // read Count1 ATE value
					if (u32Temp & 0x1) // if value valid, continue else stop here and keep RadioKmodCalData[0].i16CalTemp = 0x8000
					{
						u32Temp = u32Temp >> 1;
						RadioKmodCalData[0].u32Count1LSB = u32Temp & 0xFFFF;
						RadioKmodCalData[0].u32Count1MSB = (u32Temp >>16) & 0x3F;

						u32Temp = *(uint32_t *)0x9FDB4; // read Count2 ATE value
						if (u32Temp & 0x1)// if value valid, continue else stop here and keep RadioKmodCalData[0].i16CalTemp = 0x8000
						{
							u32Temp = u32Temp >> 1;
							RadioKmodCalData[0].u32Count2LSB = u32Temp & 0xFFFF;
							RadioKmodCalData[0].u32Count2MSB = (u32Temp >>16) & 0x3F;
							RadioKmodCalData[0].i16CalTemp = RadioConfiguration.i16ATECalTemp;
						}

					}

				}
			}
			vRadio_JN518x_Temp_SetKmodData();
		}
    }
}



void vRadio_JN518x_Temp_Update(int16_t s16Temp)
{
		int16_t i16DeltaT;

		vRadio_JN518x_Temp_GetInfos();

		// store TCurrent on 12bit, flag TCur has been received and reset ReCal Needed flag
		RadioConfiguration.i16TCur = s16Temp;
		RadioConfiguration.u8TCur_Received = 1;
		RadioConfiguration.u8ReCal_needed = 0;

	if (RadioConfiguration.u8InitDone)
	{
		// assume temp is 12bit signed values in 11.1 format (<<4 and >>4 for sign extension)
		i16DeltaT = RadioConfiguration.i16TCur - RadioConfiguration.i16TCal;

		// abs DeltaT
		if (i16DeltaT <0) i16DeltaT = -i16DeltaT;
		// check abs DeltaT against threshold (40 dCelcius) in 11.1 and set flag "need re-cal" if greater or equal
		if (i16DeltaT >= i16RecalThresholdTemp) RadioConfiguration.u8ReCal_needed = 1;

	}
	vRadio_JN518x_Temp_SetInfos();
}
bool vRadio_JN518xRecal(void)
{
	vRadio_JN518x_Temp_GetInfos();

	if (RadioConfiguration.u8ReCal_needed)
	{
		if (RadioConfiguration.u8InitDone)
		{
			RadioConfiguration.bDoCalibrate =true;
			radio_jn518x_RSSI_cal();
			radio_jn518x_Synthesizer_Full_Cal();
			radio_jn518x_ZigBee_Regular_Init(); // TEST
			radio_jn518x_DCO_cal();
			// 2 following calls moved to DCO_cal
//			radio_jn518x_rx_deassert_polled();
//			radio_jn518x_power_down_to_off_polled();
			// Radio control to come from Modem/MAC
			radio_jn518x_Trx_Packet_HW_Ctrl_Init();
			// ALPHA
			// update TCal with TCur and RAZ "need re-cal" flag
			RadioConfiguration.u8ReCal_needed = 0;
			RadioConfiguration.i16TCal = RadioConfiguration.i16TCur;
			vRadio_JN518x_Temp_SetInfos();
		}
		else
		{
			vRadio_Jn518x_RadioInit(RADIO_INIT_FORCE_CAL|(RadioConfiguration.u32TxPowerMode << 8));
		}
		//Restore Radio Standard
		vRadio_Jn518x_Standard_Init((RadioConfiguration.u32RXRadioStandard << 8) | (RadioConfiguration.u32TXRadioStandard));
		return (true);
	}
	else
	{
		return (false);
	}
}

void vSetRecalThres(int16_t s16LimiTemp)
{
	i16RecalThresholdTemp = (s16LimiTemp << 1);
}
void vGetCalTemp(int16_t *s16CalTemp)
{
	*s16CalTemp = ((int16_t)((((JN518X_PMC -> AOREG_RADIO) >> TCAL_SHIFT) & TCAL_MASK) << 4) >> 4);
}



/* to be removed when XTAL init is out of radio driver */
void vRadio_Jn518x_SkipXTALInit(void)
{
	RadioConfiguration.bSkipXTAL = true;
}


void vRadio_Jn518x_EnableXTALInit(void)
{
	RadioConfiguration.bSkipXTAL = false;
}

/* BLE reset ON */
void vRadio_Jn518x_BLE_ResetOn(void)
{
  	JN518X_SYSCON -> PRESETCTRLSET1 = 	(SYSCON_PRESETCTRLSET1_BLE_RST_SET_Msk);
}

/* BLE reset OFF */
void vRadio_Jn518x_BLE_ResetOff(void)
{
  	JN518X_SYSCON -> PRESETCTRLCLR1 = 	(SYSCON_PRESETCTRLSET1_BLE_RST_SET_Msk);
}

// AGC_READY_PATCH
#ifdef AGC_READY_PATCH
void vRadio_Jn518x_Enable_AgcReadyPatch(void)
{
	if (radio_jn518x_IsNotC2MF(NULL, NULL))
	{
	   b_event_in_process_patch_on = false;
	   JN518X_BLEMODEM -> DP_FUNCTION_CTRL |= BLEMODEM_DP_FUNCTION_CTRL_RX_EN_MODE_Msk; // set for repeated RX when RX_EN_SEL is asserted

	   // TMU Interrupt Enables
		JN518X_RFPMODEM->tmu.rfp_tmu_intclrstat.val = (	EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_RX_STATE_START_MASK |
														EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_TX_STATE_START_MASK);
		JN518X_RFPMODEM->tmu.rfp_tmu_inten.val     |= (	EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_RX_STATE_START_MASK |
														EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_TX_STATE_START_MASK);

		NVIC_EnableIRQ(RFP_TMU_IRQn);
		NVIC_SetPriority(RFP_TMU_IRQn, 2);
	}
}

void vRadio_Jn518x_Disable_AgcReadyPatch(void)
{
	if (radio_jn518x_IsNotC2MF(NULL, NULL))
	{
		// Disable RX_STATE_START and TX_STATE_START events
		JN518X_RFPMODEM->tmu.rfp_tmu_inten.val     &= ~(EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_RX_STATE_START_MASK |
														EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_TX_STATE_START_MASK);
		JN518X_RFPMODEM->tmu.rfp_tmu_intclrstat.val = (	EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_RX_STATE_START_MASK |
														EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_TX_STATE_START_MASK);


		NVIC_DisableIRQ(RFP_TMU_IRQn);
		JN518X_BLEMODEM -> DP_FUNCTION_CTRL &= ~BLEMODEM_DP_FUNCTION_CTRL_RX_EN_MODE_Msk; // reset for repeated RX when RX_EN_SEL is asserted
		vRadio_Jn518x_remove_patch_ISR();
	}
}

void vRadio_Jn518x_start_rx_ISR(void)
{
    if (b_event_in_process_patch_on == false)
    {
        // enable mode to source RXEN from modem and also enable RX modem
        b_event_in_process_patch_on = true;  // Set flag to show patch is on. It may already be on if this is second RX
        // always apply direct control of RX_EN from regiser and force on
        JN518X_BLEMODEM -> DP_TOP_SYSTEM_CTRL |= (BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_EN_SEL_Msk | BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_REQ_Msk);
    }
}

void vRadio_Jn518x_remove_patch_ISR(void)
{
    if (b_event_in_process_patch_on == true)
    {
        JN518X_BLEMODEM -> DP_TOP_SYSTEM_CTRL &= ~(BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_EN_SEL_Msk | BLEMODEM_DP_TOP_SYSTEM_CTRL_RX_REQ_Msk);
        b_event_in_process_patch_on = false; // clear flag to show patch no longer on
        // In case there has been a very short RX and then immediate end of event there may be a race
        // between start RX ISR and end of event ISR
        // In case this ISR is processed first we need to clear the RX_STATE_START status bit
        // to prevent patch being reapplied
        JN518X_RFPMODEM->tmu.rfp_tmu_intclrstat.val = EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_RX_STATE_START_MASK; // Clear
    }
}

void vRadio_Jn518x_MultiRX_AgcReadyPatch(void)
{
	if (radio_jn518x_IsNotC2MF(NULL, NULL))
	{
		JN518X_BLEMODEM -> DP_FUNCTION_CTRL |= BLEMODEM_DP_FUNCTION_CTRL_RX_EN_MODE_Msk;
	}
}

void vRadio_Jn518x_SingleRX_AgcReadyPatch(void)
{
	if (radio_jn518x_IsNotC2MF(NULL, NULL))
	{
		JN518X_BLEMODEM -> DP_FUNCTION_CTRL &= ~BLEMODEM_DP_FUNCTION_CTRL_RX_EN_MODE_Msk;
	}
}

void RFP_TMU_IRQHandler(void)
{
    uint32_t tmpVal;

    tmpVal = (JN518X_RFPMODEM->tmu.rfp_tmu_intstat.val) & (JN518X_RFPMODEM->tmu.rfp_tmu_inten.val); // do not check disabled ones
    if (tmpVal & EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_RX_STATE_START_MASK)
    {
        //IRQ RX Start
        vRadio_Jn518x_start_rx_ISR();
        JN518X_RFPMODEM->tmu.rfp_tmu_intclrstat.val = EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_RX_STATE_START_MASK; // Clear
    }
    if (tmpVal & EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_TX_STATE_START_MASK)
    {
        // IRQ TX Start: Hence undo the RX start patch
        vRadio_Jn518x_remove_patch_ISR();
        JN518X_RFPMODEM->tmu.rfp_tmu_intclrstat.val = EXTAPB_REGFILE_TMU_RFP_TMU_INTSTAT_TX_STATE_START_MASK; // Clear
    }
}
#else
void vRadio_Jn518x_remove_patch_ISR(void)
{
}
void vRadio_Jn518x_Enable_AgcReadyPatch(void)
{
}
void vRadio_Jn518x_Disable_AgcReadyPatch(void)
{
}
void vRadio_Jn518x_MultiRX_AgcReadyPatch(void)
{
}
void vRadio_Jn518x_SingleRX_AgcReadyPatch(void)
{
}
#endif

#if (defined INIT_OPTIM_ZB_BLE) || (defined INIT_OPTIM_ZB_BLE_2)
#if 0
void radio_jn518x_EnableZB(void)
{
	// Reset ZB and enable clk
	if ((JN518X_SYSCON -> AHBCLKCTRL1 & SYSCON_AHBCLKCTRL1_ZIGBEE_Msk) == 0)
	{
		JN518X_SYSCON -> PRESETCTRLSET1 = 	(SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk);
		JN518X_SYSCON -> AHBCLKCTRLSET1 = (SYSCON_AHBCLKCTRL1_ZIGBEE_Msk);
		//JN518X_SYSCON -> PRESETCTRLCLR1 = 	(SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk);
		JN518X_SYSCON -> MODEMCLKSEL_b.SEL_ZIGBEE    = 0;
		JN518X_SYSCON -> PRESETCTRLCLR1 = 	(SYSCON_PRESETCTRLSET1_ZIGBEE_RST_SET_Msk);
	}
}

void radio_jn518x_EnableZBClks(void)
{
	// Reset ZB and enable clk
	if ((JN518X_SYSCON -> AHBCLKCTRL1 & SYSCON_AHBCLKCTRL1_ZIGBEE_Msk) == 0)
	{
		JN518X_SYSCON -> AHBCLKCTRLSET1 = (SYSCON_AHBCLKCTRL1_ZIGBEE_Msk);
		JN518X_SYSCON -> MODEMCLKSEL_b.SEL_ZIGBEE    = 0;
	}
//	radio_jn518x_EnableZB();
}

void radio_jn518x_DisableZBClks(void)
{
	// Disable clk
	JN518X_SYSCON -> MODEMCLKSEL_b.SEL_ZIGBEE    = 1;
	JN518X_SYSCON -> AHBCLKCTRLCLR1 = (SYSCON_AHBCLKCTRL1_ZIGBEE_Msk);
}

void radio_jn518x_EnableBLEClks(void)
{
	// We don't reset BLE to avoid BLE counter value lost. Enable CLK only
	if ((JN518X_SYSCON -> AHBCLKCTRL1 & SYSCON_AHBCLKCTRL1_BLE_Msk) == 0)
	{
		JN518X_SYSCON -> AHBCLKCTRLSET1 = (SYSCON_AHBCLKCTRL1_BLE_Msk);
		JN518X_SYSCON -> MODEMCLKSEL_b.SEL_BLE    = 0;
	}
}
#endif
/****************************************************************************
 *
 * NAME:       vRadio_jn518x_DisableZBRadio
 *
 * DESCRIPTION:
 * Disable ZB radio block.
 * This API needs to be called before vRadio_Jn518x_RadioInit and vRadio_jn518x_ActivateXtal32MRadioBiasing.
 * When ZB radio block is disabled, it is not reset and clocks are not enabled for this
 * HW block.
 * ONLY ONE OF vRadio_jn518x_DisableZBRadio or vRadio_jn518x_DisableBLERadio can be called.
 * IF BOTH APIS ARE CALLED, ONLY THE FIRST ONE HAS EFFECT.
 * IT CANNOT BE REVERSED. NEED HW RESET TO USE ZB RADIO AGAIN.
 *
 * PARAMETERS:
 * None
 *
 * RETURNS:
 * None.
 *
 ****************************************************************************/
void vRadio_jn518x_DisableZBRadio(void)
{
	if (!RadioConfiguration.bDisableBLERadio)
		RadioConfiguration.bDisableZBRadio = true;
}

/****************************************************************************
 *
 * NAME:       vRadio_jn518x_DisableBLERadio
 *
 * DESCRIPTION:
 * Disable BLE radio block.
 * This API needs to be called before vRadio_Jn518x_RadioInit and vRadio_jn518x_ActivateXtal32MRadioBiasing.
 * When BLEB radio block is disabled, clocks are not enabled for this HW block.
 * ONLY ONE OF vRadio_jn518x_DisableZBRadio or vRadio_jn518x_DisableBLERadio can be called.
 * IF BOTH APIS ARE CALLED, ONLY THE FIRST ONE HAS EFFECT.
 * IT CANNOT BE REVERSED. NEED HW RESET TO USE BLE RADIO AGAIN.
 *
 * PARAMETERS:
 * None
 *
 * RETURNS:
 * None.
 *
 ****************************************************************************/
void vRadio_jn518x_DisableBLERadio(void)
{
	if (!RadioConfiguration.bDisableZBRadio)
		RadioConfiguration.bDisableBLERadio = true;
}

#else
void vRadio_jn518x_DisableZBRadio(void)
{
}
void vRadio_jn518x_DisableBLERadio(void)
{
}
#endif

#ifdef FAST_TX_BLE

void vRadio_jn518x_EnableBLEFastTX(bool bKeepPll)
{
    uint8_t rtrip_delay = RTRIP_DELAY_BASIC;
    uint8_t rxpwrup     = RXPWRUP_DELAY_BASIC;
    uint8_t txpwrdn     = TXPWRDN_DELAY_BASIC;
    uint8_t txpwrup     = TXPWRUP_DELAY_BASIC;

	uint8_t u8PLLGroup = 0;

	if (radio_jn518x_IsNotC2MF(NULL, NULL))
	{
		// Group 1
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_val.fields.g1_spare_0 = 1; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_src_sel.fields.g1_spare_0 = 0; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_val.fields.g1_spare_1 = 1; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_src_sel.fields.g1_spare_1 = 0; //

		JN518X_RFPMODEM->transceiver.ldo_synth_d2r_if_val.fields.enable_1v8 = 1; //
		JN518X_RFPMODEM->transceiver.ldo_synth_d2r_if_src_sel.fields.enable_1v8 = 0; //

		JN518X_RFPMODEM->transceiver.ldo_vco_d2r_if_val.fields.enable_1v8 = 1; //
		JN518X_RFPMODEM->transceiver.ldo_vco_d2r_if_src_sel.fields.enable_1v8 = 0; //

		//  JN518X_RFPMODEM->transceiver.rx_ldo_d2r_if_val.fields.rx_ldo_1v4_enable = 1; //
		//  JN518X_RFPMODEM->transceiver.rx_ldo_d2r_if_src_sel.fields.rx_ldo_1v4_enable = 0; //

		// no d2a_syn_spare
		radio_waitNus(12);
		// Group 2
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_val.fields.g2_spare_0 = 1; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_src_sel.fields.g2_spare_0 = 0; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_val.fields.g2_spare_1 = 1; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_src_sel.fields.g2_spare_1 = 0; //


		// ldo_lo_d2r_if_val vout_i_1v8_set_rx and vout_i_1v8_set_tx are both left at default value and both same value of 101
		// ldo_lo_d2r_if_val vout_i_1v8_set is also 101
		// So controlling from register will give the required setting of 101
		JN518X_RFPMODEM->transceiver.ldo_lo_d2r_if_val.fields.vout_i_1v8_set = 5; //
		JN518X_RFPMODEM->transceiver.ldo_lo_d2r_if_src_sel.fields.vout_i_1v8_set = 0; //

		// Only enable ldo when the vout setting (vout_i_1v8_set) has been applied
		JN518X_RFPMODEM->transceiver.ldo_lo_d2r_if_val.fields.enable_1v8 = 1; //
		JN518X_RFPMODEM->transceiver.ldo_lo_d2r_if_src_sel.fields.enable_1v8 = 0; //


		JN518X_RFPMODEM->transceiver.pll_vco_0_d2r_if_val.fields.pll_vco_enable = 1; //
		JN518X_RFPMODEM->transceiver.pll_vco_0_d2r_if_src_sel.fields.pll_vco_enable = 0; //


	}
	else
	{
        if (bKeepPll)
        {
          u8PLLGroup = 1;
          JN518X_RFPMODEM -> tmu.comparator_pre_rx1.val=TMU_PRE_RX1_FAST;
          JN518X_RFPMODEM -> tmu.comparator_pre_rx2.val=TMU_PRE_RX2_FAST;
          JN518X_RFPMODEM -> tmu.comparator_pre_rx3.val=TMU_PRE_RX3_FAST;
          //
          JN518X_RFPMODEM -> tmu.comparator_pre_tx1.val=TMU_PRE_TX1_FAST;
          JN518X_RFPMODEM -> tmu.comparator_pre_tx2.val=TMU_PRE_TX2_FAST;
          JN518X_RFPMODEM -> tmu.comparator_pre_tx3.val=TMU_PRE_TX3_FAST;

          JN518X_RFPMODEM->tmu.comparator_packet_start.val = TMU_PACKET_START_FAST;

        }
		// for ES2MF use new dummy bits to control G1, G2 and PLL: set bits
		JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val |= (  (0x1 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_G1_GRP_FORCED_POS)
																		|(0x1 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_G2_GRP_FORCED_POS)
																		|(u8PLLGroup << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_GRP_FORCED_POS));
	}

// Following settings give 39.6us from falling RXEN to rising TXEN at link layer
// TX3 is asserted 8us before data from link layer starts

// TMU timings - target settings
    JN518X_RFPMODEM->tmu.comparator_pre_g1.fields.comparator_pre = TMU_PRE_G1_FAST;// 1;
    JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre = TMU_PRE_G2_FAST; //2; //0.5us
    JN518X_RFPMODEM->tmu.comparator_pre_dp_reset.fields.comparator_pre =    TMU_PRE_DP_RESET_FAST; // RF - 20180926
    JN518X_RFPMODEM-> tmu.comparator_post_dp_reset.fields.comparator_post = TMU_POST_DP_RESET_FAST;  // SMB 28/01/19

//// Current setting in Radio Driver for G1, G2:
////   JN518X_RFPMODEM->tmu.comparator_pre_g1.fields.comparator_pre = 25;
////   JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre = 55; //27.5us
//// above  settings save (55-2)/2 = 26.5us
//// Current setting in Radio Driver for PWRUPDN:
//#ifndef ACCESS_ADDRESS_PATCH
//// JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN_b.rw_ble_radiopwrupdn = 0x3C890F4D; // changed to gain 7us at startup // standard value used for many sims - lengthen RTRIP delay to centre sync found
//// TXPWRUP 0x4D (77), reduce by 27 =>  now 50, 0x32
//// RXPWRUP 0x89 (137) reduce by 27 => now 110 0x6E  [but actually using 0x6F
//	JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN_b.rw_ble_radiopwrupdn = 0x3C6E0F32; // 10Sept: TXPWRUP now 84-27 (0x39) as G1 and G2 on
//#else
//// RTRIP_DELAY +4 and RXPWRUP +4 to compensate rfagc_track_delay changed from 4 to 0
//	JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN_b.rw_ble_radiopwrupdn = 0x40720F32; // 21Nov: TXPWRUP now 84-27 (0x39) as G1 and G2 on
//#endif


	// The access address patch checks all 32bits of access address instead of 28
	// It adds 4usec delay to the receive processing delay
#ifdef ACCESS_ADDRESS_PATCH
	  rtrip_delay += 4;
	  rxpwrup += 4;
#endif
	  // Radio startup delay is altered by these two options - so adjust TX adn RX power up values
	  if (bKeepPll)// Do not set this on non-MF device
	  {
		txpwrup-= (27 + 15);
		rxpwrup-= (27 +15);
	  }
	  else
	  {
		txpwrup-= (27);
		rxpwrup-= (27);
	  }

	  JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN_b.rw_ble_radiopwrupdn =  (rtrip_delay<<24)
																  | (rxpwrup <<16)
																  | (txpwrdn <<8)
																  | (txpwrup) ;
}

void vRadio_jn518x_DisableBLEFastTX(void)
{
    // create local variables for the 4 parts of the BLE timings register and initialise to the standard delay
    uint8_t rtrip_delay = RTRIP_DELAY_BASIC;
    uint8_t rxpwrup     = RXPWRUP_DELAY_BASIC;
    uint8_t txpwrdn     = TXPWRDN_DELAY_BASIC;
    uint8_t txpwrup     = TXPWRUP_DELAY_BASIC;

 	if (radio_jn518x_IsNotC2MF(NULL, NULL))
	{
		// Group 1
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_val.fields.g1_spare_0 = 0; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_src_sel.fields.g1_spare_0 = 1; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_val.fields.g1_spare_1 = 0; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_src_sel.fields.g1_spare_1 = 1; //

		JN518X_RFPMODEM->transceiver.ldo_synth_d2r_if_val.fields.enable_1v8 = 1; //
		JN518X_RFPMODEM->transceiver.ldo_synth_d2r_if_src_sel.fields.enable_1v8 = 0; //

		JN518X_RFPMODEM->transceiver.ldo_vco_d2r_if_val.fields.enable_1v8 = 0; //
		JN518X_RFPMODEM->transceiver.ldo_vco_d2r_if_src_sel.fields.enable_1v8 = 1; //

		//  JN518X_RFPMODEM->transceiver.rx_ldo_d2r_if_val.fields.rx_ldo_1v4_enable = 1; //
		//  JN518X_RFPMODEM->transceiver.rx_ldo_d2r_if_src_sel.fields.rx_ldo_1v4_enable = 0; //

		// no d2a_syn_spare
		radio_waitNus(12);
		// Group 2
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_val.fields.g2_spare_0 = 0; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_src_sel.fields.g2_spare_0 = 1; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_val.fields.g2_spare_1 = 0; //
		JN518X_RFPMODEM->transceiver.global_spare_d2r_if_src_sel.fields.g2_spare_1 = 1; //

		// ldo_lo_d2r_if_val vout_i_1v8_set_rx and vout_i_1v8_set_tx are both left at default value and both same value of 101
		// ldo_lo_d2r_if_val vout_i_1v8_set is also 101
		// So controlling from register will give the required setting of 101
		JN518X_RFPMODEM->transceiver.ldo_lo_d2r_if_val.fields.vout_i_1v8_set = 5; //
		JN518X_RFPMODEM->transceiver.ldo_lo_d2r_if_src_sel.fields.vout_i_1v8_set = 1; //

		// Only enable ldo when the vout setting (vout_i_1v8_set) has been applied
		JN518X_RFPMODEM->transceiver.ldo_lo_d2r_if_val.fields.enable_1v8 = 0; //
		JN518X_RFPMODEM->transceiver.ldo_lo_d2r_if_src_sel.fields.enable_1v8 = 1; //


		JN518X_RFPMODEM->transceiver.pll_vco_0_d2r_if_val.fields.pll_vco_enable = 0; //
		JN518X_RFPMODEM->transceiver.pll_vco_0_d2r_if_src_sel.fields.pll_vco_enable = 1; //

	}
	else
	{
		// for ES2MF use new dummy bits to control G1, G2 and PLL: clear bits
		JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val &= ~( EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_G1_GRP_FORCED_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_G2_GRP_FORCED_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_GRP_FORCED_MASK);
	}

	// TMU timings - SET ALL FIELDS AFFECTED BY THE fAST OPERATION BACK TO THEIR BASIC / STANDARD VALUES
	JN518X_RFPMODEM->tmu.comparator_pre_g1.fields.comparator_pre = TMU_PRE_G1_BASIC;
	JN518X_RFPMODEM->tmu.comparator_pre_g2.fields.comparator_pre = TMU_PRE_G2_BASIC;
	JN518X_RFPMODEM->tmu.comparator_pre_dp_reset.fields.comparator_pre = TMU_PRE_DP_RESET_BASIC;
	JN518X_RFPMODEM->tmu.comparator_post_dp_reset.fields.comparator_post = TMU_POST_DP_RESET_BASIC;
	JN518X_RFPMODEM -> tmu.comparator_pre_rx1.val=TMU_PRE_RX1_BASIC;
	JN518X_RFPMODEM -> tmu.comparator_pre_rx2.val=TMU_PRE_RX2_BASIC;
	JN518X_RFPMODEM -> tmu.comparator_pre_rx3.val=TMU_PRE_RX3_BASIC;
	//
	JN518X_RFPMODEM -> tmu.comparator_pre_tx1.val=TMU_PRE_TX1_BASIC;
	JN518X_RFPMODEM -> tmu.comparator_pre_tx2.val=TMU_PRE_TX2_BASIC;
	JN518X_RFPMODEM -> tmu.comparator_pre_tx3.val=TMU_PRE_TX3_BASIC;

	JN518X_RFPMODEM->tmu.comparator_packet_start.val = TMU_PACKET_START_BASIC;

	//  RW_BLE_RADIOPWRUPDN needs returning to standard setting

	// The access address patch checks all 32bits of access address instead of 28
	// It adds 4usec delay to the receive processing delay
#ifdef ACCESS_ADDRESS_PATCH
	rtrip_delay += 4;
	rxpwrup += 4;
#endif
	JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN =    (rtrip_delay<<24)
										 | (rxpwrup <<16)
										 | (txpwrdn <<8)
										 |  txpwrup ;
	// Replaced following timing control with the above code - removed absolute values to the defines section
	/*
	#ifndef ACCESS_ADDRESS_PATCH
	// JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN_b.rw_ble_radiopwrupdn = 0x3C890F4D; // changed to gain 7us at startup // standard value used for many sims - lengthen RTRIP delay to centre sync found
	// TXPWRUP 0x4D (77), reduce by 27 =>  now 50, 0x32
	// RXPWRUP 0x89 (137) reduce by 27 => now 110 0x6E  [but actually using 0x6F
	        JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN_b.rw_ble_radiopwrupdn = 0x3C890F4D; // 10Sept: TXPWRUP now 84-27 (0x39) as G1 and G2 on
	#else
	// RTRIP_DELAY +4 and RXPWRUP +4 to compensate rfagc_track_delay changed from 4 to 0
	        JN518X_BLELNK-> RW_BLE_RADIOPWRUPDN_b.rw_ble_radiopwrupdn = 0x408D0F4D; // 21Nov: TXPWRUP now 84-27 (0x39) as G1 and G2 on
	#endif
	*/
}
#else
void vRadio_jn518x_EnableBLEFastTX(bool bKeepPll)
{
}
void vRadio_jn518x_DisableBLEFastTX(void)
{
}
#endif

void vRadio_jn518x_ZBtoBLE(void)
{

}

void vRadio_jn518x_BLEtoZB(void)
{
	if (!(radio_jn518x_IsNotC2MF(NULL, NULL)))
	{
		// for ES2MF use new dummy bits to control G1, G2 and PLL: clear bits
		JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val &= ~( EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_G1_GRP_FORCED_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_G2_GRP_FORCED_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_PLL_GRP_FORCED_MASK);
	}

}




#ifdef RECALTIMEAPI
uint32_t u32Radio_JN518x_Get_Next_Recal_Duration(void)
{
	uint8_t i;
	uint32_t u32ReturnedDuration = 0;

	if (RadioConfiguration.u8InitDone)
	{
		if (!RadioConfiguration.u8ReCal_needed)
		{
			u32ReturnedDuration =0;
		} // else keep decision to run calibration and TempCur will be taken as TCal
		else
		{
			u32ReturnedDuration =RADIO_RECAL_TIME_WITH_KMOD_INIT_US;
			/* check Kmod calibration */
	    	// read Kmod cal results form flash
	    	for (i = 0; i<KMOD_TEMP_POINTS; i++)
	    	{
	    		if (((RadioKmodCalData[i].i16CalTemp-i16RecalThresholdTemp) <= RadioConfiguration.i16TCur)
	    			&& (RadioConfiguration.i16TCur <= (RadioKmodCalData[i].i16CalTemp+i16RecalThresholdTemp)))
	    		{
	    			u32ReturnedDuration =RADIO_RECAL_TIME_WITHOUT_KMOD_INIT_US;
					break;
	    		}
	    	}
	    }

	} // else keep decision to run calibration and TempCur will be taken as TCal, clear ReCal needed
	return(u32ReturnedDuration);
}

#else
uint32 u16Radio_JN518x_Get_Next_Recal_Duration(void)
{
	return(0x0);
}
#endif

void vRadio_Jn518x_AntennaDiversityTxRxEnable(bool bRxEnabled, bool bTxEnabled)
{
	JN518X_ZBMODEM -> MRX_CTRL_b.rx_cor_hi = 20;
	if (!radio_jn518x_IsNotC2MF(NULL, NULL))
	{
		if ((bTxEnabled) || (bRxEnabled))
		{
	JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val |= (  (0x1 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_AD_DOUBLE_ZERO_DETECT_POS)
																	|(0x1 << EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_AD_TIMER_ONLY_POS));
		}
		else
		{
			JN518X_RFPMODEM -> transceiver.dummy_output_d2r_if_val.val &= ~( EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_AD_DOUBLE_ZERO_DETECT_MASK
																		|EXTAPB_REGFILE_TRANSCEIVER_DUMMY_OUTPUT_D2R_IF_VAL_AD_TIMER_ONLY_MASK);
		}
	}

    if(bTxEnabled)
    {
    	JN518X_ZBMODEM->ANT_DIV_b.tx_ad_en =1;
    	RadioConfiguration.bADEnabled = true;
    }
    else
    {
    	JN518X_ZBMODEM->ANT_DIV_b.tx_ad_en =0;
    	RadioConfiguration.bADEnabled = false;
    }

    if(bRxEnabled)
    {
    	JN518X_ZBMODEM->ANT_DIV_b.rx_ad_en =1;
    	JN518X_ZBMODEM->ANT_DIV_b.ad_rssi_thr = RadioConfiguration.u16ADConfigThr; //-80dBm to be refine
    	JN518X_ZBMODEM->ANT_DIV_b.rx_ad_timer = RadioConfiguration.u8ADConfigTimer;   // 40us (value x4)
    	RadioConfiguration.bADEnabled = true;
    }
    else
    {
    	JN518X_ZBMODEM->ANT_DIV_b.rx_ad_en =0;
    	RadioConfiguration.bADEnabled = false;
    }

}

void vRadio_Jn518x_AntennaDiversityConfigure(uint16_t rssi_thr, uint8_t rx_timer)
{
	RadioConfiguration.u16ADConfigThr = (rssi_thr & 0x03FF);
	RadioConfiguration.u8ADConfigTimer = (rx_timer & 0x0F);
}


void vRadio_Jn518x_AntennaDiversitySwitch(void)
{
	JN518X_ZBMODEM->ANT_DIV_P |= 1;
}

uint8_t u8Radio_Jn518x_AntennaDiversityStatus(void)
{
	return ((uint8_t)(JN518X_ZBMODEM->MSTAT_b.rx_ad_ant));
}

int16_t i16Radio_Jn518x_GetNbRSSISync(void)
{
	return (((int16_t)((JN518X_RFPMODEM->rx_datapath.nb_rssi_dbm_sync.val)<<6))>>6);
}

void vRadio_Enable_DCO_DAC(void)
{
	if (!RadioConfiguration.bDcoDacEnabled)
	{
		JN518X_RFPMODEM -> transceiver.aaf_d2r_if_val.fields.rx_aaf_i_enable = 1; // Anti-aliasing filter enable (I side)
		JN518X_RFPMODEM -> transceiver.aaf_d2r_if_val.fields.rx_aaf_q_enable = 1; // Anti-aliasing filter enable (Q/DAC filter side)
		JN518X_RFPMODEM -> transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_i_enable = 0;  //0=register NOT function
		JN518X_RFPMODEM -> transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_q_enable = 0;  //0=register NOT function

		// Needs LDO IF supply to be active for DCOC DAC proper settling
		// LDO_IF interface: manual enabling
		JN518X_RFPMODEM -> transceiver.ldo_if_d2r_if_val.fields.enable_1v8 = 1; // LDO IF activation forced
		// LDO_IF interface: source selection
		JN518X_RFPMODEM -> transceiver.ldo_if_d2r_if_src_sel.fields.enable_1v8 = 0; // source=register, not TMU

		RadioConfiguration.bDcoDacEnabled = true;

		// patch to ensure that the DAC starts in a few us instead of to 10ms
		// activate DCbus on Q
		JN518X_ASYSCON->DCBUSCTRL_b.ADDR = 0x138;
		JN518X_ASYSCON->DCBUSCTRL_b.MUX1 = 0;
		JN518X_ASYSCON->DCBUSCTRL_b.MUX2 =0;
		// activate DCbus on I
		JN518X_ASYSCON->DCBUSCTRL_b.ADDR = 0x170;
		JN518X_ASYSCON->DCBUSCTRL_b.MUX1 = 0;
		JN518X_ASYSCON->DCBUSCTRL_b.MUX2 =0;
		//disable DCbus
		JN518X_ASYSCON->DCBUSCTRL_b.ADDR = 0x0;
		JN518X_ASYSCON->DCBUSCTRL_b.MUX1 = 0;
		JN518X_ASYSCON->DCBUSCTRL_b.MUX2 =0;
	}
}

void vRadio_Disable_DCO_DAC(void)
{
	if (RadioConfiguration.bDcoDacEnabled)
	{
		// restore ctrl to TMU
		JN518X_RFPMODEM -> transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_i_enable = 1;  //0=register NOT function
		JN518X_RFPMODEM -> transceiver.aaf_d2r_if_src_sel.fields.rx_aaf_q_enable = 1;  //0=register NOT function
		JN518X_RFPMODEM -> transceiver.ldo_if_d2r_if_src_sel.fields.enable_1v8 = 1; // source=register, not TMU

		RadioConfiguration.bDcoDacEnabled = false;
	}
}
#ifdef AA_ERROR_RECOVERY_PATCH

void BLE_DP1_IRQHandler(void)
{
	// patch
	JN518X_BLEMODEM -> DP_ANTENNA_CTRL_b.TEST_FD_POWER = 1;

	// clear interrupt
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT1 = 1;
}

void BLE_DP2_IRQHandler(void)
{
	// removepatch
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT1_MSK = 0;
	JN518X_BLEMODEM -> DP_ANTENNA_CTRL_b.TEST_FD_POWER = 0;
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT1 = 1;
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT1_MSK = 1;

	// clear interrupt
	JN518X_BLEMODEM->DP_INT_b.DP_INTERRUPT2 = 1;
}
#endif
