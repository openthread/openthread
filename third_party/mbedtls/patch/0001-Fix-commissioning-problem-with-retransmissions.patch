diff --git a/third_party/mbedtls/repo/library/ssl_tls.c b/third_party/mbedtls/repo/library/ssl_tls.c
index 84a04ae..72e4684 100644
--- a/third_party/mbedtls/repo/library/ssl_tls.c
+++ b/third_party/mbedtls/repo/library/ssl_tls.c
@@ -3070,6 +3070,23 @@ static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
 }
 #endif /* MBEDTLS_SSL_PROTO_DTLS */
 
+static inline uint64_t ssl_load_six_bytes( unsigned char *buf )
+{
+    return( ( (uint64_t) buf[0] << 40 ) |
+            ( (uint64_t) buf[1] << 32 ) |
+            ( (uint64_t) buf[2] << 24 ) |
+            ( (uint64_t) buf[3] << 16 ) |
+            ( (uint64_t) buf[4] <<  8 ) |
+            ( (uint64_t) buf[5]       ) );
+}
+
+#ifndef OT_DTLS_SLOW_CPU
+#define OT_DTLS_SLOW_CPU 1
+#endif //ndef OT_DTLS_SLOW_CPU
+#ifndef OT_DTLS_COMPUTATION_UNTILL_SEQ_NR
+#define OT_DTLS_COMPUTATION_UNTILL_SEQ_NR 6
+#endif //ndef OT_DTLS_COMPUTATION_UNTILL_SEQ_NR
+
 int mbedtls_ssl_prepare_handshake_record( mbedtls_ssl_context *ssl )
 {
     if( ssl->in_msglen < mbedtls_ssl_hs_hdr_len( ssl ) )
@@ -3101,8 +3118,22 @@ int mbedtls_ssl_prepare_handshake_record( mbedtls_ssl_context *ssl )
             /* Retransmit only on last message from previous flight, to avoid
              * too many retransmissions.
              * Besides, No sane server ever retransmits HelloVerifyRequest */
-            if( recv_msg_seq == ssl->handshake->in_flight_start_seq - 1 &&
-                ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST )
+            uint64_t rec_seqnum = ssl_load_six_bytes( ssl->in_ctr + 2 );
+            MBEDTLS_SSL_DEBUG_MSG( 1, ( "dtls seq %d", (uint32_t) (rec_seqnum&0xFFFFFFFF)));
+            if( (recv_msg_seq == ssl->handshake->in_flight_start_seq - 1) 
+                && (ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST) 
+#if OT_DTLS_SLOW_CPU == 1
+                /* if the crypto calculations take longer then the timeout
+                 * then don't reply to retransmissions that are currently in the rx queue.
+                 * Since the calculation time is deterministic, we know how many messages
+                 * from the queue need to be skipped; i.e. -> we don't trigger
+                 * retransmits on them */
+                && (ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_HELLO)
+                && (ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE)
+                && (ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_HELLO_DONE)
+                && (rec_seqnum     >  OT_DTLS_COMPUTATION_UNTILL_SEQ_NR)
+#endif
+                )
             {
                 MBEDTLS_SSL_DEBUG_MSG( 2, ( "received message from last flight, "
                                     "message_seq = %d, start_of_flight = %d",
@@ -3122,7 +3153,6 @@ int mbedtls_ssl_prepare_handshake_record( mbedtls_ssl_context *ssl )
                                     recv_msg_seq,
                                     ssl->handshake->in_msg_seq ) );
             }
-
             return( MBEDTLS_ERR_SSL_WANT_READ );
         }
         /* Wait until message completion to increment in_msg_seq */
@@ -3191,16 +3221,6 @@ static void ssl_dtls_replay_reset( mbedtls_ssl_context *ssl )
     ssl->in_window = 0;
 }
 
-static inline uint64_t ssl_load_six_bytes( unsigned char *buf )
-{
-    return( ( (uint64_t) buf[0] << 40 ) |
-            ( (uint64_t) buf[1] << 32 ) |
-            ( (uint64_t) buf[2] << 24 ) |
-            ( (uint64_t) buf[3] << 16 ) |
-            ( (uint64_t) buf[4] <<  8 ) |
-            ( (uint64_t) buf[5]       ) );
-}
-
 /*
  * Return 0 if sequence number is acceptable, -1 otherwise
  */
@@ -3608,6 +3628,24 @@ static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
                                         "expected %d, received %d",
                                         ssl->in_epoch, rec_epoch ) );
 
+#if defined(MBEDTLS_SSL_SRV_C)
+            /*
+             * Check for an epoch 0 Change Cipher Spec retransmission.
+             */
+            if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
+                ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER &&
+                rec_epoch == 0 &&
+                ssl->in_epoch == 1 &&
+                ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
+                ssl->in_left > 13 &&
+                ssl->in_buf[13] == MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE )
+            {
+                MBEDTLS_SSL_DEBUG_MSG( 1, ( "possible Client Key Exchange "
+                                            "retransmission" ) );
+                return( mbedtls_ssl_resend( ssl ) );
+            }
+#endif
+
 #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && defined(MBEDTLS_SSL_SRV_C)
             /*
              * Check for an epoch 0 ClientHello. We can't use in_msg here to
@@ -3737,7 +3775,8 @@ int mbedtls_ssl_read_record( mbedtls_ssl_context *ssl )
 
         ret = mbedtls_ssl_handle_message_type( ssl );
 
-    } while( MBEDTLS_ERR_SSL_NON_FATAL == ret );
+    } while( MBEDTLS_ERR_SSL_NON_FATAL == ret ||
+             ( MBEDTLS_ERR_SSL_WANT_READ == ret && ssl->in_msglen ) );
 
     if( 0 != ret )
     {
