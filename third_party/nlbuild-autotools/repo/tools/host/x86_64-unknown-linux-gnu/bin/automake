#!/usr/bin/perl -w
# -*- perl -*-
# Generated from bin/automake.in; do not edit by hand.

eval 'case $# in 0) exec /usr/bin/perl -S "$0";; *) exec /usr/bin/perl -S "$0" "$@";; esac'
    if 0;

# automake - create Makefile.in from Makefile.am
# Copyright (C) 1994-2013 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Originally written by David Mackenzie <djm@gnu.ai.mit.edu>.
# Perl reimplementation by Tom Tromey <tromey@redhat.com>, and
# Alexandre Duret-Lutz <adl@gnu.org>.

package Automake;

use strict;

BEGIN
{
  @Automake::perl_libdirs = ('//share/automake-1.14')
    unless @Automake::perl_libdirs;
  unshift @INC, @Automake::perl_libdirs;

  # Override SHELL.  This is required on DJGPP so that system() uses
  # bash, not COMMAND.COM which doesn't quote arguments properly.
  # Other systems aren't expected to use $SHELL when Automake
  # runs, but it should be safe to drop the "if DJGPP" guard if
  # it turns up other systems need the same thing.  After all,
  # if SHELL is used, ./configure's SHELL is always better than
  # the user's SHELL (which may be something like tcsh).
  $ENV{'SHELL'} = '/bin/sh' if exists $ENV{'DJDIR'};
}

use Automake::Config;
BEGIN
{
  if ($perl_threads)
    {
      require threads;
      import threads;
      require Thread::Queue;
      import Thread::Queue;
    }
}
use Automake::General;
use Automake::XFile;
use Automake::Channels;
use Automake::ChannelDefs;
use Automake::Configure_ac;
use Automake::FileUtils;
use Automake::Location;
use Automake::Condition qw/TRUE FALSE/;
use Automake::DisjConditions;
use Automake::Options;
use Automake::Variable;
use Automake::VarDef;
use Automake::Rule;
use Automake::RuleDef;
use Automake::Wrap 'makefile_wrap';
use Automake::Language;
use File::Basename;
use File::Spec;
use Carp;

## ----------------------- ##
## Subroutine prototypes.  ##
## ----------------------- ##

# BEGIN AUTOMATICALLY GENERATED PROTOTYPES
sub append_exeext (&$);
sub check_gnits_standards ();
sub check_gnu_standards ();
sub check_trailing_slash ($\$);
sub check_typos ();
sub define_files_variable ($\@$$);
sub define_standard_variables ();
sub define_verbose_libtool ();
sub define_verbose_texinfo ();
sub do_check_merge_target ();
sub get_number_of_threads ();
sub handle_compile ();
sub handle_data ();
sub handle_dist ();
sub handle_emacs_lisp ();
sub handle_factored_dependencies ();
sub handle_footer ();
sub handle_gettext ();
sub handle_headers ();
sub handle_install ();
sub handle_java ();
sub handle_languages ();
sub handle_libraries ();
sub handle_libtool ();
sub handle_ltlibraries ();
sub handle_makefiles_serial ();
sub handle_man_pages ();
sub handle_minor_options ();
sub handle_options ();
sub handle_programs ();
sub handle_python ();
sub handle_scripts ();
sub handle_silent ();
sub handle_subdirs ();
sub handle_tags ();
sub handle_tests ();
sub handle_tests_dejagnu ();
sub handle_texinfo ();
sub handle_user_recursion ();
sub initialize_per_input ();
sub lang_lex_finish ();
sub lang_sub_obj ();
sub lang_vala_finish ();
sub lang_yacc_finish ();
sub locate_aux_dir ();
sub parse_arguments ();
sub scan_aclocal_m4 ();
sub scan_autoconf_files ();
sub silent_flag ();
sub transform ($\%);
sub transform_token ($\%$);
sub usage ();
sub version ();
sub yacc_lex_finish_helper ();
# END AUTOMATICALLY GENERATED PROTOTYPES


## ----------- ##
## Constants.  ##
## ----------- ##

# Some regular expressions.  One reason to put them here is that it
# makes indentation work better in Emacs.

# Writing singled-quoted-$-terminated regexes is a pain because
# perl-mode thinks of $' as the ${'} variable (instead of a $ followed
# by a closing quote.  Letting perl-mode think the quote is not closed
# leads to all sort of misindentations.  On the other hand, defining
# regexes as double-quoted strings is far less readable.  So usually
# we will write:
#
#  $REGEX = '^regex_value' . "\$";

my $IGNORE_PATTERN = '^\s*##([^#\n].*)?\n';
my $WHITE_PATTERN = '^\s*' . "\$";
my $COMMENT_PATTERN = '^#';
my $TARGET_PATTERN='[$a-zA-Z0-9_.@%][-.a-zA-Z0-9_(){}/$+@%]*';
# A rule has three parts: a list of targets, a list of dependencies,
# and optionally actions.
my $RULE_PATTERN =
  "^($TARGET_PATTERN(?:(?:\\\\\n|\\s)+$TARGET_PATTERN)*) *:([^=].*|)\$";

# Only recognize leading spaces, not leading tabs.  If we recognize
# leading tabs here then we need to make the reader smarter, because
# otherwise it will think rules like 'foo=bar; \' are errors.
my $ASSIGNMENT_PATTERN = '^ *([^ \t=:+]*)\s*([:+]?)=\s*(.*)' . "\$";
# This pattern recognizes a Gnits version id and sets $1 if the
# release is an alpha release.  We also allow a suffix which can be
# used to extend the version number with a "fork" identifier.
my $GNITS_VERSION_PATTERN = '\d+\.\d+([a-z]|\.\d+)?(-[A-Za-z0-9]+)?';

my $IF_PATTERN = '^if\s+(!?)\s*([A-Za-z][A-Za-z0-9_]*)\s*(?:#.*)?' . "\$";
my $ELSE_PATTERN =
  '^else(?:\s+(!?)\s*([A-Za-z][A-Za-z0-9_]*))?\s*(?:#.*)?' . "\$";
my $ENDIF_PATTERN =
  '^endif(?:\s+(!?)\s*([A-Za-z][A-Za-z0-9_]*))?\s*(?:#.*)?' . "\$";
my $PATH_PATTERN = '(\w|[+/.-])+';
# This will pass through anything not of the prescribed form.
my $INCLUDE_PATTERN = ('^include\s+'
		       . '((\$\(top_srcdir\)/' . $PATH_PATTERN . ')'
		       . '|(\$\(srcdir\)/' . $PATH_PATTERN . ')'
		       . '|([^/\$]' . $PATH_PATTERN . '))\s*(#.*)?' . "\$");

# Directories installed during 'install-exec' phase.
my $EXEC_DIR_PATTERN =
  '^(?:bin|sbin|libexec|sysconf|localstate|lib|pkglib|.*exec.*)' . "\$";

# Values for AC_CANONICAL_*
use constant AC_CANONICAL_BUILD  => 1;
use constant AC_CANONICAL_HOST   => 2;
use constant AC_CANONICAL_TARGET => 3;

# Values indicating when something should be cleaned.
use constant MOSTLY_CLEAN     => 0;
use constant CLEAN            => 1;
use constant DIST_CLEAN       => 2;
use constant MAINTAINER_CLEAN => 3;

# Libtool files.
my @libtool_files = qw(ltmain.sh config.guess config.sub);
# ltconfig appears here for compatibility with old versions of libtool.
my @libtool_sometimes = qw(ltconfig ltcf-c.sh ltcf-cxx.sh ltcf-gcj.sh);

# Commonly found files we look for and automatically include in
# DISTFILES.
my @common_files =
    (qw(ABOUT-GNU ABOUT-NLS AUTHORS BACKLOG COPYING COPYING.DOC COPYING.LIB
	COPYING.LESSER ChangeLog INSTALL NEWS README THANKS TODO
	ar-lib compile config.guess config.rpath
	config.sub depcomp install-sh libversion.in mdate-sh
	missing mkinstalldirs py-compile texinfo.tex ylwrap),
     @libtool_files, @libtool_sometimes);

# Commonly used files we auto-include, but only sometimes.  This list
# is used for the --help output only.
my @common_sometimes =
  qw(aclocal.m4 acconfig.h config.h.top config.h.bot configure
     configure.ac configure.in stamp-vti);

# Standard directories from the GNU Coding Standards, and additional
# pkg* directories from Automake.  Stored in a hash for fast member check.
my %standard_prefix =
    map { $_ => 1 } (qw(bin data dataroot doc dvi exec html include info
			lib libexec lisp locale localstate man man1 man2
			man3 man4 man5 man6 man7 man8 man9 oldinclude pdf
			pkgdata pkginclude pkglib pkglibexec ps sbin
			sharedstate sysconf));

# Copyright on generated Makefile.ins.
my $gen_copyright = "\
# Copyright (C) 1994-$RELEASE_YEAR Free Software Foundation, Inc.

# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.
";

# These constants are returned by the lang_*_rewrite functions.
# LANG_SUBDIR means that the resulting object file should be in a
# subdir if the source file is.  In this case the file name cannot
# have '..' components.
use constant LANG_IGNORE  => 0;
use constant LANG_PROCESS => 1;
use constant LANG_SUBDIR  => 2;

# These are used when keeping track of whether an object can be built
# by two different paths.
use constant COMPILE_LIBTOOL  => 1;
use constant COMPILE_ORDINARY => 2;

# We can't always associate a location to a variable or a rule,
# when it's defined by Automake.  We use INTERNAL in this case.
use constant INTERNAL => new Automake::Location;

# Serialization keys for message queues.
use constant QUEUE_MESSAGE   => "msg";
use constant QUEUE_CONF_FILE => "conf file";
use constant QUEUE_LOCATION  => "location";
use constant QUEUE_STRING    => "string";

## ---------------------------------- ##
## Variables related to the options.  ##
## ---------------------------------- ##

# TRUE if we should always generate Makefile.in.
my $force_generation = 1;

# From the Perl manual.
my $symlink_exists = (eval 'symlink ("", "");', $@ eq '');

# TRUE if missing standard files should be installed.
my $add_missing = 0;

# TRUE if we should copy missing files; otherwise symlink if possible.
my $copy_missing = 0;

# TRUE if we should always update files that we know about.
my $force_missing = 0;


## ---------------------------------------- ##
## Variables filled during files scanning.  ##
## ---------------------------------------- ##

# Name of the configure.ac file.
my $configure_ac;

# Files found by scanning configure.ac for LIBOBJS.
my %libsources = ();

# Names used in AC_CONFIG_HEADERS call.
my @config_headers = ();

# Names used in AC_CONFIG_LINKS call.
my @config_links = ();

# List of Makefile.am's to process, and their corresponding outputs.
my @input_files = ();
my %output_files = ();

# Complete list of Makefile.am's that exist.
my @configure_input_files = ();

# List of files in AC_CONFIG_FILES/AC_OUTPUT without Makefile.am's,
# and their outputs.
my @other_input_files = ();
# Where each AC_CONFIG_FILES/AC_OUTPUT/AC_CONFIG_LINK/AC_CONFIG_HEADERS
# appears.  The keys are the files created by these macros.
my %ac_config_files_location = ();
# The condition under which AC_CONFIG_FOOS appears.
my %ac_config_files_condition = ();

# Directory to search for configure-required files.  This
# will be computed by locate_aux_dir() and can be set using
# AC_CONFIG_AUX_DIR in configure.ac.
# $CONFIG_AUX_DIR is the 'raw' directory, valid only in the source-tree.
my $config_aux_dir = '';
my $config_aux_dir_set_in_configure_ac = 0;
# $AM_CONFIG_AUX_DIR is prefixed with $(top_srcdir), so it can be used
# in Makefiles.
my $am_config_aux_dir = '';

# Directory to search for AC_LIBSOURCE files, as set by AC_CONFIG_LIBOBJ_DIR
# in configure.ac.
my $config_libobj_dir = '';

# Whether AM_GNU_GETTEXT has been seen in configure.ac.
my $seen_gettext = 0;
# Whether AM_GNU_GETTEXT([external]) is used.
my $seen_gettext_external = 0;
# Where AM_GNU_GETTEXT appears.
my $ac_gettext_location;
# Whether AM_GNU_GETTEXT_INTL_SUBDIR has been seen.
my $seen_gettext_intl = 0;

# The arguments of the AM_EXTRA_RECURSIVE_TARGETS call (if any).
my @extra_recursive_targets = ();

# Lists of tags supported by Libtool.
my %libtool_tags = ();
# 1 if Libtool uses LT_SUPPORTED_TAG.  If it does, then it also
# uses AC_REQUIRE_AUX_FILE.
my $libtool_new_api = 0;

# Most important AC_CANONICAL_* macro seen so far.
my $seen_canonical = 0;

# Where AM_MAINTAINER_MODE appears.
my $seen_maint_mode;

# Actual version we've seen.
my $package_version = '';

# Where version is defined.
my $package_version_location;

# TRUE if we've seen AM_PROG_AR
my $seen_ar = 0;

# Location of AC_REQUIRE_AUX_FILE calls, indexed by their argument.
my %required_aux_file = ();

# Where AM_INIT_AUTOMAKE is called;
my $seen_init_automake = 0;

# TRUE if we've seen AM_AUTOMAKE_VERSION.
my $seen_automake_version = 0;

# Hash table of discovered configure substitutions.  Keys are names,
# values are 'FILE:LINE' strings which are used by error message
# generation.
my %configure_vars = ();

# Ignored configure substitutions (i.e., variables not to be output in
# Makefile.in)
my %ignored_configure_vars = ();

# Files included by $configure_ac.
my @configure_deps = ();

# Greatest timestamp of configure's dependencies.
my $configure_deps_greatest_timestamp = 0;

# Hash table of AM_CONDITIONAL variables seen in configure.
my %configure_cond = ();

# This maps extensions onto language names.
my %extension_map = ();

# List of the DIST_COMMON files we discovered while reading
# configure.ac.
my $configure_dist_common = '';

# This maps languages names onto objects.
my %languages = ();
# Maps each linker variable onto a language object.
my %link_languages = ();

# maps extensions to needed source flags.
my %sourceflags = ();

# List of targets we must always output.
# FIXME: Complete, and remove falsely required targets.
my %required_targets =
  (
   'all'          => 1,
   'dvi'	  => 1,
   'pdf'	  => 1,
   'ps'		  => 1,
   'info'	  => 1,
   'install-info' => 1,
   'install'      => 1,
   'install-data' => 1,
   'install-exec' => 1,
   'uninstall'    => 1,

   # FIXME: Not required, temporary hacks.
   # Well, actually they are sort of required: the -recursive
   # targets will run them anyway...
   'html-am'         => 1,
   'dvi-am'          => 1,
   'pdf-am'          => 1,
   'ps-am'           => 1,
   'info-am'         => 1,
   'install-data-am' => 1,
   'install-exec-am' => 1,
   'install-html-am' => 1,
   'install-dvi-am'  => 1,
   'install-pdf-am'  => 1,
   'install-ps-am'   => 1,
   'install-info-am' => 1,
   'installcheck-am' => 1,
   'uninstall-am'    => 1,
   'tags-am'         => 1,
   'ctags-am'        => 1,
   'cscopelist-am'   => 1,
   'install-man'     => 1,
  );

# Queue to push require_conf_file requirements to.
my $required_conf_file_queue;

# The name of the Makefile currently being processed.
my $am_file = 'BUG';

################################################################

## ------------------------------------------ ##
## Variables reset by &initialize_per_input.  ##
## ------------------------------------------ ##

# Relative dir of the output makefile.
my $relative_dir;

# Greatest timestamp of the output's dependencies (excluding
# configure's dependencies).
my $output_deps_greatest_timestamp;

# These variables are used when generating each Makefile.in.
# They hold the Makefile.in until it is ready to be printed.
my $output_vars;
my $output_all;
my $output_header;
my $output_rules;
my $output_trailer;

# This is the conditional stack, updated on if/else/endif, and
# used to build Condition objects.
my @cond_stack;

# This holds the set of included files.
my @include_stack;

# List of dependencies for the obvious targets.
my @all;
my @check;
my @check_tests;

# Keys in this hash table are files to delete.  The associated
# value tells when this should happen (MOSTLY_CLEAN, DIST_CLEAN, etc.)
my %clean_files;

# Keys in this hash table are object files or other files in
# subdirectories which need to be removed.  This only holds files
# which are created by compilations.  The value in the hash indicates
# when the file should be removed.
my %compile_clean_files;

# Keys in this hash table are directories where we expect to build a
# libtool object.  We use this information to decide what directories
# to delete.
my %libtool_clean_directories;

# Value of $(SOURCES), used by tags.am.
my @sources;
# Sources which go in the distribution.
my @dist_sources;

# This hash maps object file names onto their corresponding source
# file names.  This is used to ensure that each object is created
# by a single source file.
my %object_map;

# This hash maps object file names onto an integer value representing
# whether this object has been built via ordinary compilation or
# libtool compilation (the COMPILE_* constants).
my %object_compilation_map;


# This keeps track of the directories for which we've already
# created dirstamp code.  Keys are directories, values are stamp files.
# Several keys can share the same stamp files if they are equivalent
# (as are './/foo' and 'foo').
my %directory_map;

# All .P files.
my %dep_files;

# This is a list of all targets to run during "make dist".
my @dist_targets;

# Keep track of all programs declared in this Makefile, without
# $(EXEEXT).  @substitutions@ are not listed.
my %known_programs;
my %known_libraries;

# This keeps track of which extensions we've seen (that we care
# about).
my %extension_seen;

# This is random scratch space for the language finish functions.
# Don't randomly overwrite it; examine other uses of keys first.
my %language_scratch;

# We keep track of which objects need special (per-executable)
# handling on a per-language basis.
my %lang_specific_files;

# This is set when 'handle_dist' has finished.  Once this happens,
# we should no longer push on dist_common.
my $handle_dist_run;

# Used to store a set of linkers needed to generate the sources currently
# under consideration.
my %linkers_used;

# True if we need 'LINK' defined.  This is a hack.
my $need_link;

# Does the generated Makefile have to build some compiled object
# (for binary programs, or plain or libtool libraries)?
my $must_handle_compiled_objects;

# Record each file processed by make_paragraphs.
my %transformed_files;

################################################################

## ---------------------------------------------- ##
## Variables not reset by &initialize_per_input.  ##
## ---------------------------------------------- ##

# Cache each file processed by make_paragraphs.
# (This is different from %transformed_files because
# %transformed_files is reset for each file while %am_file_cache
# it global to the run.)
my %am_file_cache;

################################################################

# var_SUFFIXES_trigger ($TYPE, $VALUE)
# ------------------------------------
# This is called by Automake::Variable::define() when SUFFIXES
# is defined ($TYPE eq '') or appended ($TYPE eq '+').
# The work here needs to be performed as a side-effect of the
# macro_define() call because SUFFIXES definitions impact
# on $KNOWN_EXTENSIONS_PATTERN which is used used when parsing
# the input am file.
sub var_SUFFIXES_trigger
{
    my ($type, $value) = @_;
    accept_extensions (split (' ', $value));
}
Automake::Variable::hook ('SUFFIXES', \&var_SUFFIXES_trigger);

################################################################


# initialize_per_input ()
# -----------------------
# (Re)-Initialize per-Makefile.am variables.
sub initialize_per_input ()
{
    reset_local_duplicates ();

    $relative_dir = undef;

    $output_deps_greatest_timestamp = 0;

    $output_vars = '';
    $output_all = '';
    $output_header = '';
    $output_rules = '';
    $output_trailer = '';

    Automake::Options::reset;
    Automake::Variable::reset;
    Automake::Rule::reset;

    @cond_stack = ();

    @include_stack = ();

    @all = ();
    @check = ();
    @check_tests = ();

    %clean_files = ();
    %compile_clean_files = ();

    # We always include '.'.  This isn't strictly correct.
    %libtool_clean_directories = ('.' => 1);

    @sources = ();
    @dist_sources = ();

    %object_map = ();
    %object_compilation_map = ();

    %directory_map = ();

    %dep_files = ();

    @dist_targets = ();

    %known_programs = ();
    %known_libraries= ();

    %extension_seen = ();

    %language_scratch = ();

    %lang_specific_files = ();

    $handle_dist_run = 0;

    $need_link = 0;

    $must_handle_compiled_objects = 0;

    %transformed_files = ();
}


################################################################

# Initialize our list of languages that are internally supported.

my @cpplike_flags =
  qw{
    $(DEFS)
    $(DEFAULT_INCLUDES)
    $(INCLUDES)
    $(AM_CPPFLAGS)
    $(CPPFLAGS)
  };

# C.
register_language ('name' => 'c',
		   'Name' => 'C',
		   'config_vars' => ['CC'],
		   'autodep' => '',
		   'flags' => ['CFLAGS', 'CPPFLAGS'],
		   'ccer' => 'CC',
		   'compiler' => 'COMPILE',
		   'compile' => "\$(CC) @cpplike_flags \$(AM_CFLAGS) \$(CFLAGS)",
		   'lder' => 'CCLD',
		   'ld' => '$(CC)',
		   'linker' => 'LINK',
		   'link' => '$(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'CC',
		   'extensions' => ['.c']);

# C++.
register_language ('name' => 'cxx',
		   'Name' => 'C++',
		   'config_vars' => ['CXX'],
		   'linker' => 'CXXLINK',
		   'link' => '$(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'autodep' => 'CXX',
		   'flags' => ['CXXFLAGS', 'CPPFLAGS'],
		   'compile' => "\$(CXX) @cpplike_flags \$(AM_CXXFLAGS) \$(CXXFLAGS)",
		   'ccer' => 'CXX',
		   'compiler' => 'CXXCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'CXX',
		   'lder' => 'CXXLD',
		   'ld' => '$(CXX)',
		   'pure' => 1,
		   'extensions' => ['.c++', '.cc', '.cpp', '.cxx', '.C']);

# Objective C.
register_language ('name' => 'objc',
		   'Name' => 'Objective C',
		   'config_vars' => ['OBJC'],
		   'linker' => 'OBJCLINK',
		   'link' => '$(OBJCLD) $(AM_OBJCFLAGS) $(OBJCFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'autodep' => 'OBJC',
		   'flags' => ['OBJCFLAGS', 'CPPFLAGS'],
		   'compile' => "\$(OBJC) @cpplike_flags \$(AM_OBJCFLAGS) \$(OBJCFLAGS)",
		   'ccer' => 'OBJC',
		   'compiler' => 'OBJCCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'lder' => 'OBJCLD',
		   'ld' => '$(OBJC)',
		   'pure' => 1,
		   'extensions' => ['.m']);

# Objective C++.
register_language ('name' => 'objcxx',
		   'Name' => 'Objective C++',
		   'config_vars' => ['OBJCXX'],
		   'linker' => 'OBJCXXLINK',
		   'link' => '$(OBJCXXLD) $(AM_OBJCXXFLAGS) $(OBJCXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'autodep' => 'OBJCXX',
		   'flags' => ['OBJCXXFLAGS', 'CPPFLAGS'],
		   'compile' => "\$(OBJCXX) @cpplike_flags \$(AM_OBJCXXFLAGS) \$(OBJCXXFLAGS)",
		   'ccer' => 'OBJCXX',
		   'compiler' => 'OBJCXXCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'lder' => 'OBJCXXLD',
		   'ld' => '$(OBJCXX)',
		   'pure' => 1,
		   'extensions' => ['.mm']);

# Unified Parallel C.
register_language ('name' => 'upc',
		   'Name' => 'Unified Parallel C',
		   'config_vars' => ['UPC'],
		   'linker' => 'UPCLINK',
		   'link' => '$(UPCLD) $(AM_UPCFLAGS) $(UPCFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'autodep' => 'UPC',
		   'flags' => ['UPCFLAGS', 'CPPFLAGS'],
		   'compile' => "\$(UPC) @cpplike_flags \$(AM_UPCFLAGS) \$(UPCFLAGS)",
		   'ccer' => 'UPC',
		   'compiler' => 'UPCCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'lder' => 'UPCLD',
		   'ld' => '$(UPC)',
		   'pure' => 1,
		   'extensions' => ['.upc']);

# Headers.
register_language ('name' => 'header',
		   'Name' => 'Header',
		   'extensions' => ['.h', '.H', '.hxx', '.h++', '.hh',
				    '.hpp', '.inc'],
		   # No output.
		   'output_extensions' => sub { return () },
		   # Nothing to do.
		   '_finish' => sub { });

# Vala
register_language ('name' => 'vala',
		   'Name' => 'Vala',
		   'config_vars' => ['VALAC'],
		   'flags' => [],
		   'compile' => '$(VALAC) $(AM_VALAFLAGS) $(VALAFLAGS)',
		   'ccer' => 'VALAC',
		   'compiler' => 'VALACOMPILE',
		   'extensions' => ['.vala'],
		   'output_extensions' => sub { (my $ext = $_[0]) =~ s/vala$/c/;
						return ($ext,) },
		   'rule_file' => 'vala',
		   '_finish' => \&lang_vala_finish,
		   '_target_hook' => \&lang_vala_target_hook,
		   'nodist_specific' => 1);

# Yacc (C & C++).
register_language ('name' => 'yacc',
		   'Name' => 'Yacc',
		   'config_vars' => ['YACC'],
		   'flags' => ['YFLAGS'],
		   'compile' => '$(YACC) $(AM_YFLAGS) $(YFLAGS)',
		   'ccer' => 'YACC',
		   'compiler' => 'YACCCOMPILE',
		   'extensions' => ['.y'],
		   'output_extensions' => sub { (my $ext = $_[0]) =~ tr/y/c/;
						return ($ext,) },
		   'rule_file' => 'yacc',
		   '_finish' => \&lang_yacc_finish,
		   '_target_hook' => \&lang_yacc_target_hook,
		   'nodist_specific' => 1);
register_language ('name' => 'yaccxx',
		   'Name' => 'Yacc (C++)',
		   'config_vars' => ['YACC'],
		   'rule_file' => 'yacc',
		   'flags' => ['YFLAGS'],
		   'ccer' => 'YACC',
		   'compiler' => 'YACCCOMPILE',
		   'compile' => '$(YACC) $(AM_YFLAGS) $(YFLAGS)',
		   'extensions' => ['.y++', '.yy', '.yxx', '.ypp'],
		   'output_extensions' => sub { (my $ext = $_[0]) =~ tr/y/c/;
						return ($ext,) },
		   '_finish' => \&lang_yacc_finish,
		   '_target_hook' => \&lang_yacc_target_hook,
		   'nodist_specific' => 1);

# Lex (C & C++).
register_language ('name' => 'lex',
		   'Name' => 'Lex',
		   'config_vars' => ['LEX'],
		   'rule_file' => 'lex',
		   'flags' => ['LFLAGS'],
		   'compile' => '$(LEX) $(AM_LFLAGS) $(LFLAGS)',
		   'ccer' => 'LEX',
		   'compiler' => 'LEXCOMPILE',
		   'extensions' => ['.l'],
		   'output_extensions' => sub { (my $ext = $_[0]) =~ tr/l/c/;
						return ($ext,) },
		   '_finish' => \&lang_lex_finish,
		   '_target_hook' => \&lang_lex_target_hook,
		   'nodist_specific' => 1);
register_language ('name' => 'lexxx',
		   'Name' => 'Lex (C++)',
		   'config_vars' => ['LEX'],
		   'rule_file' => 'lex',
		   'flags' => ['LFLAGS'],
		   'compile' => '$(LEX) $(AM_LFLAGS) $(LFLAGS)',
		   'ccer' => 'LEX',
		   'compiler' => 'LEXCOMPILE',
		   'extensions' => ['.l++', '.ll', '.lxx', '.lpp'],
		   'output_extensions' => sub { (my $ext = $_[0]) =~ tr/l/c/;
						return ($ext,) },
		   '_finish' => \&lang_lex_finish,
		   '_target_hook' => \&lang_lex_target_hook,
		   'nodist_specific' => 1);

# Assembler.
register_language ('name' => 'asm',
		   'Name' => 'Assembler',
		   'config_vars' => ['CCAS', 'CCASFLAGS'],

		   'flags' => ['CCASFLAGS'],
		   # Users can set AM_CCASFLAGS to include DEFS, INCLUDES,
		   # or anything else required.  They can also set CCAS.
		   # Or simply use Preprocessed Assembler.
		   'compile' => '$(CCAS) $(AM_CCASFLAGS) $(CCASFLAGS)',
		   'ccer' => 'CCAS',
		   'compiler' => 'CCASCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'extensions' => ['.s']);

# Preprocessed Assembler.
register_language ('name' => 'cppasm',
		   'Name' => 'Preprocessed Assembler',
		   'config_vars' => ['CCAS', 'CCASFLAGS'],

		   'autodep' => 'CCAS',
		   'flags' => ['CCASFLAGS', 'CPPFLAGS'],
		   'compile' => "\$(CCAS) @cpplike_flags \$(AM_CCASFLAGS) \$(CCASFLAGS)",
		   'ccer' => 'CPPAS',
		   'compiler' => 'CPPASCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'extensions' => ['.S', '.sx']);

# Fortran 77
register_language ('name' => 'f77',
		   'Name' => 'Fortran 77',
		   'config_vars' => ['F77'],
		   'linker' => 'F77LINK',
		   'link' => '$(F77LD) $(AM_FFLAGS) $(FFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'flags' => ['FFLAGS'],
		   'compile' => '$(F77) $(AM_FFLAGS) $(FFLAGS)',
		   'ccer' => 'F77',
		   'compiler' => 'F77COMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'F77',
		   'lder' => 'F77LD',
		   'ld' => '$(F77)',
		   'pure' => 1,
		   'extensions' => ['.f', '.for']);

# Fortran
register_language ('name' => 'fc',
		   'Name' => 'Fortran',
		   'config_vars' => ['FC'],
		   'linker' => 'FCLINK',
		   'link' => '$(FCLD) $(AM_FCFLAGS) $(FCFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'flags' => ['FCFLAGS'],
		   'compile' => '$(FC) $(AM_FCFLAGS) $(FCFLAGS)',
		   'ccer' => 'FC',
		   'compiler' => 'FCCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'FC',
		   'lder' => 'FCLD',
		   'ld' => '$(FC)',
		   'pure' => 1,
		   'extensions' => ['.f90', '.f95', '.f03', '.f08']);

# Preprocessed Fortran
register_language ('name' => 'ppfc',
		   'Name' => 'Preprocessed Fortran',
		   'config_vars' => ['FC'],
		   'linker' => 'FCLINK',
		   'link' => '$(FCLD) $(AM_FCFLAGS) $(FCFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'lder' => 'FCLD',
		   'ld' => '$(FC)',
		   'flags' => ['FCFLAGS', 'CPPFLAGS'],
		   'ccer' => 'PPFC',
		   'compiler' => 'PPFCCOMPILE',
		   'compile' => "\$(FC) @cpplike_flags \$(AM_FCFLAGS) \$(FCFLAGS)",
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'FC',
		   'pure' => 1,
		   'extensions' => ['.F90','.F95', '.F03', '.F08']);

# Preprocessed Fortran 77
#
# The current support for preprocessing Fortran 77 just involves
# passing "$(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS)
# $(CPPFLAGS)" as additional flags to the Fortran 77 compiler, since
# this is how GNU Make does it; see the "GNU Make Manual, Edition 0.51
# for 'make' Version 3.76 Beta" (specifically, from info file
# '(make)Catalogue of Rules').
#
# A better approach would be to write an Autoconf test
# (i.e. AC_PROG_FPP) for a Fortran 77 preprocessor, because not all
# Fortran 77 compilers know how to do preprocessing.  The Autoconf
# macro AC_PROG_FPP should test the Fortran 77 compiler first for
# preprocessing capabilities, and then fall back on cpp (if cpp were
# available).
register_language ('name' => 'ppf77',
		   'Name' => 'Preprocessed Fortran 77',
		   'config_vars' => ['F77'],
		   'linker' => 'F77LINK',
		   'link' => '$(F77LD) $(AM_FFLAGS) $(FFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'lder' => 'F77LD',
		   'ld' => '$(F77)',
		   'flags' => ['FFLAGS', 'CPPFLAGS'],
		   'ccer' => 'PPF77',
		   'compiler' => 'PPF77COMPILE',
		   'compile' => "\$(F77) @cpplike_flags \$(AM_FFLAGS) \$(FFLAGS)",
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'F77',
		   'pure' => 1,
		   'extensions' => ['.F']);

# Ratfor.
register_language ('name' => 'ratfor',
		   'Name' => 'Ratfor',
		   'config_vars' => ['F77'],
		   'linker' => 'F77LINK',
		   'link' => '$(F77LD) $(AM_FFLAGS) $(FFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'lder' => 'F77LD',
		   'ld' => '$(F77)',
		   'flags' => ['RFLAGS', 'FFLAGS'],
		   # FIXME also FFLAGS.
		   'compile' => '$(F77) $(AM_FFLAGS) $(FFLAGS) $(AM_RFLAGS) $(RFLAGS)',
		   'ccer' => 'F77',
		   'compiler' => 'RCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'F77',
		   'pure' => 1,
		   'extensions' => ['.r']);

# Java via gcj.
register_language ('name' => 'java',
		   'Name' => 'Java',
		   'config_vars' => ['GCJ'],
		   'linker' => 'GCJLINK',
		   'link' => '$(GCJLD) $(AM_GCJFLAGS) $(GCJFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@',
		   'autodep' => 'GCJ',
		   'flags' => ['GCJFLAGS'],
		   'compile' => '$(GCJ) $(AM_GCJFLAGS) $(GCJFLAGS)',
		   'ccer' => 'GCJ',
		   'compiler' => 'GCJCOMPILE',
		   'compile_flag' => '-c',
		   'output_flag' => '-o',
		   'libtool_tag' => 'GCJ',
		   'lder' => 'GCJLD',
		   'ld' => '$(GCJ)',
		   'pure' => 1,
		   'extensions' => ['.java', '.class', '.zip', '.jar']);

################################################################

# Error reporting functions.

# err_am ($MESSAGE, [%OPTIONS])
# -----------------------------
# Uncategorized errors about the current Makefile.am.
sub err_am
{
  msg_am ('error', @_);
}

# err_ac ($MESSAGE, [%OPTIONS])
# -----------------------------
# Uncategorized errors about configure.ac.
sub err_ac
{
  msg_ac ('error', @_);
}

# msg_am ($CHANNEL, $MESSAGE, [%OPTIONS])
# ---------------------------------------
# Messages about about the current Makefile.am.
sub msg_am
{
  my ($channel, $msg, %opts) = @_;
  msg $channel, "${am_file}.am", $msg, %opts;
}

# msg_ac ($CHANNEL, $MESSAGE, [%OPTIONS])
# ---------------------------------------
# Messages about about configure.ac.
sub msg_ac
{
  my ($channel, $msg, %opts) = @_;
  msg $channel, $configure_ac, $msg, %opts;
}

################################################################

# subst ($TEXT)
# -------------
# Return a configure-style substitution using the indicated text.
# We do this to avoid having the substitutions directly in automake.in;
# when we do that they are sometimes removed and this causes confusion
# and bugs.
sub subst
{
    my ($text) = @_;
    return '@' . $text . '@';
}

################################################################


# $BACKPATH
# backname ($RELDIR)
# -------------------
# If I "cd $RELDIR", then to come back, I should "cd $BACKPATH".
# For instance 'src/foo' => '../..'.
# Works with non strictly increasing paths, i.e., 'src/../lib' => '..'.
sub backname
{
    my ($file) = @_;
    my @res;
    foreach (split (/\//, $file))
    {
	next if $_ eq '.' || $_ eq '';
	if ($_ eq '..')
	{
	    pop @res
	      or prog_error ("trying to reverse path '$file' pointing outside tree");
	}
	else
	{
	    push (@res, '..');
	}
    }
    return join ('/', @res) || '.';
}

################################################################

# Silent rules handling functions.

# verbose_var (NAME)
# ------------------
# The public variable stem used to implement silent rules.
sub verbose_var
{
    my ($name) = @_;
    return 'AM_V_' . $name;
}

# verbose_private_var (NAME)
# --------------------------
# The naming policy for the private variables for silent rules.
sub verbose_private_var
{
    my ($name) = @_;
    return 'am__v_' . $name;
}

# define_verbose_var (NAME, VAL-IF-SILENT, [VAL-IF-VERBOSE])
# ----------------------------------------------------------
# For  silent rules, setup VAR and dispatcher, to expand to
# VAL-IF-SILENT if silent, to VAL-IF-VERBOSE (defaulting to
# empty) if not.
sub define_verbose_var
{
    my ($name, $silent_val, $verbose_val) = @_;
    $verbose_val = '' unless defined $verbose_val;
    my $var = verbose_var ($name);
    my $pvar = verbose_private_var ($name);
    my $silent_var = $pvar . '_0';
    my $verbose_var = $pvar . '_1';
    # For typical 'make's, 'configure' replaces AM_V (inside @@) with $(V)
    # and AM_DEFAULT_V (inside @@) with $(AM_DEFAULT_VERBOSITY).
    # For strict POSIX 2008 'make's, it replaces them with 0 or 1 instead.
    # See AM_SILENT_RULES in m4/silent.m4.
    define_variable ($var, '$(' . $pvar . '_@'.'AM_V'.'@)', INTERNAL);
    define_variable ($pvar . '_', '$(' . $pvar . '_@'.'AM_DEFAULT_V'.'@)',
                     INTERNAL);
    Automake::Variable::define ($silent_var, VAR_AUTOMAKE, '', TRUE,
                                $silent_val, '', INTERNAL, VAR_ASIS)
      if (! vardef ($silent_var, TRUE));
    Automake::Variable::define ($verbose_var, VAR_AUTOMAKE, '', TRUE,
                                $verbose_val, '', INTERNAL, VAR_ASIS)
      if (! vardef ($verbose_var, TRUE));
}

# verbose_flag (NAME)
# -------------------
# Contents of '%VERBOSE%' variable to expand before rule command.
sub verbose_flag
{
    my ($name) = @_;
    return '$(' . verbose_var ($name) . ')';
}

sub verbose_nodep_flag
{
    my ($name) = @_;
    return '$(' . verbose_var ($name) . subst ('am__nodep') . ')';
}

# silent_flag
# -----------
# Contents of %SILENT%: variable to expand to '@' when silent.
sub silent_flag ()
{
    return verbose_flag ('at');
}

# define_verbose_tagvar (NAME)
# ----------------------------
# Engage the needed silent rules machinery for tag NAME.
sub define_verbose_tagvar
{
    my ($name) = @_;
    define_verbose_var ($name, '@echo "  '. $name . ' ' x (8 - length ($name)) . '" $@;');
}

# Engage the needed silent rules machinery for assorted texinfo commands.
sub define_verbose_texinfo ()
{
  my @tagvars = ('DVIPS', 'MAKEINFO', 'INFOHTML', 'TEXI2DVI', 'TEXI2PDF');
  foreach my $tag (@tagvars)
    {
      define_verbose_tagvar($tag);
    }
  define_verbose_var('texinfo', '-q');
  define_verbose_var('texidevnull', '> /dev/null');
}

# Engage the needed silent rules machinery for 'libtool --silent'.
sub define_verbose_libtool ()
{
    define_verbose_var ('lt', '--silent');
    return verbose_flag ('lt');
}

sub handle_silent ()
{
    # Define "$(AM_V_P)", expanding to a shell conditional that can be
    # used in make recipes to determine whether we are being run in
    # silent mode or not.  The choice of the name derives from the LISP
    # convention of appending the letter 'P' to denote a predicate (see
    # also "the '-P' convention" in the Jargon File); we do so for lack
    # of a better convention.
    define_verbose_var ('P', 'false', ':');
    # *Always* provide the user with '$(AM_V_GEN)', unconditionally.
    define_verbose_tagvar ('GEN');
    define_verbose_var ('at', '@');
}


################################################################


# Handle AUTOMAKE_OPTIONS variable.  Return 0 on error, 1 otherwise.
sub handle_options ()
{
  my $var = var ('AUTOMAKE_OPTIONS');
  if ($var)
    {
      if ($var->has_conditional_contents)
	{
	  msg_var ('unsupported', $var,
		   "'AUTOMAKE_OPTIONS' cannot have conditional contents");
	}
      my @options = map { { option => $_->[1], where => $_->[0] } }
			$var->value_as_list_recursive (cond_filter => TRUE,
						       location => 1);
      return 0 unless process_option_list (@options);
    }

  if ($strictness == GNITS)
    {
      set_option ('readme-alpha', INTERNAL);
      set_option ('std-options', INTERNAL);
      set_option ('check-news', INTERNAL);
    }

  return 1;
}

# shadow_unconditionally ($varname, $where)
# -----------------------------------------
# Return a $(variable) that contains all possible values
# $varname can take.
# If the VAR wasn't defined conditionally, return $(VAR).
# Otherwise we create an am__VAR_DIST variable which contains
# all possible values, and return $(am__VAR_DIST).
sub shadow_unconditionally
{
  my ($varname, $where) = @_;
  my $var = var $varname;
  if ($var->has_conditional_contents)
    {
      $varname = "am__${varname}_DIST";
      my @files = uniq ($var->value_as_list_recursive);
      define_pretty_variable ($varname, TRUE, $where, @files);
    }
  return "\$($varname)"
}

# check_user_variables (@LIST)
# ----------------------------
# Make sure each variable VAR in @LIST does not exist, suggest using AM_VAR
# otherwise.
sub check_user_variables
{
  my @dont_override = @_;
  foreach my $flag (@dont_override)
    {
      my $var = var $flag;
      if ($var)
	{
	  for my $cond ($var->conditions->conds)
	    {
	      if ($var->rdef ($cond)->owner == VAR_MAKEFILE)
		{
		  msg_cond_var ('gnu', $cond, $flag,
				"'$flag' is a user variable, "
				. "you should not override it;\n"
				. "use 'AM_$flag' instead");
		}
	    }
	}
    }
}

# Call finish function for each language that was used.
sub handle_languages ()
{
    if (! option 'no-dependencies')
    {
	# Include auto-dep code.  Don't include it if DEP_FILES would
	# be empty.
	if (keys %extension_seen && keys %dep_files)
	{
	    # Set location of depcomp.
	    define_variable ('depcomp',
			     "\$(SHELL) $am_config_aux_dir/depcomp",
			     INTERNAL);
	    define_variable ('am__depfiles_maybe', 'depfiles', INTERNAL);

	    require_conf_file ("$am_file.am", FOREIGN, 'depcomp');

	    my @deplist = sort keys %dep_files;
	    # Generate each 'include' individually.  Irix 6 make will
	    # not properly include several files resulting from a
	    # variable expansion; generating many separate includes
	    # seems safest.
	    $output_rules .= "\n";
	    foreach my $iter (@deplist)
	    {
		$output_rules .= (subst ('AMDEP_TRUE')
				  . subst ('am__include')
				  . ' '
				  . subst ('am__quote')
				  . $iter
				  . subst ('am__quote')
				  . "\n");
	    }

	    # Compute the set of directories to remove in distclean-depend.
	    my @depdirs = uniq (map { dirname ($_) } @deplist);
	    $output_rules .= file_contents ('depend',
					    new Automake::Location,
					    DEPDIRS => "@depdirs");
	}
    }
    else
    {
	define_variable ('depcomp', '', INTERNAL);
	define_variable ('am__depfiles_maybe', '', INTERNAL);
    }

    my %done;

    # Is the C linker needed?
    my $needs_c = 0;
    foreach my $ext (sort keys %extension_seen)
    {
	next unless $extension_map{$ext};

	my $lang = $languages{$extension_map{$ext}};

	my $rule_file = $lang->rule_file || 'depend2';

	# Get information on $LANG.
	my $pfx = $lang->autodep;
	my $fpfx = ($pfx eq '') ? 'CC' : $pfx;

	my ($AMDEP, $FASTDEP) =
	  (option 'no-dependencies' || $lang->autodep eq 'no')
	  ? ('FALSE', 'FALSE') : ('AMDEP', "am__fastdep$fpfx");

	my $verbose = verbose_flag ($lang->ccer || 'GEN');
	my $verbose_nodep = ($AMDEP eq 'FALSE')
	  ? $verbose : verbose_nodep_flag ($lang->ccer || 'GEN');
	my $silent = silent_flag ();

	my %transform = ('EXT'     => $ext,
			 'PFX'     => $pfx,
			 'FPFX'    => $fpfx,
			 'AMDEP'   => $AMDEP,
			 'FASTDEP' => $FASTDEP,
			 '-c'      => $lang->compile_flag || '',
			 # These are not used, but they need to be defined
			 # so transform() do not complain.
			 SUBDIROBJ     => 0,
			 'DERIVED-EXT' => 'BUG',
			 DIST_SOURCE   => 1,
			 VERBOSE   => $verbose,
			 'VERBOSE-NODEP' => $verbose_nodep,
			 SILENT    => $silent,
			);

	# Generate the appropriate rules for this extension.
	if (((! option 'no-dependencies') && $lang->autodep ne 'no')
	    || defined $lang->compile)
	{
	    # Compute a possible derived extension.
	    # This is not used by depend2.am.
	    my $der_ext = ($lang->output_extensions->($ext))[0];

	    # When we output an inference rule like '.c.o:' we
	    # have two cases to consider: either subdir-objects
	    # is used, or it is not.
	    #
	    # In the latter case the rule is used to build objects
	    # in the current directory, and dependencies always
	    # go into './$(DEPDIR)/'.  We can hard-code this value.
	    #
	    # In the former case the rule can be used to build
	    # objects in sub-directories too.  Dependencies should
	    # go into the appropriate sub-directories, e.g.,
	    # 'sub/$(DEPDIR)/'.  The value of this directory
	    # needs to be computed on-the-fly.
	    #
	    # DEPBASE holds the name of this directory, plus the
	    # basename part of the object file (extensions Po, TPo,
	    # Plo, TPlo will be added later as appropriate).  It is
	    # either hardcoded, or a shell variable ('$depbase') that
	    # will be computed by the rule.
	    my $depbase =
	      option ('subdir-objects') ? '$$depbase' : '$(DEPDIR)/$*';
	    $output_rules .=
	      file_contents ($rule_file,
			     new Automake::Location,
			     %transform,
			     GENERIC   => 1,

			     'DERIVED-EXT' => $der_ext,

			     DEPBASE   => $depbase,
			     BASE      => '$*',
			     SOURCE    => '$<',
			     SOURCEFLAG => $sourceflags{$ext} || '',
			     OBJ       => '$@',
			     OBJOBJ    => '$@',
			     LTOBJ     => '$@',

			     COMPILE   => '$(' . $lang->compiler . ')',
			     LTCOMPILE => '$(LT' . $lang->compiler . ')',
			     -o        => $lang->output_flag,
			     SUBDIROBJ => !! option 'subdir-objects');
	}

	# Now include code for each specially handled object with this
	# language.
	my %seen_files = ();
	foreach my $file (@{$lang_specific_files{$lang->name}})
	{
	    my ($derived, $source, $obj, $myext, $srcext, %file_transform) = @$file;

	    # We might see a given object twice, for instance if it is
	    # used under different conditions.
	    next if defined $seen_files{$obj};
	    $seen_files{$obj} = 1;

	    prog_error ("found " . $lang->name .
			" in handle_languages, but compiler not defined")
	      unless defined $lang->compile;

	    my $obj_compile = $lang->compile;

	    # Rewrite each occurrence of 'AM_$flag' in the compile
	    # rule into '${derived}_$flag' if it exists.
	    for my $flag (@{$lang->flags})
	      {
		my $val = "${derived}_$flag";
		$obj_compile =~ s/\(AM_$flag\)/\($val\)/
		  if set_seen ($val);
	      }

	    my $libtool_tag = '';
	    if ($lang->libtool_tag && exists $libtool_tags{$lang->libtool_tag})
	      {
		$libtool_tag = '--tag=' . $lang->libtool_tag . ' '
	      }

	    my $ptltflags = "${derived}_LIBTOOLFLAGS";
	    $ptltflags = 'AM_LIBTOOLFLAGS' unless set_seen $ptltflags;

	    my $ltverbose = define_verbose_libtool ();
	    my $obj_ltcompile =
	      "\$(LIBTOOL) $ltverbose $libtool_tag\$($ptltflags) \$(LIBTOOLFLAGS) "
	      . "--mode=compile $obj_compile";

	    # We _need_ '-o' for per object rules.
	    my $output_flag = $lang->output_flag || '-o';

	    my $depbase = dirname ($obj);
	    $depbase = ''
		if $depbase eq '.';
	    $depbase .= '/'
		unless $depbase eq '';
	    $depbase .= '$(DEPDIR)/' . basename ($obj);

	    $output_rules .=
	      file_contents ($rule_file,
			     new Automake::Location,
			     %transform,
			     GENERIC   => 0,

			     DEPBASE   => $depbase,
			     BASE      => $obj,
			     SOURCE    => $source,
			     SOURCEFLAG => $sourceflags{$srcext} || '',
			     # Use $myext and not '.o' here, in case
			     # we are actually building a new source
			     # file -- e.g. via yacc.
			     OBJ       => "$obj$myext",
			     OBJOBJ    => "$obj.obj",
			     LTOBJ     => "$obj.lo",

			     VERBOSE   => $verbose,
			     'VERBOSE-NODEP'  => $verbose_nodep,
			     SILENT    => $silent,
			     COMPILE   => $obj_compile,
			     LTCOMPILE => $obj_ltcompile,
			     -o        => $output_flag,
			     %file_transform);
	}

	# The rest of the loop is done once per language.
	next if defined $done{$lang};
	$done{$lang} = 1;

	# Load the language dependent Makefile chunks.
	my %lang = map { uc ($_) => 0 } keys %languages;
	$lang{uc ($lang->name)} = 1;
	$output_rules .= file_contents ('lang-compile',
					new Automake::Location,
					%transform, %lang);

	# If the source to a program consists entirely of code from a
	# 'pure' language, for instance C++ or Fortran 77, then we
	# don't need the C compiler code.  However if we run into
	# something unusual then we do generate the C code.  There are
	# probably corner cases here that do not work properly.
	# People linking Java code to Fortran code deserve pain.
	$needs_c ||= ! $lang->pure;

	define_compiler_variable ($lang)
	  if ($lang->compile);

	define_linker_variable ($lang)
	  if ($lang->link);

	require_variables ("$am_file.am", $lang->Name . " source seen",
			   TRUE, @{$lang->config_vars});

	# Call the finisher.
	$lang->finish;

	# Flags listed in '->flags' are user variables (per GNU Standards),
	# they should not be overridden in the Makefile...
	my @dont_override = @{$lang->flags};
	# ... and so is LDFLAGS.
	push @dont_override, 'LDFLAGS' if $lang->link;

	check_user_variables @dont_override;
    }

    # If the project is entirely C++ or entirely Fortran 77 (i.e., 1
    # suffix rule was learned), don't bother with the C stuff.  But if
    # anything else creeps in, then use it.
    my @languages_seen = map { $languages{$extension_map{$_}}->name }
                             (keys %extension_seen);
    @languages_seen = uniq (@languages_seen);
    $needs_c = 1 if @languages_seen > 1;
    if ($need_link || $needs_c)
      {
	define_compiler_variable ($languages{'c'})
	  unless defined $done{$languages{'c'}};
	define_linker_variable ($languages{'c'});
      }
}


# append_exeext { PREDICATE } $MACRO
# ----------------------------------
# Append $(EXEEXT) to each filename in $F appearing in the Makefile
# variable $MACRO if &PREDICATE($F) is true.  @substitutions@ are
# ignored.
#
# This is typically used on all filenames of *_PROGRAMS, and filenames
# of TESTS that are programs.
sub append_exeext (&$)
{
  my ($pred, $macro) = @_;

  transform_variable_recursively
    ($macro, $macro, 'am__EXEEXT', 0, INTERNAL,
     sub {
       my ($subvar, $val, $cond, $full_cond) = @_;
       # Append $(EXEEXT) unless the user did it already, or it's a
       # @substitution@.
       $val .= '$(EXEEXT)'
	 if $val !~ /(?:\$\(EXEEXT\)$|^[@]\w+[@]$)/ && &$pred ($val);
       return $val;
     });
}


# Check to make sure a source defined in LIBOBJS is not explicitly
# mentioned.  This is a separate function (as opposed to being inlined
# in handle_source_transform) because it isn't always appropriate to
# do this check.
sub check_libobjs_sources
{
  my ($one_file, $unxformed) = @_;

  foreach my $prefix ('', 'EXTRA_', 'dist_', 'nodist_',
		      'dist_EXTRA_', 'nodist_EXTRA_')
    {
      my @files;
      my $varname = $prefix . $one_file . '_SOURCES';
      my $var = var ($varname);
      if ($var)
	{
	  @files = $var->value_as_list_recursive;
	}
      elsif ($prefix eq '')
	{
	  @files = ($unxformed . '.c');
	}
      else
	{
	  next;
	}

      foreach my $file (@files)
	{
	  err_var ($prefix . $one_file . '_SOURCES',
		   "automatically discovered file '$file' should not" .
		   " be explicitly mentioned")
	    if defined $libsources{$file};
	}
    }
}


# @OBJECTS
# handle_single_transform ($VAR, $TOPPARENT, $DERIVED, $OBJ, $FILE, %TRANSFORM)
# -----------------------------------------------------------------------------
# Does much of the actual work for handle_source_transform.
# Arguments are:
#   $VAR is the name of the variable that the source filenames come from
#   $TOPPARENT is the name of the _SOURCES variable which is being processed
#   $DERIVED is the name of resulting executable or library
#   $OBJ is the object extension (e.g., '.lo')
#   $FILE the source file to transform
#   %TRANSFORM contains extras arguments to pass to file_contents
#     when producing explicit rules
# Result is a list of the names of objects
# %linkers_used will be updated with any linkers needed
sub handle_single_transform
{
    my ($var, $topparent, $derived, $obj, $_file, %transform) = @_;
    my @files = ($_file);
    my @result = ();

    # Turn sources into objects.  We use a while loop like this
    # because we might add to @files in the loop.
    while (scalar @files > 0)
    {
	$_ = shift @files;

	# Configure substitutions in _SOURCES variables are errors.
	if (/^\@.*\@$/)
	{
	  my $parent_msg = '';
	  $parent_msg = "\nand is referred to from '$topparent'"
	    if $topparent ne $var->name;
	  err_var ($var,
		   "'" . $var->name . "' includes configure substitution '$_'"
		   . $parent_msg . ";\nconfigure " .
		   "substitutions are not allowed in _SOURCES variables");
	  next;
	}

	# If the source file is in a subdirectory then the '.o' is put
	# into the current directory, unless the subdir-objects option
	# is in effect.

	# Split file name into base and extension.
	next if ! /^(?:(.*)\/)?([^\/]*)($KNOWN_EXTENSIONS_PATTERN)$/;
	my $full = $_;
	my $directory = $1 || '';
	my $base = $2;
	my $extension = $3;

	# We must generate a rule for the object if it requires its own flags.
	my $renamed = 0;
	my ($linker, $object);

	# This records whether we've seen a derived source file (e.g.
	# yacc output).
	my $derived_source = 0;

	# This holds the 'aggregate context' of the file we are
	# currently examining.  If the file is compiled with
	# per-object flags, then it will be the name of the object.
	# Otherwise it will be 'AM'.  This is used by the target hook
	# language function.
	my $aggregate = 'AM';

	$extension = derive_suffix ($extension, $obj);
	my $lang;
	if ($extension_map{$extension} &&
	    ($lang = $languages{$extension_map{$extension}}))
	{
	    # Found the language, so see what it says.
	    saw_extension ($extension);

	    # Do we have per-executable flags for this executable?
	    my $have_per_exec_flags = 0;
	    my @peflags = @{$lang->flags};
	    push @peflags, 'LIBTOOLFLAGS' if $obj eq '.lo';
	    foreach my $flag (@peflags)
	      {
		if (set_seen ("${derived}_$flag"))
		  {
		    $have_per_exec_flags = 1;
		    last;
		  }
	      }

	    # Note: computed subr call.  The language rewrite function
	    # should return one of the LANG_* constants.  It could
	    # also return a list whose first value is such a constant
	    # and whose second value is a new source extension which
	    # should be applied.  This means this particular language
	    # generates another source file which we must then process
	    # further.
	    my $subr = \&{'lang_' . $lang->name . '_rewrite'};
	    defined &$subr or $subr = \&lang_sub_obj;
	    my ($r, $source_extension)
		= &$subr ($directory, $base, $extension,
			  $obj, $have_per_exec_flags, $var);
	    # Skip this entry if we were asked not to process it.
	    next if $r == LANG_IGNORE;

	    # Now extract linker and other info.
	    $linker = $lang->linker;

	    my $this_obj_ext;
	    if (defined $source_extension)
	    {
		$this_obj_ext = $source_extension;
		$derived_source = 1;
	    }
	    else
	    {
		$this_obj_ext = $obj;
	    }
	    $object = $base . $this_obj_ext;

	    if ($have_per_exec_flags)
	    {
		# We have a per-executable flag in effect for this
		# object.  In this case we rewrite the object's
		# name to ensure it is unique.

		# We choose the name 'DERIVED_OBJECT' to ensure
		# (1) uniqueness, and (2) continuity between
		# invocations.  However, this will result in a
		# name that is too long for losing systems, in
		# some situations.  So we provide _SHORTNAME to
		# override.

		my $dname = $derived;
		my $var = var ($derived . '_SHORTNAME');
		if ($var)
		{
		    # FIXME: should use the same Condition as
		    # the _SOURCES variable.  But this is really
		    # silly overkill -- nobody should have
		    # conditional shortnames.
		    $dname = $var->variable_value;
		}
		$object = $dname . '-' . $object;

		prog_error ($lang->name . " flags defined without compiler")
		  if ! defined $lang->compile;

		$renamed = 1;
	    }

	    # If rewrite said it was ok, put the object into a
	    # subdir.
	    if ($directory ne '')
	    {
              if ($r == LANG_SUBDIR)
                {
                  $object = $directory . '/' . $object;
                }
              else
                {
                  # Since the next major version of automake (2.0) will
                  # make the behaviour so far only activated with the
                  # 'subdir-object' option mandatory, it's better if we
                  # start warning users not using that option.
                  # As suggested by Peter Johansson, we strive to avoid
                  # the warning when it would be irrelevant, i.e., if
                  # all source files sit in "current" directory.
                  msg_var 'unsupported', $var,
                          "source file '$full' is in a subdirectory,"
                          . "\nbut option 'subdir-objects' is disabled";
                  msg 'unsupported', INTERNAL, <<'EOF', uniq_scope => US_GLOBAL;
possible forward-incompatibility.
At least a source file is in a subdirectory, but the 'subdir-objects'
automake option hasn't been enabled.  For now, the corresponding output
object file(s) will be placed in the top-level directory.  However,
this behaviour will change in future Automake versions: they will
unconditionally cause object files to be placed in the same subdirectory
of the corresponding sources.
You are advised to start using 'subdir-objects' option throughout your
project, to avoid future incompatibilities.
EOF
                }
	    }

	    # If the object file has been renamed (because per-target
	    # flags are used) we cannot compile the file with an
	    # inference rule: we need an explicit rule.
	    #
	    # If the source is in a subdirectory and the object is in
	    # the current directory, we also need an explicit rule.
	    #
	    # If both source and object files are in a subdirectory
	    # (this happens when the subdir-objects option is used),
	    # then the inference will work.
	    #
	    # The latter case deserves a historical note.  When the
	    # subdir-objects option was added on 1999-04-11 it was
	    # thought that inferences rules would work for
	    # subdirectory objects too.  Later, on 1999-11-22,
	    # automake was changed to output explicit rules even for
	    # subdir-objects.  Nobody remembers why, but this occurred
	    # soon after the merge of the user-dep-gen-branch so it
	    # might be related.  In late 2003 people complained about
	    # the size of the generated Makefile.ins (libgcj, with
	    # 2200+ subdir objects was reported to have a 9MB
	    # Makefile), so we now rely on inference rules again.
	    # Maybe we'll run across the same issue as in the past,
	    # but at least this time we can document it.  However since
	    # dependency tracking has evolved it is possible that
	    # our old problem no longer exists.
	    # Using inference rules for subdir-objects has been tested
	    # with GNU make, Solaris make, Ultrix make, BSD make,
	    # HP-UX make, and OSF1 make successfully.
	    if ($renamed
		|| ($directory ne '' && ! option 'subdir-objects')
		# We must also use specific rules for a nodist_ source
		# if its language requests it.
		|| ($lang->nodist_specific && ! $transform{'DIST_SOURCE'}))
	    {
		my $obj_sans_ext = substr ($object, 0,
					   - length ($this_obj_ext));
		my $full_ansi;
		if ($directory ne '')
	          {
			$full_ansi = $directory . '/' . $base . $extension;
	          }
		else
	          {
			$full_ansi = $base . $extension;
	          }

		my @specifics = ($full_ansi, $obj_sans_ext,
				 # Only use $this_obj_ext in the derived
				 # source case because in the other case we
				 # *don't* want $(OBJEXT) to appear here.
				 ($derived_source ? $this_obj_ext : '.o'),
				 $extension);

		# If we renamed the object then we want to use the
		# per-executable flag name.  But if this is simply a
		# subdir build then we still want to use the AM_ flag
		# name.
		if ($renamed)
		  {
		    unshift @specifics, $derived;
		    $aggregate = $derived;
		  }
		else
		  {
		    unshift @specifics, 'AM';
		  }

		# Each item on this list is a reference to a list consisting
		# of four values followed by additional transform flags for
		# file_contents.  The four values are the derived flag prefix
		# (e.g. for 'foo_CFLAGS', it is 'foo'), the name of the
		# source file, the base name of the output file, and
		# the extension for the object file.
		push (@{$lang_specific_files{$lang->name}},
		      [@specifics, %transform]);
	    }
	}
	elsif ($extension eq $obj)
	{
	    # This is probably the result of a direct suffix rule.
	    # In this case we just accept the rewrite.
	    $object = "$base$extension";
	    $object = "$directory/$object" if $directory ne '';
	    $linker = '';
	}
	else
	{
	    # No error message here.  Used to have one, but it was
	    # very unpopular.
	    # FIXME: we could potentially do more processing here,
	    # perhaps treating the new extension as though it were a
	    # new source extension (as above).  This would require
	    # more restructuring than is appropriate right now.
	    next;
	}

	err_am "object '$object' created by '$full' and '$object_map{$object}'"
	  if (defined $object_map{$object}
	      && $object_map{$object} ne $full);

	my $comp_val = (($object =~ /\.lo$/)
			? COMPILE_LIBTOOL : COMPILE_ORDINARY);
	(my $comp_obj = $object) =~ s/\.lo$/.\$(OBJEXT)/;
	if (defined $object_compilation_map{$comp_obj}
	    && $object_compilation_map{$comp_obj} != 0
	    # Only see the error once.
	    && ($object_compilation_map{$comp_obj}
		!= (COMPILE_LIBTOOL | COMPILE_ORDINARY))
	    && $object_compilation_map{$comp_obj} != $comp_val)
	  {
	    err_am "object '$comp_obj' created both with libtool and without";
	  }
	$object_compilation_map{$comp_obj} |= $comp_val;

	if (defined $lang)
	{
	    # Let the language do some special magic if required.
	    $lang->target_hook ($aggregate, $object, $full, %transform);
	}

	if ($derived_source)
	  {
	    prog_error ($lang->name . " has automatic dependency tracking")
	      if $lang->autodep ne 'no';
	    # Make sure this new source file is handled next.  That will
	    # make it appear to be at the right place in the list.
	    unshift (@files, $object);
	    # Distribute derived sources unless the source they are
	    # derived from is not.
	    push_dist_common ($object)
	      unless ($topparent =~ /^(?:nobase_)?nodist_/);
	    next;
	  }

	$linkers_used{$linker} = 1;

	push (@result, $object);

	if (! defined $object_map{$object})
	{
	    my @dep_list = ();
	    $object_map{$object} = $full;

	    # If resulting object is in subdir, we need to make
	    # sure the subdir exists at build time.
	    if ($object =~ /\//)
	    {
		# FIXME: check that $DIRECTORY is somewhere in the
		# project

		# For Java, the way we're handling it right now, a
		# '..' component doesn't make sense.
		if ($lang && $lang->name eq 'java' && $object =~ /(\/|^)\.\.\//)
		  {
		    err_am "'$full' should not contain a '..' component";
		  }

                # Make sure *all* objects files in the subdirectory are
                # removed by "make mostlyclean".  Not only this is more
                # efficient than listing the object files to be removed
                # individually (which would cause an 'rm' invocation for
                # each of them -- very inefficient, see bug#10697), it
                # would also leave stale object files in the subdirectory
                # whenever a source file there is removed or renamed.
                $compile_clean_files{"$directory/*.\$(OBJEXT)"} = MOSTLY_CLEAN;
                if ($object =~ /\.lo$/)
                  {
                    # If we have a libtool object, then we also must remove
                    # any '.lo' objects in its same subdirectory.
                    $compile_clean_files{"$directory/*.lo"} = MOSTLY_CLEAN;
                    # Remember to cleanup .libs/ in this directory.
                    $libtool_clean_directories{$directory} = 1;
                  }

		push (@dep_list, require_build_directory ($directory));

		# If we're generating dependencies, we also want
		# to make sure that the appropriate subdir of the
		# .deps directory is created.
		push (@dep_list,
		      require_build_directory ($directory . '/$(DEPDIR)'))
		  unless option 'no-dependencies';
	    }

	    pretty_print_rule ($object . ':', "\t", @dep_list)
		if scalar @dep_list > 0;
	}

	# Transform .o or $o file into .P file (for automatic
	# dependency code).
        # Properly flatten multiple adjacent slashes, as Solaris 10 make
        # might fail over them in an include statement.
        # Leading double slashes may be special, as per Posix, so deal
        # with them carefully.
        if ($lang && $lang->autodep ne 'no')
        {
            my $depfile = $object;
            $depfile =~ s/\.([^.]*)$/.P$1/;
            $depfile =~ s/\$\(OBJEXT\)$/o/;
            my $maybe_extra_leading_slash = '';
            $maybe_extra_leading_slash = '/' if $depfile =~ m,^//[^/],;
            $depfile =~ s,/+,/,g;
            my $basename = basename ($depfile);
            # This might make $dirname empty, but we account for that below.
            (my $dirname = dirname ($depfile)) =~ s/\/*$//;
            $dirname = $maybe_extra_leading_slash . $dirname;
            $dep_files{$dirname . '/$(DEPDIR)/' . $basename} = 1;
        }
    }

    return @result;
}


# $LINKER
# define_objects_from_sources ($VAR, $OBJVAR, $NODEFINE, $ONE_FILE,
#                              $OBJ, $PARENT, $TOPPARENT, $WHERE, %TRANSFORM)
# ---------------------------------------------------------------------------
# Define an _OBJECTS variable for a _SOURCES variable (or subvariable)
#
# Arguments are:
#   $VAR is the name of the _SOURCES variable
#   $OBJVAR is the name of the _OBJECTS variable if known (otherwise
#     it will be generated and returned).
#   $NODEFINE is a boolean: if true, $OBJVAR will not be defined (but
#     work done to determine the linker will be).
#   $ONE_FILE is the canonical (transformed) name of object to build
#   $OBJ is the object extension (i.e. either '.o' or '.lo').
#   $TOPPARENT is the _SOURCES variable being processed.
#   $WHERE context into which this definition is done
#   %TRANSFORM extra arguments to pass to file_contents when producing
#     rules
#
# Result is a pair ($LINKER, $OBJVAR):
#    $LINKER is a boolean, true if a linker is needed to deal with the objects
sub define_objects_from_sources
{
  my ($var, $objvar, $nodefine, $one_file,
      $obj, $topparent, $where, %transform) = @_;

  my $needlinker = "";

  transform_variable_recursively
    ($var, $objvar, 'am__objects', $nodefine, $where,
     # The transform code to run on each filename.
     sub {
       my ($subvar, $val, $cond, $full_cond) = @_;
       my @trans = handle_single_transform ($subvar, $topparent,
					    $one_file, $obj, $val,
					    %transform);
       $needlinker = "true" if @trans;
       return @trans;
     });

  return $needlinker;
}


# handle_source_transform ($CANON_TARGET, $TARGET, $OBJEXT, $WHERE, %TRANSFORM)
# -----------------------------------------------------------------------------
# Handle SOURCE->OBJECT transform for one program or library.
# Arguments are:
#   canonical (transformed) name of target to build
#   actual target of object to build
#   object extension (i.e., either '.o' or '$o')
#   location of the source variable
#   extra arguments to pass to file_contents when producing rules
# Return the name of the linker variable that must be used.
# Empty return means just use 'LINK'.
sub handle_source_transform
{
    # one_file is canonical name.  unxformed is given name.  obj is
    # object extension.
    my ($one_file, $unxformed, $obj, $where, %transform) = @_;

    my $linker = '';

    # No point in continuing if _OBJECTS is defined.
    return if reject_var ($one_file . '_OBJECTS',
			  $one_file . '_OBJECTS should not be defined');

    my %used_pfx = ();
    my $needlinker;
    %linkers_used = ();
    foreach my $prefix ('', 'EXTRA_', 'dist_', 'nodist_',
			'dist_EXTRA_', 'nodist_EXTRA_')
    {
	my $varname = $prefix . $one_file . "_SOURCES";
	my $var = var $varname;
	next unless $var;

	# We are going to define _OBJECTS variables using the prefix.
	# Then we glom them all together.  So we can't use the null
	# prefix here as we need it later.
	my $xpfx = ($prefix eq '') ? 'am_' : $prefix;

	# Keep track of which prefixes we saw.
	$used_pfx{$xpfx} = 1
	  unless $prefix =~ /EXTRA_/;

	push @sources, "\$($varname)";
	push @dist_sources, shadow_unconditionally ($varname, $where)
	  unless (option ('no-dist') || $prefix =~ /^nodist_/);

	$needlinker |=
	    define_objects_from_sources ($varname,
					 $xpfx . $one_file . '_OBJECTS',
					 !!($prefix =~ /EXTRA_/),
					 $one_file, $obj, $varname, $where,
					 DIST_SOURCE => ($prefix !~ /^nodist_/),
					 %transform);
    }
    if ($needlinker)
    {
	$linker ||= resolve_linker (%linkers_used);
    }

    my @keys = sort keys %used_pfx;
    if (scalar @keys == 0)
    {
	# The default source for libfoo.la is libfoo.c, but for
	# backward compatibility we first look at libfoo_la.c,
	# if no default source suffix is given.
	my $old_default_source = "$one_file.c";
	my $ext_var = var ('AM_DEFAULT_SOURCE_EXT');
	my $default_source_ext = $ext_var ? variable_value ($ext_var) : '.c';
	msg_var ('unsupported', $ext_var, $ext_var->name . " can assume at most one value")
	  if $default_source_ext =~ /[\t ]/;
	(my $default_source = $unxformed) =~ s,(\.[^./\\]*)?$,$default_source_ext,;
	# TODO: Remove this backward-compatibility hack in Automake 2.0.
	if ($old_default_source ne $default_source
	    && !$ext_var
	    && (rule $old_default_source
		|| rule '$(srcdir)/' . $old_default_source
		|| rule '${srcdir}/' . $old_default_source
		|| -f $old_default_source))
	  {
	    my $loc = $where->clone;
	    $loc->pop_context;
	    msg ('obsolete', $loc,
		 "the default source for '$unxformed' has been changed "
		 . "to '$default_source'.\n(Using '$old_default_source' for "
		 . "backward compatibility.)");
	    $default_source = $old_default_source;
	  }
	# If a rule exists to build this source with a $(srcdir)
	# prefix, use that prefix in our variables too.  This is for
	# the sake of BSD Make.
	if (rule '$(srcdir)/' . $default_source
	    || rule '${srcdir}/' . $default_source)
	  {
	    $default_source = '$(srcdir)/' . $default_source;
	  }

	define_variable ($one_file . "_SOURCES", $default_source, $where);
	push (@sources, $default_source);
	push (@dist_sources, $default_source);

	%linkers_used = ();
	my (@result) =
	  handle_single_transform ($one_file . '_SOURCES',
				   $one_file . '_SOURCES',
				   $one_file, $obj,
				   $default_source, %transform);
	$linker ||= resolve_linker (%linkers_used);
	define_pretty_variable ($one_file . '_OBJECTS', TRUE, $where, @result);
    }
    else
    {
	@keys = map { '$(' . $_ . $one_file . '_OBJECTS)' } @keys;
	define_pretty_variable ($one_file . '_OBJECTS', TRUE, $where, @keys);
    }

    # If we want to use 'LINK' we must make sure it is defined.
    if ($linker eq '')
    {
	$need_link = 1;
    }

    return $linker;
}


# handle_lib_objects ($XNAME, $VAR)
# ---------------------------------
# Special-case ALLOCA and LIBOBJS substitutions in _LDADD or _LIBADD variables.
# Also, generate _DEPENDENCIES variable if appropriate.
# Arguments are:
#   transformed name of object being built, or empty string if no object
#   name of _LDADD/_LIBADD-type variable to examine
# Returns 1 if LIBOBJS seen, 0 otherwise.
sub handle_lib_objects
{
  my ($xname, $varname) = @_;

  my $var = var ($varname);
  prog_error "'$varname' undefined"
    unless $var;
  prog_error "unexpected variable name '$varname'"
    unless $varname =~ /^(.*)(?:LIB|LD)ADD$/;
  my $prefix = $1 || 'AM_';

  my $seen_libobjs = 0;
  my $flagvar = 0;

  transform_variable_recursively
    ($varname, $xname . '_DEPENDENCIES', 'am__DEPENDENCIES',
     ! $xname, INTERNAL,
     # Transformation function, run on each filename.
     sub {
       my ($subvar, $val, $cond, $full_cond) = @_;

       if ($val =~ /^-/)
	 {
	   # Skip -lfoo and -Ldir silently; these are explicitly allowed.
	   if ($val !~ /^-[lL]/ &&
	       # Skip -dlopen and -dlpreopen; these are explicitly allowed
	       # for Libtool libraries or programs.  (Actually we are a bit
	       # lax here since this code also applies to non-libtool
	       # libraries or programs, for which -dlopen and -dlopreopen
	       # are pure nonsense.  Diagnosing this doesn't seem very
	       # important: the developer will quickly get complaints from
	       # the linker.)
	       $val !~ /^-dl(?:pre)?open$/ &&
	       # Only get this error once.
	       ! $flagvar)
	     {
	       $flagvar = 1;
	       # FIXME: should display a stack of nested variables
	       # as context when $var != $subvar.
	       err_var ($var, "linker flags such as '$val' belong in "
			. "'${prefix}LDFLAGS'");
	     }
	   return ();
	 }
       elsif ($val !~ /^\@.*\@$/)
	 {
	   # Assume we have a file of some sort, and output it into the
	   # dependency variable.  Autoconf substitutions are not output;
	   # rarely is a new dependency substituted into e.g. foo_LDADD
	   # -- but bad things (e.g. -lX11) are routinely substituted.
	   # Note that LIBOBJS and ALLOCA are exceptions to this rule,
	   # and handled specially below.
	   return $val;
	 }
       elsif ($val =~ /^\@(LT)?LIBOBJS\@$/)
	 {
	   handle_LIBOBJS ($subvar, $cond, $1);
	   $seen_libobjs = 1;
	   return $val;
	 }
       elsif ($val =~ /^\@(LT)?ALLOCA\@$/)
	 {
	   handle_ALLOCA ($subvar, $cond, $1);
	   return $val;
	 }
       else
	 {
	   return ();
	 }
     });

  return $seen_libobjs;
}

# handle_LIBOBJS_or_ALLOCA ($VAR)
# -------------------------------
# Definitions common to LIBOBJS and ALLOCA.
# VAR should be one of LIBOBJS, LTLIBOBJS, ALLOCA, or LTALLOCA.
sub handle_LIBOBJS_or_ALLOCA
{
  my ($var) = @_;

  my $dir = '';

  # If LIBOBJS files must be built in another directory we have
  # to define LIBOBJDIR and ensure the files get cleaned.
  # Otherwise LIBOBJDIR can be left undefined, and the cleaning
  # is achieved by 'rm -f *.$(OBJEXT)' in compile.am.
  if ($config_libobj_dir
      && $relative_dir ne $config_libobj_dir)
    {
      if (option 'subdir-objects')
	{
	  # In the top-level Makefile we do not use $(top_builddir), because
	  # we are already there, and since the targets are built without
	  # a $(top_builddir), it helps BSD Make to match them with
	  # dependencies.
	  $dir = "$config_libobj_dir/"
	    if $config_libobj_dir ne '.';
	  $dir = backname ($relative_dir) . "/$dir"
	    if $relative_dir ne '.';
	  define_variable ('LIBOBJDIR', "$dir", INTERNAL);
	  $clean_files{"\$($var)"} = MOSTLY_CLEAN;
	  # If LTLIBOBJS is used, we must also clear LIBOBJS (which might
	  # be created by libtool as a side-effect of creating LTLIBOBJS).
	  $clean_files{"\$($var)"} = MOSTLY_CLEAN if $var =~ s/^LT//;
	}
      else
	{
	  error ("'\$($var)' cannot be used outside '$config_libobj_dir' if"
		 . " 'subdir-objects' is not set");
	}
    }

  return $dir;
}

sub handle_LIBOBJS
{
  my ($var, $cond, $lt) = @_;
  my $myobjext = $lt ? 'lo' : 'o';
  $lt ||= '';

  $var->requires_variables ("\@${lt}LIBOBJS\@ used", $lt . 'LIBOBJS')
    if ! keys %libsources;

  my $dir = handle_LIBOBJS_or_ALLOCA "${lt}LIBOBJS";

  foreach my $iter (keys %libsources)
    {
      if ($iter =~ /\.[cly]$/)
	{
	  saw_extension ($&);
	  saw_extension ('.c');
	}

      if ($iter =~ /\.h$/)
	{
	  require_libsource_with_macro ($cond, $var, FOREIGN, $iter);
	}
      elsif ($iter ne 'alloca.c')
	{
	  my $rewrite = $iter;
	  $rewrite =~ s/\.c$/.P$myobjext/;
	  $dep_files{$dir . '$(DEPDIR)/' . $rewrite} = 1;
	  $rewrite = "^" . quotemeta ($iter) . "\$";
	  # Only require the file if it is not a built source.
	  my $bs = var ('BUILT_SOURCES');
	  if (! $bs || ! grep (/$rewrite/, $bs->value_as_list_recursive))
	    {
	      require_libsource_with_macro ($cond, $var, FOREIGN, $iter);
	    }
	}
    }
}

sub handle_ALLOCA
{
  my ($var, $cond, $lt) = @_;
  my $myobjext = $lt ? 'lo' : 'o';
  $lt ||= '';
  my $dir = handle_LIBOBJS_or_ALLOCA "${lt}ALLOCA";

  $var->requires_variables ("\@${lt}ALLOCA\@ used", $lt . 'ALLOCA');
  $dep_files{$dir . '$(DEPDIR)/alloca.P' . $myobjext} = 1;
  require_libsource_with_macro ($cond, $var, FOREIGN, 'alloca.c');
  saw_extension ('.c');
}

# Canonicalize the input parameter.
sub canonicalize
{
    my ($string) = @_;
    $string =~ tr/A-Za-z0-9_\@/_/c;
    return $string;
}

# Canonicalize a name, and check to make sure the non-canonical name
# is never used.  Returns canonical name.  Arguments are name and a
# list of suffixes to check for.
sub check_canonical_spelling
{
  my ($name, @suffixes) = @_;

  my $xname = canonicalize ($name);
  if ($xname ne $name)
    {
      foreach my $xt (@suffixes)
	{
	  reject_var ("$name$xt", "use '$xname$xt', not '$name$xt'");
	}
    }

  return $xname;
}

# Set up the compile suite.
sub handle_compile ()
{
   return if ! $must_handle_compiled_objects;

    # Boilerplate.
    my $default_includes = '';
    if (! option 'nostdinc')
      {
	my @incs = ('-I.', subst ('am__isrc'));

	my $var = var 'CONFIG_HEADER';
	if ($var)
	  {
	    foreach my $hdr (split (' ', $var->variable_value))
	      {
		push @incs, '-I' . dirname ($hdr);
	      }
	  }
	# We want '-I. -I$(srcdir)', but the latter -I is redundant
	# and unaesthetic in non-VPATH builds.  We use `-I.@am__isrc@`
	# instead.  It will be replaced by '-I.' or '-I. -I$(srcdir)'.
	# Items in CONFIG_HEADER are never in $(srcdir) so it is safe
	# to just put @am__isrc@ right after '-I.', without a space.
	($default_includes = ' ' . uniq (@incs)) =~ s/ @/@/;
      }

    my (@mostly_rms, @dist_rms);
    foreach my $item (sort keys %compile_clean_files)
    {
	if ($compile_clean_files{$item} == MOSTLY_CLEAN)
	{
	    push (@mostly_rms, "\t-rm -f $item");
	}
	elsif ($compile_clean_files{$item} == DIST_CLEAN)
	{
	    push (@dist_rms, "\t-rm -f $item");
	}
	else
	{
	  prog_error 'invalid entry in %compile_clean_files';
	}
    }

    my ($coms, $vars, $rules) =
      file_contents_internal (1, "$libdir/am/compile.am",
			      new Automake::Location,
			      'DEFAULT_INCLUDES' => $default_includes,
			      'MOSTLYRMS' => join ("\n", @mostly_rms),
			      'DISTRMS' => join ("\n", @dist_rms));
    $output_vars .= $vars;
    $output_rules .= "$coms$rules";
}

# Handle libtool rules.
sub handle_libtool ()
{
  return unless var ('LIBTOOL');

  # Libtool requires some files, but only at top level.
  # (Starting with Libtool 2.0 we do not have to bother.  These
  # requirements are done with AC_REQUIRE_AUX_FILE.)
  require_conf_file_with_macro (TRUE, 'LIBTOOL', FOREIGN, @libtool_files)
    if $relative_dir eq '.' && ! $libtool_new_api;

  my @libtool_rms;
  foreach my $item (sort keys %libtool_clean_directories)
    {
      my $dir = ($item eq '.') ? '' : "$item/";
      # .libs is for Unix, _libs for DOS.
      push (@libtool_rms, "\t-rm -rf ${dir}.libs ${dir}_libs");
    }

  check_user_variables 'LIBTOOLFLAGS';

  # Output the libtool compilation rules.
  $output_rules .= file_contents ('libtool',
				  new Automake::Location,
				   LTRMS => join ("\n", @libtool_rms));
}


sub handle_programs ()
{
  my @proglist = am_install_var ('progs', 'PROGRAMS',
				 'bin', 'sbin', 'libexec', 'pkglibexec',
				 'noinst', 'check');
  return if ! @proglist;
  $must_handle_compiled_objects = 1;

  my $seen_global_libobjs =
    var ('LDADD') && handle_lib_objects ('', 'LDADD');

  foreach my $pair (@proglist)
    {
      my ($where, $one_file) = @$pair;

      my $seen_libobjs = 0;
      my $obj = '.$(OBJEXT)';

      $known_programs{$one_file} = $where;

      # Canonicalize names and check for misspellings.
      my $xname = check_canonical_spelling ($one_file, '_LDADD', '_LDFLAGS',
                                            '_SOURCES', '_OBJECTS',
                                            '_DEPENDENCIES');

      $where->push_context ("while processing program '$one_file'");
      $where->set (INTERNAL->get);

      my $linker = handle_source_transform ($xname, $one_file, $obj, $where,
                                            NONLIBTOOL => 1, LIBTOOL => 0);

      if (var ($xname . "_LDADD"))
	{
	  $seen_libobjs = handle_lib_objects ($xname, $xname . '_LDADD');
	}
      else
	{
	  # User didn't define prog_LDADD override.  So do it.
	  define_variable ($xname . '_LDADD', '$(LDADD)', $where);

	  # This does a bit too much work.  But we need it to
	  # generate _DEPENDENCIES when appropriate.
	  if (var ('LDADD'))
	    {
	      $seen_libobjs = handle_lib_objects ($xname, 'LDADD');
	    }
	}

      reject_var ($xname . '_LIBADD',
		  "use '${xname}_LDADD', not '${xname}_LIBADD'");

      set_seen ($xname . '_DEPENDENCIES');
      set_seen ('EXTRA_' . $xname . '_DEPENDENCIES');
      set_seen ($xname . '_LDFLAGS');

      # Determine program to use for link.
      my($xlink, $vlink) = define_per_target_linker_variable ($linker, $xname);
      $vlink = verbose_flag ($vlink || 'GEN');

      # If the resulting program lies in a subdirectory,
      # ensure that the directory exists before we need it.
      my $dirstamp = require_build_directory_maybe ($one_file);

      $libtool_clean_directories{dirname ($one_file)} = 1;

      $output_rules .= file_contents ('program',
                                      $where,
                                      PROGRAM  => $one_file,
                                      XPROGRAM => $xname,
                                      XLINK    => $xlink,
                                      VERBOSE  => $vlink,
                                      DIRSTAMP => $dirstamp,
                                      EXEEXT   => '$(EXEEXT)');

      if ($seen_libobjs || $seen_global_libobjs)
	{
	  if (var ($xname . '_LDADD'))
	    {
	      check_libobjs_sources ($xname, $xname . '_LDADD');
	    }
	  elsif (var ('LDADD'))
	    {
	      check_libobjs_sources ($xname, 'LDADD');
	    }
	}
    }
}


sub handle_libraries ()
{
  my @liblist = am_install_var ('libs', 'LIBRARIES',
                                'lib', 'pkglib', 'noinst', 'check');
  return if ! @liblist;
  $must_handle_compiled_objects = 1;

  my @prefix = am_primary_prefixes ('LIBRARIES', 0, 'lib', 'pkglib',
				    'noinst', 'check');

  if (@prefix)
    {
      my $var = rvar ($prefix[0] . '_LIBRARIES');
      $var->requires_variables ('library used', 'RANLIB');
    }

  define_variable ('AR', 'ar', INTERNAL);
  define_variable ('ARFLAGS', 'cru', INTERNAL);
  define_verbose_tagvar ('AR');

  foreach my $pair (@liblist)
    {
      my ($where, $onelib) = @$pair;

      my $seen_libobjs = 0;
      # Check that the library fits the standard naming convention.
      my $bn = basename ($onelib);
      if ($bn !~ /^lib.*\.a$/)
	{
	  $bn =~ s/^(?:lib)?(.*?)(?:\.[^.]*)?$/lib$1.a/;
	  my $suggestion = dirname ($onelib) . "/$bn";
	  $suggestion =~ s|^\./||g;
	  msg ('error-gnu/warn', $where,
	       "'$onelib' is not a standard library name\n"
	       . "did you mean '$suggestion'?")
	}

      ($known_libraries{$onelib} = $bn) =~ s/\.a$//;

      $where->push_context ("while processing library '$onelib'");
      $where->set (INTERNAL->get);

      my $obj = '.$(OBJEXT)';

      # Canonicalize names and check for misspellings.
      my $xlib = check_canonical_spelling ($onelib, '_LIBADD', '_SOURCES',
                                           '_OBJECTS', '_DEPENDENCIES',
                                           '_AR');

      if (! var ($xlib . '_AR'))
	{
	  define_variable ($xlib . '_AR', '$(AR) $(ARFLAGS)', $where);
	}

      # Generate support for conditional object inclusion in
      # libraries.
      if (var ($xlib . '_LIBADD'))
	{
	  if (handle_lib_objects ($xlib, $xlib . '_LIBADD'))
	    {
	      $seen_libobjs = 1;
	    }
	}
      else
	{
	  define_variable ($xlib . "_LIBADD", '', $where);
	}

      reject_var ($xlib . '_LDADD',
		  "use '${xlib}_LIBADD', not '${xlib}_LDADD'");

      # Make sure we at look at this.
      set_seen ($xlib . '_DEPENDENCIES');
      set_seen ('EXTRA_' . $xlib . '_DEPENDENCIES');

      handle_source_transform ($xlib, $onelib, $obj, $where,
                               NONLIBTOOL => 1, LIBTOOL => 0);

      # If the resulting library lies in a subdirectory,
      # make sure this directory will exist.
      my $dirstamp = require_build_directory_maybe ($onelib);
      my $verbose = verbose_flag ('AR');
      my $silent = silent_flag ();

      $output_rules .= file_contents ('library',
                                       $where,
                                       VERBOSE  => $verbose,
                                       SILENT   => $silent,
                                       LIBRARY  => $onelib,
                                       XLIBRARY => $xlib,
                                       DIRSTAMP => $dirstamp);

      if ($seen_libobjs)
	{
	  if (var ($xlib . '_LIBADD'))
	    {
	      check_libobjs_sources ($xlib, $xlib . '_LIBADD');
	    }
	}

      if (! $seen_ar)
	{
	  msg ('extra-portability', $where,
	       "'$onelib': linking libraries using a non-POSIX\n"
	       . "archiver requires 'AM_PROG_AR' in '$configure_ac'")
	}
    }
}


sub handle_ltlibraries ()
{
  my @liblist = am_install_var ('ltlib', 'LTLIBRARIES',
                                'noinst', 'lib', 'pkglib', 'check');
  return if ! @liblist;
  $must_handle_compiled_objects = 1;

  my @prefix = am_primary_prefixes ('LTLIBRARIES', 0, 'lib', 'pkglib',
				    'noinst', 'check');

  if (@prefix)
    {
      my $var = rvar ($prefix[0] . '_LTLIBRARIES');
      $var->requires_variables ('Libtool library used', 'LIBTOOL');
    }

  my %instdirs = ();
  my %instsubdirs = ();
  my %instconds = ();
  my %liblocations = ();	# Location (in Makefile.am) of each library.

  foreach my $key (@prefix)
    {
      # Get the installation directory of each library.
      my $dir = $key;
      my $strip_subdir = 1;
      if ($dir =~ /^nobase_/)
        {
	  $dir =~ s/^nobase_//;
	  $strip_subdir = 0;
	}
      my $var = rvar ($key . '_LTLIBRARIES');

      # We reject libraries which are installed in several places
      # in the same condition, because we can only specify one
      # '-rpath' option.
      $var->traverse_recursively
	(sub
	 {
	   my ($var, $val, $cond, $full_cond) = @_;
	   my $hcond = $full_cond->human;
	   my $where = $var->rdef ($cond)->location;
	   my $ldir = '';
	   $ldir = '/' . dirname ($val)
	     if (!$strip_subdir);
	   # A library cannot be installed in different directories
	   # in overlapping conditions.
	   if (exists $instconds{$val})
	     {
	       my ($msg, $acond) =
		 $instconds{$val}->ambiguous_p ($val, $full_cond);

	       if ($msg)
		 {
		   error ($where, $msg, partial => 1);
		   my $dirtxt = "installed " . ($strip_subdir ? "in" : "below") . " '$dir'";
		   $dirtxt = "built for '$dir'"
		     if $dir eq 'EXTRA' || $dir eq 'noinst' || $dir eq 'check';
		   my $dircond =
		     $full_cond->true ? "" : " in condition $hcond";

		   error ($where, "'$val' should be $dirtxt$dircond ...",
			  partial => 1);

		   my $hacond = $acond->human;
		   my $adir = $instdirs{$val}{$acond};
		   my $adirtxt = "installed in '$adir'";
		   $adirtxt = "built for '$adir'"
		     if ($adir eq 'EXTRA' || $adir eq 'noinst'
			 || $adir eq 'check');
		   my $adircond = $acond->true ? "" : " in condition $hacond";

		   my $onlyone = ($dir ne $adir) ?
		     ("\nLibtool libraries can be built for only one "
		      . "destination") : "";

		   error ($liblocations{$val}{$acond},
			  "... and should also be $adirtxt$adircond.$onlyone");
		   return;
		 }
	     }
	   else
	     {
	       $instconds{$val} = new Automake::DisjConditions;
	     }
	   $instdirs{$val}{$full_cond} = $dir;
	   $instsubdirs{$val}{$full_cond} = $ldir;
	   $liblocations{$val}{$full_cond} = $where;
	   $instconds{$val} = $instconds{$val}->merge ($full_cond);
	 },
	 sub
	 {
	   return ();
	 },
	 skip_ac_subst => 1);
    }

  foreach my $pair (@liblist)
    {
      my ($where, $onelib) = @$pair;

      my $seen_libobjs = 0;
      my $obj = '.lo';

      # Canonicalize names and check for misspellings.
      my $xlib = check_canonical_spelling ($onelib, '_LIBADD', '_LDFLAGS',
                                           '_SOURCES', '_OBJECTS',
                                           '_DEPENDENCIES');

      # Check that the library fits the standard naming convention.
      my $libname_rx = '^lib.*\.la';
      my $ldvar = var ("${xlib}_LDFLAGS") || var ('AM_LDFLAGS');
      my $ldvar2 = var ('LDFLAGS');
      if (($ldvar && grep (/-module/, $ldvar->value_as_list_recursive))
	  || ($ldvar2 && grep (/-module/, $ldvar2->value_as_list_recursive)))
	{
	  # Relax name checking for libtool modules.
	  $libname_rx = '\.la';
	}

      my $bn = basename ($onelib);
      if ($bn !~ /$libname_rx$/)
	{
	  my $type = 'library';
	  if ($libname_rx eq '\.la')
	    {
	      $bn =~ s/^(lib|)(.*?)(?:\.[^.]*)?$/$1$2.la/;
	      $type = 'module';
	    }
	  else
	    {
	      $bn =~ s/^(?:lib)?(.*?)(?:\.[^.]*)?$/lib$1.la/;
	    }
	  my $suggestion = dirname ($onelib) . "/$bn";
	  $suggestion =~ s|^\./||g;
	  msg ('error-gnu/warn', $where,
	       "'$onelib' is not a standard libtool $type name\n"
	       . "did you mean '$suggestion'?")
	}

      ($known_libraries{$onelib} = $bn) =~ s/\.la$//;

      $where->push_context ("while processing Libtool library '$onelib'");
      $where->set (INTERNAL->get);

      # Make sure we look at these.
      set_seen ($xlib . '_LDFLAGS');
      set_seen ($xlib . '_DEPENDENCIES');
      set_seen ('EXTRA_' . $xlib . '_DEPENDENCIES');

      # Generate support for conditional object inclusion in
      # libraries.
      if (var ($xlib . '_LIBADD'))
	{
	  if (handle_lib_objects ($xlib, $xlib . '_LIBADD'))
	    {
	      $seen_libobjs = 1;
	    }
	}
      else
	{
	  define_variable ($xlib . "_LIBADD", '', $where);
	}

      reject_var ("${xlib}_LDADD",
		  "use '${xlib}_LIBADD', not '${xlib}_LDADD'");


      my $linker = handle_source_transform ($xlib, $onelib, $obj, $where,
                                            NONLIBTOOL => 0, LIBTOOL => 1);

      # Determine program to use for link.
      my($xlink, $vlink) = define_per_target_linker_variable ($linker, $xlib);
      $vlink = verbose_flag ($vlink || 'GEN');

      my $rpathvar = "am_${xlib}_rpath";
      my $rpath = "\$($rpathvar)";
      foreach my $rcond ($instconds{$onelib}->conds)
	{
	  my $val;
	  if ($instdirs{$onelib}{$rcond} eq 'EXTRA'
	      || $instdirs{$onelib}{$rcond} eq 'noinst'
	      || $instdirs{$onelib}{$rcond} eq 'check')
	    {
	      # It's an EXTRA_ library, so we can't specify -rpath,
	      # because we don't know where the library will end up.
	      # The user probably knows, but generally speaking automake
	      # doesn't -- and in fact configure could decide
	      # dynamically between two different locations.
	      $val = '';
	    }
	  else
	    {
	      $val = ('-rpath $(' . $instdirs{$onelib}{$rcond} . 'dir)');
	      $val .= $instsubdirs{$onelib}{$rcond}
	        if defined $instsubdirs{$onelib}{$rcond};
	    }
	  if ($rcond->true)
	    {
	      # If $rcond is true there is only one condition and
	      # there is no point defining an helper variable.
	      $rpath = $val;
	    }
	  else
	    {
	      define_pretty_variable ($rpathvar, $rcond, INTERNAL, $val);
	    }
	}

      # If the resulting library lies in a subdirectory,
      # make sure this directory will exist.
      my $dirstamp = require_build_directory_maybe ($onelib);

      # Remember to cleanup .libs/ in this directory.
      my $dirname = dirname $onelib;
      $libtool_clean_directories{$dirname} = 1;

      $output_rules .= file_contents ('ltlibrary',
                                      $where,
                                      LTLIBRARY  => $onelib,
                                      XLTLIBRARY => $xlib,
                                      RPATH      => $rpath,
                                      XLINK      => $xlink,
                                      VERBOSE    => $vlink,
                                      DIRSTAMP   => $dirstamp);
      if ($seen_libobjs)
	{
	  if (var ($xlib . '_LIBADD'))
	    {
	      check_libobjs_sources ($xlib, $xlib . '_LIBADD');
	    }
	}

      if (! $seen_ar)
	{
	  msg ('extra-portability', $where,
	       "'$onelib': linking libtool libraries using a non-POSIX\n"
	       . "archiver requires 'AM_PROG_AR' in '$configure_ac'")
	}
    }
}

# See if any _SOURCES variable were misspelled.
sub check_typos ()
{
  # It is ok if the user sets this particular variable.
  set_seen 'AM_LDFLAGS';

  foreach my $primary ('SOURCES', 'LIBADD', 'LDADD', 'LDFLAGS', 'DEPENDENCIES')
    {
      foreach my $var (variables $primary)
	{
	  my $varname = $var->name;
	  # A configure variable is always legitimate.
	  next if exists $configure_vars{$varname};

	  for my $cond ($var->conditions->conds)
	    {
	      $varname =~ /^(?:EXTRA_)?(?:nobase_)?(?:dist_|nodist_)?(.*)_[[:alnum:]]+$/;
	      msg_var ('syntax', $var, "variable '$varname' is defined but no"
		       . " program or\nlibrary has '$1' as canonical name"
		       . " (possible typo)")
		unless $var->rdef ($cond)->seen;
	    }
	}
    }
}


sub handle_scripts ()
{
    # NOTE we no longer automatically clean SCRIPTS, because it is
    # useful to sometimes distribute scripts verbatim.  This happens
    # e.g. in Automake itself.
    am_install_var ('-candist', 'scripts', 'SCRIPTS',
                    'bin', 'sbin', 'libexec', 'pkglibexec', 'pkgdata',
                    'noinst', 'check');
}


## ------------------------ ##
## Handling Texinfo files.  ##
## ------------------------ ##

# ($OUTFILE, $VFILE)
# scan_texinfo_file ($FILENAME)
# -----------------------------
# $OUTFILE     - name of the info file produced by $FILENAME.
# $VFILE       - name of the version.texi file used (undef if none).
sub scan_texinfo_file
{
  my ($filename) = @_;

  my $texi = new Automake::XFile "< $filename";
  verb "reading $filename";

  my ($outfile, $vfile);
  while ($_ = $texi->getline)
    {
      if (/^\@setfilename +(\S+)/)
	{
	  # Honor only the first @setfilename.  (It's possible to have
	  # more occurrences later if the manual shows examples of how
	  # to use @setfilename...)
	  next if $outfile;

	  $outfile = $1;
	  if (index ($outfile, '.') < 0)
	    {
	      msg 'obsolete', "$filename:$.",
	          "use of suffix-less info files is discouraged"
	    }
	  elsif ($outfile !~ /\.info$/)
	    {
	      error ("$filename:$.",
		     "output '$outfile' has unrecognized extension");
	      return;
	    }
	}
      # A "version.texi" file is actually any file whose name matches
      # "vers*.texi".
      elsif (/^\@include\s+(vers[^.]*\.texi)\s*$/)
	{
	  $vfile = $1;
	}
    }

  if (! $outfile)
    {
      err_am "'$filename' missing \@setfilename";
      return;
    }

  return ($outfile, $vfile);
}


# ($DIRSTAMP, @CLEAN_FILES)
# output_texinfo_build_rules ($SOURCE, $DEST, $INSRC, @DEPENDENCIES)
# ------------------------------------------------------------------
# SOURCE - the source Texinfo file
# DEST - the destination Info file
# INSRC - whether DEST should be built in the source tree
# DEPENDENCIES - known dependencies
sub output_texinfo_build_rules
{
  my ($source, $dest, $insrc, @deps) = @_;

  # Split 'a.texi' into 'a' and '.texi'.
  my ($spfx, $ssfx) = ($source =~ /^(.*?)(\.[^.]*)?$/);
  my ($dpfx, $dsfx) = ($dest =~ /^(.*?)(\.[^.]*)?$/);

  $ssfx ||= "";
  $dsfx ||= "";

  # We can output two kinds of rules: the "generic" rules use Make
  # suffix rules and are appropriate when $source and $dest do not lie
  # in a sub-directory; the "specific" rules are needed in the other
  # case.
  #
  # The former are output only once (this is not really apparent here,
  # but just remember that some logic deeper in Automake will not
  # output the same rule twice); while the later need to be output for
  # each Texinfo source.
  my $generic;
  my $makeinfoflags;
  my $sdir = dirname $source;
  if ($sdir eq '.' && dirname ($dest) eq '.')
    {
      $generic = 1;
      $makeinfoflags = '-I $(srcdir)';
    }
  else
    {
      $generic = 0;
      $makeinfoflags = "-I $sdir -I \$(srcdir)/$sdir";
    }

  # A directory can contain two kinds of info files: some built in the
  # source tree, and some built in the build tree.  The rules are
  # different in each case.  However we cannot output two different
  # set of generic rules.  Because in-source builds are more usual, we
  # use generic rules in this case and fall back to "specific" rules
  # for build-dir builds.  (It should not be a problem to invert this
  # if needed.)
  $generic = 0 unless $insrc;

  # We cannot use a suffix rule to build info files with an empty
  # extension.  Otherwise we would output a single suffix inference
  # rule, with separate dependencies, as in
  #
  #    .texi:
  #             $(MAKEINFO) ...
  #    foo.info: foo.texi
  #
  # which confuse Solaris make.  (See the Autoconf manual for
  # details.)  Therefore we use a specific rule in this case.  This
  # applies to info files only (dvi and pdf files always have an
  # extension).
  my $generic_info = ($generic && $dsfx) ? 1 : 0;

  # If the resulting file lies in a subdirectory,
  # make sure this directory will exist.
  my $dirstamp = require_build_directory_maybe ($dest);

  my $dipfx = ($insrc ? '$(srcdir)/' : '') . $dpfx;

  $output_rules .= file_contents ('texibuild',
				  new Automake::Location,
                                  AM_V_MAKEINFO    => verbose_flag('MAKEINFO'),
                                  AM_V_TEXI2DVI    => verbose_flag('TEXI2DVI'),
                                  AM_V_TEXI2PDF    => verbose_flag('TEXI2PDF'),
				  DEPS             => "@deps",
				  DEST_PREFIX      => $dpfx,
				  DEST_INFO_PREFIX => $dipfx,
				  DEST_SUFFIX      => $dsfx,
				  DIRSTAMP         => $dirstamp,
				  GENERIC          => $generic,
				  GENERIC_INFO     => $generic_info,
				  INSRC		   => $insrc,
				  MAKEINFOFLAGS    => $makeinfoflags,
                                  SILENT           => silent_flag(),
				  SOURCE           => ($generic
						       ? '$<' : $source),
				  SOURCE_INFO      => ($generic_info
						       ? '$<' : $source),
				  SOURCE_REAL      => $source,
				  SOURCE_SUFFIX    => $ssfx,
                                  TEXIQUIET        => verbose_flag('texinfo'),
                                  TEXIDEVNULL      => verbose_flag('texidevnull'),
				  );
  return ($dirstamp, "$dpfx.dvi", "$dpfx.pdf", "$dpfx.ps", "$dpfx.html");
}


# ($MOSTLYCLEAN, $TEXICLEAN, $MAINTCLEAN)
# handle_texinfo_helper ($info_texinfos)
# --------------------------------------
# Handle all Texinfo source; helper for 'handle_texinfo'.
sub handle_texinfo_helper
{
  my ($info_texinfos) = @_;
  my (@infobase, @info_deps_list, @texi_deps);
  my %versions;
  my $done = 0;
  my (@mostly_cleans, @texi_cleans, @maint_cleans) = ('', '', '');

  # Build a regex matching user-cleaned files.
  my $d = var 'DISTCLEANFILES';
  my $c = var 'CLEANFILES';
  my @f = ();
  push @f, $d->value_as_list_recursive (inner_expand => 1) if $d;
  push @f, $c->value_as_list_recursive (inner_expand => 1) if $c;
  @f = map { s|[^A-Za-z_0-9*\[\]\-]|\\$&|g; s|\*|[^/]*|g; $_; } @f;
  my $user_cleaned_files = '^(?:' . join ('|', @f) . ')$';

  foreach my $texi
      ($info_texinfos->value_as_list_recursive (inner_expand => 1))
    {
      my $infobase = $texi;
      if ($infobase =~ s/\.texi$//)
        {
          1; # Nothing more to do.
        }
      elsif ($infobase =~ s/\.(txi|texinfo)$//)
        {
	  msg_var 'obsolete', $info_texinfos,
	          "suffix '.$1' for Texinfo files is discouraged;" .
                  " use '.texi' instead";
        }
      else
	{
	  # FIXME: report line number.
	  err_am "texinfo file '$texi' has unrecognized extension";
	  next;
	}

      push @infobase, $infobase;

      # If 'version.texi' is referenced by input file, then include
      # automatic versioning capability.
      my ($out_file, $vtexi) =
	scan_texinfo_file ("$relative_dir/$texi")
	or next;
      # Directory of auxiliary files and build by-products used by texi2dvi
      # and texi2pdf.
      push @mostly_cleans, "$infobase.t2d";
      push @mostly_cleans, "$infobase.t2p";

      # If the Texinfo source is in a subdirectory, create the
      # resulting info in this subdirectory.  If it is in the current
      # directory, try hard to not prefix "./" because it breaks the
      # generic rules.
      my $outdir = dirname ($texi) . '/';
      $outdir = "" if $outdir eq './';
      $out_file =  $outdir . $out_file;

      # Until Automake 1.6.3, .info files were built in the
      # source tree.  This was an obstacle to the support of
      # non-distributed .info files, and non-distributed .texi
      # files.
      #
      # * Non-distributed .texi files is important in some packages
      #   where .texi files are built at make time, probably using
      #   other binaries built in the package itself, maybe using
      #   tools or information found on the build host.  Because
      #   these files are not distributed they are always rebuilt
      #   at make time; they should therefore not lie in the source
      #   directory.  One plan was to support this using
      #   nodist_info_TEXINFOS or something similar.  (Doing this
      #   requires some sanity checks.  For instance Automake should
      #   not allow:
      #      dist_info_TEXINFOS = foo.texi
      #      nodist_foo_TEXINFOS = included.texi
      #   because a distributed file should never depend on a
      #   non-distributed file.)
      #
      # * If .texi files are not distributed, then .info files should
      #   not be distributed either.  There are also cases where one
      #   wants to distribute .texi files, but does not want to
      #   distribute the .info files.  For instance the Texinfo package
      #   distributes the tool used to build these files; it would
      #   be a waste of space to distribute them.  It's not clear
      #   which syntax we should use to indicate that .info files should
      #   not be distributed.  Akim Demaille suggested that eventually
      #   we switch to a new syntax:
      #   |  Maybe we should take some inspiration from what's already
      #   |  done in the rest of Automake.  Maybe there is too much
      #   |  syntactic sugar here, and you want
      #   |     nodist_INFO = bar.info
      #   |     dist_bar_info_SOURCES = bar.texi
      #   |     bar_texi_DEPENDENCIES = foo.texi
      #   |  with a bit of magic to have bar.info represent the whole
      #   |  bar*info set.  That's a lot more verbose that the current
      #   |  situation, but it is # not new, hence the user has less
      #   |  to learn.
      #	  |
      #   |  But there is still too much room for meaningless specs:
      #   |     nodist_INFO = bar.info
      #   |     dist_bar_info_SOURCES = bar.texi
      #   |     dist_PS = bar.ps something-written-by-hand.ps
      #   |     nodist_bar_ps_SOURCES = bar.texi
      #   |     bar_texi_DEPENDENCIES = foo.texi
      #   |  here bar.texi is dist_ in line 2, and nodist_ in 4.
      #
      # Back to the point, it should be clear that in order to support
      # non-distributed .info files, we need to build them in the
      # build tree, not in the source tree (non-distributed .texi
      # files are less of a problem, because we do not output build
      # rules for them).  In Automake 1.7 .info build rules have been
      # largely cleaned up so that .info files get always build in the
      # build tree, even when distributed.  The idea was that
      #   (1) if during a VPATH build the .info file was found to be
      #       absent or out-of-date (in the source tree or in the
      #       build tree), Make would rebuild it in the build tree.
      #       If an up-to-date source-tree of the .info file existed,
      #       make would not rebuild it in the build tree.
      #   (2) having two copies of .info files, one in the source tree
      #       and one (newer) in the build tree is not a problem
      #       because 'make dist' always pick files in the build tree
      #       first.
      # However it turned out the be a bad idea for several reasons:
      #   * Tru64, OpenBSD, and FreeBSD (not NetBSD) Make do not behave
      #     like GNU Make on point (1) above.  These implementations
      #     of Make would always rebuild .info files in the build
      #     tree, even if such files were up to date in the source
      #     tree.  Consequently, it was impossible to perform a VPATH
      #     build of a package containing Texinfo files using these
      #     Make implementations.
      #     (Refer to the Autoconf Manual, section "Limitation of
      #     Make", paragraph "VPATH", item "target lookup", for
      #     an account of the differences between these
      #     implementations.)
      #   * The GNU Coding Standards require these files to be built
      #     in the source-tree (when they are distributed, that is).
      #   * Keeping a fresher copy of distributed files in the
      #     build tree can be annoying during development because
      #     - if the files is kept under CVS, you really want it
      #       to be updated in the source tree
      #     - it is confusing that 'make distclean' does not erase
      #       all files in the build tree.
      #
      # Consequently, starting with Automake 1.8, .info files are
      # built in the source tree again.  Because we still plan to
      # support non-distributed .info files at some point, we
      # have a single variable ($INSRC) that controls whether
      # the current .info file must be built in the source tree
      # or in the build tree.  Actually this variable is switched
      # off in two cases:
      #  (1) For '.info' files that appear to be cleaned; this is for
      #      backward compatibility with package such as Texinfo,
      #      which do things like
      #        info_TEXINFOS = texinfo.txi info-stnd.texi info.texi
      #        DISTCLEANFILES = texinfo texinfo-* info*.info*
      #        # Do not create info files for distribution.
      #        dist-info:
      #      in order not to distribute .info files.
      #  (2) When the undocumented option 'info-in-builddir' is given.
      #      This is done to allow the developers of GCC, GDB, GNU
      #      binutils and the GNU bfd library to force the '.info' files
      #      to be generated in the builddir rather than the srcdir, as
      #      was once done when the (now removed) 'cygnus' option was
      #      given.  See automake bug#11034 for more discussion.
      my $insrc = 1;
      my $soutdir = '$(srcdir)/' . $outdir;

      if (option 'info-in-builddir')
        {
          $insrc = 0;
        }
      elsif ($out_file =~ $user_cleaned_files)
        {
          $insrc = 0;
          msg 'obsolete', "$am_file.am", <<EOF;
Oops!
    It appears this file (or files included by it) are triggering
    an undocumented, soon-to-be-removed automake hack.
    Future automake versions will no longer place in the builddir
    (rather than in the srcdir) the generated '.info' files that
    appear to be cleaned, by e.g. being listed in CLEANFILES or
    DISTCLEANFILES.
    If you want your '.info' files to be placed in the builddir
    rather than in the srcdir, you have to use the shiny new
    'info-in-builddir' automake option.
EOF
        }

      $outdir = $soutdir if $insrc;

      # If user specified file_TEXINFOS, then use that as explicit
      # dependency list.
      @texi_deps = ();
      push (@texi_deps, "${soutdir}${vtexi}") if $vtexi;

      my $canonical = canonicalize ($infobase);
      if (var ($canonical . "_TEXINFOS"))
	{
	  push (@texi_deps, '$(' . $canonical . '_TEXINFOS)');
	  push_dist_common ('$(' . $canonical . '_TEXINFOS)');
	}

      my ($dirstamp, @cfiles) =
	output_texinfo_build_rules ($texi, $out_file, $insrc, @texi_deps);
      push (@texi_cleans, @cfiles);

      push (@info_deps_list, $out_file);

      # If a vers*.texi file is needed, emit the rule.
      if ($vtexi)
	{
	  err_am ("'$vtexi', included in '$texi', "
		  . "also included in '$versions{$vtexi}'")
	    if defined $versions{$vtexi};
	  $versions{$vtexi} = $texi;

	  # We number the stamp-vti files.  This is doable since the
	  # actual names don't matter much.  We only number starting
	  # with the second one, so that the common case looks nice.
	  my $vti = ($done ? $done : 'vti');
	  ++$done;

	  # This is ugly, but it is our historical practice.
	  if ($config_aux_dir_set_in_configure_ac)
	    {
	      require_conf_file_with_macro (TRUE, 'info_TEXINFOS', FOREIGN,
					    'mdate-sh');
	    }
	  else
	    {
	      require_file_with_macro (TRUE, 'info_TEXINFOS',
				       FOREIGN, 'mdate-sh');
	    }

	  my $conf_dir;
	  if ($config_aux_dir_set_in_configure_ac)
	    {
	      $conf_dir = "$am_config_aux_dir/";
	    }
	  else
	    {
	      $conf_dir = '$(srcdir)/';
	    }
	  $output_rules .= file_contents ('texi-vers',
					  new Automake::Location,
					  TEXI     => $texi,
					  VTI      => $vti,
					  STAMPVTI => "${soutdir}stamp-$vti",
					  VTEXI    => "$soutdir$vtexi",
					  MDDIR    => $conf_dir,
					  DIRSTAMP => $dirstamp);
	}
    }

  # Handle location of texinfo.tex.
  my $need_texi_file = 0;
  my $texinfodir;
  if (var ('TEXINFO_TEX'))
    {
      # The user defined TEXINFO_TEX so assume he knows what he is
      # doing.
      $texinfodir = ('$(srcdir)/'
		     . dirname (variable_value ('TEXINFO_TEX')));
    }
  elsif ($config_aux_dir_set_in_configure_ac)
    {
      $texinfodir = $am_config_aux_dir;
      define_variable ('TEXINFO_TEX', "$texinfodir/texinfo.tex", INTERNAL);
      $need_texi_file = 2; # so that we require_conf_file later
    }
  else
    {
      $texinfodir = '$(srcdir)';
      $need_texi_file = 1;
    }
  define_variable ('am__TEXINFO_TEX_DIR', $texinfodir, INTERNAL);

  push (@dist_targets, 'dist-info');

  if (! option 'no-installinfo')
    {
      # Make sure documentation is made and installed first.  Use
      # $(INFO_DEPS), not 'info', because otherwise recursive makes
      # get run twice during "make all".
      unshift (@all, '$(INFO_DEPS)');
    }

  define_files_variable ("DVIS", @infobase, 'dvi', INTERNAL);
  define_files_variable ("PDFS", @infobase, 'pdf', INTERNAL);
  define_files_variable ("PSS", @infobase, 'ps', INTERNAL);
  define_files_variable ("HTMLS", @infobase, 'html', INTERNAL);

  # This next isn't strictly needed now -- the places that look here
  # could easily be changed to look in info_TEXINFOS.  But this is
  # probably better, in case noinst_TEXINFOS is ever supported.
  define_variable ("TEXINFOS", variable_value ('info_TEXINFOS'), INTERNAL);

  # Do some error checking.  Note that this file is not required
  # when in Cygnus mode; instead we defined TEXINFO_TEX explicitly
  # up above.
  if ($need_texi_file && ! option 'no-texinfo.tex')
    {
      if ($need_texi_file > 1)
	{
	  require_conf_file_with_macro (TRUE, 'info_TEXINFOS', FOREIGN,
					'texinfo.tex');
	}
      else
	{
	  require_file_with_macro (TRUE, 'info_TEXINFOS', FOREIGN,
				   'texinfo.tex');
	}
    }

  return (makefile_wrap ("", "\t  ", @mostly_cleans),
	  makefile_wrap ("", "\t  ", @texi_cleans),
	  makefile_wrap ("", "\t  ", @maint_cleans));
}


sub handle_texinfo ()
{
  reject_var 'TEXINFOS', "'TEXINFOS' is an anachronism; use 'info_TEXINFOS'";
  # FIXME: I think this is an obsolete future feature name.
  reject_var 'html_TEXINFOS', "HTML generation not yet supported";

  my $info_texinfos = var ('info_TEXINFOS');
  my ($mostlyclean, $clean, $maintclean) = ('', '', '');
  if ($info_texinfos)
    {
      define_verbose_texinfo;
      ($mostlyclean, $clean, $maintclean) = handle_texinfo_helper ($info_texinfos);
      chomp $mostlyclean;
      chomp $clean;
      chomp $maintclean;
    }

  $output_rules .=  file_contents ('texinfos',
				   new Automake::Location,
                                   AM_V_DVIPS    => verbose_flag('DVIPS'),
				   MOSTLYCLEAN   => $mostlyclean,
				   TEXICLEAN     => $clean,
				   MAINTCLEAN    => $maintclean,
				   'LOCAL-TEXIS' => !!$info_texinfos,
                                   TEXIQUIET     => verbose_flag('texinfo'));
}


sub handle_man_pages ()
{
  reject_var 'MANS', "'MANS' is an anachronism; use 'man_MANS'";

  # Find all the sections in use.  We do this by first looking for
  # "standard" sections, and then looking for any additional
  # sections used in man_MANS.
  my (%sections, %notrans_sections, %trans_sections,
      %notrans_vars, %trans_vars, %notrans_sect_vars, %trans_sect_vars);
  # We handle nodist_ for uniformity.  man pages aren't distributed
  # by default so it isn't actually very important.
  foreach my $npfx ('', 'notrans_')
    {
      foreach my $pfx ('', 'dist_', 'nodist_')
	{
	  # Add more sections as needed.
	  foreach my $section ('0'..'9', 'n', 'l')
	    {
	      my $varname = $npfx . $pfx . 'man' . $section . '_MANS';
	      if (var ($varname))
		{
		  $sections{$section} = 1;
		  $varname = '$(' . $varname . ')';
		  if ($npfx eq 'notrans_')
		    {
		      $notrans_sections{$section} = 1;
		      $notrans_sect_vars{$varname} = 1;
		    }
		  else
		    {
		      $trans_sections{$section} = 1;
		      $trans_sect_vars{$varname} = 1;
		    }

		  push_dist_common ($varname)
		    if $pfx eq 'dist_';
		}
	    }

	  my $varname = $npfx . $pfx . 'man_MANS';
	  my $var = var ($varname);
	  if ($var)
	    {
	      foreach ($var->value_as_list_recursive)
		{
		  # A page like 'foo.1c' goes into man1dir.
		  if (/\.([0-9a-z])([a-z]*)$/)
		    {
		      $sections{$1} = 1;
		      if ($npfx eq 'notrans_')
			{
			  $notrans_sections{$1} = 1;
			}
		      else
			{
			  $trans_sections{$1} = 1;
			}
		    }
		}

	      $varname = '$(' . $varname . ')';
	      if ($npfx eq 'notrans_')
		{
		  $notrans_vars{$varname} = 1;
		}
	      else
		{
		  $trans_vars{$varname} = 1;
		}
	      push_dist_common ($varname)
		if $pfx eq 'dist_';
	    }
	}
    }

  return unless %sections;

  my @unsorted_deps;

  # Build section independent variables.
  my $have_notrans = %notrans_vars;
  my @notrans_list = sort keys %notrans_vars;
  my $have_trans = %trans_vars;
  my @trans_list = sort keys %trans_vars;

  # Now for each section, generate an install and uninstall rule.
  # Sort sections so output is deterministic.
  foreach my $section (sort keys %sections)
    {
      # Build section dependent variables.
      my $notrans_mans = $have_notrans || exists $notrans_sections{$section};
      my $trans_mans = $have_trans || exists $trans_sections{$section};
      my (%notrans_this_sect, %trans_this_sect);
      my $expr = 'man' . $section . '_MANS';
      foreach my $varname (keys %notrans_sect_vars)
	{
	  if ($varname =~ /$expr/)
	    {
	      $notrans_this_sect{$varname} = 1;
	    }
	}
      foreach my $varname (keys %trans_sect_vars)
	{
	  if ($varname =~ /$expr/)
	    {
	      $trans_this_sect{$varname} = 1;
	    }
	}
      my @notrans_sect_list = sort keys %notrans_this_sect;
      my @trans_sect_list = sort keys %trans_this_sect;
      @unsorted_deps = (keys %notrans_vars, keys %trans_vars,
                        keys %notrans_this_sect, keys %trans_this_sect);
      my @deps = sort @unsorted_deps;
      $output_rules .= file_contents ('mans',
                                      new Automake::Location,
                                      SECTION           => $section,
                                      DEPS              => "@deps",
                                      NOTRANS_MANS      => $notrans_mans,
                                      NOTRANS_SECT_LIST => "@notrans_sect_list",
                                      HAVE_NOTRANS      => $have_notrans,
                                      NOTRANS_LIST      => "@notrans_list",
                                      TRANS_MANS        => $trans_mans,
                                      TRANS_SECT_LIST   => "@trans_sect_list",
                                      HAVE_TRANS        => $have_trans,
                                      TRANS_LIST        => "@trans_list");
    }

  @unsorted_deps  = (keys %notrans_vars, keys %trans_vars,
                     keys %notrans_sect_vars, keys %trans_sect_vars);
  my @mans = sort @unsorted_deps;
  $output_vars .= file_contents ('mans-vars',
				 new Automake::Location,
				 MANS => "@mans");

  push (@all, '$(MANS)')
    unless option 'no-installman';
}


sub handle_data ()
{
    am_install_var ('-noextra', '-candist', 'data', 'DATA',
                    'data', 'dataroot', 'doc', 'dvi', 'html', 'pdf',
                    'ps', 'sysconf', 'sharedstate', 'localstate',
                    'pkgdata', 'lisp', 'noinst', 'check');
}


sub handle_tags ()
{
    my @config;
    foreach my $spec (@config_headers)
      {
        my ($out, @ins) = split_config_file_spec ($spec);
	foreach my $in (@ins)
	  {
            # If the config header source is in this directory,
	    # require it.
	    push @config, basename ($in)
              if $relative_dir eq dirname ($in);
	   }
      }

    define_variable ('am__tagged_files',
                     '$(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)'
                     . "@config", INTERNAL);

    if (rvar('am__tagged_files')->value_as_list_recursive
          || var ('ETAGS_ARGS') || var ('SUBDIRS'))
      {
	$output_rules .= file_contents ('tags', new Automake::Location);
	set_seen 'TAGS_DEPENDENCIES';
      }
    else
      {
        reject_var ('TAGS_DEPENDENCIES',
		    "it doesn't make sense to define 'TAGS_DEPENDENCIES'"
		    . " without\nsources or 'ETAGS_ARGS'");
	# Every Makefile must define some sort of TAGS rule.
	# Otherwise, it would be possible for a top-level "make TAGS"
	# to fail because some subdirectory failed.  Ditto ctags and
        # cscope.
        $output_rules .=
          "tags TAGS:\n\n" .
          "ctags CTAGS:\n\n" .
          "cscope cscopelist:\n\n";
      }
}


# user_phony_rule ($NAME)
# -----------------------
# Return false if rule $NAME does not exist.  Otherwise,
# declare it as phony, complete its definition (in case it is
# conditional), and return its Automake::Rule instance.
sub user_phony_rule
{
  my ($name) = @_;
  my $rule = rule $name;
  if ($rule)
    {
      depend ('.PHONY', $name);
      # Define $NAME in all condition where it is not already defined,
      # so that it is always OK to depend on $NAME.
      for my $c ($rule->not_always_defined_in_cond (TRUE)->conds)
	{
	  Automake::Rule::define ($name, 'internal', RULE_AUTOMAKE,
				  $c, INTERNAL);
	  $output_rules .= $c->subst_string . "$name:\n";
	}
    }
  return $rule;
}


# Handle 'dist' target.
sub handle_dist ()
{
  # Substitutions for distdir.am
  my %transform;

  # Define DIST_SUBDIRS.  This must always be done, regardless of the
  # no-dist setting: target like 'distclean' or 'maintainer-clean' use it.
  my $subdirs = var ('SUBDIRS');
  if ($subdirs)
    {
      # If SUBDIRS is conditionally defined, then set DIST_SUBDIRS
      # to all possible directories, and use it.  If DIST_SUBDIRS is
      # defined, just use it.

      # Note that we check DIST_SUBDIRS first on purpose, so that
      # we don't call has_conditional_contents for now reason.
      # (In the past one project used so many conditional subdirectories
      # that calling has_conditional_contents on SUBDIRS caused
      # automake to grow to 150Mb -- this should not happen with
      # the current implementation of has_conditional_contents,
      # but it's more efficient to avoid the call anyway.)
      if (var ('DIST_SUBDIRS'))
	{
	}
      elsif ($subdirs->has_conditional_contents)
	{
	  define_pretty_variable
	    ('DIST_SUBDIRS', TRUE, INTERNAL,
	     uniq ($subdirs->value_as_list_recursive));
	}
      else
	{
	  # We always define this because that is what 'distclean'
	  # wants.
	  define_pretty_variable ('DIST_SUBDIRS', TRUE, INTERNAL,
				  '$(SUBDIRS)');
	}
    }

  # The remaining definitions are only required when a dist target is used.
  return if option 'no-dist';

  # At least one of the archive formats must be enabled.
  if ($relative_dir eq '.')
    {
      my $archive_defined = option 'no-dist-gzip' ? 0 : 1;
      $archive_defined ||=
	grep { option "dist-$_" } qw(shar zip tarZ bzip2 lzip xz);
      error (option 'no-dist-gzip',
	     "no-dist-gzip specified but no dist-* specified,\n"
	     . "at least one archive format must be enabled")
	unless $archive_defined;
    }

  # Look for common files that should be included in distribution.
  # If the aux dir is set, and it does not have a Makefile.am, then
  # we check for these files there as well.
  my $check_aux = 0;
  if ($relative_dir eq '.'
      && $config_aux_dir_set_in_configure_ac)
    {
      if (! is_make_dir ($config_aux_dir))
	{
	  $check_aux = 1;
	}
    }
  foreach my $cfile (@common_files)
    {
      if (dir_has_case_matching_file ($relative_dir, $cfile)
	  # The file might be absent, but if it can be built it's ok.
	  || rule $cfile)
	{
	  push_dist_common ($cfile);
	}

      # Don't use 'elsif' here because a file might meaningfully
      # appear in both directories.
      if ($check_aux && dir_has_case_matching_file ($config_aux_dir, $cfile))
	{
	  push_dist_common ("$config_aux_dir/$cfile")
	}
    }

  # We might copy elements from $configure_dist_common to
  # %dist_common if we think we need to.  If the file appears in our
  # directory, we would have discovered it already, so we don't
  # check that.  But if the file is in a subdir without a Makefile,
  # we want to distribute it here if we are doing '.'.  Ugly!
  # Also, in some corner cases, it's possible that the following code
  # will cause the same file to appear in the $(DIST_COMMON) variables
  # of two distinct Makefiles; but this is not a problem, since the
  # 'distdir' target in 'lib/am/distdir.am' can deal with the same
  # file being distributed multiple times.
  # See also automake bug#9651.
  if ($relative_dir eq '.')
    {
      foreach my $file (split (' ' , $configure_dist_common))
	{
	  my $dir = dirname ($file);
	  push_dist_common ($file)
	    if ($dir eq '.' || ! is_make_dir ($dir));
	}
    }

  # Files to distributed.  Don't use ->value_as_list_recursive
  # as it recursively expands '$(dist_pkgdata_DATA)' etc.
  my @dist_common = split (' ', rvar ('DIST_COMMON')->variable_value);
  @dist_common = uniq (@dist_common);
  variable_delete 'DIST_COMMON';
  define_pretty_variable ('DIST_COMMON', TRUE, INTERNAL, @dist_common);

  # Now that we've processed DIST_COMMON, disallow further attempts
  # to set it.
  $handle_dist_run = 1;

  $transform{'DISTCHECK-HOOK'} = !! rule 'distcheck-hook';
  $transform{'GETTEXT'} = $seen_gettext && !$seen_gettext_external;

  # If the target 'dist-hook' exists, make sure it is run.  This
  # allows users to do random weird things to the distribution
  # before it is packaged up.
  push (@dist_targets, 'dist-hook')
    if user_phony_rule 'dist-hook';
  $transform{'DIST-TARGETS'} = join (' ', @dist_targets);

  my $flm = option ('filename-length-max');
  my $filename_filter = $flm ? '.' x $flm->[1] : '';

  $output_rules .= file_contents ('distdir',
				  new Automake::Location,
				  %transform,
				  FILENAME_FILTER => $filename_filter);
}


# check_directory ($NAME, $WHERE [, $RELATIVE_DIR = "."])
# -------------------------------------------------------
# Ensure $NAME is a directory (in $RELATIVE_DIR), and that it uses a sane
# name.  Use $WHERE as a location in the diagnostic, if any.
sub check_directory
{
  my ($dir, $where, $reldir) = @_;
  $reldir = '.' unless defined $reldir;

  error $where, "required directory $reldir/$dir does not exist"
    unless -d "$reldir/$dir";

  # If an 'obj/' directory exists, BSD make will enter it before
  # reading 'Makefile'.  Hence the 'Makefile' in the current directory
  # will not be read.
  #
  #  % cat Makefile
  #  all:
  #          echo Hello
  #  % cat obj/Makefile
  #  all:
  #          echo World
  #  % make      # GNU make
  #  echo Hello
  #  Hello
  #  % pmake     # BSD make
  #  echo World
  #  World
  msg ('portability', $where,
       "naming a subdirectory 'obj' causes troubles with BSD make")
    if $dir eq 'obj';

  # 'aux' is probably the most important of the following forbidden name,
  # since it's tempting to use it as an AC_CONFIG_AUX_DIR.
  msg ('portability', $where,
       "name '$dir' is reserved on W32 and DOS platforms")
    if grep (/^\Q$dir\E$/i, qw/aux lpt1 lpt2 lpt3 com1 com2 com3 com4 con prn/);
}

# check_directories_in_var ($VARIABLE)
# ------------------------------------
# Recursively check all items in variables $VARIABLE as directories
sub check_directories_in_var
{
  my ($var) = @_;
  $var->traverse_recursively
    (sub
     {
       my ($var, $val, $cond, $full_cond) = @_;
       check_directory ($val, $var->rdef ($cond)->location, $relative_dir);
       return ();
     },
     undef,
     skip_ac_subst => 1);
}


sub handle_subdirs ()
{
  my $subdirs = var ('SUBDIRS');
  return
    unless $subdirs;

  check_directories_in_var $subdirs;

  my $dsubdirs = var ('DIST_SUBDIRS');
  check_directories_in_var $dsubdirs
    if $dsubdirs;

  $output_rules .= file_contents ('subdirs', new Automake::Location);
  rvar ('RECURSIVE_TARGETS')->rdef (TRUE)->{'pretty'} = VAR_SORTED; # Gross!
}


# ($REGEN, @DEPENDENCIES)
# scan_aclocal_m4
# ---------------
# If aclocal.m4 creation is automated, return the list of its dependencies.
sub scan_aclocal_m4 ()
{
  my $regen_aclocal = 0;

  set_seen 'CONFIG_STATUS_DEPENDENCIES';
  set_seen 'CONFIGURE_DEPENDENCIES';

  if (-f 'aclocal.m4')
    {
      define_variable ("ACLOCAL_M4", '$(top_srcdir)/aclocal.m4', INTERNAL);

      my $aclocal = new Automake::XFile "< aclocal.m4";
      my $line = $aclocal->getline;
      $regen_aclocal = $line =~ 'generated automatically by aclocal';
    }

  my @ac_deps = ();

  if (set_seen ('ACLOCAL_M4_SOURCES'))
    {
      push (@ac_deps, '$(ACLOCAL_M4_SOURCES)');
      msg_var ('obsolete', 'ACLOCAL_M4_SOURCES',
	       "'ACLOCAL_M4_SOURCES' is obsolete.\n"
	       . "It should be safe to simply remove it");
    }

  # Note that it might be possible that aclocal.m4 doesn't exist but
  # should be auto-generated.  This case probably isn't very
  # important.

  return ($regen_aclocal, @ac_deps);
}


# Helper function for 'substitute_ac_subst_variables'.
sub substitute_ac_subst_variables_worker
{
  my ($token) = @_;
  return "\@$token\@" if var $token;
  return "\${$token\}";
}

# substitute_ac_subst_variables ($TEXT)
# -------------------------------------
# Replace any occurrence of ${FOO} in $TEXT by @FOO@ if FOO is an AC_SUBST
# variable.
sub substitute_ac_subst_variables
{
  my ($text) = @_;
  $text =~ s/\${([^ \t=:+{}]+)}/substitute_ac_subst_variables_worker ($1)/ge;
  return $text;
}

# @DEPENDENCIES
# prepend_srcdir (@INPUTS)
# ------------------------
# Prepend $(srcdir) or $(top_srcdir) to all @INPUTS.  The idea is that
# if an input file has a directory part the same as the current
# directory, then the directory part is simply replaced by $(srcdir).
# But if the directory part is different, then $(top_srcdir) is
# prepended.
sub prepend_srcdir
{
  my (@inputs) = @_;
  my @newinputs;

  foreach my $single (@inputs)
    {
      if (dirname ($single) eq $relative_dir)
	{
	  push (@newinputs, '$(srcdir)/' . basename ($single));
	}
      else
	{
	  push (@newinputs, '$(top_srcdir)/' . $single);
	}
    }
  return @newinputs;
}

# @DEPENDENCIES
# rewrite_inputs_into_dependencies ($OUTPUT, @INPUTS)
# ---------------------------------------------------
# Compute a list of dependencies appropriate for the rebuild
# rule of
#   AC_CONFIG_FILES($OUTPUT:$INPUT[0]:$INPUTS[1]:...)
# Also distribute $INPUTs which are not built by another AC_CONFIG_FOOs.
sub rewrite_inputs_into_dependencies
{
  my ($file, @inputs) = @_;
  my @res = ();

  for my $i (@inputs)
    {
      # We cannot create dependencies on shell variables.
      next if (substitute_ac_subst_variables $i) =~ /\$/;

      if (exists $ac_config_files_location{$i} && $i ne $file)
	{
	  my $di = dirname $i;
	  if ($di eq $relative_dir)
	    {
	      $i = basename $i;
	    }
	  # In the top-level Makefile we do not use $(top_builddir), because
	  # we are already there, and since the targets are built without
	  # a $(top_builddir), it helps BSD Make to match them with
	  # dependencies.
	  elsif ($relative_dir ne '.')
	    {
	      $i = '$(top_builddir)/' . $i;
	    }
	}
      else
	{
	  msg ('error', $ac_config_files_location{$file},
	       "required file '$i' not found")
	    unless $i =~ /\$/ || exists $output_files{$i} || -f $i;
	  ($i) = prepend_srcdir ($i);
	  push_dist_common ($i);
	}
      push @res, $i;
    }
  return @res;
}



# handle_configure ($MAKEFILE_AM, $MAKEFILE_IN, $MAKEFILE, @INPUTS)
# -----------------------------------------------------------------
# Handle remaking and configure stuff.
# We need the name of the input file, to do proper remaking rules.
sub handle_configure
{
  my ($makefile_am, $makefile_in, $makefile, @inputs) = @_;

  prog_error 'empty @inputs'
    unless @inputs;

  my ($rel_makefile_am, $rel_makefile_in) = prepend_srcdir ($makefile_am,
							    $makefile_in);
  my $rel_makefile = basename $makefile;

  my $colon_infile = ':' . join (':', @inputs);
  $colon_infile = '' if $colon_infile eq ":$makefile.in";
  my @rewritten = rewrite_inputs_into_dependencies ($makefile, @inputs);
  my ($regen_aclocal_m4, @aclocal_m4_deps) = scan_aclocal_m4;
  define_pretty_variable ('am__aclocal_m4_deps', TRUE, INTERNAL,
			  @configure_deps, @aclocal_m4_deps,
			  '$(top_srcdir)/' . $configure_ac);
  my @configuredeps = ('$(am__aclocal_m4_deps)', '$(CONFIGURE_DEPENDENCIES)');
  push @configuredeps, '$(ACLOCAL_M4)' if -f 'aclocal.m4';
  define_pretty_variable ('am__configure_deps', TRUE, INTERNAL,
			  @configuredeps);

  my $automake_options = '--' . $strictness_name .
			 (global_option 'no-dependencies' ? ' --ignore-deps' : '');

  $output_rules .= file_contents
    ('configure',
     new Automake::Location,
     MAKEFILE              => $rel_makefile,
     'MAKEFILE-DEPS'       => "@rewritten",
     'CONFIG-MAKEFILE'     => ($relative_dir eq '.') ? '$@' : '$(subdir)/$@',
     'MAKEFILE-IN'         => $rel_makefile_in,
     'HAVE-MAKEFILE-IN-DEPS' => (@include_stack > 0),
     'MAKEFILE-IN-DEPS'    => "@include_stack",
     'MAKEFILE-AM'         => $rel_makefile_am,
     'AUTOMAKE-OPTIONS'    => $automake_options,
     'MAKEFILE-AM-SOURCES' => "$makefile$colon_infile",
     'REGEN-ACLOCAL-M4'    => $regen_aclocal_m4,
     VERBOSE               => verbose_flag ('GEN'));

  if ($relative_dir eq '.')
    {
      push_dist_common ('acconfig.h')
	if -f 'acconfig.h';
    }

  # If we have a configure header, require it.
  my $hdr_index = 0;
  my @distclean_config;
  foreach my $spec (@config_headers)
    {
      $hdr_index += 1;
      # $CONFIG_H_PATH: config.h from top level.
      my ($config_h_path, @ins) = split_config_file_spec ($spec);
      my $config_h_dir = dirname ($config_h_path);

      # If the header is in the current directory we want to build
      # the header here.  Otherwise, if we're at the topmost
      # directory and the header's directory doesn't have a
      # Makefile, then we also want to build the header.
      if ($relative_dir eq $config_h_dir
	  || ($relative_dir eq '.' && ! is_make_dir ($config_h_dir)))
	{
	  my ($cn_sans_dir, $stamp_dir);
	  if ($relative_dir eq $config_h_dir)
	    {
	      $cn_sans_dir = basename ($config_h_path);
	      $stamp_dir = '';
	    }
	  else
	    {
	      $cn_sans_dir = $config_h_path;
	      if ($config_h_dir eq '.')
		{
		  $stamp_dir = '';
		}
	      else
		{
		  $stamp_dir = $config_h_dir . '/';
		}
	    }

	  # This will also distribute all inputs.
	  @ins = rewrite_inputs_into_dependencies ($config_h_path, @ins);

	  # Cannot define rebuild rules for filenames with shell variables.
	  next if (substitute_ac_subst_variables $config_h_path) =~ /\$/;

	  # Header defined in this directory.
	  my @files;
	  if (-f $config_h_path . '.top')
	    {
	      push (@files, "$cn_sans_dir.top");
	    }
	  if (-f $config_h_path . '.bot')
	    {
	      push (@files, "$cn_sans_dir.bot");
	    }

	  push_dist_common (@files);

	  # For now, acconfig.h can only appear in the top srcdir.
	  if (-f 'acconfig.h')
	    {
	      push (@files, '$(top_srcdir)/acconfig.h');
	    }

	  my $stamp = "${stamp_dir}stamp-h${hdr_index}";
	  $output_rules .=
	    file_contents ('remake-hdr',
			   new Automake::Location,
			   FILES            => "@files",
			   'FIRST-HDR'      => ($hdr_index == 1),
			   CONFIG_H         => $cn_sans_dir,
			   CONFIG_HIN       => $ins[0],
			   CONFIG_H_DEPS    => "@ins",
			   CONFIG_H_PATH    => $config_h_path,
			   STAMP            => "$stamp");

	  push @distclean_config, $cn_sans_dir, $stamp;
	}
    }

  $output_rules .= file_contents ('clean-hdr',
				  new Automake::Location,
				  FILES => "@distclean_config")
    if @distclean_config;

  # Distribute and define mkinstalldirs only if it is already present
  # in the package, for backward compatibility (some people may still
  # use $(mkinstalldirs)).
  # TODO: start warning about this in Automake 1.14, and have
  # TODO: Automake 2.0 drop it (and the mkinstalldirs script
  # TODO: as well).
  my $mkidpath = "$config_aux_dir/mkinstalldirs";
  if (-f $mkidpath)
    {
      # Use require_file so that any existing script gets updated
      # by --force-missing.
      require_conf_file ($mkidpath, FOREIGN, 'mkinstalldirs');
      define_variable ('mkinstalldirs',
		       "\$(SHELL) $am_config_aux_dir/mkinstalldirs", INTERNAL);
    }
  else
    {
      # Use $(install_sh), not $(MKDIR_P) because the latter requires
      # at least one argument, and $(mkinstalldirs) used to work
      # even without arguments (e.g. $(mkinstalldirs) $(conditional_dir)).
      define_variable ('mkinstalldirs', '$(install_sh) -d', INTERNAL);
    }

  reject_var ('CONFIG_HEADER',
	      "'CONFIG_HEADER' is an anachronism; now determined "
	      . "automatically\nfrom '$configure_ac'");

  my @config_h;
  foreach my $spec (@config_headers)
    {
      my ($out, @ins) = split_config_file_spec ($spec);
      # Generate CONFIG_HEADER define.
      if ($relative_dir eq dirname ($out))
	{
	  push @config_h, basename ($out);
	}
      else
	{
	  push @config_h, "\$(top_builddir)/$out";
	}
    }
  define_variable ("CONFIG_HEADER", "@config_h", INTERNAL)
    if @config_h;

  # Now look for other files in this directory which must be remade
  # by config.status, and generate rules for them.
  my @actual_other_files = ();
  # These get cleaned only in a VPATH build.
  my @actual_other_vpath_files = ();
  foreach my $lfile (@other_input_files)
    {
      my $file;
      my @inputs;
      if ($lfile =~ /^([^:]*):(.*)$/)
	{
	  # This is the ":" syntax of AC_OUTPUT.
	  $file = $1;
	  @inputs = split (':', $2);
	}
      else
	{
	  # Normal usage.
	  $file = $lfile;
	  @inputs = $file . '.in';
	}

      # Automake files should not be stored in here, but in %MAKE_LIST.
      prog_error ("$lfile in \@other_input_files\n"
		  . "\@other_input_files = (@other_input_files)")
	if -f $file . '.am';

      my $local = basename ($file);

      # We skip files that aren't in this directory.  However, if
      # the file's directory does not have a Makefile, and we are
      # currently doing '.', then we create a rule to rebuild the
      # file in the subdir.
      my $fd = dirname ($file);
      if ($fd ne $relative_dir)
	{
	  if ($relative_dir eq '.' && ! is_make_dir ($fd))
	    {
	      $local = $file;
	    }
	  else
	    {
	      next;
	    }
	}

      my @rewritten_inputs = rewrite_inputs_into_dependencies ($file, @inputs);

      # Cannot output rules for shell variables.
      next if (substitute_ac_subst_variables $local) =~ /\$/;

      my $condstr = '';
      my $cond = $ac_config_files_condition{$lfile};
      if (defined $cond)
        {
	  $condstr = $cond->subst_string;
	  Automake::Rule::define ($local, $configure_ac, RULE_AUTOMAKE, $cond,
				  $ac_config_files_location{$file});
        }
      $output_rules .= ($condstr . $local . ': '
			. '$(top_builddir)/config.status '
			. "@rewritten_inputs\n"
			. $condstr . "\t"
			. 'cd $(top_builddir) && '
			. '$(SHELL) ./config.status '
			. ($relative_dir eq '.' ? '' : '$(subdir)/')
			. '$@'
			. "\n");
      push (@actual_other_files, $local);
    }

  # For links we should clean destinations and distribute sources.
  foreach my $spec (@config_links)
    {
      my ($link, $file) = split /:/, $spec;
      # Some people do AC_CONFIG_LINKS($computed).  We only handle
      # the DEST:SRC form.
      next unless $file;
      my $where = $ac_config_files_location{$link};

      # Skip destinations that contain shell variables.
      if ((substitute_ac_subst_variables $link) !~ /\$/)
	{
	  # We skip links that aren't in this directory.  However, if
	  # the link's directory does not have a Makefile, and we are
	  # currently doing '.', then we add the link to CONFIG_CLEAN_FILES
	  # in '.'s Makefile.in.
	  my $local = basename ($link);
	  my $fd = dirname ($link);
	  if ($fd ne $relative_dir)
	    {
	      if ($relative_dir eq '.' && ! is_make_dir ($fd))
		{
		  $local = $link;
		}
	      else
		{
		  $local = undef;
		}
	    }
	  if ($file ne $link)
	    {
	      push @actual_other_files, $local if $local;
	    }
	  else
	    {
	      push @actual_other_vpath_files, $local if $local;
	    }
	}

      # Do not process sources that contain shell variables.
      if ((substitute_ac_subst_variables $file) !~ /\$/)
	{
	  my $fd = dirname ($file);

	  # We distribute files that are in this directory.
	  # At the top-level ('.') we also distribute files whose
	  # directory does not have a Makefile.
	  if (($fd eq $relative_dir)
	      || ($relative_dir eq '.' && ! is_make_dir ($fd)))
	    {
	      # The following will distribute $file as a side-effect when
	      # it is appropriate (i.e., when $file is not already an output).
	      # We do not need the result, just the side-effect.
	      rewrite_inputs_into_dependencies ($link, $file);
	    }
	}
    }

  # These files get removed by "make distclean".
  define_pretty_variable ('CONFIG_CLEAN_FILES', TRUE, INTERNAL,
			  @actual_other_files);
  define_pretty_variable ('CONFIG_CLEAN_VPATH_FILES', TRUE, INTERNAL,
			  @actual_other_vpath_files);
}

sub handle_headers ()
{
    my @r = am_install_var ('-defaultdist', 'header', 'HEADERS', 'include',
			    'oldinclude', 'pkginclude',
			    'noinst', 'check');
    foreach (@r)
    {
      next unless $_->[1] =~ /\..*$/;
      saw_extension ($&);
    }
}

sub handle_gettext ()
{
  return if ! $seen_gettext || $relative_dir ne '.';

  my $subdirs = var 'SUBDIRS';

  if (! $subdirs)
    {
      err_ac "AM_GNU_GETTEXT used but SUBDIRS not defined";
      return;
    }

  # Perform some sanity checks to help users get the right setup.
  # We disable these tests when po/ doesn't exist in order not to disallow
  # unusual gettext setups.
  #
  # Bruno Haible:
  # | The idea is:
  # |
  # |  1) If a package doesn't have a directory po/ at top level, it
  # |     will likely have multiple po/ directories in subpackages.
  # |
  # |  2) It is useful to warn for the absence of intl/ if AM_GNU_GETTEXT
  # |     is used without 'external'. It is also useful to warn for the
  # |     presence of intl/ if AM_GNU_GETTEXT([external]) is used. Both
  # |     warnings apply only to the usual layout of packages, therefore
  # |     they should both be disabled if no po/ directory is found at
  # |     top level.

  if (-d 'po')
    {
      my @subdirs = $subdirs->value_as_list_recursive;

      msg_var ('syntax', $subdirs,
	       "AM_GNU_GETTEXT used but 'po' not in SUBDIRS")
	if ! grep ($_ eq 'po', @subdirs);

      # intl/ is not required when AM_GNU_GETTEXT is called with the
      # 'external' option and AM_GNU_GETTEXT_INTL_SUBDIR is not called.
      msg_var ('syntax', $subdirs,
	       "AM_GNU_GETTEXT used but 'intl' not in SUBDIRS")
	if (! ($seen_gettext_external && ! $seen_gettext_intl)
	    && ! grep ($_ eq 'intl', @subdirs));

      # intl/ should not be used with AM_GNU_GETTEXT([external]), except
      # if AM_GNU_GETTEXT_INTL_SUBDIR is called.
      msg_var ('syntax', $subdirs,
	       "'intl' should not be in SUBDIRS when "
	       . "AM_GNU_GETTEXT([external]) is used")
	if ($seen_gettext_external && ! $seen_gettext_intl
	    && grep ($_ eq 'intl', @subdirs));
    }

  require_file ($ac_gettext_location, GNU, 'ABOUT-NLS');
}

# Emit makefile footer.
sub handle_footer ()
{
    reject_rule ('.SUFFIXES',
		 "use variable 'SUFFIXES', not target '.SUFFIXES'");

    # Note: AIX 4.1 /bin/make will fail if any suffix rule appears
    # before .SUFFIXES.  So we make sure that .SUFFIXES appears before
    # anything else, by sticking it right after the default: target.
    $output_header .= ".SUFFIXES:\n";
    my $suffixes = var 'SUFFIXES';
    my @suffixes = Automake::Rule::suffixes;
    if (@suffixes || $suffixes)
    {
	# Make sure SUFFIXES has unique elements.  Sort them to ensure
	# the output remains consistent.  However, $(SUFFIXES) is
	# always at the start of the list, unsorted.  This is done
	# because make will choose rules depending on the ordering of
	# suffixes, and this lets the user have some control.  Push
	# actual suffixes, and not $(SUFFIXES).  Some versions of make
	# do not like variable substitutions on the .SUFFIXES line.
	my @user_suffixes = ($suffixes
			     ? $suffixes->value_as_list_recursive : ());

	my %suffixes = map { $_ => 1 } @suffixes;
	delete @suffixes{@user_suffixes};

	$output_header .= (".SUFFIXES: "
			   . join (' ', @user_suffixes, sort keys %suffixes)
			   . "\n");
    }

    $output_trailer .= file_contents ('footer', new Automake::Location);
}


# Generate 'make install' rules.
sub handle_install ()
{
  $output_rules .= file_contents
    ('install',
     new Automake::Location,
     maybe_BUILT_SOURCES => (set_seen ('BUILT_SOURCES')
			     ? (" \$(BUILT_SOURCES)\n"
				. "\t\$(MAKE) \$(AM_MAKEFLAGS)")
			     : ''),
     'installdirs-local' => (user_phony_rule ('installdirs-local')
			     ? ' installdirs-local' : ''),
     am__installdirs => variable_value ('am__installdirs') || '');
}


# handle_all ($MAKEFILE)
#-----------------------
# Deal with 'all' and 'all-am'.
sub handle_all
{
    my ($makefile) = @_;

    # Output 'all-am'.

    # Put this at the beginning for the sake of non-GNU makes.  This
    # is still wrong if these makes can run parallel jobs.  But it is
    # right enough.
    unshift (@all, basename ($makefile));

    foreach my $spec (@config_headers)
      {
	my ($out, @ins) = split_config_file_spec ($spec);
	push (@all, basename ($out))
	  if dirname ($out) eq $relative_dir;
      }

    # Install 'all' hooks.
    push (@all, "all-local")
      if user_phony_rule "all-local";

    pretty_print_rule ("all-am:", "\t\t", @all);
    depend ('.PHONY', 'all-am', 'all');


    # Output 'all'.

    my @local_headers = ();
    push @local_headers, '$(BUILT_SOURCES)'
      if var ('BUILT_SOURCES');
    foreach my $spec (@config_headers)
      {
	my ($out, @ins) = split_config_file_spec ($spec);
	push @local_headers, basename ($out)
	  if dirname ($out) eq $relative_dir;
      }

    if (@local_headers)
      {
	# We need to make sure config.h is built before we recurse.
	# We also want to make sure that built sources are built
	# before any ordinary 'all' targets are run.  We can't do this
	# by changing the order of dependencies to the "all" because
	# that breaks when using parallel makes.  Instead we handle
	# things explicitly.
	$output_all .= ("all: @local_headers"
			. "\n\t"
			. '$(MAKE) $(AM_MAKEFLAGS) '
			. (var ('SUBDIRS') ? 'all-recursive' : 'all-am')
			. "\n\n");
        depend ('.MAKE', 'all');
      }
    else
      {
	$output_all .= "all: " . (var ('SUBDIRS')
				  ? 'all-recursive' : 'all-am') . "\n\n";
      }
}

# Generate helper targets for user-defined recursive targets, where needed.
sub handle_user_recursion ()
{
  return unless @extra_recursive_targets;

  define_pretty_variable ('am__extra_recursive_targets', TRUE, INTERNAL,
                          map { "$_-recursive" } @extra_recursive_targets);
  my $aux = var ('SUBDIRS') ? 'recursive' : 'am';
  foreach my $target (@extra_recursive_targets)
    {
      # This allows the default target's rules to be overridden in
      # Makefile.am.
      user_phony_rule ($target);
      depend ("$target", "$target-$aux");
      depend ("$target-am", "$target-local");
      # Every user-defined recursive target 'foo' *must* have a valid
      # associated 'foo-local' rule; we define it as an empty rule by
      # default, so that the user can transparently extend it in his
      # own Makefile.am.
      pretty_print_rule ("$target-local:", '', '');
      # $target-recursive might as well be undefined, so do not add
      # it here; it's taken care of in subdirs.am anyway.
      depend (".PHONY", "$target-am", "$target-local");
    }
}


# Handle check merge target specially.
sub do_check_merge_target ()
{
  # Include user-defined local form of target.
  push @check_tests, 'check-local'
    if user_phony_rule 'check-local';

  # The check target must depend on the local equivalent of
  # 'all', to ensure all the primary targets are built.  Then it
  # must build the local check rules.
  $output_rules .= "check-am: all-am\n";
  if (@check)
    {
      pretty_print_rule ("\t\$(MAKE) \$(AM_MAKEFLAGS)", "\t  ", @check);
      depend ('.MAKE', 'check-am');
    }

  if (@check_tests)
    {
      pretty_print_rule ("\t\$(MAKE) \$(AM_MAKEFLAGS)", "\t  ",
			 @check_tests);
      depend ('.MAKE', 'check-am');
    }

  depend '.PHONY', 'check', 'check-am';
  # Handle recursion.  We have to honor BUILT_SOURCES like for 'all:'.
  $output_rules .= ("check: "
		    . (var ('BUILT_SOURCES')
		       ? "\$(BUILT_SOURCES)\n\t\$(MAKE) \$(AM_MAKEFLAGS) "
		       : '')
		    . (var ('SUBDIRS') ? 'check-recursive' : 'check-am')
		    . "\n");
  depend ('.MAKE', 'check')
    if var ('BUILT_SOURCES');
}

# Handle all 'clean' targets.
sub handle_clean
{
  my ($makefile) = @_;

  # Clean the files listed in user variables if they exist.
  $clean_files{'$(MOSTLYCLEANFILES)'} = MOSTLY_CLEAN
    if var ('MOSTLYCLEANFILES');
  $clean_files{'$(CLEANFILES)'} = CLEAN
    if var ('CLEANFILES');
  $clean_files{'$(DISTCLEANFILES)'} = DIST_CLEAN
    if var ('DISTCLEANFILES');
  $clean_files{'$(MAINTAINERCLEANFILES)'} = MAINTAINER_CLEAN
    if var ('MAINTAINERCLEANFILES');

  # Built sources are automatically removed by maintainer-clean.
  $clean_files{'$(BUILT_SOURCES)'} = MAINTAINER_CLEAN
    if var ('BUILT_SOURCES');

  # Compute a list of "rm"s to run for each target.
  my %rms = (MOSTLY_CLEAN, [],
	     CLEAN, [],
	     DIST_CLEAN, [],
	     MAINTAINER_CLEAN, []);

  foreach my $file (keys %clean_files)
    {
      my $when = $clean_files{$file};
      prog_error 'invalid entry in %clean_files'
	unless exists $rms{$when};

      my $rm = "rm -f $file";
      # If file is a variable, make sure when don't call 'rm -f' without args.
      $rm ="test -z \"$file\" || $rm"
	if ($file =~ /^\s*\$(\(.*\)|\{.*\})\s*$/);

      push @{$rms{$when}}, "\t-$rm\n";
    }

  $output_rules .= file_contents
    ('clean',
     new Automake::Location,
     MOSTLYCLEAN_RMS      => join ('', sort @{$rms{&MOSTLY_CLEAN}}),
     CLEAN_RMS            => join ('', sort @{$rms{&CLEAN}}),
     DISTCLEAN_RMS        => join ('', sort @{$rms{&DIST_CLEAN}}),
     MAINTAINER_CLEAN_RMS => join ('', sort @{$rms{&MAINTAINER_CLEAN}}),
     MAKEFILE             => basename $makefile,
     );
}


# Subroutine for handle_factored_dependencies() to let '.PHONY' and
# other '.TARGETS' be last.  This is meant to be used as a comparison
# subroutine passed to the sort built-int.
sub target_cmp
{
  return 0 if $a eq $b;

  my $a1 = substr ($a, 0, 1);
  my $b1 = substr ($b, 0, 1);
  if ($a1 ne $b1)
    {
      return -1 if $b1 eq '.';
      return 1 if $a1 eq '.';
    }
  return $a cmp $b;
}


# Handle everything related to gathered targets.
sub handle_factored_dependencies ()
{
  # Reject bad hooks.
  foreach my $utarg ('uninstall-data-local', 'uninstall-data-hook',
		     'uninstall-exec-local', 'uninstall-exec-hook',
		     'uninstall-dvi-local',
		     'uninstall-html-local',
		     'uninstall-info-local',
		     'uninstall-pdf-local',
		     'uninstall-ps-local')
    {
      my $x = $utarg;
      $x =~ s/-.*-/-/;
      reject_rule ($utarg, "use '$x', not '$utarg'");
    }

  reject_rule ('install-local',
	       "use 'install-data-local' or 'install-exec-local', "
	       . "not 'install-local'");

  reject_rule ('install-hook',
	       "use 'install-data-hook' or 'install-exec-hook', "
	       . "not 'install-hook'");

  # Install the -local hooks.
  foreach (keys %dependencies)
    {
      # Hooks are installed on the -am targets.
      s/-am$// or next;
      depend ("$_-am", "$_-local")
	if user_phony_rule "$_-local";
    }

  # Install the -hook hooks.
  # FIXME: Why not be as liberal as we are with -local hooks?
  foreach ('install-exec', 'install-data', 'uninstall')
    {
      if (user_phony_rule "$_-hook")
	{
	  depend ('.MAKE', "$_-am");
	  register_action("$_-am",
			  ("\t\@\$(NORMAL_INSTALL)\n"
			   . "\t\$(MAKE) \$(AM_MAKEFLAGS) $_-hook"));
	}
    }

  # All the required targets are phony.
  depend ('.PHONY', keys %required_targets);

  # Actually output gathered targets.
  foreach (sort target_cmp keys %dependencies)
    {
      # If there is nothing about this guy, skip it.
      next
	unless (@{$dependencies{$_}}
		|| $actions{$_}
		|| $required_targets{$_});

      # Define gathered targets in undefined conditions.
      # FIXME: Right now we must handle .PHONY as an exception,
      # because people write things like
      #    .PHONY: myphonytarget
      # to append dependencies.  This would not work if Automake
      # refrained from defining its own .PHONY target as it does
      # with other overridden targets.
      # Likewise for '.MAKE'.
      my @undefined_conds = (TRUE,);
      if ($_ ne '.PHONY' && $_ ne '.MAKE')
	{
	  @undefined_conds =
	    Automake::Rule::define ($_, 'internal',
				    RULE_AUTOMAKE, TRUE, INTERNAL);
	}
      my @uniq_deps = uniq (sort @{$dependencies{$_}});
      foreach my $cond (@undefined_conds)
	{
	  my $condstr = $cond->subst_string;
	  pretty_print_rule ("$condstr$_:", "$condstr\t", @uniq_deps);
	  $output_rules .= $actions{$_} if defined $actions{$_};
	  $output_rules .= "\n";
	}
    }
}


sub handle_tests_dejagnu ()
{
    push (@check_tests, 'check-DEJAGNU');
    $output_rules .= file_contents ('dejagnu', new Automake::Location);
}

# handle_per_suffix_test ($TEST_SUFFIX, [%TRANSFORM])
#----------------------------------------------------
sub handle_per_suffix_test
{
  my ($test_suffix, %transform) = @_;
  my ($pfx, $generic, $am_exeext);
  if ($test_suffix eq '')
    {
      $pfx = '';
      $generic = 0;
      $am_exeext = 'FALSE';
    }
  else
    {
      prog_error ("test suffix '$test_suffix' lacks leading dot")
        unless $test_suffix =~ m/^\.(.*)/;
      $pfx = uc ($1) . '_';
      $generic = 1;
      $am_exeext = exists $configure_vars{'EXEEXT'} ? 'am__EXEEXT'
                                                    : 'FALSE';
    }
  # The "test driver" program, deputed to handle tests protocol used by
  # test scripts.  By default, it's assumed that no protocol is used, so
  # we fall back to the old behaviour, implemented by the 'test-driver'
  # auxiliary script.
  if (! var "${pfx}LOG_DRIVER")
    {
      require_conf_file ("parallel-tests", FOREIGN, 'test-driver');
      define_variable ("${pfx}LOG_DRIVER",
                       "\$(SHELL) $am_config_aux_dir/test-driver",
                       INTERNAL);
    }
  my $driver = '$(' . $pfx . 'LOG_DRIVER)';
  my $driver_flags = '$(AM_' . $pfx . 'LOG_DRIVER_FLAGS)'
                       . ' $(' . $pfx . 'LOG_DRIVER_FLAGS)';
  my $compile = "${pfx}LOG_COMPILE";
  define_variable ($compile,
                   '$(' . $pfx . 'LOG_COMPILER)'
                      . ' $(AM_' .  $pfx . 'LOG_FLAGS)'
                      . ' $(' . $pfx . 'LOG_FLAGS)',
                     INTERNAL);
  $output_rules .= file_contents ('check2', new Automake::Location,
                                   GENERIC => $generic,
                                   DRIVER => $driver,
                                   DRIVER_FLAGS => $driver_flags,
                                   COMPILE => '$(' . $compile . ')',
                                   EXT => $test_suffix,
                                   am__EXEEXT => $am_exeext,
                                   %transform);
}

# is_valid_test_extension ($EXT)
# ------------------------------
# Return true if $EXT can appear in $(TEST_EXTENSIONS), return false
# otherwise.
sub is_valid_test_extension
{
  my $ext = shift;
  return 1
    if ($ext =~ /^\.[a-zA-Z_][a-zA-Z0-9_]*$/);
  return 1
    if (exists $configure_vars{'EXEEXT'} && $ext eq subst ('EXEEXT'));
  return 0;
}


sub handle_tests ()
{
  if (option 'dejagnu')
    {
      handle_tests_dejagnu;
    }
  else
    {
      foreach my $c ('DEJATOOL', 'RUNTEST', 'RUNTESTFLAGS')
	{
	  reject_var ($c, "'$c' defined but 'dejagnu' not in "
		      . "'AUTOMAKE_OPTIONS'");
	}
    }

  if (var ('TESTS'))
    {
      push (@check_tests, 'check-TESTS');
      my $check_deps = "@check";
      $output_rules .= file_contents ('check', new Automake::Location,
                                      SERIAL_TESTS => !! option 'serial-tests',
                                      CHECK_DEPS => $check_deps);

      # Tests that are known programs should have $(EXEEXT) appended.
      # For matching purposes, we need to adjust XFAIL_TESTS as well.
      append_exeext { exists $known_programs{$_[0]} } 'TESTS';
      append_exeext { exists $known_programs{$_[0]} } 'XFAIL_TESTS'
	if (var ('XFAIL_TESTS'));

      if (! option 'serial-tests')
        {
	  define_variable ('TEST_SUITE_LOG', 'test-suite.log', INTERNAL);
	  my $suff = '.test';
	  my $at_exeext = '';
	  my $handle_exeext = exists $configure_vars{'EXEEXT'};
	  if ($handle_exeext)
	    {
	      $at_exeext = subst ('EXEEXT');
	      $suff = $at_exeext  . ' ' . $suff;
	    }
          if (! var 'TEST_EXTENSIONS')
            {
	      define_variable ('TEST_EXTENSIONS', $suff, INTERNAL);
            }
          my $var = var 'TEST_EXTENSIONS';
          # Currently, we are not able to deal with conditional contents
          # in TEST_EXTENSIONS.
          if ($var->has_conditional_contents)
           {
	     msg_var 'unsupported', $var,
                     "'TEST_EXTENSIONS' cannot have conditional contents";
           }
	  my @test_suffixes = $var->value_as_list_recursive;
          if ((my @invalid_test_suffixes =
                  grep { !is_valid_test_extension $_ } @test_suffixes) > 0)
            {
              error $var->rdef (TRUE)->location,
                    "invalid test extensions: @invalid_test_suffixes";
            }
          @test_suffixes = grep { is_valid_test_extension $_ } @test_suffixes;
	  if ($handle_exeext)
	    {
	      unshift (@test_suffixes, $at_exeext)
	        unless $test_suffixes[0] eq $at_exeext;
	    }
	  unshift (@test_suffixes, '');

	  transform_variable_recursively
	    ('TESTS', 'TEST_LOGS', 'am__testlogs', 1, INTERNAL,
	      sub {
	        my ($subvar, $val, $cond, $full_cond) = @_;
		my $obj = $val;
		return $obj
		  if $val =~ /^\@.*\@$/;
		$obj =~ s/\$\(EXEEXT\)$//o;

		if ($val =~ /(\$\((top_)?srcdir\))\//o)
		  {
		    msg ('error', $subvar->rdef ($cond)->location,
			 "using '$1' in TESTS is currently broken: '$val'");
		  }

		foreach my $test_suffix (@test_suffixes)
		  {
		    next
		      if $test_suffix eq $at_exeext || $test_suffix eq '';
		    return substr ($obj, 0, length ($obj) - length ($test_suffix)) . '.log'
		      if substr ($obj, - length ($test_suffix)) eq $test_suffix;
		  }
		my $base = $obj;
		$obj .= '.log';
                handle_per_suffix_test ('',
                                        OBJ => $obj,
                                        BASE => $base,
                                        SOURCE => $val);
	        return $obj;
	      });

	  my $nhelper=1;
	  my $prev = 'TESTS';
	  my $post = '';
	  my $last_suffix = $test_suffixes[$#test_suffixes];
	  my $cur = '';
	  foreach my $test_suffix (@test_suffixes)
	    {
	      if ($test_suffix eq $last_suffix)
	        {
		  $cur = 'TEST_LOGS';
		}
	      else
	        {
		  $cur = 'am__test_logs' . $nhelper;
		}
	      define_variable ($cur,
		'$(' . $prev . ':' . $test_suffix . $post . '=.log)', INTERNAL);
	      $post = '.log';
	      $prev = $cur;
	      $nhelper++;
	      if ($test_suffix ne $at_exeext && $test_suffix ne '')
	        {
                  handle_per_suffix_test ($test_suffix,
                                          OBJ => '',
                                          BASE => '$*',
                                          SOURCE => '$<');
	        }
	    }
	  $clean_files{'$(TEST_LOGS)'} = MOSTLY_CLEAN;
	  $clean_files{'$(TEST_LOGS:.log=.trs)'} = MOSTLY_CLEAN;
	  $clean_files{'$(TEST_SUITE_LOG)'} = MOSTLY_CLEAN;
	}
    }
}

sub handle_emacs_lisp ()
{
  my @elfiles = am_install_var ('-candist', 'lisp', 'LISP',
                                'lisp', 'noinst');

  return if ! @elfiles;

  define_pretty_variable ('am__ELFILES', TRUE, INTERNAL,
			  map { $_->[1] } @elfiles);
  define_pretty_variable ('am__ELCFILES', TRUE, INTERNAL,
			  '$(am__ELFILES:.el=.elc)');
  # This one can be overridden by users.
  define_pretty_variable ('ELCFILES', TRUE, INTERNAL, '$(LISP:.el=.elc)');

  push @all, '$(ELCFILES)';

  require_variables ($elfiles[0][0], "Emacs Lisp sources seen", TRUE,
		     'EMACS', 'lispdir');
}

sub handle_python ()
{
  my @pyfiles = am_install_var ('-defaultdist', 'python', 'PYTHON',
                                'noinst');
  return if ! @pyfiles;

  require_variables ($pyfiles[0][0], "Python sources seen", TRUE, 'PYTHON');
  require_conf_file ($pyfiles[0][0], FOREIGN, 'py-compile');
  define_variable ('py_compile', "$am_config_aux_dir/py-compile", INTERNAL);
}

sub handle_java ()
{
    my @sourcelist = am_install_var ('-candist',
                                     'java', 'JAVA',
                                     'noinst', 'check');
    return if ! @sourcelist;

    my @prefixes = am_primary_prefixes ('JAVA', 1,
				        'noinst', 'check');

    my $dir;
    my @java_sources = ();
    foreach my $prefix (@prefixes)
      {
        (my $curs = $prefix) =~ s/^(?:nobase_)?(?:dist_|nodist_)?//;

	next
	  if $curs eq 'EXTRA';

        push @java_sources, '$(' . $prefix . '_JAVA' . ')';

	if (defined $dir)
	  {
	    err_var "${curs}_JAVA", "multiple _JAVA primaries in use"
	     unless $curs eq $dir;
	  }

	$dir = $curs;
      }

    define_pretty_variable ('am__java_sources', TRUE, INTERNAL,
                            "@java_sources");

    if ($dir eq 'check')
      {
        push (@check, "class$dir.stamp");
      }
    else
      {
        push (@all, "class$dir.stamp");
      }
}


sub handle_minor_options ()
{
  if (option 'readme-alpha')
    {
      if ($relative_dir eq '.')
	{
	  if ($package_version !~ /^$GNITS_VERSION_PATTERN$/)
	    {
	      msg ('error-gnits', $package_version_location,
		   "version '$package_version' doesn't follow " .
		   "Gnits standards");
	    }
	  if (defined $1 && -f 'README-alpha')
	    {
	      # This means we have an alpha release.  See
	      # GNITS_VERSION_PATTERN for details.
	      push_dist_common ('README-alpha');
	    }
	}
    }
}

################################################################

# ($OUTPUT, @INPUTS)
# split_config_file_spec ($SPEC)
# ------------------------------
# Decode the Autoconf syntax for config files (files, headers, links
# etc.).
sub split_config_file_spec
{
  my ($spec) = @_;
  my ($output, @inputs) = split (/:/, $spec);

  push @inputs, "$output.in"
    unless @inputs;

  return ($output, @inputs);
}

# $input
# locate_am (@POSSIBLE_SOURCES)
# -----------------------------
# AC_CONFIG_FILES allow specifications such as Makefile:top.in:mid.in:bot.in
# This functions returns the first *.in file for which a *.am exists.
# It returns undef otherwise.
sub locate_am
{
  my (@rest) = @_;
  my $input;
  foreach my $file (@rest)
    {
      if (($file =~ /^(.*)\.in$/) && -f "$1.am")
	{
	  $input = $file;
	  last;
	}
    }
  return $input;
}

my %make_list;

# scan_autoconf_config_files ($WHERE, $CONFIG-FILES)
# --------------------------------------------------
# Study $CONFIG-FILES which is the first argument to AC_CONFIG_FILES
# (or AC_OUTPUT).
sub scan_autoconf_config_files
{
  my ($where, $config_files) = @_;

  # Look at potential Makefile.am's.
  foreach (split ' ', $config_files)
    {
      # Must skip empty string for Perl 4.
      next if $_ eq "\\" || $_ eq '';

      # Handle $local:$input syntax.
      my ($local, @rest) = split (/:/);
      @rest = ("$local.in",) unless @rest;
      # Keep in sync with test 'conffile-leading-dot.sh'.
      msg ('unsupported', $where,
           "omit leading './' from config file names such as '$local';"
           . "\nremake rules might be subtly broken otherwise")
        if ($local =~ /^\.\//);
      my $input = locate_am @rest;
      if ($input)
	{
	  # We have a file that automake should generate.
	  $make_list{$input} = join (':', ($local, @rest));
	}
      else
	{
	  # We have a file that automake should cause to be
	  # rebuilt, but shouldn't generate itself.
	  push (@other_input_files, $_);
	}
      $ac_config_files_location{$local} = $where;
      $ac_config_files_condition{$local} =
        new Automake::Condition (@cond_stack)
          if (@cond_stack);
    }
}


sub scan_autoconf_traces
{
  my ($filename) = @_;

  # Macros to trace, with their minimal number of arguments.
  #
  # IMPORTANT: If you add a macro here, you should also add this macro
  # =========  to Automake-preselection in autoconf/lib/autom4te.in.
  my %traced = (
		AC_CANONICAL_BUILD => 0,
		AC_CANONICAL_HOST => 0,
		AC_CANONICAL_TARGET => 0,
		AC_CONFIG_AUX_DIR => 1,
		AC_CONFIG_FILES => 1,
		AC_CONFIG_HEADERS => 1,
		AC_CONFIG_LIBOBJ_DIR => 1,
		AC_CONFIG_LINKS => 1,
		AC_FC_SRCEXT => 1,
		AC_INIT => 0,
		AC_LIBSOURCE => 1,
		AC_REQUIRE_AUX_FILE => 1,
		AC_SUBST_TRACE => 1,
		AM_AUTOMAKE_VERSION => 1,
                AM_PROG_MKDIR_P => 0,
		AM_CONDITIONAL => 2,
		AM_EXTRA_RECURSIVE_TARGETS => 1,
		AM_GNU_GETTEXT => 0,
		AM_GNU_GETTEXT_INTL_SUBDIR => 0,
		AM_INIT_AUTOMAKE => 0,
		AM_MAINTAINER_MODE => 0,
		AM_PROG_AR => 0,
		_AM_SUBST_NOTMAKE => 1,
		_AM_COND_IF => 1,
		_AM_COND_ELSE => 1,
		_AM_COND_ENDIF => 1,
		LT_SUPPORTED_TAG => 1,
		_LT_AC_TAGCONFIG => 0,
		m4_include => 1,
		m4_sinclude => 1,
		sinclude => 1,
	      );

  my $traces = ($ENV{AUTOCONF} || 'autoconf') . " ";

  # Use a separator unlikely to be used, not ':', the default, which
  # has a precise meaning for AC_CONFIG_FILES and so on.
  $traces .= join (' ',
		   map { "--trace=$_" . ':\$f:\$l::\$d::\$n::\${::}%' }
		   (keys %traced));

  my $tracefh = new Automake::XFile ("$traces $filename |");
  verb "reading $traces";

  @cond_stack = ();
  my $where;

  while ($_ = $tracefh->getline)
    {
      chomp;
      my ($here, $depth, @args) = split (/::/);
      $where = new Automake::Location $here;
      my $macro = $args[0];

      prog_error ("unrequested trace '$macro'")
	unless exists $traced{$macro};

      # Skip and diagnose malformed calls.
      if ($#args < $traced{$macro})
	{
	  msg ('syntax', $where, "not enough arguments for $macro");
	  next;
	}

      # Alphabetical ordering please.
      if ($macro eq 'AC_CANONICAL_BUILD')
	{
	  if ($seen_canonical <= AC_CANONICAL_BUILD)
	    {
	      $seen_canonical = AC_CANONICAL_BUILD;
	    }
	}
      elsif ($macro eq 'AC_CANONICAL_HOST')
	{
	  if ($seen_canonical <= AC_CANONICAL_HOST)
	    {
	      $seen_canonical = AC_CANONICAL_HOST;
	    }
	}
      elsif ($macro eq 'AC_CANONICAL_TARGET')
	{
	  $seen_canonical = AC_CANONICAL_TARGET;
	}
      elsif ($macro eq 'AC_CONFIG_AUX_DIR')
	{
	  if ($seen_init_automake)
	    {
	      error ($where, "AC_CONFIG_AUX_DIR must be called before "
		     . "AM_INIT_AUTOMAKE ...", partial => 1);
	      error ($seen_init_automake, "... AM_INIT_AUTOMAKE called here");
	    }
	  $config_aux_dir = $args[1];
	  $config_aux_dir_set_in_configure_ac = 1;
	  check_directory ($config_aux_dir, $where);
	}
      elsif ($macro eq 'AC_CONFIG_FILES')
	{
	  # Look at potential Makefile.am's.
	  scan_autoconf_config_files ($where, $args[1]);
	}
      elsif ($macro eq 'AC_CONFIG_HEADERS')
	{
	  foreach my $spec (split (' ', $args[1]))
	    {
	      my ($dest, @src) = split (':', $spec);
	      $ac_config_files_location{$dest} = $where;
	      push @config_headers, $spec;
	    }
	}
      elsif ($macro eq 'AC_CONFIG_LIBOBJ_DIR')
	{
	  $config_libobj_dir = $args[1];
	  check_directory ($config_libobj_dir, $where);
	}
      elsif ($macro eq 'AC_CONFIG_LINKS')
	{
	  foreach my $spec (split (' ', $args[1]))
	    {
	      my ($dest, $src) = split (':', $spec);
	      $ac_config_files_location{$dest} = $where;
	      push @config_links, $spec;
	    }
	}
      elsif ($macro eq 'AC_FC_SRCEXT')
	{
	  my $suffix = $args[1];
	  # These flags are used as %SOURCEFLAG% in depend2.am,
	  # where the trailing space is important.
	  $sourceflags{'.' . $suffix} = '$(FCFLAGS_' . $suffix . ') '
	    if ($suffix eq 'f90' || $suffix eq 'f95' || $suffix eq 'f03' || $suffix eq 'f08');
	}
      elsif ($macro eq 'AC_INIT')
	{
	  if (defined $args[2])
	    {
	      $package_version = $args[2];
	      $package_version_location = $where;
	    }
	}
      elsif ($macro eq 'AC_LIBSOURCE')
	{
	  $libsources{$args[1]} = $here;
	}
      elsif ($macro eq 'AC_REQUIRE_AUX_FILE')
	{
	  # Only remember the first time a file is required.
	  $required_aux_file{$args[1]} = $where
	    unless exists $required_aux_file{$args[1]};
	}
      elsif ($macro eq 'AC_SUBST_TRACE')
	{
	  # Just check for alphanumeric in AC_SUBST_TRACE.  If you do
	  # AC_SUBST(5), then too bad.
	  $configure_vars{$args[1]} = $where
	    if $args[1] =~ /^\w+$/;
	}
      elsif ($macro eq 'AM_AUTOMAKE_VERSION')
	{
	  error ($where,
		 "version mismatch.  This is Automake $VERSION,\n" .
		 "but the definition used by this AM_INIT_AUTOMAKE\n" .
		 "comes from Automake $args[1].  You should recreate\n" .
		 "aclocal.m4 with aclocal and run automake again.\n",
		 # $? = 63 is used to indicate version mismatch to missing.
		 exit_code => 63)
	    if $VERSION ne $args[1];

	  $seen_automake_version = 1;
	}
      elsif ($macro eq 'AM_PROG_MKDIR_P')
	{
	  msg 'obsolete', $where, <<'EOF';
The 'AM_PROG_MKDIR_P' macro is deprecated, and its use is discouraged.
You should use the Autoconf-provided 'AC_PROG_MKDIR_P' macro instead,
and use '$(MKDIR_P)' instead of '$(mkdir_p)'in your Makefile.am files.
EOF
	}
      elsif ($macro eq 'AM_CONDITIONAL')
	{
	  $configure_cond{$args[1]} = $where;
	}
      elsif ($macro eq 'AM_EXTRA_RECURSIVE_TARGETS')
	{
          # Empty leading/trailing fields might be produced by split,
          # hence the grep is really needed.
          push @extra_recursive_targets,
               grep (/./, (split /\s+/, $args[1]));
	}
      elsif ($macro eq 'AM_GNU_GETTEXT')
	{
	  $seen_gettext = $where;
	  $ac_gettext_location = $where;
	  $seen_gettext_external = grep ($_ eq 'external', @args);
	}
      elsif ($macro eq 'AM_GNU_GETTEXT_INTL_SUBDIR')
	{
	  $seen_gettext_intl = $where;
	}
      elsif ($macro eq 'AM_INIT_AUTOMAKE')
	{
	  $seen_init_automake = $where;
	  if (defined $args[2])
	    {
              msg 'obsolete', $where, <<'EOF';
AM_INIT_AUTOMAKE: two- and three-arguments forms are deprecated.  For more info, see:
http://www.gnu.org/software/automake/manual/automake.html#Modernize-AM_005fINIT_005fAUTOMAKE-invocation
EOF
	      $package_version = $args[2];
	      $package_version_location = $where;
	    }
	  elsif (defined $args[1])
	    {
	      my @opts = split (' ', $args[1]);
	      @opts = map { { option => $_, where => $where } } @opts;
	      exit $exit_code unless process_global_option_list (@opts);
	    }
	}
      elsif ($macro eq 'AM_MAINTAINER_MODE')
	{
	  $seen_maint_mode = $where;
	}
      elsif ($macro eq 'AM_PROG_AR')
	{
	  $seen_ar = $where;
	}
      elsif ($macro eq '_AM_COND_IF')
        {
	  cond_stack_if ('', $args[1], $where);
	  error ($where, "missing m4 quoting, macro depth $depth")
	    if ($depth != 1);
	}
      elsif ($macro eq '_AM_COND_ELSE')
        {
	  cond_stack_else ('!', $args[1], $where);
	  error ($where, "missing m4 quoting, macro depth $depth")
	    if ($depth != 1);
	}
      elsif ($macro eq '_AM_COND_ENDIF')
        {
	  cond_stack_endif (undef, undef, $where);
	  error ($where, "missing m4 quoting, macro depth $depth")
	    if ($depth != 1);
	}
      elsif ($macro eq '_AM_SUBST_NOTMAKE')
	{
	  $ignored_configure_vars{$args[1]} = $where;
	}
      elsif ($macro eq 'm4_include'
	     || $macro eq 'm4_sinclude'
	     || $macro eq 'sinclude')
	{
	  # Skip missing 'sinclude'd files.
	  next if $macro ne 'm4_include' && ! -f $args[1];

	  # Some modified versions of Autoconf don't use
	  # frozen files.  Consequently it's possible that we see all
	  # m4_include's performed during Autoconf's startup.
	  # Obviously we don't want to distribute Autoconf's files
	  # so we skip absolute filenames here.
	  push @configure_deps, '$(top_srcdir)/' . $args[1]
	    unless $here =~ m,^(?:\w:)?[\\/],;
	  # Keep track of the greatest timestamp.
	  if (-e $args[1])
	    {
	      my $mtime = mtime $args[1];
	      $configure_deps_greatest_timestamp = $mtime
		if $mtime > $configure_deps_greatest_timestamp;
	    }
	}
      elsif ($macro eq 'LT_SUPPORTED_TAG')
	{
	  $libtool_tags{$args[1]} = 1;
	  $libtool_new_api = 1;
	}
      elsif ($macro eq '_LT_AC_TAGCONFIG')
	{
	  # _LT_AC_TAGCONFIG is an old macro present in Libtool 1.5.
	  # We use it to detect whether tags are supported.  Our
	  # preferred interface is LT_SUPPORTED_TAG, but it was
	  # introduced in Libtool 1.6.
	  if (0 == keys %libtool_tags)
	    {
	      # Hardcode the tags supported by Libtool 1.5.
	      %libtool_tags = (CC => 1, CXX => 1, GCJ => 1, F77 => 1);
	    }
	}
    }

  error ($where, "condition stack not properly closed")
    if (@cond_stack);

  $tracefh->close;
}


# Check whether we use 'configure.ac' or 'configure.in'.
# Scan it (and possibly 'aclocal.m4') for interesting things.
# We must scan aclocal.m4 because there might be AC_SUBSTs and such there.
sub scan_autoconf_files ()
{
  # Reinitialize libsources here.  This isn't really necessary,
  # since we currently assume there is only one configure.ac.  But
  # that won't always be the case.
  %libsources = ();

  # Keep track of the youngest configure dependency.
  $configure_deps_greatest_timestamp = mtime $configure_ac;
  if (-e 'aclocal.m4')
    {
      my $mtime = mtime 'aclocal.m4';
      $configure_deps_greatest_timestamp = $mtime
	if $mtime > $configure_deps_greatest_timestamp;
    }

  scan_autoconf_traces ($configure_ac);

  @configure_input_files = sort keys %make_list;
  # Set input and output files if not specified by user.
  if (! @input_files)
    {
      @input_files = @configure_input_files;
      %output_files = %make_list;
    }


  if (! $seen_init_automake)
    {
      err_ac ("no proper invocation of AM_INIT_AUTOMAKE was found.\nYou "
	      . "should verify that $configure_ac invokes AM_INIT_AUTOMAKE,"
	      . "\nthat aclocal.m4 is present in the top-level directory,\n"
	      . "and that aclocal.m4 was recently regenerated "
	      . "(using aclocal)");
    }
  else
    {
      if (! $seen_automake_version)
	{
	  if (-f 'aclocal.m4')
	    {
	      error ($seen_init_automake,
		     "your implementation of AM_INIT_AUTOMAKE comes from " .
		     "an\nold Automake version.  You should recreate " .
		     "aclocal.m4\nwith aclocal and run automake again",
		     # $? = 63 is used to indicate version mismatch to missing.
		     exit_code => 63);
	    }
	  else
	    {
	      error ($seen_init_automake,
		     "no proper implementation of AM_INIT_AUTOMAKE was " .
		     "found,\nprobably because aclocal.m4 is missing.\n" .
		     "You should run aclocal to create this file, then\n" .
		     "run automake again");
	    }
	}
    }

  locate_aux_dir ();

  # Look for some files we need.  Always check for these.  This
  # check must be done for every run, even those where we are only
  # looking at a subdir Makefile.  We must set relative_dir for
  # push_required_file to work.
  # Sort the files for stable verbose output.
  $relative_dir = '.';
  foreach my $file (sort keys %required_aux_file)
    {
      require_conf_file ($required_aux_file{$file}->get, FOREIGN, $file)
    }
  err_am "'install.sh' is an anachronism; use 'install-sh' instead"
    if -f $config_aux_dir . '/install.sh';

  # Preserve dist_common for later.
  $configure_dist_common = variable_value ('DIST_COMMON') || '';

}

################################################################

# Do any extra checking for GNU standards.
sub check_gnu_standards ()
{
  if ($relative_dir eq '.')
    {
      # In top level (or only) directory.
      require_file ("$am_file.am", GNU,
		    qw/INSTALL NEWS README AUTHORS ChangeLog/);

      # Accept one of these three licenses; default to COPYING.
      # Make sure we do not overwrite an existing license.
      my $license;
      foreach (qw /COPYING COPYING.LIB COPYING.LESSER/)
	{
	  if (-f $_)
	    {
	      $license = $_;
	      last;
	    }
	}
      require_file ("$am_file.am", GNU, 'COPYING')
	unless $license;
    }

  for my $opt ('no-installman', 'no-installinfo')
    {
      msg ('error-gnu', option $opt,
	   "option '$opt' disallowed by GNU standards")
	if option $opt;
    }
}

# Do any extra checking for GNITS standards.
sub check_gnits_standards ()
{
  if ($relative_dir eq '.')
    {
      # In top level (or only) directory.
      require_file ("$am_file.am", GNITS, 'THANKS');
    }
}

################################################################
#
# Functions to handle files of each language.

# Each 'lang_X_rewrite($DIRECTORY, $BASE, $EXT)' function follows a
# simple formula: Return value is LANG_SUBDIR if the resulting object
# file should be in a subdir if the source file is, LANG_PROCESS if
# file is to be dealt with, LANG_IGNORE otherwise.

# Much of the actual processing is handled in
# handle_single_transform.  These functions exist so that
# auxiliary information can be recorded for a later cleanup pass.
# Note that the calls to these functions are computed, so don't bother
# searching for their precise names in the source.

# This is just a convenience function that can be used to determine
# when a subdir object should be used.
sub lang_sub_obj ()
{
    return option 'subdir-objects' ? LANG_SUBDIR : LANG_PROCESS;
}

# Rewrite a single header file.
sub lang_header_rewrite
{
    # Header files are simply ignored.
    return LANG_IGNORE;
}

# Rewrite a single Vala source file.
sub lang_vala_rewrite
{
    my ($directory, $base, $ext) = @_;

    (my $newext = $ext) =~ s/vala$/c/;
    return (LANG_SUBDIR, $newext);
}

# Rewrite a single yacc/yacc++ file.
sub lang_yacc_rewrite
{
    my ($directory, $base, $ext) = @_;

    my $r = lang_sub_obj;
    (my $newext = $ext) =~ tr/y/c/;
    return ($r, $newext);
}
sub lang_yaccxx_rewrite { lang_yacc_rewrite (@_); };

# Rewrite a single lex/lex++ file.
sub lang_lex_rewrite
{
    my ($directory, $base, $ext) = @_;

    my $r = lang_sub_obj;
    (my $newext = $ext) =~ tr/l/c/;
    return ($r, $newext);
}
sub lang_lexxx_rewrite { lang_lex_rewrite (@_); };

# Rewrite a single Java file.
sub lang_java_rewrite
{
    return LANG_SUBDIR;
}

# The lang_X_finish functions are called after all source file
# processing is done.  Each should handle defining rules for the
# language, etc.  A finish function is only called if a source file of
# the appropriate type has been seen.

sub lang_vala_finish_target
{
  my ($self, $name) = @_;

  my $derived = canonicalize ($name);
  my $var = var "${derived}_SOURCES";
  return unless $var;

  my @vala_sources = grep { /\.(vala|vapi)$/ } ($var->value_as_list_recursive);

  # For automake bug#11229.
  return unless @vala_sources;

  foreach my $vala_file (@vala_sources)
    {
      my $c_file = $vala_file;
      if ($c_file =~ s/(.*)\.vala$/$1.c/)
        {
          $c_file = "\$(srcdir)/$c_file";
          $output_rules .= "$c_file: \$(srcdir)/${derived}_vala.stamp\n"
            . "\t\@if test -f \$@; then :; else rm -f \$(srcdir)/${derived}_vala.stamp; fi\n"
            . "\t\@if test -f \$@; then :; else \\\n"
            . "\t  \$(MAKE) \$(AM_MAKEFLAGS) \$(srcdir)/${derived}_vala.stamp; \\\n"
            . "\tfi\n";
	  $clean_files{$c_file} = MAINTAINER_CLEAN;
        }
    }

  # Add rebuild rules for generated header and vapi files
  my $flags = var ($derived . '_VALAFLAGS');
  if ($flags)
    {
      my $lastflag = '';
      foreach my $flag ($flags->value_as_list_recursive)
	{
	  if (grep (/$lastflag/, ('-H', '-h', '--header', '--internal-header',
	                          '--vapi', '--internal-vapi', '--gir')))
	    {
	      my $headerfile = "\$(srcdir)/$flag";
	      $output_rules .= "$headerfile: \$(srcdir)/${derived}_vala.stamp\n"
		. "\t\@if test -f \$@; then :; else rm -f \$(srcdir)/${derived}_vala.stamp; fi\n"
		. "\t\@if test -f \$@; then :; else \\\n"
		. "\t  \$(MAKE) \$(AM_MAKEFLAGS) \$(srcdir)/${derived}_vala.stamp; \\\n"
		. "\tfi\n";

	      # valac is not used when building from dist tarballs
	      # distribute the generated files
	      push_dist_common ($headerfile);
	      $clean_files{$headerfile} = MAINTAINER_CLEAN;
	    }
	  $lastflag = $flag;
	}
    }

  my $compile = $self->compile;

  # Rewrite each occurrence of 'AM_VALAFLAGS' in the compile
  # rule into '${derived}_VALAFLAGS' if it exists.
  my $val = "${derived}_VALAFLAGS";
  $compile =~ s/\(AM_VALAFLAGS\)/\($val\)/
    if set_seen ($val);

  # VALAFLAGS is a user variable (per GNU Standards),
  # it should not be overridden in the Makefile...
  check_user_variables 'VALAFLAGS';

  my $dirname = dirname ($name);

  # Only generate C code, do not run C compiler
  $compile .= " -C";

  my $verbose = verbose_flag ('VALAC');
  my $silent = silent_flag ();
  my $stampfile = "\$(srcdir)/${derived}_vala.stamp";

  $output_rules .=
    "\$(srcdir)/${derived}_vala.stamp: @vala_sources\n".
# Since the C files generated from the vala sources depend on the
# ${derived}_vala.stamp file, we must ensure its timestamp is older than
# those of the C files generated by the valac invocation below (this is
# especially important on systems with sub-second timestamp resolution).
# Thus we need to create the stamp file *before* invoking valac, and to
# move it to its final location only after valac has been invoked.
    "\t${silent}rm -f \$\@ && echo stamp > \$\@-t\n".
    "\t${verbose}\$(am__cd) \$(srcdir) && $compile @vala_sources\n".
    "\t${silent}mv -f \$\@-t \$\@\n";

  push_dist_common ($stampfile);

  $clean_files{$stampfile} = MAINTAINER_CLEAN;
}

# Add output rules to invoke valac and create stamp file as a witness
# to handle multiple outputs. This function is called after all source
# file processing is done.
sub lang_vala_finish ()
{
  my ($self) = @_;

  foreach my $prog (keys %known_programs)
    {
      lang_vala_finish_target ($self, $prog);
    }

  while (my ($name) = each %known_libraries)
    {
      lang_vala_finish_target ($self, $name);
    }
}

# The built .c files should be cleaned only on maintainer-clean
# as the .c files are distributed. This function is called for each
# .vala source file.
sub lang_vala_target_hook
{
  my ($self, $aggregate, $output, $input, %transform) = @_;

  $clean_files{$output} = MAINTAINER_CLEAN;
}

# This is a yacc helper which is called whenever we have decided to
# compile a yacc file.
sub lang_yacc_target_hook
{
    my ($self, $aggregate, $output, $input, %transform) = @_;

    # If some relevant *YFLAGS variable contains the '-d' flag, we'll
    # have to to generate special code.
    my $yflags_contains_minus_d = 0;

    foreach my $pfx ("", "${aggregate}_")
      {
	my $yflagsvar = var ("${pfx}YFLAGS");
	next unless $yflagsvar;
	# We cannot work reliably with conditionally-defined YFLAGS.
	if ($yflagsvar->has_conditional_contents)
	  {
	    msg_var ('unsupported', $yflagsvar,
	             "'${pfx}YFLAGS' cannot have conditional contents");
	  }
	else
	  {
	    $yflags_contains_minus_d = 1
	      if grep (/^-d$/, $yflagsvar->value_as_list_recursive);
	  }
      }

    if ($yflags_contains_minus_d)
      {
	# Found a '-d' that applies to the compilation of this file.
	# Add a dependency for the generated header file, and arrange
	# for that file to be included in the distribution.

	# The extension of the output file (e.g., '.c' or '.cxx').
	# We'll need it to compute the name of the generated header file.
	(my $output_ext = basename ($output)) =~ s/.*(\.[^.]+)$/$1/;

	# We know that a yacc input should be turned into either a C or
	# C++ output file.  We depend on this fact (here and in yacc.am),
	# so check that it really holds.
	my $lang = $languages{$extension_map{$output_ext}};
	prog_error "invalid output name '$output' for yacc file '$input'"
	  if (!$lang || ($lang->name ne 'c' && $lang->name ne 'cxx'));

	(my $header_ext = $output_ext) =~ s/c/h/g;
        # Quote $output_ext in the regexp, so that dots in it are taken
        # as literal dots, not as metacharacters.
	(my $header = $output) =~ s/\Q$output_ext\E$/$header_ext/;

	foreach my $cond (Automake::Rule::define (${header}, 'internal',
						  RULE_AUTOMAKE, TRUE,
						  INTERNAL))
	  {
	    my $condstr = $cond->subst_string;
	    $output_rules .=
	      "$condstr${header}: $output\n"
	      # Recover from removal of $header
	      . "$condstr\t\@if test ! -f \$@; then rm -f $output; else :; fi\n"
	      . "$condstr\t\@if test ! -f \$@; then \$(MAKE) \$(AM_MAKEFLAGS) $output; else :; fi\n";
	  }
	# Distribute the generated file, unless its .y source was
	# listed in a nodist_ variable.  (handle_source_transform()
	# will set DIST_SOURCE.)
	push_dist_common ($header)
	  if $transform{'DIST_SOURCE'};

	# The GNU rules say that yacc/lex output files should be removed
	# by maintainer-clean.  However, if the files are not distributed,
	# then we want to remove them with "make clean"; otherwise,
	# "make distcheck" will fail.
	$clean_files{$header} = $transform{'DIST_SOURCE'} ? MAINTAINER_CLEAN : CLEAN;
      }
    # See the comment above for $HEADER.
    $clean_files{$output} = $transform{'DIST_SOURCE'} ? MAINTAINER_CLEAN : CLEAN;
}

# This is a lex helper which is called whenever we have decided to
# compile a lex file.
sub lang_lex_target_hook
{
    my ($self, $aggregate, $output, $input, %transform) = @_;
    # The GNU rules say that yacc/lex output files should be removed
    # by maintainer-clean.  However, if the files are not distributed,
    # then we want to remove them with "make clean"; otherwise,
    # "make distcheck" will fail.
    $clean_files{$output} = $transform{'DIST_SOURCE'} ? MAINTAINER_CLEAN : CLEAN;
}

# This is a helper for both lex and yacc.
sub yacc_lex_finish_helper ()
{
  return if defined $language_scratch{'lex-yacc-done'};
  $language_scratch{'lex-yacc-done'} = 1;

  # FIXME: for now, no line number.
  require_conf_file ($configure_ac, FOREIGN, 'ylwrap');
  define_variable ('YLWRAP', "$am_config_aux_dir/ylwrap", INTERNAL);
}

sub lang_yacc_finish ()
{
  return if defined $language_scratch{'yacc-done'};
  $language_scratch{'yacc-done'} = 1;

  reject_var 'YACCFLAGS', "'YACCFLAGS' obsolete; use 'YFLAGS' instead";

  yacc_lex_finish_helper;
}


sub lang_lex_finish ()
{
  return if defined $language_scratch{'lex-done'};
  $language_scratch{'lex-done'} = 1;

  yacc_lex_finish_helper;
}


# Given a hash table of linker names, pick the name that has the most
# precedence.  This is lame, but something has to have global
# knowledge in order to eliminate the conflict.  Add more linkers as
# required.
sub resolve_linker
{
    my (%linkers) = @_;

    foreach my $l (qw(GCJLINK OBJCXXLINK CXXLINK F77LINK FCLINK OBJCLINK UPCLINK))
    {
	return $l if defined $linkers{$l};
    }
    return 'LINK';
}

# Called to indicate that an extension was used.
sub saw_extension
{
    my ($ext) = @_;
    $extension_seen{$ext} = 1;
}

# register_language (%ATTRIBUTE)
# ------------------------------
# Register a single language.
# Each %ATTRIBUTE is of the form ATTRIBUTE => VALUE.
sub register_language
{
  my (%option) = @_;

  # Set the defaults.
  $option{'autodep'} = 'no'
    unless defined $option{'autodep'};
  $option{'linker'} = ''
    unless defined $option{'linker'};
  $option{'flags'} = []
    unless defined $option{'flags'};
  $option{'output_extensions'} = sub { return ( '.$(OBJEXT)', '.lo' ) }
    unless defined $option{'output_extensions'};
  $option{'nodist_specific'} = 0
    unless defined $option{'nodist_specific'};

  my $lang = new Automake::Language (%option);

  # Fill indexes.
  $extension_map{$_} = $lang->name foreach @{$lang->extensions};
  $languages{$lang->name} = $lang;
  my $link = $lang->linker;
  if ($link)
    {
      if (exists $link_languages{$link})
	{
	  prog_error ("'$link' has different definitions in "
		      . $lang->name . " and " . $link_languages{$link}->name)
	    if $lang->link ne $link_languages{$link}->link;
	}
      else
	{
	  $link_languages{$link} = $lang;
	}
    }

  # Update the pattern of known extensions.
  accept_extensions (@{$lang->extensions});

  # Update the suffix rules map.
  foreach my $suffix (@{$lang->extensions})
    {
      foreach my $dest ($lang->output_extensions->($suffix))
	{
	  register_suffix_rule (INTERNAL, $suffix, $dest);
	}
    }
}

# derive_suffix ($EXT, $OBJ)
# --------------------------
# This function is used to find a path from a user-specified suffix $EXT
# to $OBJ or to some other suffix we recognize internally, e.g. 'cc'.
sub derive_suffix
{
  my ($source_ext, $obj) = @_;

  while (!$extension_map{$source_ext} && $source_ext ne $obj)
    {
      my $new_source_ext = next_in_suffix_chain ($source_ext, $obj);
      last if not defined $new_source_ext;
      $source_ext = $new_source_ext;
    }

  return $source_ext;
}


# Pretty-print something and append to '$output_rules'.
sub pretty_print_rule
{
    $output_rules .= makefile_wrap (shift, shift, @_);
}


################################################################


## -------------------------------- ##
## Handling the conditional stack.  ##
## -------------------------------- ##


# $STRING
# make_conditional_string ($NEGATE, $COND)
# ----------------------------------------
sub make_conditional_string
{
  my ($negate, $cond) = @_;
  $cond = "${cond}_TRUE"
    unless $cond =~ /^TRUE|FALSE$/;
  $cond = Automake::Condition::conditional_negate ($cond)
    if $negate;
  return $cond;
}


my %_am_macro_for_cond =
  (
  AMDEP => "one of the compiler tests\n"
	   . "    AC_PROG_CC, AC_PROG_CXX, AC_PROG_OBJC, AC_PROG_OBJCXX,\n"
	   . "    AM_PROG_AS, AM_PROG_GCJ, AM_PROG_UPC",
  am__fastdepCC => 'AC_PROG_CC',
  am__fastdepCCAS => 'AM_PROG_AS',
  am__fastdepCXX => 'AC_PROG_CXX',
  am__fastdepGCJ => 'AM_PROG_GCJ',
  am__fastdepOBJC => 'AC_PROG_OBJC',
  am__fastdepOBJCXX => 'AC_PROG_OBJCXX',
  am__fastdepUPC => 'AM_PROG_UPC'
  );

# $COND
# cond_stack_if ($NEGATE, $COND, $WHERE)
# --------------------------------------
sub cond_stack_if
{
  my ($negate, $cond, $where) = @_;

  if (! $configure_cond{$cond} && $cond !~ /^TRUE|FALSE$/)
    {
      my $text = "$cond does not appear in AM_CONDITIONAL";
      my $scope = US_LOCAL;
      if (exists $_am_macro_for_cond{$cond})
	{
	  my $mac = $_am_macro_for_cond{$cond};
	  $text .= "\n  The usual way to define '$cond' is to add ";
	  $text .= ($mac =~ / /) ? $mac : "'$mac'";
	  $text .= "\n  to '$configure_ac' and run 'aclocal' and 'autoconf' again";
	  # These warnings appear in Automake files (depend2.am),
	  # so there is no need to display them more than once:
	  $scope = US_GLOBAL;
	}
      error $where, $text, uniq_scope => $scope;
    }

  push (@cond_stack, make_conditional_string ($negate, $cond));

  return new Automake::Condition (@cond_stack);
}


# $COND
# cond_stack_else ($NEGATE, $COND, $WHERE)
# ----------------------------------------
sub cond_stack_else
{
  my ($negate, $cond, $where) = @_;

  if (! @cond_stack)
    {
      error $where, "else without if";
      return FALSE;
    }

  $cond_stack[$#cond_stack] =
    Automake::Condition::conditional_negate ($cond_stack[$#cond_stack]);

  # If $COND is given, check against it.
  if (defined $cond)
    {
      $cond = make_conditional_string ($negate, $cond);

      error ($where, "else reminder ($negate$cond) incompatible with "
	     . "current conditional: $cond_stack[$#cond_stack]")
	if $cond_stack[$#cond_stack] ne $cond;
    }

  return new Automake::Condition (@cond_stack);
}


# $COND
# cond_stack_endif ($NEGATE, $COND, $WHERE)
# -----------------------------------------
sub cond_stack_endif
{
  my ($negate, $cond, $where) = @_;
  my $old_cond;

  if (! @cond_stack)
    {
      error $where, "endif without if";
      return TRUE;
    }

  # If $COND is given, check against it.
  if (defined $cond)
    {
      $cond = make_conditional_string ($negate, $cond);

      error ($where, "endif reminder ($negate$cond) incompatible with "
	     . "current conditional: $cond_stack[$#cond_stack]")
	if $cond_stack[$#cond_stack] ne $cond;
    }

  pop @cond_stack;

  return new Automake::Condition (@cond_stack);
}





## ------------------------ ##
## Handling the variables.  ##
## ------------------------ ##


# define_pretty_variable ($VAR, $COND, $WHERE, @VALUE)
# ----------------------------------------------------
# Like define_variable, but the value is a list, and the variable may
# be defined conditionally.  The second argument is the condition
# under which the value should be defined; this should be the empty
# string to define the variable unconditionally.  The third argument
# is a list holding the values to use for the variable.  The value is
# pretty printed in the output file.
sub define_pretty_variable
{
    my ($var, $cond, $where, @value) = @_;

    if (! vardef ($var, $cond))
    {
	Automake::Variable::define ($var, VAR_AUTOMAKE, '', $cond, "@value",
				    '', $where, VAR_PRETTY);
	rvar ($var)->rdef ($cond)->set_seen;
    }
}


# define_variable ($VAR, $VALUE, $WHERE)
# --------------------------------------
# Define a new Automake Makefile variable VAR to VALUE, but only if
# not already defined.
sub define_variable
{
    my ($var, $value, $where) = @_;
    define_pretty_variable ($var, TRUE, $where, $value);
}


# define_files_variable ($VAR, \@BASENAME, $EXTENSION, $WHERE)
# ------------------------------------------------------------
# Define the $VAR which content is the list of file names composed of
# a @BASENAME and the $EXTENSION.
sub define_files_variable ($\@$$)
{
  my ($var, $basename, $extension, $where) = @_;
  define_variable ($var,
		   join (' ', map { "$_.$extension" } @$basename),
		   $where);
}


# Like define_variable, but define a variable to be the configure
# substitution by the same name.
sub define_configure_variable
{
  my ($var) = @_;
  # Some variables we do not want to output.  For instance it
  # would be a bad idea to output `U = @U@` when `@U@` can be
  # substituted as `\`.
  my $pretty = exists $ignored_configure_vars{$var} ? VAR_SILENT : VAR_ASIS;
  Automake::Variable::define ($var, VAR_CONFIGURE, '', TRUE, subst ($var),
			      '', $configure_vars{$var}, $pretty);
}


# define_compiler_variable ($LANG)
# --------------------------------
# Define a compiler variable.  We also handle defining the 'LT'
# version of the command when using libtool.
sub define_compiler_variable
{
    my ($lang) = @_;

    my ($var, $value) = ($lang->compiler, $lang->compile);
    my $libtool_tag = '';
    $libtool_tag = '--tag=' . $lang->libtool_tag . ' '
      if $lang->libtool_tag && exists $libtool_tags{$lang->libtool_tag};
    define_variable ($var, $value, INTERNAL);
    if (var ('LIBTOOL'))
      {
	my $verbose = define_verbose_libtool ();
	define_variable ("LT$var",
                         "\$(LIBTOOL) $verbose $libtool_tag\$(AM_LIBTOOLFLAGS)"
                         . " \$(LIBTOOLFLAGS) --mode=compile $value",
                         INTERNAL);
      }
    define_verbose_tagvar ($lang->ccer || 'GEN');
}


sub define_linker_variable
{
    my ($lang) = @_;

    my $libtool_tag = '';
    $libtool_tag = '--tag=' . $lang->libtool_tag . ' '
      if $lang->libtool_tag && exists $libtool_tags{$lang->libtool_tag};
    # CCLD = $(CC).
    define_variable ($lang->lder, $lang->ld, INTERNAL);
    # CCLINK = $(CCLD) blah blah...
    my $link = '';
    if (var ('LIBTOOL'))
      {
	my $verbose = define_verbose_libtool ();
	$link = "\$(LIBTOOL) $verbose $libtool_tag\$(AM_LIBTOOLFLAGS) "
		. "\$(LIBTOOLFLAGS) --mode=link ";
      }
    define_variable ($lang->linker, $link . $lang->link, INTERNAL);
    define_variable ($lang->compiler, $lang, INTERNAL);
    define_verbose_tagvar ($lang->lder || 'GEN');
}

sub define_per_target_linker_variable
{
  my ($linker, $target) = @_;

  # If the user wrote a custom link command, we don't define ours.
  return "${target}_LINK"
    if set_seen "${target}_LINK";

  my $xlink = $linker ? $linker : 'LINK';

  my $lang = $link_languages{$xlink};
  prog_error "Unknown language for linker variable '$xlink'"
    unless $lang;

  my $link_command = $lang->link;
  if (var 'LIBTOOL')
    {
      my $libtool_tag = '';
      $libtool_tag = '--tag=' . $lang->libtool_tag . ' '
	if $lang->libtool_tag && exists $libtool_tags{$lang->libtool_tag};

      my $verbose = define_verbose_libtool ();
      $link_command =
	"\$(LIBTOOL) $verbose $libtool_tag\$(AM_LIBTOOLFLAGS) \$(LIBTOOLFLAGS) "
	. "--mode=link " . $link_command;
    }

  # Rewrite each occurrence of 'AM_$flag' in the link
  # command into '${derived}_$flag' if it exists.
  my $orig_command = $link_command;
  my @flags = (@{$lang->flags}, 'LDFLAGS');
  push @flags, 'LIBTOOLFLAGS' if var 'LIBTOOL';
  for my $flag (@flags)
    {
      my $val = "${target}_$flag";
      $link_command =~ s/\(AM_$flag\)/\($val\)/
	if set_seen ($val);
    }

  # If the computed command is the same as the generic command, use
  # the command linker variable.
  return ($lang->linker, $lang->lder)
    if $link_command eq $orig_command;

  define_variable ("${target}_LINK", $link_command, INTERNAL);
  return ("${target}_LINK", $lang->lder);
}

################################################################

# check_trailing_slash ($WHERE, $LINE)
# ------------------------------------
# Return 1 iff $LINE ends with a slash.
# Might modify $LINE.
sub check_trailing_slash ($\$)
{
  my ($where, $line) = @_;

  # Ignore '##' lines.
  return 0 if $$line =~ /$IGNORE_PATTERN/o;

  # Catch and fix a common error.
  msg "syntax", $where, "whitespace following trailing backslash"
    if $$line =~ s/\\\s+\n$/\\\n/;

  return $$line =~ /\\$/;
}


# read_am_file ($AMFILE, $WHERE, $RELDIR)
# ---------------------------------------
# Read Makefile.am and set up %contents.  Simultaneously copy lines
# from Makefile.am into $output_trailer, or define variables as
# appropriate.  NOTE we put rules in the trailer section.  We want
# user rules to come after our generated stuff.
sub read_am_file
{
    my ($amfile, $where, $reldir) = @_;
    my $canon_reldir = &canonicalize ($reldir);

    my $am_file = new Automake::XFile ("< $amfile");
    verb "reading $amfile";

    # Keep track of the youngest output dependency.
    my $mtime = mtime $amfile;
    $output_deps_greatest_timestamp = $mtime
      if $mtime > $output_deps_greatest_timestamp;

    my $spacing = '';
    my $comment = '';
    my $blank = 0;
    my $saw_bk = 0;
    my $var_look = VAR_ASIS;

    use constant IN_VAR_DEF => 0;
    use constant IN_RULE_DEF => 1;
    use constant IN_COMMENT => 2;
    my $prev_state = IN_RULE_DEF;

    while ($_ = $am_file->getline)
    {
	$where->set ("$amfile:$.");
	if (/$IGNORE_PATTERN/o)
	{
	    # Merely delete comments beginning with two hashes.
	}
	elsif (/$WHITE_PATTERN/o)
	{
	    error $where, "blank line following trailing backslash"
	      if $saw_bk;
	    # Stick a single white line before the incoming macro or rule.
	    $spacing = "\n";
	    $blank = 1;
	    # Flush all comments seen so far.
	    if ($comment ne '')
	    {
		$output_vars .= $comment;
		$comment = '';
	    }
	}
	elsif (/$COMMENT_PATTERN/o)
	{
	    # Stick comments before the incoming macro or rule.  Make
	    # sure a blank line precedes the first block of comments.
	    $spacing = "\n" unless $blank;
	    $blank = 1;
	    $comment .= $spacing . $_;
	    $spacing = '';
	    $prev_state = IN_COMMENT;
	}
	else
	{
	    last;
	}
	$saw_bk = check_trailing_slash ($where, $_);
    }

    # We save the conditional stack on entry, and then check to make
    # sure it is the same on exit.  This lets us conditionally include
    # other files.
    my @saved_cond_stack = @cond_stack;
    my $cond = new Automake::Condition (@cond_stack);

    my $last_var_name = '';
    my $last_var_type = '';
    my $last_var_value = '';
    my $last_where;
    # FIXME: shouldn't use $_ in this loop; it is too big.
    while ($_)
    {
	$where->set ("$amfile:$.");

	# Make sure the line is \n-terminated.
	chomp;
	$_ .= "\n";

	# Don't look at MAINTAINER_MODE_TRUE here.  That shouldn't be
	# used by users.  @MAINT@ is an anachronism now.
	$_ =~ s/\@MAINT\@//g
	    unless $seen_maint_mode;

	my $new_saw_bk = check_trailing_slash ($where, $_);

	if ($reldir eq '.')
	  {
	    # If present, eat the following '_' or '/', converting
	    # "%reldir%/foo" and "%canon_reldir%_foo" into plain "foo"
	    # when $reldir is '.'.
	    $_ =~ s,%(D|reldir)%/,,g;
	    $_ =~ s,%(C|canon_reldir)%_,,g;
	  }
	$_ =~ s/%(D|reldir)%/${reldir}/g;
	$_ =~ s/%(C|canon_reldir)%/${canon_reldir}/g;

	if (/$IGNORE_PATTERN/o)
	{
	    # Merely delete comments beginning with two hashes.

	    # Keep any backslash from the previous line.
	    $new_saw_bk = $saw_bk;
	}
	elsif (/$WHITE_PATTERN/o)
	{
	    # Stick a single white line before the incoming macro or rule.
	    $spacing = "\n";
	    error $where, "blank line following trailing backslash"
	      if $saw_bk;
	}
	elsif (/$COMMENT_PATTERN/o)
	{
	    error $where, "comment following trailing backslash"
	      if $saw_bk && $prev_state != IN_COMMENT;

	    # Stick comments before the incoming macro or rule.
	    $comment .= $spacing . $_;
	    $spacing = '';
	    $prev_state = IN_COMMENT;
	}
	elsif ($saw_bk)
	{
	    if ($prev_state == IN_RULE_DEF)
	    {
	      my $cond = new Automake::Condition @cond_stack;
	      $output_trailer .= $cond->subst_string;
	      $output_trailer .= $_;
	    }
	    elsif ($prev_state == IN_COMMENT)
	    {
		# If the line doesn't start with a '#', add it.
		# We do this because a continued comment like
		#   # A = foo \
		#         bar \
		#         baz
		# is not portable.  BSD make doesn't honor
		# escaped newlines in comments.
		s/^#?/#/;
		$comment .= $spacing . $_;
	    }
	    else # $prev_state == IN_VAR_DEF
	    {
	      $last_var_value .= ' '
		unless $last_var_value =~ /\s$/;
	      $last_var_value .= $_;

	      if (!/\\$/)
		{
		  Automake::Variable::define ($last_var_name, VAR_MAKEFILE,
					      $last_var_type, $cond,
					      $last_var_value, $comment,
					      $last_where, VAR_ASIS)
		    if $cond != FALSE;
		  $comment = $spacing = '';
		}
	    }
	}

	elsif (/$IF_PATTERN/o)
	  {
	    $cond = cond_stack_if ($1, $2, $where);
	  }
	elsif (/$ELSE_PATTERN/o)
	  {
	    $cond = cond_stack_else ($1, $2, $where);
	  }
	elsif (/$ENDIF_PATTERN/o)
	  {
	    $cond = cond_stack_endif ($1, $2, $where);
	  }

	elsif (/$RULE_PATTERN/o)
	{
	    # Found a rule.
	    $prev_state = IN_RULE_DEF;

	    # For now we have to output all definitions of user rules
	    # and can't diagnose duplicates (see the comment in
	    # Automake::Rule::define). So we go on and ignore the return value.
	    Automake::Rule::define ($1, $amfile, RULE_USER, $cond, $where);

	    check_variable_expansions ($_, $where);

	    $output_trailer .= $comment . $spacing;
	    my $cond = new Automake::Condition @cond_stack;
	    $output_trailer .= $cond->subst_string;
	    $output_trailer .= $_;
	    $comment = $spacing = '';
	}
	elsif (/$ASSIGNMENT_PATTERN/o)
	{
	    # Found a macro definition.
	    $prev_state = IN_VAR_DEF;
	    $last_var_name = $1;
	    $last_var_type = $2;
	    $last_var_value = $3;
	    $last_where = $where->clone;
	    if ($3 ne '' && substr ($3, -1) eq "\\")
	      {
		# We preserve the '\' because otherwise the long lines
		# that are generated will be truncated by broken
		# 'sed's.
		$last_var_value = $3 . "\n";
	      }
	    # Normally we try to output variable definitions in the
	    # same format they were input.  However, POSIX compliant
	    # systems are not required to support lines longer than
	    # 2048 bytes (most notably, some sed implementation are
	    # limited to 4000 bytes, and sed is used by config.status
	    # to rewrite Makefile.in into Makefile).  Moreover nobody
	    # would really write such long lines by hand since it is
	    # hardly maintainable.  So if a line is longer that 1000
	    # bytes (an arbitrary limit), assume it has been
	    # automatically generated by some tools, and flatten the
	    # variable definition.  Otherwise, keep the variable as it
	    # as been input.
	    $var_look = VAR_PRETTY if length ($last_var_value) >= 1000;

	    if (!/\\$/)
	      {
		Automake::Variable::define ($last_var_name, VAR_MAKEFILE,
					    $last_var_type, $cond,
					    $last_var_value, $comment,
					    $last_where, $var_look)
		  if $cond != FALSE;
		$comment = $spacing = '';
		$var_look = VAR_ASIS;
	      }
	}
	elsif (/$INCLUDE_PATTERN/o)
	{
	    my $path = $1;

	    if ($path =~ s/^\$\(top_srcdir\)\///)
	      {
		push (@include_stack, "\$\(top_srcdir\)/$path");
		# Distribute any included file.

		# Always use the $(top_srcdir) prefix in DIST_COMMON,
		# otherwise OSF make will implicitly copy the included
		# file in the build tree during "make distdir" to satisfy
		# the dependency.
		# (subdir-am-cond.sh and subdir-ac-cond.sh will fail)
		push_dist_common ("\$\(top_srcdir\)/$path");
	      }
	    else
	      {
		$path =~ s/\$\(srcdir\)\///;
		push (@include_stack, "\$\(srcdir\)/$path");
		# Always use the $(srcdir) prefix in DIST_COMMON,
		# otherwise OSF make will implicitly copy the included
		# file in the build tree during "make distdir" to satisfy
		# the dependency.
		# (subdir-am-cond.sh and subdir-ac-cond.sh will fail)
		push_dist_common ("\$\(srcdir\)/$path");
		$path = $relative_dir . "/" . $path if $relative_dir ne '.';
	      }
	    my $new_reldir = File::Spec->abs2rel ($path, $relative_dir);
	    $new_reldir = '.' if $new_reldir !~ s,/[^/]*$,,;
	    $where->push_context ("'$path' included from here");
	    read_am_file ($path, $where, $new_reldir);
	    $where->pop_context;
	}
	else
	{
	    # This isn't an error; it is probably a continued rule.
	    # In fact, this is what we assume.
	    $prev_state = IN_RULE_DEF;
	    check_variable_expansions ($_, $where);
	    $output_trailer .= $comment . $spacing;
	    my $cond = new Automake::Condition @cond_stack;
	    $output_trailer .= $cond->subst_string;
	    $output_trailer .= $_;
	    $comment = $spacing = '';
	    error $where, "'#' comment at start of rule is unportable"
	      if $_ =~ /^\t\s*\#/;
	}

	$saw_bk = $new_saw_bk;
	$_ = $am_file->getline;
    }

    $output_trailer .= $comment;

    error ($where, "trailing backslash on last line")
      if $saw_bk;

    error ($where, (@cond_stack ? "unterminated conditionals: @cond_stack"
		    : "too many conditionals closed in include file"))
      if "@saved_cond_stack" ne "@cond_stack";
}


# A helper for read_main_am_file which initializes configure variables
# and variables from header-vars.am.
sub define_standard_variables ()
{
  my $saved_output_vars = $output_vars;
  my ($comments, undef, $rules) =
    file_contents_internal (1, "$libdir/am/header-vars.am",
			    new Automake::Location);

  foreach my $var (sort keys %configure_vars)
    {
      define_configure_variable ($var);
    }

  $output_vars .= $comments . $rules;
}


# read_main_am_file ($MAKEFILE_AM, $MAKEFILE_IN)
# ----------------------------------------------
sub read_main_am_file
{
    my ($amfile, $infile) = @_;

    # This supports the strange variable tricks we are about to play.
    prog_error ("variable defined before read_main_am_file\n" . variables_dump ())
      if (scalar (variables) > 0);

    # Generate copyright header for generated Makefile.in.
    # We do discard the output of predefined variables, handled below.
    $output_vars = ("# " . basename ($infile) . " generated by automake "
		   . $VERSION . " from " . basename ($amfile) . ".\n");
    $output_vars .= '# ' . subst ('configure_input') . "\n";
    $output_vars .= $gen_copyright;

    # We want to predefine as many variables as possible.  This lets
    # the user set them with '+=' in Makefile.am.
    define_standard_variables;

    # Read user file, which might override some of our values.
    read_am_file ($amfile, new Automake::Location, '.');
}



################################################################

# $STRING
# flatten ($ORIGINAL_STRING)
# --------------------------
sub flatten
{
  $_ = shift;

  s/\\\n//somg;
  s/\s+/ /g;
  s/^ //;
  s/ $//;

  return $_;
}


# transform_token ($TOKEN, \%PAIRS, $KEY)
# ---------------------------------------
# Return the value associated to $KEY in %PAIRS, as used on $TOKEN
# (which should be ?KEY? or any of the special %% requests)..
sub transform_token ($\%$)
{
  my ($token, $transform, $key) = @_;
  my $res = $transform->{$key};
  prog_error "Unknown key '$key' in '$token'" unless defined $res;
  return $res;
}


# transform ($TOKEN, \%PAIRS)
# ---------------------------
# If ($TOKEN, $VAL) is in %PAIRS:
#   - replaces %KEY% with $VAL,
#   - enables/disables ?KEY? and ?!KEY?,
#   - replaces %?KEY% with TRUE or FALSE.
sub transform ($\%)
{
  my ($token, $transform) = @_;

  # %KEY%.
  # Must be before the following pattern to exclude the case
  # when there is neither IFTRUE nor IFFALSE.
  if ($token =~ /^%([\w\-]+)%$/)
    {
      return transform_token ($token, %$transform, $1);
    }
  # %?KEY%.
  elsif ($token =~ /^%\?([\w\-]+)%$/)
    {
      return transform_token ($token, %$transform, $1) ? 'TRUE' : 'FALSE';
    }
  # ?KEY? and ?!KEY?.
  elsif ($token =~ /^ \? (!?) ([\w\-]+) \? $/x)
    {
      my $neg = ($1 eq '!') ? 1 : 0;
      my $val = transform_token ($token, %$transform, $2);
      return (!!$val == $neg) ? '##%' : '';
    }
  else
    {
      prog_error "Unknown request format: $token";
    }
}

# $TEXT
# preprocess_file ($MAKEFILE, [%TRANSFORM])
# -----------------------------------------
# Load a $MAKEFILE, apply the %TRANSFORM, and return the result.
# No extra parsing or post-processing is done (i.e., recognition of
# rules declaration or of make variables definitions).
sub preprocess_file
{
  my ($file, %transform) = @_;

  # Complete %transform with global options.
  # Note that %transform goes last, so it overrides global options.
  %transform = ( 'MAINTAINER-MODE'
		 => $seen_maint_mode ? subst ('MAINTAINER_MODE_TRUE') : '',

		 'XZ'          => !! option 'dist-xz',
		 'LZIP'        => !! option 'dist-lzip',
		 'BZIP2'       => !! option 'dist-bzip2',
		 'COMPRESS'    => !! option 'dist-tarZ',
		 'GZIP'        =>  ! option 'no-dist-gzip',
		 'SHAR'        => !! option 'dist-shar',
		 'ZIP'         => !! option 'dist-zip',

		 'INSTALL-INFO' =>  ! option 'no-installinfo',
		 'INSTALL-MAN'  =>  ! option 'no-installman',
		 'CK-NEWS'      => !! option 'check-news',

		 'SUBDIRS'      => !! var ('SUBDIRS'),
		 'TOPDIR_P'     => $relative_dir eq '.',

		 'BUILD'    => ($seen_canonical >= AC_CANONICAL_BUILD),
		 'HOST'     => ($seen_canonical >= AC_CANONICAL_HOST),
		 'TARGET'   => ($seen_canonical >= AC_CANONICAL_TARGET),

		 'LIBTOOL'      => !! var ('LIBTOOL'),
		 'NONLIBTOOL'   => 1,
		%transform);

  if (! defined ($_ = $am_file_cache{$file}))
    {
      verb "reading $file";
      # Swallow the whole file.
      my $fc_file = new Automake::XFile "< $file";
      my $saved_dollar_slash = $/;
      undef $/;
      $_ = $fc_file->getline;
      $/ = $saved_dollar_slash;
      $fc_file->close;
      # Remove ##-comments.
      # Besides we don't need more than two consecutive new-lines.
      s/(?:$IGNORE_PATTERN|(?<=\n\n)\n+)//gom;
      # Remember the contents of the just-read file.
      $am_file_cache{$file} = $_;
    }

  # Substitute Automake template tokens.
  s/(?: % \?? [\w\-]+ %
      | \? !? [\w\-]+ \?
    )/transform($&, %transform)/gex;
  # transform() may have added some ##%-comments to strip.
  # (we use '##%' instead of '##' so we can distinguish ##%##%##% from
  # ####### and do not remove the latter.)
  s/^[ \t]*(?:##%)+.*\n//gm;

  return $_;
}


# @PARAGRAPHS
# make_paragraphs ($MAKEFILE, [%TRANSFORM])
# -----------------------------------------
# Load a $MAKEFILE, apply the %TRANSFORM, and return it as a list of
# paragraphs.
sub make_paragraphs
{
  my ($file, %transform) = @_;
  $transform{FIRST} = !$transformed_files{$file};
  $transformed_files{$file} = 1;

  my @lines = split /(?<!\\)\n/, preprocess_file ($file, %transform);
  my @res;

  while (defined ($_ = shift @lines))
    {
      my $paragraph = $_;
      # If we are a rule, eat as long as we start with a tab.
      if (/$RULE_PATTERN/smo)
	{
	  while (defined ($_ = shift @lines) && $_ =~ /^\t/)
	    {
	      $paragraph .= "\n$_";
	    }
	  unshift (@lines, $_);
	}

      # If we are a comments, eat as much comments as you can.
      elsif (/$COMMENT_PATTERN/smo)
	{
	  while (defined ($_ = shift @lines)
		 && $_ =~ /$COMMENT_PATTERN/smo)
	    {
	      $paragraph .= "\n$_";
	    }
	  unshift (@lines, $_);
	}

      push @res, $paragraph;
    }

  return @res;
}



# ($COMMENT, $VARIABLES, $RULES)
# file_contents_internal ($IS_AM, $FILE, $WHERE, [%TRANSFORM])
# ------------------------------------------------------------
# Return contents of a file from $libdir/am, automatically skipping
# macros or rules which are already known. $IS_AM iff the caller is
# reading an Automake file (as opposed to the user's Makefile.am).
sub file_contents_internal
{
    my ($is_am, $file, $where, %transform) = @_;

    $where->set ($file);

    my $result_vars = '';
    my $result_rules = '';
    my $comment = '';
    my $spacing = '';

    # The following flags are used to track rules spanning across
    # multiple paragraphs.
    my $is_rule = 0;		# 1 if we are processing a rule.
    my $discard_rule = 0;	# 1 if the current rule should not be output.

    # We save the conditional stack on entry, and then check to make
    # sure it is the same on exit.  This lets us conditionally include
    # other files.
    my @saved_cond_stack = @cond_stack;
    my $cond = new Automake::Condition (@cond_stack);

    foreach (make_paragraphs ($file, %transform))
    {
	# FIXME: no line number available.
	$where->set ($file);

	# Sanity checks.
	error $where, "blank line following trailing backslash:\n$_"
	  if /\\$/;
	error $where, "comment following trailing backslash:\n$_"
	  if /\\#/;

	if (/^$/)
	{
	    $is_rule = 0;
	    # Stick empty line before the incoming macro or rule.
	    $spacing = "\n";
	}
	elsif (/$COMMENT_PATTERN/mso)
	{
	    $is_rule = 0;
	    # Stick comments before the incoming macro or rule.
	    $comment = "$_\n";
	}

	# Handle inclusion of other files.
	elsif (/$INCLUDE_PATTERN/o)
	{
	    if ($cond != FALSE)
	      {
		my $file = ($is_am ? "$libdir/am/" : '') . $1;
		$where->push_context ("'$file' included from here");
		# N-ary '.=' fails.
		my ($com, $vars, $rules)
		  = file_contents_internal ($is_am, $file, $where, %transform);
		$where->pop_context;
		$comment .= $com;
		$result_vars .= $vars;
		$result_rules .= $rules;
	      }
	}

	# Handling the conditionals.
	elsif (/$IF_PATTERN/o)
	  {
	    $cond = cond_stack_if ($1, $2, $file);
	  }
	elsif (/$ELSE_PATTERN/o)
	  {
	    $cond = cond_stack_else ($1, $2, $file);
	  }
	elsif (/$ENDIF_PATTERN/o)
	  {
	    $cond = cond_stack_endif ($1, $2, $file);
	  }

	# Handling rules.
	elsif (/$RULE_PATTERN/mso)
	{
	  $is_rule = 1;
	  $discard_rule = 0;
	  # Separate relationship from optional actions: the first
	  # `new-line tab" not preceded by backslash (continuation
	  # line).
	  my $paragraph = $_;
	  /^(.*?)(?:(?<!\\)\n(\t.*))?$/s;
	  my ($relationship, $actions) = ($1, $2 || '');

	  # Separate targets from dependencies: the first colon.
	  $relationship =~ /^([^:]+\S+) *: *(.*)$/som;
	  my ($targets, $dependencies) = ($1, $2);
	  # Remove the escaped new lines.
	  # I don't know why, but I have to use a tmp $flat_deps.
	  my $flat_deps = flatten ($dependencies);
	  my @deps = split (' ', $flat_deps);

	  foreach (split (' ', $targets))
	    {
	      # FIXME: 1. We are not robust to people defining several targets
	      # at once, only some of them being in %dependencies.  The
	      # actions from the targets in %dependencies are usually generated
	      # from the content of %actions, but if some targets in $targets
	      # are not in %dependencies the ELSE branch will output
	      # a rule for all $targets (i.e. the targets which are both
	      # in %dependencies and $targets will have two rules).

	      # FIXME: 2. The logic here is not able to output a
	      # multi-paragraph rule several time (e.g. for each condition
	      # it is defined for) because it only knows the first paragraph.

	      # FIXME: 3. We are not robust to people defining a subset
	      # of a previously defined "multiple-target" rule.  E.g.
	      # 'foo:' after 'foo bar:'.

	      # Output only if not in FALSE.
	      if (defined $dependencies{$_} && $cond != FALSE)
		{
		  depend ($_, @deps);
		  register_action ($_, $actions);
		}
	      else
		{
		  # Free-lance dependency.  Output the rule for all the
		  # targets instead of one by one.
		  my @undefined_conds =
		    Automake::Rule::define ($targets, $file,
					    $is_am ? RULE_AUTOMAKE : RULE_USER,
					    $cond, $where);
		  for my $undefined_cond (@undefined_conds)
		    {
		      my $condparagraph = $paragraph;
		      $condparagraph =~ s/^/$undefined_cond->subst_string/gme;
		      $result_rules .= "$spacing$comment$condparagraph\n";
		    }
		  if (scalar @undefined_conds == 0)
		    {
		      # Remember to discard next paragraphs
		      # if they belong to this rule.
		      # (but see also FIXME: #2 above.)
		      $discard_rule = 1;
		    }
		  $comment = $spacing = '';
		  last;
		}
	    }
	}

	elsif (/$ASSIGNMENT_PATTERN/mso)
	{
	    my ($var, $type, $val) = ($1, $2, $3);
	    error $where, "variable '$var' with trailing backslash"
	      if /\\$/;

	    $is_rule = 0;

	    Automake::Variable::define ($var,
					$is_am ? VAR_AUTOMAKE : VAR_MAKEFILE,
					$type, $cond, $val, $comment, $where,
					VAR_ASIS)
	      if $cond != FALSE;

	    $comment = $spacing = '';
	}
	else
	{
	    # This isn't an error; it is probably some tokens which
	    # configure is supposed to replace, such as '@SET-MAKE@',
	    # or some part of a rule cut by an if/endif.
	    if (! $cond->false && ! ($is_rule && $discard_rule))
	      {
		s/^/$cond->subst_string/gme;
		$result_rules .= "$spacing$comment$_\n";
	      }
	    $comment = $spacing = '';
	}
    }

    error ($where, @cond_stack ?
	   "unterminated conditionals: @cond_stack" :
	   "too many conditionals closed in include file")
      if "@saved_cond_stack" ne "@cond_stack";

    return ($comment, $result_vars, $result_rules);
}


# $CONTENTS
# file_contents ($BASENAME, $WHERE, [%TRANSFORM])
# -----------------------------------------------
# Return contents of a file from $libdir/am, automatically skipping
# macros or rules which are already known.
sub file_contents
{
    my ($basename, $where, %transform) = @_;
    my ($comments, $variables, $rules) =
      file_contents_internal (1, "$libdir/am/$basename.am", $where,
			      %transform);
    return "$comments$variables$rules";
}


# @PREFIX
# am_primary_prefixes ($PRIMARY, $CAN_DIST, @PREFIXES)
# ----------------------------------------------------
# Find all variable prefixes that are used for install directories.  A
# prefix 'zar' qualifies iff:
#
# * 'zardir' is a variable.
# * 'zar_PRIMARY' is a variable.
#
# As a side effect, it looks for misspellings.  It is an error to have
# a variable ending in a "reserved" suffix whose prefix is unknown, e.g.
# "bni_PROGRAMS".  However, unusual prefixes are allowed if a variable
# of the same name (with "dir" appended) exists.  For instance, if the
# variable "zardir" is defined, then "zar_PROGRAMS" becomes valid.
# This is to provide a little extra flexibility in those cases which
# need it.
sub am_primary_prefixes
{
  my ($primary, $can_dist, @prefixes) = @_;

  local $_;
  my %valid = map { $_ => 0 } @prefixes;
  $valid{'EXTRA'} = 0;
  foreach my $var (variables $primary)
    {
      # Automake is allowed to define variables that look like primaries
      # but which aren't.  E.g. INSTALL_sh_DATA.
      # Autoconf can also define variables like INSTALL_DATA, so
      # ignore all configure variables (at least those which are not
      # redefined in Makefile.am).
      # FIXME: We should make sure that these variables are not
      # conditionally defined (or else adjust the condition below).
      my $def = $var->def (TRUE);
      next if $def && $def->owner != VAR_MAKEFILE;

      my $varname = $var->name;

      if ($varname =~ /^(nobase_)?(dist_|nodist_)?(.*)_[[:alnum:]]+$/)
	{
	  my ($base, $dist, $X) = ($1 || '', $2 || '', $3 || '');
	  if ($dist ne '' && ! $can_dist)
	    {
	      err_var ($var,
		       "invalid variable '$varname': 'dist' is forbidden");
	    }
	  # Standard directories must be explicitly allowed.
	  elsif (! defined $valid{$X} && exists $standard_prefix{$X})
	    {
	      err_var ($var,
		       "'${X}dir' is not a legitimate directory " .
		       "for '$primary'");
	    }
	  # A not explicitly valid directory is allowed if Xdir is defined.
	  elsif (! defined $valid{$X} &&
		 $var->requires_variables ("'$varname' is used", "${X}dir"))
	    {
	      # Nothing to do.  Any error message has been output
	      # by $var->requires_variables.
	    }
	  else
	    {
	      # Ensure all extended prefixes are actually used.
	      $valid{"$base$dist$X"} = 1;
	    }
	}
      else
	{
	  prog_error "unexpected variable name: $varname";
	}
    }

  # Return only those which are actually defined.
  return sort grep { var ($_ . '_' . $primary) } keys %valid;
}


# am_install_var (-OPTION..., file, HOW, where...)
# ------------------------------------------------
#
# Handle 'where_HOW' variable magic.  Does all lookups, generates
# install code, and possibly generates code to define the primary
# variable.  The first argument is the name of the .am file to munge,
# the second argument is the primary variable (e.g. HEADERS), and all
# subsequent arguments are possible installation locations.
#
# Returns list of [$location, $value] pairs, where
# $value's are the values in all where_HOW variable, and $location
# there associated location (the place here their parent variables were
# defined).
#
# FIXME: this should be rewritten to be cleaner.  It should be broken
# up into multiple functions.
#
sub am_install_var
{
  my (@args) = @_;

  my $do_require = 1;
  my $can_dist = 0;
  my $default_dist = 0;
  while (@args)
    {
      if ($args[0] eq '-noextra')
	{
	  $do_require = 0;
	}
      elsif ($args[0] eq '-candist')
	{
	  $can_dist = 1;
	}
      elsif ($args[0] eq '-defaultdist')
	{
	  $default_dist = 1;
	  $can_dist = 1;
	}
      elsif ($args[0] !~ /^-/)
	{
	  last;
	}
      shift (@args);
    }

  my ($file, $primary, @prefix) = @args;

  # Now that configure substitutions are allowed in where_HOW
  # variables, it is an error to actually define the primary.  We
  # allow 'JAVA', as it is customarily used to mean the Java
  # interpreter.  This is but one of several Java hacks.  Similarly,
  # 'PYTHON' is customarily used to mean the Python interpreter.
  reject_var $primary, "'$primary' is an anachronism"
    unless $primary eq 'JAVA' || $primary eq 'PYTHON';

  # Get the prefixes which are valid and actually used.
  @prefix = am_primary_prefixes ($primary, $can_dist, @prefix);

  # If a primary includes a configure substitution, then the EXTRA_
  # form is required.  Otherwise we can't properly do our job.
  my $require_extra;

  my @used = ();
  my @result = ();

  foreach my $X (@prefix)
    {
      my $nodir_name = $X;
      my $one_name = $X . '_' . $primary;
      my $one_var = var $one_name;

      my $strip_subdir = 1;
      # If subdir prefix should be preserved, do so.
      if ($nodir_name =~ /^nobase_/)
	{
	  $strip_subdir = 0;
	  $nodir_name =~ s/^nobase_//;
	}

      # If files should be distributed, do so.
      my $dist_p = 0;
      if ($can_dist)
	{
	  $dist_p = (($default_dist && $nodir_name !~ /^nodist_/)
		     || (! $default_dist && $nodir_name =~ /^dist_/));
	  $nodir_name =~ s/^(dist|nodist)_//;
	}


      # Use the location of the currently processed variable.
      # We are not processing a particular condition, so pick the first
      # available.
      my $tmpcond = $one_var->conditions->one_cond;
      my $where = $one_var->rdef ($tmpcond)->location->clone;

      # Append actual contents of where_PRIMARY variable to
      # @result, skipping @substitutions@.
      foreach my $locvals ($one_var->value_as_list_recursive (location => 1))
	{
	  my ($loc, $value) = @$locvals;
	  # Skip configure substitutions.
	  if ($value =~ /^\@.*\@$/)
	    {
	      if ($nodir_name eq 'EXTRA')
		{
		  error ($where,
			 "'$one_name' contains configure substitution, "
			 . "but shouldn't");
		}
	      # Check here to make sure variables defined in
	      # configure.ac do not imply that EXTRA_PRIMARY
	      # must be defined.
	      elsif (! defined $configure_vars{$one_name})
		{
		  $require_extra = $one_name
		    if $do_require;
		}
	    }
	  else
	    {
	      # Strip any $(EXEEXT) suffix the user might have added,
              # or this will confuse handle_source_transform() and
              # check_canonical_spelling().
	      # We'll add $(EXEEXT) back later anyway.
	      # Do it here rather than in handle_programs so the
              # uniquifying at the end of this function works.
	      ${$locvals}[1] =~ s/\$\(EXEEXT\)$//
	        if $primary eq 'PROGRAMS';

	      push (@result, $locvals);
	    }
	}
      # A blatant hack: we rewrite each _PROGRAMS primary to include
      # EXEEXT.
      append_exeext { 1 } $one_name
	if $primary eq 'PROGRAMS';
      # "EXTRA" shouldn't be used when generating clean targets,
      # all, or install targets.  We used to warn if EXTRA_FOO was
      # defined uselessly, but this was annoying.
      next
	if $nodir_name eq 'EXTRA';

      if ($nodir_name eq 'check')
	{
	  push (@check, '$(' . $one_name . ')');
	}
      else
	{
	  push (@used, '$(' . $one_name . ')');
	}

      # Is this to be installed?
      my $install_p = $nodir_name ne 'noinst' && $nodir_name ne 'check';

      # If so, with install-exec? (or install-data?).
      my $exec_p = ($nodir_name =~ /$EXEC_DIR_PATTERN/o);

      my $check_options_p = $install_p && !! option 'std-options';

      # Use the location of the currently processed variable as context.
      $where->push_context ("while processing '$one_name'");

      # The variable containing all files to distribute.
      my $distvar = "\$($one_name)";
      $distvar = shadow_unconditionally ($one_name, $where)
	if ($dist_p && $one_var->has_conditional_contents);

      # Singular form of $PRIMARY.
      (my $one_primary = $primary) =~ s/S$//;
      $output_rules .= file_contents ($file, $where,
                                      PRIMARY     => $primary,
                                      ONE_PRIMARY => $one_primary,
                                      DIR         => $X,
                                      NDIR        => $nodir_name,
                                      BASE        => $strip_subdir,
                                      EXEC        => $exec_p,
                                      INSTALL     => $install_p,
                                      DIST        => $dist_p,
                                      DISTVAR     => $distvar,
                                      'CK-OPTS'   => $check_options_p);
    }

  # The JAVA variable is used as the name of the Java interpreter.
  # The PYTHON variable is used as the name of the Python interpreter.
  if (@used && $primary ne 'JAVA' && $primary ne 'PYTHON')
    {
      # Define it.
      define_pretty_variable ($primary, TRUE, INTERNAL, @used);
      $output_vars .= "\n";
    }

  err_var ($require_extra,
	   "'$require_extra' contains configure substitution,\n"
	   . "but 'EXTRA_$primary' not defined")
    if ($require_extra && ! var ('EXTRA_' . $primary));

  # Push here because PRIMARY might be configure time determined.
  push (@all, '$(' . $primary . ')')
    if @used && $primary ne 'JAVA' && $primary ne 'PYTHON';

  # Make the result unique.  This lets the user use conditionals in
  # a natural way, but still lets us program lazily -- we don't have
  # to worry about handling a particular object more than once.
  # We will keep only one location per object.
  my %result = ();
  for my $pair (@result)
    {
      my ($loc, $val) = @$pair;
      $result{$val} = $loc;
    }
  my @l = sort keys %result;
  return map { [$result{$_}->clone, $_] } @l;
}


################################################################

# Each key in this hash is the name of a directory holding a
# Makefile.in.  These variables are local to 'is_make_dir'.
my %make_dirs = ();
my $make_dirs_set = 0;

# is_make_dir ($DIRECTORY)
# ------------------------
sub is_make_dir
{
    my ($dir) = @_;
    if (! $make_dirs_set)
    {
	foreach my $iter (@configure_input_files)
	{
	    $make_dirs{dirname ($iter)} = 1;
	}
	# We also want to notice Makefile.in's.
	foreach my $iter (@other_input_files)
	{
	    if ($iter =~ /Makefile\.in$/)
	    {
		$make_dirs{dirname ($iter)} = 1;
	    }
	}
	$make_dirs_set = 1;
    }
    return defined $make_dirs{$dir};
}

################################################################

# Find the aux dir.  This should match the algorithm used by
# ./configure. (See the Autoconf documentation for for
# AC_CONFIG_AUX_DIR.)
sub locate_aux_dir ()
{
  if (! $config_aux_dir_set_in_configure_ac)
    {
      # The default auxiliary directory is the first
      # of ., .., or ../.. that contains install-sh.
      # Assume . if install-sh doesn't exist yet.
      for my $dir (qw (. .. ../..))
	{
	  if (-f "$dir/install-sh")
	    {
	      $config_aux_dir = $dir;
	      last;
	    }
	}
      $config_aux_dir = '.' unless $config_aux_dir;
    }
  # Avoid unsightly '/.'s.
  $am_config_aux_dir =
    '$(top_srcdir)' . ($config_aux_dir eq '.' ? "" : "/$config_aux_dir");
  $am_config_aux_dir =~ s,/*$,,;
}


# push_required_file ($DIR, $FILE, $FULLFILE)
# -------------------------------------------
# Push the given file onto DIST_COMMON.
sub push_required_file
{
  my ($dir, $file, $fullfile) = @_;

  # If the file to be distributed is in the same directory of the
  # currently processed Makefile.am, then we want to distribute it
  # from this same Makefile.am.
  if ($dir eq $relative_dir)
    {
      push_dist_common ($file);
    }
  # This is needed to allow a construct in a non-top-level Makefile.am
  # to require a file in the build-aux directory (see at least the test
  # script 'test-driver-is-distributed.sh').  This is related to the
  # automake bug#9546.  Note that the use of $config_aux_dir instead
  # of $am_config_aux_dir here is deliberate and necessary.
  elsif ($dir eq $config_aux_dir)
    {
      push_dist_common ("$am_config_aux_dir/$file");
    }
  # FIXME: another spacial case, for AC_LIBOBJ/AC_LIBSOURCE support.
  # We probably need some refactoring of this function and its callers,
  # to have a more explicit and systematic handling of all the special
  # cases; but, since there are only two of them, this is low-priority
  # ATM.
  elsif ($config_libobj_dir && $dir eq $config_libobj_dir)
    {
      # Avoid unsightly '/.'s.
      my $am_config_libobj_dir =
        '$(top_srcdir)' .
        ($config_libobj_dir eq '.' ? "" : "/$config_libobj_dir");
      $am_config_libobj_dir =~ s|/*$||;
      push_dist_common ("$am_config_libobj_dir/$file");
    }
  elsif ($relative_dir eq '.' && ! is_make_dir ($dir))
    {
      # If we are doing the topmost directory, and the file is in a
      # subdir which does not have a Makefile, then we distribute it
      # here.

      # If a required file is above the source tree, it is important
      # to prefix it with '$(srcdir)' so that no VPATH search is
      # performed.  Otherwise problems occur with Make implementations
      # that rewrite and simplify rules whose dependencies are found in a
      # VPATH location.  Here is an example with OSF1/Tru64 Make.
      #
      #   % cat Makefile
      #   VPATH = sub
      #   distdir: ../a
      #	          echo ../a
      #   % ls
      #   Makefile a
      #   % make
      #   echo a
      #   a
      #
      # Dependency '../a' was found in 'sub/../a', but this make
      # implementation simplified it as 'a'.  (Note that the sub/
      # directory does not even exist.)
      #
      # This kind of VPATH rewriting seems hard to cancel.  The
      # distdir.am hack against VPATH rewriting works only when no
      # simplification is done, i.e., for dependencies which are in
      # subdirectories, not in enclosing directories.  Hence, in
      # the latter case we use a full path to make sure no VPATH
      # search occurs.
      $fullfile = '$(srcdir)/' . $fullfile
	if $dir =~ m,^\.\.(?:$|/),;

      push_dist_common ($fullfile);
    }
  else
    {
      prog_error "a Makefile in relative directory $relative_dir " .
                 "can't add files in directory $dir to DIST_COMMON";
    }
}


# If a file name appears as a key in this hash, then it has already
# been checked for.  This allows us not to report the same error more
# than once.
my %required_file_not_found = ();

# required_file_check_or_copy ($WHERE, $DIRECTORY, $FILE)
# -------------------------------------------------------
# Verify that the file must exist in $DIRECTORY, or install it.
sub required_file_check_or_copy
{
  my ($where, $dir, $file) = @_;

  my $fullfile = "$dir/$file";
  my $found_it = 0;
  my $dangling_sym = 0;

  if (-l $fullfile && ! -f $fullfile)
    {
      $dangling_sym = 1;
    }
  elsif (dir_has_case_matching_file ($dir, $file))
    {
      $found_it = 1;
    }

  # '--force-missing' only has an effect if '--add-missing' is
  # specified.
  return
    if $found_it && (! $add_missing || ! $force_missing);

  # If we've already looked for it, we're done.  You might
  # wonder why we don't do this before searching for the
  # file.  If we do that, then something like
  # AC_OUTPUT(subdir/foo foo) will fail to put foo.in into
  # DIST_COMMON.
  if (! $found_it)
    {
      return if defined $required_file_not_found{$fullfile};
      $required_file_not_found{$fullfile} = 1;
    }
  if ($dangling_sym && $add_missing)
    {
      unlink ($fullfile);
    }

  my $trailer = '';
  my $trailer2 = '';
  my $suppress = 0;

  # Only install missing files according to our desired
  # strictness level.
  my $message = "required file '$fullfile' not found";
  if ($add_missing)
    {
      if (-f "$libdir/$file")
        {
          $suppress = 1;

          # Install the missing file.  Symlink if we
          # can, copy if we must.  Note: delete the file
          # first, in case it is a dangling symlink.
          $message = "installing '$fullfile'";

          # The license file should not be volatile.
          if ($file eq "COPYING")
            {
              $message .= " using GNU General Public License v3 file";
              $trailer2 = "\n    Consider adding the COPYING file"
                        . " to the version control system"
                        . "\n    for your code, to avoid questions"
                        . " about which license your project uses";
            }

          # Windows Perl will hang if we try to delete a
          # file that doesn't exist.
          unlink ($fullfile) if -f $fullfile;
          if ($symlink_exists && ! $copy_missing)
            {
              if (! symlink ("$libdir/$file", $fullfile)
                  || ! -e $fullfile)
                {
                  $suppress = 0;
                  $trailer = "; error while making link: $!";
                }
            }
          elsif (system ('cp', "$libdir/$file", $fullfile))
            {
              $suppress = 0;
              $trailer = "\n    error while copying";
            }
          set_dir_cache_file ($dir, $file);
        }
    }
  else
    {
      $trailer = "\n  'automake --add-missing' can install '$file'"
        if -f "$libdir/$file";
    }

  # If --force-missing was specified, and we have
  # actually found the file, then do nothing.
  return
    if $found_it && $force_missing;

  # If we couldn't install the file, but it is a target in
  # the Makefile, don't print anything.  This allows files
  # like README, AUTHORS, or THANKS to be generated.
  return
    if !$suppress && rule $file;

  msg ($suppress ? 'note' : 'error', $where, "$message$trailer$trailer2");
}


# require_file_internal ($WHERE, $MYSTRICT, $DIRECTORY, $QUEUE, @FILES)
# ---------------------------------------------------------------------
# Verify that the file must exist in $DIRECTORY, or install it.
# $MYSTRICT is the strictness level at which this file becomes required.
# Worker threads may queue up the action to be serialized by the master,
# if $QUEUE is true
sub require_file_internal
{
  my ($where, $mystrict, $dir, $queue, @files) = @_;

  return
    unless $strictness >= $mystrict;

  foreach my $file (@files)
    {
      push_required_file ($dir, $file, "$dir/$file");
      if ($queue)
        {
          queue_required_file_check_or_copy ($required_conf_file_queue,
                                             QUEUE_CONF_FILE, $relative_dir,
                                             $where, $mystrict, @files);
        }
      else
        {
          required_file_check_or_copy ($where, $dir, $file);
        }
    }
}

# require_file ($WHERE, $MYSTRICT, @FILES)
# ----------------------------------------
sub require_file
{
    my ($where, $mystrict, @files) = @_;
    require_file_internal ($where, $mystrict, $relative_dir, 0, @files);
}

# require_file_with_macro ($COND, $MACRO, $MYSTRICT, @FILES)
# ----------------------------------------------------------
sub require_file_with_macro
{
    my ($cond, $macro, $mystrict, @files) = @_;
    $macro = rvar ($macro) unless ref $macro;
    require_file ($macro->rdef ($cond)->location, $mystrict, @files);
}

# require_libsource_with_macro ($COND, $MACRO, $MYSTRICT, @FILES)
# ---------------------------------------------------------------
# Require an AC_LIBSOURCEd file.  If AC_CONFIG_LIBOBJ_DIR was called, it
# must be in that directory.  Otherwise expect it in the current directory.
sub require_libsource_with_macro
{
    my ($cond, $macro, $mystrict, @files) = @_;
    $macro = rvar ($macro) unless ref $macro;
    if ($config_libobj_dir)
      {
	require_file_internal ($macro->rdef ($cond)->location, $mystrict,
			       $config_libobj_dir, 0, @files);
      }
    else
      {
	require_file ($macro->rdef ($cond)->location, $mystrict, @files);
      }
}

# queue_required_file_check_or_copy ($QUEUE, $KEY, $DIR, $WHERE,
#                                    $MYSTRICT, @FILES)
# --------------------------------------------------------------
sub queue_required_file_check_or_copy
{
    my ($queue, $key, $dir, $where, $mystrict, @files) = @_;
    my @serial_loc;
    if (ref $where)
      {
        @serial_loc = (QUEUE_LOCATION, $where->serialize ());
      }
    else
      {
        @serial_loc = (QUEUE_STRING, $where);
      }
    $queue->enqueue ($key, $dir, @serial_loc, $mystrict, 0 + @files, @files);
}

# require_queued_file_check_or_copy ($QUEUE)
# ------------------------------------------
sub require_queued_file_check_or_copy
{
    my ($queue) = @_;
    my $where;
    my $dir = $queue->dequeue ();
    my $loc_key = $queue->dequeue ();
    if ($loc_key eq QUEUE_LOCATION)
      {
	$where = Automake::Location::deserialize ($queue);
      }
    elsif ($loc_key eq QUEUE_STRING)
      {
	$where = $queue->dequeue ();
      }
    else
      {
	prog_error "unexpected key $loc_key";
      }
    my $mystrict = $queue->dequeue ();
    my $nfiles = $queue->dequeue ();
    my @files;
    push @files, $queue->dequeue ()
      foreach (1 .. $nfiles);
    return
      unless $strictness >= $mystrict;
    foreach my $file (@files)
      {
        required_file_check_or_copy ($where, $config_aux_dir, $file);
      }
}

# require_conf_file ($WHERE, $MYSTRICT, @FILES)
# ---------------------------------------------
# Looks in configuration path, as specified by AC_CONFIG_AUX_DIR.
sub require_conf_file
{
    my ($where, $mystrict, @files) = @_;
    my $queue = defined $required_conf_file_queue ? 1 : 0;
    require_file_internal ($where, $mystrict, $config_aux_dir,
                           $queue, @files);
}


# require_conf_file_with_macro ($COND, $MACRO, $MYSTRICT, @FILES)
# ---------------------------------------------------------------
sub require_conf_file_with_macro
{
    my ($cond, $macro, $mystrict, @files) = @_;
    require_conf_file (rvar ($macro)->rdef ($cond)->location,
		       $mystrict, @files);
}

################################################################

# require_build_directory ($DIRECTORY)
# ------------------------------------
# Emit rules to create $DIRECTORY if needed, and return
# the file that any target requiring this directory should be made
# dependent upon.
# We don't want to emit the rule twice, and want to reuse it
# for directories with equivalent names (e.g., 'foo/bar' and './foo//bar').
sub require_build_directory
{
  my $directory = shift;

  return $directory_map{$directory} if exists $directory_map{$directory};

  my $cdir = File::Spec->canonpath ($directory);

  if (exists $directory_map{$cdir})
    {
      my $stamp = $directory_map{$cdir};
      $directory_map{$directory} = $stamp;
      return $stamp;
    }

  my $dirstamp = "$cdir/\$(am__dirstamp)";

  $directory_map{$directory} = $dirstamp;
  $directory_map{$cdir} = $dirstamp;

  # Set a variable for the dirstamp basename.
  define_pretty_variable ('am__dirstamp', TRUE, INTERNAL,
			  '$(am__leading_dot)dirstamp');

  # Directory must be removed by 'make distclean'.
  $clean_files{$dirstamp} = DIST_CLEAN;

  $output_rules .= ("$dirstamp:\n"
		    . "\t\@\$(MKDIR_P) $directory\n"
		    . "\t\@: > $dirstamp\n");

  return $dirstamp;
}

# require_build_directory_maybe ($FILE)
# -------------------------------------
# If $FILE lies in a subdirectory, emit a rule to create this
# directory and return the file that $FILE should be made
# dependent upon.  Otherwise, just return the empty string.
sub require_build_directory_maybe
{
    my $file = shift;
    my $directory = dirname ($file);

    if ($directory ne '.')
    {
	return require_build_directory ($directory);
    }
    else
    {
	return '';
    }
}

################################################################

# Push a list of files onto '@dist_common'.
sub push_dist_common
{
  prog_error "push_dist_common run after handle_dist"
    if $handle_dist_run;
  Automake::Variable::define ('DIST_COMMON', VAR_AUTOMAKE, '+', TRUE, "@_",
			      '', INTERNAL, VAR_PRETTY);
}


################################################################

# generate_makefile ($MAKEFILE_AM, $MAKEFILE_IN)
# ----------------------------------------------
# Generate a Makefile.in given the name of the corresponding Makefile and
# the name of the file output by config.status.
sub generate_makefile
{
  my ($makefile_am, $makefile_in) = @_;

  # Reset all the Makefile.am related variables.
  initialize_per_input;

  # AUTOMAKE_OPTIONS can contains -W flags to disable or enable
  # warnings for this file.  So hold any warning issued before
  # we have processed AUTOMAKE_OPTIONS.
  buffer_messages ('warning');

  # $OUTPUT is encoded.  If it contains a ":" then the first element
  # is the real output file, and all remaining elements are input
  # files.  We don't scan or otherwise deal with these input files,
  # other than to mark them as dependencies.  See the subroutine
  # 'scan_autoconf_files' for details.
  my ($makefile, @inputs) = split (/:/, $output_files{$makefile_in});

  $relative_dir = dirname ($makefile);

  read_main_am_file ($makefile_am, $makefile_in);
  if (not handle_options)
    {
      # Process buffered warnings.
      flush_messages;
      # Fatal error.  Just return, so we can continue with next file.
      return;
    }
  # Process buffered warnings.
  flush_messages;

  # There are a few install-related variables that you should not define.
  foreach my $var ('PRE_INSTALL', 'POST_INSTALL', 'NORMAL_INSTALL')
    {
      my $v = var $var;
      if ($v)
	{
	  my $def = $v->def (TRUE);
	  prog_error "$var not defined in condition TRUE"
	    unless $def;
	  reject_var $var, "'$var' should not be defined"
	    if $def->owner != VAR_AUTOMAKE;
	}
    }

  # Catch some obsolete variables.
  msg_var ('obsolete', 'INCLUDES',
	   "'INCLUDES' is the old name for 'AM_CPPFLAGS' (or '*_CPPFLAGS')")
    if var ('INCLUDES');

  # Must do this after reading .am file.
  define_variable ('subdir', $relative_dir, INTERNAL);

  # If DIST_SUBDIRS is defined, make sure SUBDIRS is, so that
  # recursive rules are enabled.
  define_pretty_variable ('SUBDIRS', TRUE, INTERNAL, '')
    if var 'DIST_SUBDIRS' && ! var 'SUBDIRS';

  # Check first, because we might modify some state.
  check_gnu_standards;
  check_gnits_standards;

  handle_configure ($makefile_am, $makefile_in, $makefile, @inputs);
  handle_gettext;
  handle_libraries;
  handle_ltlibraries;
  handle_programs;
  handle_scripts;

  handle_silent;

  # These must be run after all the sources are scanned.  They use
  # variables defined by handle_libraries(), handle_ltlibraries(),
  # or handle_programs().
  handle_compile;
  handle_languages;
  handle_libtool;

  # Variables used by distdir.am and tags.am.
  define_pretty_variable ('SOURCES', TRUE, INTERNAL, @sources);
  if (! option 'no-dist')
    {
      define_pretty_variable ('DIST_SOURCES', TRUE, INTERNAL, @dist_sources);
    }

  handle_texinfo;
  handle_emacs_lisp;
  handle_python;
  handle_java;
  handle_man_pages;
  handle_data;
  handle_headers;
  handle_subdirs;
  handle_user_recursion;
  handle_tags;
  handle_minor_options;
  # Must come after handle_programs so that %known_programs is up-to-date.
  handle_tests;

  # This must come after most other rules.
  handle_dist;

  handle_footer;
  do_check_merge_target;
  handle_all ($makefile);

  # FIXME: Gross!
  if (var ('lib_LTLIBRARIES') && var ('bin_PROGRAMS'))
    {
      $output_rules .= "install-binPROGRAMS: install-libLTLIBRARIES\n\n";
    }
  if (var ('nobase_lib_LTLIBRARIES') && var ('bin_PROGRAMS'))
    {
      $output_rules .= "install-binPROGRAMS: install-nobase_libLTLIBRARIES\n\n";
    }

  handle_install;
  handle_clean ($makefile);
  handle_factored_dependencies;

  # Comes last, because all the above procedures may have
  # defined or overridden variables.
  $output_vars .= output_variables;

  check_typos;

  if ($exit_code != 0)
    {
      verb "not writing $makefile_in because of earlier errors";
      return;
    }

  my $am_relative_dir = dirname ($makefile_am);
  mkdir ($am_relative_dir, 0755) if ! -d $am_relative_dir;

  # We make sure that 'all:' is the first target.
  my $output =
    "$output_vars$output_all$output_header$output_rules$output_trailer";

  # Decide whether we must update the output file or not.
  # We have to update in the following situations.
  #  * $force_generation is set.
  #  * any of the output dependencies is younger than the output
  #  * the contents of the output is different (this can happen
  #    if the project has been populated with a file listed in
  #    @common_files since the last run).
  # Output's dependencies are split in two sets:
  #  * dependencies which are also configure dependencies
  #    These do not change between each Makefile.am
  #  * other dependencies, specific to the Makefile.am being processed
  #    (such as the Makefile.am itself, or any Makefile fragment
  #    it includes).
  my $timestamp = mtime $makefile_in;
  if (! $force_generation
      && $configure_deps_greatest_timestamp < $timestamp
      && $output_deps_greatest_timestamp < $timestamp
      && $output eq contents ($makefile_in))
    {
      verb "$makefile_in unchanged";
      # No need to update.
      return;
    }

  if (-e $makefile_in)
    {
      unlink ($makefile_in)
	or fatal "cannot remove $makefile_in: $!";
    }

  my $gm_file = new Automake::XFile "> $makefile_in";
  verb "creating $makefile_in";
  print $gm_file $output;
}


################################################################


# Helper function for usage().
sub print_autodist_files
{
  # NOTE: we need to call our 'uniq' function with the leading '&'
  # here, because otherwise perl complains that "Unquoted string
  # 'uniq' may clash with future reserved word".
  my @lcomm = sort (&uniq (@_));

  my @four;
  format USAGE_FORMAT =
  @<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<
  $four[0],           $four[1],           $four[2],           $four[3]
.
  local $~ = "USAGE_FORMAT";

  my $cols = 4;
  my $rows = int(@lcomm / $cols);
  my $rest = @lcomm % $cols;

  if ($rest)
    {
      $rows++;
    }
  else
    {
      $rest = $cols;
    }

  for (my $y = 0; $y < $rows; $y++)
    {
      @four = ("", "", "", "");
      for (my $x = 0; $x < $cols; $x++)
        {
          last if $y + 1 == $rows && $x == $rest;

          my $idx = (($x > $rest)
               ?  ($rows * $rest + ($rows - 1) * ($x - $rest))
               : ($rows * $x));

          $idx += $y;
          $four[$x] = $lcomm[$idx];
        }
      write;
    }
}


sub usage ()
{
    print "Usage: $0 [OPTION]... [Makefile]...

Generate Makefile.in for configure from Makefile.am.

Operation modes:
      --help               print this help, then exit
      --version            print version number, then exit
  -v, --verbose            verbosely list files processed
      --no-force           only update Makefile.in's that are out of date
  -W, --warnings=CATEGORY  report the warnings falling in CATEGORY

Dependency tracking:
  -i, --ignore-deps      disable dependency tracking code
      --include-deps     enable dependency tracking code

Flavors:
      --foreign          set strictness to foreign
      --gnits            set strictness to gnits
      --gnu              set strictness to gnu

Library files:
  -a, --add-missing      add missing standard files to package
      --libdir=DIR       set directory storing library files
      --print-libdir     print directory storing library files
  -c, --copy             with -a, copy missing files (default is symlink)
  -f, --force-missing    force update of standard files

";
    Automake::ChannelDefs::usage;

    print "\nFiles automatically distributed if found " .
          "(always):\n";
    print_autodist_files @common_files;
    print "\nFiles automatically distributed if found " .
          "(under certain conditions):\n";
    print_autodist_files @common_sometimes;

    print '
Report bugs to <bug-automake@gnu.org>.
GNU Automake home page: <http://www.gnu.org/software/automake/>.
General help using GNU software: <http://www.gnu.org/gethelp/>.
';

    # --help always returns 0 per GNU standards.
    exit 0;
}


sub version ()
{
  print <<EOF;
automake (GNU $PACKAGE) $VERSION
Copyright (C) $RELEASE_YEAR Free Software Foundation, Inc.
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl-2.0.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Tom Tromey <tromey\@redhat.com>
       and Alexandre Duret-Lutz <adl\@gnu.org>.
EOF
  # --version always returns 0 per GNU standards.
  exit 0;
}

################################################################

# Parse command line.
sub parse_arguments ()
{
  my $strict = 'gnu';
  my $ignore_deps = 0;
  my @warnings = ();

  my %cli_options =
    (
     'version' => \&version,
     'help'    => \&usage,
     'libdir=s'	=> \$libdir,
     'print-libdir'     => sub { print "$libdir\n"; exit 0; },
     'gnu'		=> sub { $strict = 'gnu'; },
     'gnits'		=> sub { $strict = 'gnits'; },
     'foreign'		=> sub { $strict = 'foreign'; },
     'include-deps'	=> sub { $ignore_deps = 0; },
     'i|ignore-deps'	=> sub { $ignore_deps = 1; },
     'no-force'	=> sub { $force_generation = 0; },
     'f|force-missing'  => \$force_missing,
     'a|add-missing'	=> \$add_missing,
     'c|copy'		=> \$copy_missing,
     'v|verbose'	=> sub { setup_channel 'verb', silent => 0; },
     'W|warnings=s'     => \@warnings,
     );

  use Automake::Getopt ();
  Automake::Getopt::parse_options %cli_options;

  set_strictness ($strict);
  my $cli_where = new Automake::Location;
  set_global_option ('no-dependencies', $cli_where) if $ignore_deps;
  for my $warning (@warnings)
    {
      parse_warnings ('-W', $warning);
    }

  return unless @ARGV;

  my $errspec = 0;
  foreach my $arg (@ARGV)
    {
      fatal ("empty argument\nTry '$0 --help' for more information")
	if ($arg eq '');

      # Handle $local:$input syntax.
      my ($local, @rest) = split (/:/, $arg);
      @rest = ("$local.in",) unless @rest;
      my $input = locate_am @rest;
      if ($input)
	{
	  push @input_files, $input;
	  $output_files{$input} = join (':', ($local, @rest));
	}
      else
	{
	  error "no Automake input file found for '$arg'";
	  $errspec = 1;
	}
    }
  fatal "no input file found among supplied arguments"
    if $errspec && ! @input_files;
}


# handle_makefile ($MAKEFILE)
# ---------------------------
sub handle_makefile
{
  my ($file) =  @_;
  ($am_file = $file) =~ s/\.in$//;
  if (! -f ($am_file . '.am'))
    {
      error "'$am_file.am' does not exist";
    }
  else
    {
      # Any warning setting now local to this Makefile.am.
      dup_channel_setup;

      generate_makefile ($am_file . '.am', $file);

      # Back out any warning setting.
      drop_channel_setup;
    }
}

# Deal with all makefiles, without threads.
sub handle_makefiles_serial ()
{
  foreach my $file (@input_files)
    {
      handle_makefile ($file);
    }
}

# Logic for deciding how many worker threads to use.
sub get_number_of_threads ()
{
  my $nthreads = $ENV{'AUTOMAKE_JOBS'} || 0;

  $nthreads = 0
    unless $nthreads =~ /^[0-9]+$/;

  # It doesn't make sense to use more threads than makefiles,
  my $max_threads = @input_files;

  if ($nthreads > $max_threads)
    {
      $nthreads = $max_threads;
    }
  return $nthreads;
}

# handle_makefiles_threaded ($NTHREADS)
# -------------------------------------
# Deal with all makefiles, using threads.  The general strategy is to
# spawn NTHREADS worker threads, dispatch makefiles to them, and let the
# worker threads push back everything that needs serialization:
# * warning and (normal) error messages, for stable stderr output
#   order and content (avoiding duplicates, for example),
# * races when installing aux files (and respective messages),
# * races when collecting aux files for distribution.
#
# The latter requires that the makefile that deals with the aux dir
# files be handled last, done by the master thread.
sub handle_makefiles_threaded
{
  my ($nthreads) = @_;

  # The file queue distributes all makefiles, the message queues
  # collect all serializations needed for respective files.
  my $file_queue = Thread::Queue->new;
  my %msg_queues;
  foreach my $file (@input_files)
    {
      $msg_queues{$file} = Thread::Queue->new;
    }

  verb "spawning $nthreads worker threads";
  my @threads = (1 .. $nthreads);
  foreach my $t (@threads)
    {
      $t = threads->new (sub
	{
	  while (my $file = $file_queue->dequeue)
	    {
	      verb "handling $file";
	      my $queue = $msg_queues{$file};
	      setup_channel_queue ($queue, QUEUE_MESSAGE);
	      $required_conf_file_queue = $queue;
	      handle_makefile ($file);
	      $queue->enqueue (undef);
	      setup_channel_queue (undef, undef);
	      $required_conf_file_queue = undef;
	    }
	  return $exit_code;
	});
    }

  # Queue all makefiles.
  verb "queuing " . @input_files . " input files";
  $file_queue->enqueue (@input_files, (undef) x @threads);

  # Collect and process serializations.
  foreach my $file (@input_files)
    {
      verb "dequeuing messages for " . $file;
      reset_local_duplicates ();
      my $queue = $msg_queues{$file};
      while (my $key = $queue->dequeue)
	{
	  if ($key eq QUEUE_MESSAGE)
	    {
	      pop_channel_queue ($queue);
	    }
	  elsif ($key eq QUEUE_CONF_FILE)
	    {
	      require_queued_file_check_or_copy ($queue);
	    }
	  else
	    {
	      prog_error "unexpected key $key";
	    }
	}
    }

  foreach my $t (@threads)
    {
      my @exit_thread = $t->join;
      $exit_code = $exit_thread[0]
	if ($exit_thread[0] > $exit_code);
    }
}

################################################################

# Parse the WARNINGS environment variable.
parse_WARNINGS;

# Parse command line.
parse_arguments;

$configure_ac = require_configure_ac;

# Do configure.ac scan only once.
scan_autoconf_files;

if (! @input_files)
  {
    my $msg = '';
    $msg = "\nDid you forget AC_CONFIG_FILES([Makefile]) in $configure_ac?"
      if -f 'Makefile.am';
    fatal ("no 'Makefile.am' found for any configure output$msg");
  }

my $nthreads = get_number_of_threads ();

if ($perl_threads && $nthreads >= 1)
  {
    handle_makefiles_threaded ($nthreads);
  }
else
  {
    handle_makefiles_serial ();
  }

exit $exit_code;


### Setup "GNU" style for perl-mode and cperl-mode.
## Local Variables:
## perl-indent-level: 2
## perl-continued-statement-offset: 2
## perl-continued-brace-offset: 0
## perl-brace-offset: 0
## perl-brace-imaginary-offset: 0
## perl-label-offset: -2
## cperl-indent-level: 2
## cperl-brace-offset: 0
## cperl-continued-brace-offset: 0
## cperl-label-offset: -2
## cperl-extra-newline-before-brace: t
## cperl-merge-trailing-else: nil
## cperl-continued-statement-offset: 2
## End:
